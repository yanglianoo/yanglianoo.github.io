<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Xhyper剖析[4]--XhyperCPU虚拟化 | TimerのBlog</title><meta name="author" content="Timer"><meta name="copyright" content="Timer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="5.1 vcpu构建在 CPU 虚拟化中，首先明确一个概念就是 Guest VM 依然还是运行在实际的物理 CPU 上，那么这里提到的 VCPU 是一个什么概念呢？  VCPU 的运行与进程的上下文切换是类似的，当 Guest VM 需要切换到 VCPU 运行时，Hypervisor 就将 VCPU 对应的 Guest VM 的上下文恢复到对应的物理 CPU 中。当 Guest OS 由于执行一些">
<meta property="og:type" content="article">
<meta property="og:title" content="Xhyper剖析[4]--XhyperCPU虚拟化">
<meta property="og:url" content="https://yanglianoo.github.io/2026/01/20/Xhyper%E5%89%96%E6%9E%90-4-XhyperCPU%E8%99%9A%E6%8B%9F%E5%8C%96/index.html">
<meta property="og:site_name" content="TimerのBlog">
<meta property="og:description" content="5.1 vcpu构建在 CPU 虚拟化中，首先明确一个概念就是 Guest VM 依然还是运行在实际的物理 CPU 上，那么这里提到的 VCPU 是一个什么概念呢？  VCPU 的运行与进程的上下文切换是类似的，当 Guest VM 需要切换到 VCPU 运行时，Hypervisor 就将 VCPU 对应的 Guest VM 的上下文恢复到对应的物理 CPU 中。当 Guest OS 由于执行一些">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yanglianoo.github.io/2026/01/20/Xhyper%E5%89%96%E6%9E%90-4-XhyperCPU%E8%99%9A%E6%8B%9F%E5%8C%96/17689241119091.png">
<meta property="article:published_time" content="2026-01-20T15:48:15.000Z">
<meta property="article:modified_time" content="2026-01-20T15:50:00.158Z">
<meta property="article:author" content="Timer">
<meta property="article:tag" content="ARM64">
<meta property="article:tag" content="Hypervisor">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yanglianoo.github.io/2026/01/20/Xhyper%E5%89%96%E6%9E%90-4-XhyperCPU%E8%99%9A%E6%8B%9F%E5%8C%96/17689241119091.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yanglianoo.github.io/2026/01/20/Xhyper%E5%89%96%E6%9E%90-4-XhyperCPU%E8%99%9A%E6%8B%9F%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Xhyper剖析[4]--XhyperCPU虚拟化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-01-20 23:50:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="TimerのBlog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2026/01/20/Xhyper%E5%89%96%E6%9E%90-4-XhyperCPU%E8%99%9A%E6%8B%9F%E5%8C%96/17689241119091.png')"><nav id="nav"><span id="blog-info"><a href="/" title="TimerのBlog"><span class="site-name">TimerのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Xhyper剖析[4]--XhyperCPU虚拟化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-20T15:48:15.000Z" title="发表于 2026-01-20 23:48:15">2026-01-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-20T15:50:00.158Z" title="更新于 2026-01-20 23:50:00">2026-01-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Xhyper%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">Xhyper源码剖析</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Xhyper剖析[4]--XhyperCPU虚拟化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="5-1-vcpu构建"><a href="#5-1-vcpu构建" class="headerlink" title="5.1 vcpu构建"></a>5.1 vcpu构建</h3><p>在 CPU 虚拟化中，首先明确一个概念就是 Guest VM 依然还是运行在实际的物理 CPU 上，那么这里提到的 VCPU 是一个什么概念呢？</p>
<ul>
<li>VCPU 的运行与进程的上下文切换是类似的，当 Guest VM 需要切换到 VCPU 运行时，Hypervisor 就将 VCPU 对应的 Guest VM 的上下文恢复到对应的物理 CPU 中。当 Guest OS 由于执行一些敏感指令、访问没有权限的内存等情况时，会陷入运行在更高特权级的 Hypervisor，然后 Hypervisor 负责将物理 CPU 的状态保存到 VCPU 上下文中。所以我们这里就可以理解 VCPU 就是对物理 CPU 资源的抽象，Hypervisor 实现了物理 CPU 对 Guest VM 的时间复用。</li>
<li>在 Hypervisor 中可以控制所有的系统资源，包括之前讲到的物理内存、IO 设备、中断、指令等。Hypervisor 可以配置 Guest VM 在执行到敏感指令时触发异常，该异常会被路由到 EL2 的 Hypervisor 中，然后可以对这些敏感指令进行模拟。</li>
</ul>
<p>首先对<code>Guest VM</code>进行抽象：</p>
<ul>
<li>一个VM包括其需要的CPU个数，二阶段地址转换的页表基地址寄存器和VCPU集合</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vm.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vm</span> &#123;</span><br><span class="line">    <span class="type">char</span>       name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>        nvcpu;</span><br><span class="line">    u64       *vttbr;</span><br><span class="line">    <span class="type">spinlock_t</span> vm_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">vcpu</span> *vcpus[NCPU];</span><br><span class="line">&#125; <span class="type">vm_t</span>;</span><br></pre></td></tr></table></figure>

<p>vcpu需要保存的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">vcpu_state</span> &#123;</span></span><br><span class="line">    VCPU_UNUSED,</span><br><span class="line">    VCPU_ALLOCED,</span><br><span class="line">    VCPU_READY,</span><br><span class="line">    VCPU_RUNNING,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vcpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u64 x[<span class="number">31</span>];</span><br><span class="line">        u64 spsr;</span><br><span class="line">        u64 elr;</span><br><span class="line">    &#125; regs;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u64 spsr_el1;</span><br><span class="line">        u64 elr_el1;</span><br><span class="line">        u64 mpidr_el1;</span><br><span class="line">        u64 midr_el1;</span><br><span class="line">        u64 sp_el0;</span><br><span class="line">        u64 sp_el1;</span><br><span class="line">        u64 ttbr0_el1;</span><br><span class="line">        u64 ttbr1_el1;</span><br><span class="line">        u64 tcr_el1;</span><br><span class="line">        u64 vbar_el1;</span><br><span class="line">        u64 sctlr_el1;</span><br><span class="line">        u64 cntv_ctl_el0;</span><br><span class="line">        u64 cntv_tval_el0;</span><br><span class="line">        u64 cntfrq_el0;</span><br><span class="line">    &#125; sys_regs;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *core_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm</span>  *<span class="title">vm</span>;</span></span><br><span class="line">    <span class="type">int</span>        cpuid;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">vcpu_state</span> <span class="title">state</span>;</span></span><br><span class="line">&#125; <span class="type">vcpu_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>保存通用寄存器<code>regs</code>和系统寄存器<code>sys_regs</code></li>
</ul>
<p>在<code>Xhyper</code>中一个物理<code>cpu</code>对应一个<code>vcpu</code></p>
<p><img src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-4-XhyperCPU%E8%99%9A%E6%8B%9F%E5%8C%96/17689241119102.png" alt="img"></p>
<p>创建一个<code>vcpu</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">vcpu_t</span> *<span class="title">create_vcpu</span><span class="params">(<span class="type">vm_t</span> *vm, <span class="type">int</span> vcpuid, u64 entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">vcpu_t</span> *vcpu = <span class="built_in">vcpu_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span>(vcpu == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">abort</span>(<span class="string">&quot;Unable to alloc a vcpu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vcpu-&gt;core_name = <span class="string">&quot;Cortex-A72&quot;</span>;</span><br><span class="line">    vcpu-&gt;vm        = vm;</span><br><span class="line">    vcpu-&gt;cpuid     = vcpuid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        程序状态保存寄存器（SPSR）</span></span><br><span class="line"><span class="comment">        SPSR_M(5) : 5 = 0b0101 EL1 handler模式</span></span><br><span class="line"><span class="comment">        SPSR_DAIF : (0xf &lt;&lt; 6) = 0b1111 &lt;&lt; 6 = 0b1111000000 = 0x3C0</span></span><br><span class="line"><span class="comment">            - D（位 9）：Debug 异常（如断点、单步）屏蔽。</span></span><br><span class="line"><span class="comment">            - A（位 8）：SError（系统错误）屏蔽。</span></span><br><span class="line"><span class="comment">            - I（位 7）：IRQ（普通中断）屏蔽。</span></span><br><span class="line"><span class="comment">            - F（位 6）：FIQ（快速中断）屏蔽</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    vcpu-&gt;regs.spsr = <span class="built_in">SPSR_M</span>(<span class="number">5</span>) | SPSR_DAIF;    <span class="comment">/* used to set the spsr_el2 */</span></span><br><span class="line">    <span class="comment">// elr 存放了异常返回地址</span></span><br><span class="line">    vcpu-&gt;regs.elr  = entry;                    <span class="comment">/* used to set the elr_el2 */</span></span><br><span class="line">    <span class="comment">// cpu ID判断寄存器</span></span><br><span class="line">    vcpu-&gt;sys_regs.mpidr_el1 = vcpuid;          <span class="comment">/* used to fake the mpidr_el1 */</span></span><br><span class="line">    <span class="comment">// cpu型号厂商等信息</span></span><br><span class="line">    vcpu-&gt;sys_regs.midr_el1  = <span class="number">0x410FD081</span>;      <span class="comment">/* used to fake the core to cortex-a72 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vcpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改regs.spsr，该值在进入 Guest VM 之前会被加载到 SPSR_EL2 寄存器中，可以保证异常返回到 Aarch64 状态的 EL1。</li>
<li>修改regs.elr，该值在进入 Guest VM 之前会被加载到 ELR_EL2 寄存器中，可以保证异常返回到 Guest VM 的入口地址。</li>
<li>修改sys_regs.mpidr_el1，该值在进入 Guest VM 之前会被加载到 MPIDR_EL1 寄存器中，能够使 Guest VM 看到虚假的核号。</li>
<li>修改sys_regs.midr_el1，该值在进入 Guest VM 之前会被加载到 MIDR_EL1 寄存器中，能够使 Guest VM 看到虚假的 CPU 身份信息</li>
</ul>
<p>选择<code>cpu</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">switch_vcpu</span><span class="params">(<span class="type">vcpu_t</span> *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前运行的物理cpu id</span></span><br><span class="line">    <span class="built_in">cur_pcpu</span>()-&gt;vcpu = vcpu;</span><br><span class="line">    <span class="comment">/* tpidr_el2保存当前执行的vcpu的地址，在上下文中可以用于获取vcpu */</span></span><br><span class="line">    <span class="built_in">write_sysreg</span>(tpidr_el2, vcpu);</span><br><span class="line"></span><br><span class="line">    vcpu-&gt;state = VCPU_RUNNING;</span><br><span class="line">    <span class="comment">/* 设置stage2转换的页表基地址寄存器 */</span></span><br><span class="line">    <span class="built_in">write_sysreg</span>(vttbr_el2, vcpu-&gt;vm-&gt;vttbr);</span><br><span class="line">    <span class="built_in">flush_tlb</span>();</span><br><span class="line">    <span class="comment">/* 设置EL1/EL0系统寄存器的初始状态 */</span></span><br><span class="line">    <span class="built_in">restore_sysreg</span>(vcpu);</span><br><span class="line">    <span class="built_in">isb</span>();</span><br><span class="line">    <span class="comment">/* 切换到EL1 */</span></span><br><span class="line">    switch_out();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先将当前 vpu 的地址保存到 TPIDR_EL2 寄存器中，这样做的目的是当 Guest VM 的该 VCPU 发生异常时，Hypervisor 可以通过读取 TPIDR_EL2 来获取发生异常的 VCPU。</li>
<li>修改 VTTBR_EL2，保证该 Guest VM 可以访问其 IPA。</li>
<li>然后将 VCPU 中的通用寄存器和系统寄存器的值加载到实际的物理寄存器中。</li>
<li>调用 switch_out 返回 Guest VM。</li>
</ul>
<p>有个重要的函数<code>switch_out</code>：</p>
<ul>
<li>从<code>tpidr_el2</code>取出<code>vcpu</code>的地址，根据此指针去恢复寄存器的值</li>
<li>恢复完成寄存器的值后，调用<code>eret</code>指令返回<code>EL1</code>执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vector.s</span><br><span class="line">.macro restore_vm_regs</span><br><span class="line">    mrs x0,  tpidr_el2          /* x0 = &amp;vcpu-&gt;regs */</span><br><span class="line">    ldp x30, x1, [x0, #8 * 30]  /* x1 = spsr_el2 */</span><br><span class="line">    ldr x2, [x0, #8 * 32]       /* x2 = elr_el2 */</span><br><span class="line">    msr spsr_el2, x1            /* spsr_el2 存放程序状态 */</span><br><span class="line">    msr elr_el2,  x2            /* elr 存放异常返回地址 */</span><br><span class="line"></span><br><span class="line">    ldp x3, x4, [x0, #8 * 0]    /* x3 = x0, x4 = x1 */</span><br><span class="line">    stp x3, x4, [sp, #-16]!     /* 将 X3 和 X4（Guest VM 的 X0 和 X1）压入栈，栈指针 SP 减 16 字节。 */</span><br><span class="line">    /* 恢复 X2-X29*/</span><br><span class="line">    ldp x2, x3, [x0, #8 * 2]</span><br><span class="line">    ldp x4, x5, [x0, #8 * 4]</span><br><span class="line">    ldp x6, x7, [x0, #8 * 6]</span><br><span class="line">    ldp x8, x9, [x0, #8 * 8]</span><br><span class="line">    ldp x10, x11, [x0, #8 * 10]</span><br><span class="line">    ldp x12, x13, [x0, #8 * 12]</span><br><span class="line">    ldp x14, x15, [x0, #8 * 14]</span><br><span class="line">    ldp x16, x17, [x0, #8 * 16]</span><br><span class="line">    ldp x18, x19, [x0, #8 * 18]</span><br><span class="line">    ldp x20, x21, [x0, #8 * 20]</span><br><span class="line">    ldp x22, x23, [x0, #8 * 22]</span><br><span class="line">    ldp x24, x25, [x0, #8 * 24]</span><br><span class="line">    ldp x26, x27, [x0, #8 * 26]</span><br><span class="line">    ldp x28, x29, [x0, #8 * 28]</span><br><span class="line">    /* 恢复 X0 和 X1 */</span><br><span class="line">    ldp x0, x1, [sp], #16</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.global  switch_out</span><br><span class="line">.type    switch_out, function</span><br><span class="line">switch_out:</span><br><span class="line">    restore_vm_regs</span><br><span class="line">    eret</span><br></pre></td></tr></table></figure>

<h3 id="5-2-启动cpu-0"><a href="#5-2-启动cpu-0" class="headerlink" title="5.2 启动cpu 0"></a>5.2 启动cpu 0</h3><p>在Xhyper的main.c的<code>hyper_init_primary</code>函数中首先调用了<code>hyper_setup();</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Provides configuration controls for virtualization */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hyper_vector</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hyper_setup</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        HCR_TSC : 控制虚拟机的 SMC（Secure Monitor Call）指令是否陷入 Hypervisor</span></span><br><span class="line"><span class="comment">        HCR_RW  : 决定虚拟机的执行状态是 AArch64 还是 AArch32</span></span><br><span class="line"><span class="comment">        HCR_VM  : 开启或关闭 Stage-2 地址转换</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    u64 hcr = HCR_TSC | HCR_RW | HCR_VM;</span><br><span class="line">    LOG_INFO(<span class="string">&quot;Setting hcr_el2 to 0x%x and enable stage 2 address translation\n&quot;</span>);</span><br><span class="line">    write_sysreg(hcr_el2, hcr);</span><br><span class="line"></span><br><span class="line">    LOG_INFO(<span class="string">&quot;Setting Vector Base Address Register for EL2\n&quot;</span>);</span><br><span class="line">    write_sysreg(vbar_el2, (u64)hyper_vector);</span><br><span class="line"></span><br><span class="line">    isb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>vbar_el2</code>寄存器是异常向量表地址寄存器，代表产生异常时陷入EL2时的异常向量表的地址，这里设置成了<code>hyper_vector</code></li>
</ul>
<p><code>hyper_vector</code>定义在<code>vector.s</code>中，关于arm异常向量表的知识参考2.3节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro save_vm_regs</span><br><span class="line">    stp x0, x1, [sp, #-16]!     /* save x0, x1 on stack */</span><br><span class="line">    mrs x0, tpidr_el2           /* x0 = &amp;vcpu-&gt;regs */</span><br><span class="line"></span><br><span class="line">    // 保存通用寄存器 X2-X29</span><br><span class="line">    stp x2, x3, [x0, #8 * 2]</span><br><span class="line">    stp x4, x5, [x0, #8 * 4]</span><br><span class="line">    stp x6, x7, [x0, #8 * 6]</span><br><span class="line">    stp x8, x9, [x0, #8 * 8]</span><br><span class="line">    stp x10, x11, [x0, #8 * 10]</span><br><span class="line">    stp x12, x13, [x0, #8 * 12]</span><br><span class="line">    stp x14, x15, [x0, #8 * 14]</span><br><span class="line">    stp x16, x17, [x0, #8 * 16]</span><br><span class="line">    stp x18, x19, [x0, #8 * 18]</span><br><span class="line">    stp x20, x21, [x0, #8 * 20]</span><br><span class="line">    stp x22, x23, [x0, #8 * 22]</span><br><span class="line">    stp x24, x25, [x0, #8 * 24]</span><br><span class="line">    stp x26, x27, [x0, #8 * 26]</span><br><span class="line">    stp x28, x29, [x0, #8 * 28]</span><br><span class="line"></span><br><span class="line">    mrs x1, spsr_el2 /* x1 = spsr_el2 */</span><br><span class="line">    mrs x2, elr_el2  /* x2 = elr_el2 */</span><br><span class="line">    ldp x3, x4, [sp], #16   /* x3 = x0, x4 = x1  从栈加载之前保存的 X0 和 X1 到 X3 和 X4*/</span><br><span class="line">    stp x30, x1, [x0, #8 *30] /* x30 = #8 *30   x1=spsr_el2 = #8 *31 保存spsr_el2*/</span><br><span class="line">    str x2, [x0, #8 * 32]  /* 保存 elr_el2 */ </span><br><span class="line">    stp x3, x4, [x0, #8 * 0] /* 保存 x0 x1 */</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.global hyper_vector</span><br><span class="line">hyper_vector:</span><br><span class="line">.balign 0x800                   //确保向量表地址按 2048 字节（2KB）对齐</span><br><span class="line">.set  vector_base, hyper_vector //定义符号 vector_base，指向 hyper_vector 地址</span><br><span class="line">.org  vector_base               // 设置汇编起始地址为 vector_base。</span><br><span class="line"></span><br><span class="line">/* Current EL with SP_EL0 */</span><br><span class="line">.org (vector_base + 0x00)</span><br><span class="line">    b .                     // sync</span><br><span class="line">.org (vector_base + 0x80)</span><br><span class="line">    b .                     // IRQ</span><br><span class="line">.org (vector_base + 0x100)</span><br><span class="line">    b .                     // FIQ</span><br><span class="line">.org (vector_base + 0x180)</span><br><span class="line">    b .                     // error</span><br><span class="line"></span><br><span class="line">/* Current EL with SP_ELx */</span><br><span class="line">.org (vector_base + 0x200)</span><br><span class="line">    b vector_el2_sync       // sync  暂时为空</span><br><span class="line">.org (vector_base + 0x280)</span><br><span class="line">    b vector_el2_irq        // IRQ 暂时为空</span><br><span class="line">.org (vector_base + 0x300)</span><br><span class="line">    b .                     // FIQ</span><br><span class="line">.org (vector_base + 0x380)</span><br><span class="line">    b .                     // error</span><br><span class="line"></span><br><span class="line">/* Lower EL using aarch64 */</span><br><span class="line">.org (vector_base + 0x400)</span><br><span class="line">    b vector_el1_sync       // sync 处理来自EL1的异sync异常</span><br><span class="line">.org (vector_base + 0x480)</span><br><span class="line">    b vector_el1_irq        // IRQ  暂时为空</span><br><span class="line">.org (vector_base + 0x500)</span><br><span class="line">    b .                     // FIQ</span><br><span class="line">.org (vector_base + 0x580)</span><br><span class="line">    b .                     // error</span><br><span class="line"></span><br><span class="line">/* Lower EL using aarch32 */</span><br><span class="line">.org (vector_base + 0x600)</span><br><span class="line">    b .                     // sync</span><br><span class="line">.org (vector_base + 0x680)</span><br><span class="line">    b .                     // IRQ</span><br><span class="line">.org (vector_base + 0x700)</span><br><span class="line">    b .                     // FIQ</span><br><span class="line">.org (vector_base + 0x780)</span><br><span class="line">    b .                     // error</span><br><span class="line"></span><br><span class="line">vector_el2_sync:</span><br><span class="line">    b .</span><br><span class="line"></span><br><span class="line">vector_el2_irq:</span><br><span class="line">    b .</span><br><span class="line"></span><br><span class="line">vector_el1_sync:</span><br><span class="line">    save_vm_regs</span><br><span class="line">    bl el1_sync_proc</span><br><span class="line">    restore_vm_regs</span><br><span class="line">    eret</span><br><span class="line"></span><br><span class="line">vector_el1_irq:</span><br><span class="line">    b .</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看见当异常为<code>vector_el1_sync</code>时会首先调用<code>save_vm_regs</code>保存当前cpu的执行状态到对应的<code>vcpu</code>中</li>
<li>然后调用<code>el1_sync_proc</code>处理异常</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//el1_sync.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">el1_sync_proc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">vcpu_t</span> *vcpu;</span><br><span class="line">    <span class="comment">/* which vcpu has been trapped into EL2 */</span></span><br><span class="line">    <span class="built_in">read_sysreg</span>(vcpu, tpidr_el2);</span><br><span class="line"></span><br><span class="line">    u64 esr, elr, far;</span><br><span class="line">    <span class="comment">/* Exception Syndrome Register */</span></span><br><span class="line">    <span class="built_in">read_sysreg</span>(esr, esr_el2);</span><br><span class="line">    <span class="comment">/* Exception Link Register */</span></span><br><span class="line">    <span class="built_in">read_sysreg</span>(elr, elr_el2);</span><br><span class="line">    <span class="comment">/* Holds the faulting Virtual Address */</span></span><br><span class="line">    <span class="built_in">read_sysreg</span>(far, far_el2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exception Class  取esr_el2寄存器的 26-31位，即EC字段*/</span></span><br><span class="line">    u64 esr_ec  = (esr &gt;&gt; <span class="number">26</span>) &amp; <span class="number">0x3F</span>;</span><br><span class="line">    <span class="comment">/* Instruction Specific Syndrome  取esr_el2寄存器0-24位，即ISS字段*/</span></span><br><span class="line">    u64 esr_iss = esr &amp; <span class="number">0x1FFFFFF</span>;</span><br><span class="line">    <span class="comment">/* Instruction Length 取esr_el2寄存器的25位，即IL字段 */</span></span><br><span class="line">    u64 esr_il  = (esr &gt;&gt; <span class="number">25</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(esr_ec) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* HVC instruction execution in AArch64 state, when HVC is not disabled. */</span></span><br><span class="line">        <span class="comment">/* 64位环境下执行HVC（Hypervisor Call）指令触发的异常。用于虚拟机监控模式（EL2），虚拟机通过此指令与Hypervisor交互。*/</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x16</span>:</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;\033[32m [el1_sync_proc] hvc trap from EL1\033[0m\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">hvc_smc_handler</span>(vcpu, esr_iss) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">abort</span>(<span class="string">&quot;Unknown HVC call #%d&quot;</span>, esr_iss);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* hvc from EL1 will set the preferred exception return address to pc+4 */</span></span><br><span class="line">            vcpu-&gt;regs.elr += <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 64位环境下执行SMC（Secure Monitor Call）指令触发的异常。用于安全监控模式（EL3），实现安全世界与非安全世界的切换*/</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x17</span>:</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;\033[32m[el1_sync_proc] smc trap from EL1\033[0m\n&quot;</span>);</span><br><span class="line">            <span class="comment">/* on smc call, iss is the imm of a smc */</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">hvc_smc_handler</span>(vcpu, esr_iss) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">abort</span>(<span class="string">&quot;Unknown SMC call #%d&quot;</span>, esr_iss);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* smc trapped from EL1 will set preferred execption return address to pc</span></span><br><span class="line"><span class="comment">             * so we need to +4 return to the next instruction.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            vcpu-&gt;regs.elr += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>(<span class="string">&quot;Unknown el1 sync: esr_ec %p, esr_iss %p, elr %p, far %p&quot;</span>, esr_ec, esr_iss, elr, far);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>esr_el2</code>寄存器的<code>ec</code>字段保存了异常产生的原因，即根据<code>ec</code>字段的值来判断是什么异常<ul>
<li>0x16：表示客户机执行的 HVC 指令触发了异常，且被陷阱到 EL2。</li>
<li>0x17: Trapped SMC 指令（由 HCR_TSC 触发）。</li>
</ul>
</li>
<li><code>esr_el2</code>寄存器的<code>iss</code>字段提供更详细的异常信息</li>
</ul>
<p>通过<code>switch_out</code>函数就会返回到<code>EL1</code>中执行，入口函数为<code>guest os</code>的<code>_start</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text, &quot;ax&quot;</span><br><span class="line">.global  _start</span><br><span class="line">.type    _start, function</span><br><span class="line">.align 4</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    /* Set stack for c code */</span><br><span class="line">    adrp    x0, sp_stack</span><br><span class="line">    /* Get Current code id */</span><br><span class="line">    mrs     x1, mpidr_el1</span><br><span class="line">    and     x1, x1, #0x0f</span><br><span class="line">    add     x2, x1, 1</span><br><span class="line">    mov     x3, #SZ_4K</span><br><span class="line">    mul     x3, x3, x2</span><br><span class="line">    add     x0, x0, x3</span><br><span class="line">    mov     sp, x0</span><br><span class="line">    cbz     x1, vm_primary_init</span><br><span class="line">    bl      vm_secondary_init</span><br><span class="line">    /* spin here */</span><br><span class="line">    b       .</span><br></pre></td></tr></table></figure>

<ul>
<li>此函数会比对当前的<code>core id</code>如果为0，则会跳转到<code>vm_primary_init</code>函数执行，如果<code>core id</code>为1则会跳转到<code>vm_secondary_init</code>函数执行</li>
</ul>
<p><code>vm_primary_init</code>函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">vm_primary_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pl011_init</span>();</span><br><span class="line">    <span class="built_in">print_logo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* test code for wakeup vcore 1 */</span></span><br><span class="line">    <span class="built_in">smc_call</span>((u64)<span class="number">0xc4000003</span>, (u64)<span class="number">1</span>, (u64)_start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am vm 1 on core 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>smc_call</code>函数可以用来启用另外一个<code>cpu</code>核心主要是调用<code>smc</code>指令来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global smc_call</span><br><span class="line">.type    smc_call, function</span><br><span class="line">smc_call:</span><br><span class="line">    smc #0</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p><code>smc</code>指定对应的id如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* https://developer.aliyun.com/article/1205031 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSCI_VERSION            0x84000000 <span class="comment">//返回 PSCI 的主版本号和次版本号（32 位值）：</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSCI_MIGRATE_INFO_TYPE  0x84000006 <span class="comment">//返回系统是否支持 CPU 迁移（migration），以及迁移的类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSCI_SYSTEM_OFF         0x84000008 <span class="comment">//通知系统进入完全关闭状态（电源关闭）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSCI_SYSTEM_RESET       0x84000009 <span class="comment">//通知系统执行重启（软复位或硬复位）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSCI_SYSTEM_CPUON       0xc4000003 <span class="comment">//唤醒一个关闭或低功耗的 CPU，设置其执行入口地址和上下文</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSCI_FEATURE            0x8400000a <span class="comment">//检查特定 PSCI 功能是否可用。输入功能 ID，返回支持状态。</span></span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-启动cpu-1"><a href="#5-3-启动cpu-1" class="headerlink" title="5.3 启动cpu 1"></a>5.3 启动cpu 1</h3><p>通过smc指令就会从<code>guest os</code>陷入到<code>el2</code>然后通过查找异常向量表调用到<code>el1_sync_proc()</code>函数，根据<code>esr_el2</code>的<code>ec</code>字段的值来判断进行下一步调用</p>
<p>如果是<code>0x17</code>即<code>smc call</code>的话会进入到<code>hvc_smc_handler</code>处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//el1_sync.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">vpsci_handler</span><span class="params">(<span class="type">vcpu_t</span> *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * x0 - function id</span></span><br><span class="line"><span class="comment">     * x1 - target cpu</span></span><br><span class="line"><span class="comment">     * x2 - entry addr (the entry addr for guest vm, not for vmm)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    u64 ret = <span class="built_in">vpsci_trap_smc</span>(vcpu, vcpu-&gt;regs.x[<span class="number">0</span>], vcpu-&gt;regs.x[<span class="number">1</span>], vcpu-&gt;regs.x[<span class="number">2</span>]);</span><br><span class="line">    vcpu-&gt;regs.x[<span class="number">0</span>] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hvc_smc_handler</span><span class="params">(<span class="type">vcpu_t</span> *vcpu, <span class="type">int</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(imm) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">vpsci_handler</span>(vcpu);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vpsci_trap_smc</code>进一步处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vpsci.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> u32 <span class="title">vpsci_version</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smc_call</span>(PSCI_VERSION, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> s32 <span class="title">vpsci_migrate_info_type</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smc_call</span>(PSCI_MIGRATE_INFO_TYPE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> s32 <span class="title">vpsci_cpu_on</span><span class="params">(<span class="type">vcpu_t</span> *vcpu, u64 funid, u64 target_cpu, u64 entry_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Vpsci cpu on call for vcpu %d on entrypoint %p\n&quot;</span>, target_cpu, entry_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(target_cpu &gt;= (u64)vcpu-&gt;vm-&gt;nvcpu) &#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Vpsci failed to wakeup vcpu\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">vcpu_t</span> *target = vcpu-&gt;vm-&gt;vcpus[target_cpu];</span><br><span class="line">    target-&gt;regs.elr = entry_addr;</span><br><span class="line">    target-&gt;state = VCPU_READY;</span><br><span class="line">    <span class="comment">/* wakeup the physical cpu */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smc_call</span>(PSCI_SYSTEM_CPUON, target_cpu, (u64)_start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">u64 <span class="title">vpsci_trap_smc</span><span class="params">(<span class="type">vcpu_t</span> *vcpu, u64 funid, u64 target_cpu, u64 entry_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vcpu == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">abort</span>(<span class="string">&quot;vpsci_trap_smc with NULL vcpu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(funid) &#123;</span><br><span class="line">        <span class="keyword">case</span> PSCI_VERSION:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vpsci_version</span>();</span><br><span class="line">        <span class="keyword">case</span> PSCI_MIGRATE_INFO_TYPE:</span><br><span class="line">            <span class="keyword">return</span> (s64)<span class="built_in">vpsci_migrate_info_type</span>();     </span><br><span class="line">        <span class="keyword">case</span> PSCI_SYSTEM_OFF:</span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Unsupported PSCI CPU OFF\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PSCI_SYSTEM_RESET:</span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Unsupported PSCI CPU RESET\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PSCI_SYSTEM_CPUON:</span><br><span class="line">            <span class="keyword">return</span> (s64)<span class="built_in">vpsci_cpu_on</span>(vcpu, funid, target_cpu, entry_addr);</span><br><span class="line">        <span class="keyword">case</span> PSCI_FEATURE:    <span class="comment">/* Linux will use this funid to get the PSCI FEATURE */</span></span><br><span class="line">            <span class="comment">/* fake it */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>(<span class="string">&quot;Unknown function id : %p from hvc/smc call&quot;</span>, funid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用的<code>id</code>号为<code>PSCI_SYSTEM_CPUON</code>时会去唤醒一个<code>cpu</code>核心：</p>
<ul>
<li>这里有个重要点，将唤醒的cpu对应的vcpu的返回地址设置为了<code>entry_addr</code>，这样被唤醒的<code>cpu</code>从<code>el2</code>返回到<code>el1</code>执行时就会返回到<code>entry_addr</code>处执行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> s32 <span class="title">vpsci_cpu_on</span><span class="params">(<span class="type">vcpu_t</span> *vcpu, u64 funid, u64 target_cpu, u64 entry_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Vpsci cpu on call for vcpu %d on entrypoint %p\n&quot;</span>, target_cpu, entry_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(target_cpu &gt;= (u64)vcpu-&gt;vm-&gt;nvcpu) &#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Vpsci failed to wakeup vcpu\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">vcpu_t</span> *target = vcpu-&gt;vm-&gt;vcpus[target_cpu];</span><br><span class="line">    target-&gt;regs.elr = entry_addr;</span><br><span class="line">    target-&gt;state = VCPU_READY;</span><br><span class="line">    <span class="comment">/* wakeup the physical cpu */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smc_call</span>(PSCI_SYSTEM_CPUON, target_cpu, (u64)_start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒的cpu核心在<code>el2</code>的执行地址为<code>_start</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text, &quot;ax&quot;</span><br><span class="line">.global  _start</span><br><span class="line">.type    _start, function</span><br><span class="line">.align 4</span><br><span class="line"></span><br><span class="line"># 设置栈指针，如果core_id = 0 , 则跳转到 hyper_init_primary</span><br><span class="line">_start:</span><br><span class="line">    /* Set stack for c code */</span><br><span class="line">    adrp    x0, sp_stack</span><br><span class="line">    /* Get Current code id */</span><br><span class="line">    mrs     x1, mpidr_el1</span><br><span class="line">    and     x1, x1, #0x0f</span><br><span class="line">    add     x2, x1, 1</span><br><span class="line">    mov     x3, #SZ_4K</span><br><span class="line">    mul     x3, x3, x2</span><br><span class="line">    add     x0, x0, x3</span><br><span class="line">    mov     sp, x0</span><br><span class="line">    cbz     x1, hyper_init_primary</span><br><span class="line">    bl      hyper_init_secondary</span><br><span class="line">    /* spin here */</span><br><span class="line">    b       .</span><br></pre></td></tr></table></figure>

<ul>
<li><code>start</code>函数会比对当前的<code>core id</code>是0还是1，如果是1，则说明是被唤醒的一个新的core，因此会跳转到<code>hyper_init_secondary</code>函数执行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hyper_init_secondary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;core %d is activated\n&quot;</span>, <span class="built_in">coreid</span>());</span><br><span class="line">    <span class="built_in">stage2_mmu_init</span>();</span><br><span class="line">    <span class="built_in">hyper_setup</span>();</span><br><span class="line">    <span class="built_in">start_vcpu</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里<code>core 1</code>也已经被启动了，<code>core 1</code>通过<code>start_vcpu</code>函数就可以返回到<code>el1</code>执行，<code>core 0</code>在处理完成<code>el1</code>来的异常后也会返回到<code>el1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector_el1_sync:</span><br><span class="line">    save_vm_regs</span><br><span class="line">    bl el1_sync_proc</span><br><span class="line">    restore_vm_regs</span><br><span class="line">    eret</span><br></pre></td></tr></table></figure>

<p>整体的流程如下：</p>
<p><img src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-4-XhyperCPU%E8%99%9A%E6%8B%9F%E5%8C%96/17689241119091.png" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yanglianoo.github.io">Timer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yanglianoo.github.io/2026/01/20/Xhyper%E5%89%96%E6%9E%90-4-XhyperCPU%E8%99%9A%E6%8B%9F%E5%8C%96/">https://yanglianoo.github.io/2026/01/20/Xhyper剖析-4-XhyperCPU虚拟化/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yanglianoo.github.io" target="_blank">TimerのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ARM64/">ARM64</a><a class="post-meta__tags" href="/tags/Hypervisor/">Hypervisor</a></div><div class="post_share"><div class="social-share" data-image="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-4-XhyperCPU%E8%99%9A%E6%8B%9F%E5%8C%96/17689241119091.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-5-MMIO%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Xhyper剖析[5]--MMIO虚拟化"><img class="cover" src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-5-MMIO%E8%99%9A%E6%8B%9F%E5%8C%96/17689243819381.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Xhyper剖析[5]--MMIO虚拟化</div></div></a></div><div class="next-post pull-right"><a href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-3-Xhyper%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Xhyper剖析[3]--Xhyper内存虚拟化"><img class="cover" src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-3-Xhyper%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/176892388736321.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Xhyper剖析[3]--Xhyper内存虚拟化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-1-2-ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="Xhyper剖析[1]--ARM64基础知识"><img class="cover" src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-1-2-ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/176892275018318.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-20</div><div class="title">Xhyper剖析[1]--ARM64基础知识</div></div></a></div><div><a href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-2-Xhyper%E5%90%AF%E5%8A%A8/" title="Xhyper剖析[2]--Xhyper启动"><img class="cover" src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-2-Xhyper%E5%90%AF%E5%8A%A8/17689237041079.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-20</div><div class="title">Xhyper剖析[2]--Xhyper启动</div></div></a></div><div><a href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-3-Xhyper%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Xhyper剖析[3]--Xhyper内存虚拟化"><img class="cover" src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-3-Xhyper%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/176892388736321.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-20</div><div class="title">Xhyper剖析[3]--Xhyper内存虚拟化</div></div></a></div><div><a href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-5-MMIO%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Xhyper剖析[5]--MMIO虚拟化"><img class="cover" src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-5-MMIO%E8%99%9A%E6%8B%9F%E5%8C%96/17689243819381.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-20</div><div class="title">Xhyper剖析[5]--MMIO虚拟化</div></div></a></div><div><a href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-6-%E4%B8%AD%E6%96%AD%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Xhyper剖析[6]--中断虚拟化"><img class="cover" src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-6-%E4%B8%AD%E6%96%AD%E8%99%9A%E6%8B%9F%E5%8C%96/17689244713913.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-20</div><div class="title">Xhyper剖析[6]--中断虚拟化</div></div></a></div><div><a href="/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" title="Linux内核启动流程分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-07</div><div class="title">Linux内核启动流程分析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Timer</div><div class="author-info__description">没有一个健康的身体，如何支撑我龌龊的灵魂!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yanglianoo"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yanglianoo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">个人微信：13699648817</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-vcpu%E6%9E%84%E5%BB%BA"><span class="toc-text">5.1 vcpu构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%90%AF%E5%8A%A8cpu-0"><span class="toc-text">5.2 启动cpu 0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%90%AF%E5%8A%A8cpu-1"><span class="toc-text">5.3 启动cpu 1</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/24/ARM64-Trust-Firmware-3-BL1%E8%A7%A3%E6%9E%90/" title="ARM64-Trust-Firmware[3]-BL1解析"><img src="/2026/01/24/ARM64-Trust-Firmware-3-BL1%E8%A7%A3%E6%9E%90/17692290470595.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM64-Trust-Firmware[3]-BL1解析"/></a><div class="content"><a class="title" href="/2026/01/24/ARM64-Trust-Firmware-3-BL1%E8%A7%A3%E6%9E%90/" title="ARM64-Trust-Firmware[3]-BL1解析">ARM64-Trust-Firmware[3]-BL1解析</a><time datetime="2026-01-24T04:29:40.000Z" title="发表于 2026-01-24 12:29:40">2026-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/24/ARM64-Trust-Firmware-2-%E5%90%AF%E5%8A%A8ATF/" title="ARM64-Trust-Firmware[2]-启动ATF"><img src="/2026/01/24/ARM64-Trust-Firmware-2-%E5%90%AF%E5%8A%A8ATF/17692287555201.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM64-Trust-Firmware[2]-启动ATF"/></a><div class="content"><a class="title" href="/2026/01/24/ARM64-Trust-Firmware-2-%E5%90%AF%E5%8A%A8ATF/" title="ARM64-Trust-Firmware[2]-启动ATF">ARM64-Trust-Firmware[2]-启动ATF</a><time datetime="2026-01-24T04:24:53.000Z" title="发表于 2026-01-24 12:24:53">2026-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/24/ARM64-Trust-Firmware-1-ARM%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/" title="ARM64-Trust-Firmware[1]-ARM安全架构"><img src="/2026/01/24/ARM64-Trust-Firmware-1-ARM%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/17692284856153.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM64-Trust-Firmware[1]-ARM安全架构"/></a><div class="content"><a class="title" href="/2026/01/24/ARM64-Trust-Firmware-1-ARM%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/" title="ARM64-Trust-Firmware[1]-ARM安全架构">ARM64-Trust-Firmware[1]-ARM安全架构</a><time datetime="2026-01-24T04:20:51.000Z" title="发表于 2026-01-24 12:20:51">2026-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-6-%E4%B8%AD%E6%96%AD%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Xhyper剖析[6]--中断虚拟化"><img src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-6-%E4%B8%AD%E6%96%AD%E8%99%9A%E6%8B%9F%E5%8C%96/17689244713913.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Xhyper剖析[6]--中断虚拟化"/></a><div class="content"><a class="title" href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-6-%E4%B8%AD%E6%96%AD%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Xhyper剖析[6]--中断虚拟化">Xhyper剖析[6]--中断虚拟化</a><time datetime="2026-01-20T15:54:17.000Z" title="发表于 2026-01-20 23:54:17">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-5-MMIO%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Xhyper剖析[5]--MMIO虚拟化"><img src="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-5-MMIO%E8%99%9A%E6%8B%9F%E5%8C%96/17689243819381.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Xhyper剖析[5]--MMIO虚拟化"/></a><div class="content"><a class="title" href="/2026/01/20/Xhyper%E5%89%96%E6%9E%90-5-MMIO%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Xhyper剖析[5]--MMIO虚拟化">Xhyper剖析[5]--MMIO虚拟化</a><time datetime="2026-01-20T15:52:10.000Z" title="发表于 2026-01-20 23:52:10">2026-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/2026/01/20/Xhyper%E5%89%96%E6%9E%90-4-XhyperCPU%E8%99%9A%E6%8B%9F%E5%8C%96/17689241119091.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By Timer</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>