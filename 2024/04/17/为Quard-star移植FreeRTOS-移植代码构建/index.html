<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>为Quard-star移植FreeRTOS-移植代码构建 | TimerのBlog</title><meta name="author" content="Timer"><meta name="copyright" content="Timer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="移植FreeRTOS1. 内存布局与移植代码架构1.1 内存启动地址修改之前我们通过OpenSBI划分了Domain，HART7是留给FreeRTOS的，起始地址设置为了0xb0000000，我们修改一下，将FreeRTOS的起始地址设置为0xBF800000，第一个修改的代码为boot的start.s  基于opensbi为quard_star创建domain | TimerのBlog (yan">
<meta property="og:type" content="article">
<meta property="og:title" content="为Quard-star移植FreeRTOS-移植代码构建">
<meta property="og:url" content="https://yanglianoo.github.io/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/index.html">
<meta property="og:site_name" content="TimerのBlog">
<meta property="og:description" content="移植FreeRTOS1. 内存布局与移植代码架构1.1 内存启动地址修改之前我们通过OpenSBI划分了Domain，HART7是留给FreeRTOS的，起始地址设置为了0xb0000000，我们修改一下，将FreeRTOS的起始地址设置为0xBF800000，第一个修改的代码为boot的start.s  基于opensbi为quard_star创建domain | TimerのBlog (yan">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yanglianoo.github.io/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422130449205.png">
<meta property="article:published_time" content="2024-04-17T09:14:47.000Z">
<meta property="article:modified_time" content="2024-04-22T08:07:26.361Z">
<meta property="article:author" content="Timer">
<meta property="article:tag" content="qemu">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="riscv">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yanglianoo.github.io/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422130449205.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yanglianoo.github.io/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '为Quard-star移植FreeRTOS-移植代码构建',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-22 16:07:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="TimerのBlog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/background.png')"><nav id="nav"><span id="blog-info"><a href="/" title="TimerのBlog"><span class="site-name">TimerのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">为Quard-star移植FreeRTOS-移植代码构建</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-17T09:14:47.000Z" title="发表于 2024-04-17 17:14:47">2024-04-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-22T08:07:26.361Z" title="更新于 2024-04-22 16:07:26">2024-04-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E4%BA%8Eqemu%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAriscv64%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/">基于qemu从零开始构建riscv64的嵌入式系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="为Quard-star移植FreeRTOS-移植代码构建"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="移植FreeRTOS"><a href="#移植FreeRTOS" class="headerlink" title="移植FreeRTOS"></a>移植FreeRTOS</h1><h2 id="1-内存布局与移植代码架构"><a href="#1-内存布局与移植代码架构" class="headerlink" title="1. 内存布局与移植代码架构"></a>1. 内存布局与移植代码架构</h2><h3 id="1-1-内存启动地址修改"><a href="#1-1-内存启动地址修改" class="headerlink" title="1.1 内存启动地址修改"></a>1.1 内存启动地址修改</h3><p>之前我们通过<code>OpenSBI</code>划分了<code>Domain</code>，<code>HART7</code>是留给<code>FreeRTOS</code>的，起始地址设置为了<code>0xb0000000</code>，我们修改一下，将<code>FreeRTOS</code>的起始地址设置为<code>0xBF800000</code>，第一个修改的代码为<code>boot</code>的<code>start.s</code></p>
<blockquote>
<p><a href="https://yanglianoo.github.io/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/">基于opensbi为quard_star创建domain | TimerのBlog (yanglianoo.github.io)</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//load trusted_fw.bin</span><br><span class="line">//[0x20400000:0x20800000] --&gt; [0xBF800000:0xBFC00000]</span><br><span class="line">   li		a0,	0x204</span><br><span class="line">slli	a0,	a0, 20      //a0 = 0x20400000</span><br><span class="line">   li		a1,	0xbf8</span><br><span class="line">slli	a1,	a1, 20      //a1 = 0xbf800000</span><br><span class="line">   li		a2,	0xbfc</span><br><span class="line">slli	a2,	a2, 20      //a2 = 0xbfc00000</span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure>

<p><code>trusted_fw.bin</code>我们是写入到<code>flash</code>的<code>0x20400000</code>地址处的，大小为<code>4k</code></p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240419174122744.png" alt="image-20240419174122744"></p>
<p>然后需要对应修改设备树的下级跳转地址：</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240419174900634.png" alt="image-20240419174900634"></p>
<p>可以看见在设备树中将<code>trusted-domain</code>的启动地址设置成了<code>0xBF800000</code>，启动的核为<code>cpu7</code>，<code>next-mode = 1</code>代表下级程序启动的<code>cpu</code>模式为<code>s</code>模式，我们是将<code>FreeRTOS</code>移植到<code>S</code>态而不是<code>M</code>态</p>
<h3 id="1-2-移植文件架构"><a href="#1-2-移植文件架构" class="headerlink" title="1.2 移植文件架构"></a>1.2 移植文件架构</h3><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240419175317425.png" alt="image-20240419175317425"></p>
<p>原本<code>trusted_domain</code>目录下就只有<code>statup.S</code>和一个<code>Makefile</code>用于在<code>uart2</code>上输出一些字符，添加移植文件后文件夹中文件如上图：</p>
<ul>
<li><code>driver</code>：串口驱动代码</li>
<li><code>FreeRTOS-Kernel</code>: FreeRTOS内核代码</li>
<li><code>riscv</code>：和<code>riscv</code>架构相关的代码</li>
<li><code>FreeRTOSConfig.h</code>：FreeRTOS的配置文件</li>
<li><code>main.c</code>：主应用程序</li>
<li><code>Makefile，link.lds</code>：编译<code>trusted_domain</code>编译规则和链接文件</li>
<li><code>startup.S</code>：启动汇编，执行一些初始化工作然后跳转到FreeRTOS内核</li>
</ul>
<h2 id="2-平台架构相关代码剖析"><a href="#2-平台架构相关代码剖析" class="headerlink" title="2. 平台架构相关代码剖析"></a>2. 平台架构相关代码剖析</h2><h3 id="2-1-driver"><a href="#2-1-driver" class="headerlink" title="2.1 driver"></a>2.1 driver</h3><p>在进行<code>domain</code>划分时，设备树文件有这样一个配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stdout</span>-path = <span class="string">&quot;/soc/uart0@10000000&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里是告知<code>OpenSBI</code>标准输出将被重定向到位于内存地址 <code>0x10000000</code> 的UART设备上，这个<code>uart</code>设备我们在下面定义了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uart0: uart0@<span class="number">10000000</span> &#123;</span><br><span class="line">	interrupts = &lt;<span class="number">0xa</span>&gt;;</span><br><span class="line">	interrupt-parent = &lt;<span class="number">0x11</span>&gt;;</span><br><span class="line">	clock-frequency = &lt;<span class="number">0x384000</span>&gt;;</span><br><span class="line">	reg = &lt;<span class="number">0x0</span> <span class="number">0x10000000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">	compatible = <span class="string">&quot;ns16550a&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>cpu7</code>即<code>trusted_domain</code>的配置中，我们使用的是<code>uart2</code>，因此我们需要手动编写<code>uart2</code>的串口驱动代码而不是使用<code>OpenSBI</code>的标准输入输出串口，<code>uart0</code>已经被我们的<code>TimerOS</code>使用了，根据设备树可知，<code>uart2</code>是<code>ns16550a</code>这款芯片，<code>qemu</code>默认的虚拟串口也是使用的这款芯片，我们先来看看这款串口芯片的芯片手册：</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240420150457253.png" alt="image-20240420150457253"></p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240420145859088.png" alt="image-20240420145859088"></p>
<ul>
<li>总共有10个寄存器，但是有的寄存器是可以复用的，<code>A2 A1 A0</code>代表此寄存器的映射地址，实际去操作此寄存器的时候需要加上串口设备的偏移地址，这里是<code>uart2 : 0x10002000</code>，每个寄存器都是8个bit</li>
</ul>
<blockquote>
<p><code>ns16550a</code>串口芯片的编程手册我放在了<code>ref</code>目录下，可以去看看这个视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Q5411w7z5?p=17&vd_source=1325a6af2d360c06e8e0c5e177802b1b">第7章（下）-Hello RVOS_哔哩哔哩_bilibili</a></p>
</blockquote>
<p>接下来来看看<code>driver</code>目录下的代码：</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240420151441701.png" alt="image-20240420151441701"></p>
<p><code>quard_star.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUARD_STAR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONS(NUM, TYPE)NUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONS(NUM, TYPE)NUM##TYPE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIM_HART			7   <span class="comment">//cpu的启动核</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_ADDR			CONS(0x02000000, UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MSIP			CONS(0x0000, UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECMP		CONS(0x4000, UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIME			CONS(0xbff8, UL)</span></span><br><span class="line"><span class="comment">//NS16550 串口映射的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NS16550_ADDR		CONS(0x10002000, UL)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义了一些宏定义的值，主要是<code>#define NS16550_ADDR		CONS(0x10002000, UL)</code>定义了串口的映射地址</li>
</ul>
<p><code>ns16550.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns16550.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 寄存器定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_RBR		0x00 <span class="comment">/* Receiver buffer reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_THR		0x00 <span class="comment">/* Transmitter holding reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_IER		0x01 <span class="comment">/* Interrupt enable reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_IIR		0x02 <span class="comment">/* Interrupt ID reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_FCR		0x02 <span class="comment">/* FIFO control reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_LCR		0x03 <span class="comment">/* Line control reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_MCR		0x04 <span class="comment">/* Modem control reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_LSR		0x05 <span class="comment">/* Line status reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_MSR		0x06 <span class="comment">/* Modem status reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_SCR		0x07 <span class="comment">/* Scratch reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_BRDL	0x00 <span class="comment">/* Divisor latch (LSB) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_BRDH	0x01 <span class="comment">/* Divisor latch (MSB) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Line status */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_DR 0x01	  <span class="comment">/* Data ready */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_OE 0x02	  <span class="comment">/* Overrun error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_PE 0x04	  <span class="comment">/* Parity error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_FE 0x08	  <span class="comment">/* Framing error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_BI 0x10	  <span class="comment">/* Break interrupt */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_THRE 0x20 <span class="comment">/* Transmitter holding register empty */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TEMT 0x40 <span class="comment">/* Transmitter empty */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_EIRF 0x80 <span class="comment">/* Error in RCVR FIFO */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从一个地址读入一个字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">readb</span><span class="params">( <span class="type">uintptr_t</span> addr )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *( (<span class="type">uint8_t</span> *) addr );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向一个地址写入一个字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">writeb</span><span class="params">( <span class="type">uint8_t</span> b, <span class="type">uintptr_t</span> addr )</span></span><br><span class="line">&#123;</span><br><span class="line">	*( (<span class="type">uint8_t</span> *) addr ) = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns16550_tx</span><span class="params">(<span class="type">uintptr_t</span> addr, <span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读数据和写数据用的同一个寄存器</span></span><br><span class="line">    <span class="keyword">while</span> ((readb(addr + REG_LSR) &amp; LSR_THRE) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//正在读，轮询等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    writeb(c, addr + REG_THR);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义了<code>ns16550_tx</code>函数来向串口写入一个字节的数据，<code>NS16550</code>的数据寄存器为<code>RHR</code>和<code>THR</code>，他们都在偏移地址为0处，可复用为读模式和写模式</p>
</li>
<li><p><code>LSR</code>寄存器有8个bit位，用于反应串口的硬件状态，<code>bit5</code>具体代表“Transmitter Holding Register Empty”，当<code>LSR_THRE</code>为1时，它表示发送保持寄存器为空，UART准备好接受新的字节进行发送。因此在<code>ns16550_tx</code>发送数据时需要先判断此bit位，当此bit位为1时说明可以写入新的字节数据，<code>THR</code>8个bit刚好代表一个字节，写入的一个字节数据就放入了<code>THR</code></p>
</li>
</ul>
<p><code>debug_log.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quard_star.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns16550.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_LOG_BUFF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _puts(<span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*str &amp;&amp; (counter &lt; UART_LOG_BUFF_SIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	        ns16550_tx( NS16550_ADDR, <span class="string">&#x27;\r&#x27;</span> );</span><br><span class="line">	    ns16550_tx( NS16550_ADDR, *str++ );</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>debug_log.c</code>中定义了一个<code> _puts</code>函数用于将一个字符串一个字节一个字节的写入到串口中进行输出，返回输出的字符数</li>
</ul>
<h3 id="2-2-riscv"><a href="#2-2-riscv" class="headerlink" title="2.2 riscv"></a>2.2 riscv</h3><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240420164504237.png" alt="image-20240420164504237"></p>
<p><code>riscv</code>目录下是和架构以及<code>OpenSBI</code>相关的代码，我们在移植FreeRTOS到<code>cpu7</code>的S态时需要用到<code>OpenSBI</code>的一些和中断相关的功能，因此需要首先添加调用<code>OpenSBI</code>服务的代码：<code>sbi.c</code>和<code>sbi.h</code>，这里我直接给出代码，和之前<code>Timeros</code>一样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_RISCV_SBI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_RISCV_SBI_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_id</span> &#123;</span></span><br><span class="line">	SBI_EXT_0_1_SET_TIMER = <span class="number">0x0</span>,</span><br><span class="line">	SBI_EXT_0_1_CONSOLE_PUTCHAR = <span class="number">0x1</span>,</span><br><span class="line">	SBI_EXT_0_1_CONSOLE_GETCHAR = <span class="number">0x2</span>,</span><br><span class="line">	SBI_EXT_0_1_CLEAR_IPI = <span class="number">0x3</span>,</span><br><span class="line">	SBI_EXT_0_1_SEND_IPI = <span class="number">0x4</span>,</span><br><span class="line">	SBI_EXT_0_1_REMOTE_FENCE_I = <span class="number">0x5</span>,</span><br><span class="line">	SBI_EXT_0_1_REMOTE_SFENCE_VMA = <span class="number">0x6</span>,</span><br><span class="line">	SBI_EXT_0_1_REMOTE_SFENCE_VMA_ASID = <span class="number">0x7</span>,</span><br><span class="line">	SBI_EXT_0_1_SHUTDOWN = <span class="number">0x8</span>,</span><br><span class="line">	SBI_EXT_BASE = <span class="number">0x10</span>,</span><br><span class="line">	SBI_EXT_TIME = <span class="number">0x54494D45</span>,</span><br><span class="line">	SBI_EXT_IPI = <span class="number">0x735049</span>,</span><br><span class="line">	SBI_EXT_RFENCE = <span class="number">0x52464E43</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_base_fid</span> &#123;</span></span><br><span class="line">	SBI_EXT_BASE_GET_SPEC_VERSION = <span class="number">0</span>,</span><br><span class="line">	SBI_EXT_BASE_GET_IMP_ID,</span><br><span class="line">	SBI_EXT_BASE_GET_IMP_VERSION,</span><br><span class="line">	SBI_EXT_BASE_PROBE_EXT,</span><br><span class="line">	SBI_EXT_BASE_GET_MVENDORID,</span><br><span class="line">	SBI_EXT_BASE_GET_MARCHID,</span><br><span class="line">	SBI_EXT_BASE_GET_MIMPID,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_time_fid</span> &#123;</span></span><br><span class="line">	SBI_EXT_TIME_SET_TIMER = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_ipi_fid</span> &#123;</span></span><br><span class="line">	SBI_EXT_IPI_SEND_IPI = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_rfence_fid</span> &#123;</span></span><br><span class="line">	SBI_EXT_RFENCE_REMOTE_FENCE_I = <span class="number">0</span>,</span><br><span class="line">	SBI_EXT_RFENCE_REMOTE_SFENCE_VMA,</span><br><span class="line">	SBI_EXT_RFENCE_REMOTE_SFENCE_VMA_ASID,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_EXT_SET_TIMER		SBI_EXT_TIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_SET_TIMER		SBI_EXT_TIME_SET_TIMER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_EXT_SEND_IPI		SBI_EXT_IPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_SEND_IPI		SBI_EXT_IPI_SEND_IPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_EXT_REMOTE_FENCE_I		SBI_EXT_RFENCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_REMOTE_FENCE_I		SBI_EXT_RFENCE_REMOTE_FENCE_I</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_EXT_REMOTE_SFENCE_VMA	SBI_EXT_RFENCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_REMOTE_SFENCE_VMA	SBI_EXT_RFENCE_REMOTE_SFENCE_VMA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_EXT_REMOTE_SFENCE_VMA_ASID	SBI_EXT_RFENCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_REMOTE_SFENCE_VMA_ASID	SBI_EXT_RFENCE_REMOTE_SFENCE_VMA_ASID</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SBI return error codes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_SUCCESS			         0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_ERR_FAILURE			    -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_ERR_NOT_SUPPORTED		-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_ERR_INVALID_PARAM		-3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_ERR_DENIED			    -4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_ERR_INVALID_ADDRESS		-5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> error;</span><br><span class="line">	<span class="type">long</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> sbiret <span class="title function_">sbi_ecall</span><span class="params">(<span class="type">int</span> ext, <span class="type">int</span> fid, <span class="type">unsigned</span> <span class="type">long</span> arg0,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> arg1, <span class="type">unsigned</span> <span class="type">long</span> arg2,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> arg3, <span class="type">unsigned</span> <span class="type">long</span> arg4,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> arg5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_console_getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_set_timer</span><span class="params">(<span class="type">uint64_t</span> stime_value)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">sbi_get_spec_version</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_get_impl_id</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_probe_extension</span><span class="params">(<span class="type">int</span> ext)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_clear_ipi</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_shutdown</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_send_ipi</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_fence_i</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_sfence_vma</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_sfence_vma_asid</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> size,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> asid)</span>;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> sbiret <span class="title function_">sbi_ecall</span><span class="params">(<span class="type">int</span> ext, <span class="type">int</span> fid, <span class="type">unsigned</span> <span class="type">long</span> arg0,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> arg1, <span class="type">unsigned</span> <span class="type">long</span> arg2,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> arg3, <span class="type">unsigned</span> <span class="type">long</span> arg4,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> arg5)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用GCC的扩展语法，用于将一个值存储到RISC-V架构中的寄存器a0中。</span></span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a0 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a0&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg0);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a1 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a1&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg1);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a2 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a2&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg2);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a3 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a3&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg3);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a4 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a4&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg4);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a5 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a5&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg5);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a6 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a6&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(fid);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a7 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a7&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(ext);</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ecall&quot;</span></span></span><br><span class="line"><span class="params">		      : <span class="string">&quot;+r&quot;</span> (a0), <span class="string">&quot;+r&quot;</span> (a1)</span></span><br><span class="line"><span class="params">		      : <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a3), <span class="string">&quot;r&quot;</span> (a4), <span class="string">&quot;r&quot;</span> (a5), <span class="string">&quot;r&quot;</span> (a6), <span class="string">&quot;r&quot;</span> (a7)</span></span><br><span class="line"><span class="params">		      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">	ret.error = a0;</span><br><span class="line">	ret.value = a1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_set_timer() - Program the timer for next timer event.</span></span><br><span class="line"><span class="comment"> * @stime_value: The value after which next timer event should fire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_set_timer</span><span class="params">(<span class="type">uint64_t</span> stime_value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 32</span></span><br><span class="line">	sbi_ecall(SBI_EXT_SET_TIMER, SBI_FID_SET_TIMER, stime_value,</span><br><span class="line">		  stime_value &gt;&gt; <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	sbi_ecall(SBI_EXT_SET_TIMER, SBI_FID_SET_TIMER, stime_value,</span><br><span class="line">		  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_get_spec_version() - get current SBI specification version</span></span><br><span class="line"><span class="comment"> * 获取SBI规范版本 (FID #0)</span></span><br><span class="line"><span class="comment"> * Return: version id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sbi_get_spec_version</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">	ret = sbi_ecall(SBI_EXT_BASE, SBI_EXT_BASE_GET_SPEC_VERSION,</span><br><span class="line">			<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ret.error)</span><br><span class="line">		<span class="keyword">if</span> (ret.value)</span><br><span class="line">			<span class="keyword">return</span> ret.value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_get_impl_id() - get SBI implementation ID</span></span><br><span class="line"><span class="comment"> * 获取SBI规范版本 (FID #0)  基本拓展 EID = 0x10</span></span><br><span class="line"><span class="comment"> * Return: implementation ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_get_impl_id</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">	ret = sbi_ecall(SBI_EXT_BASE, SBI_EXT_BASE_GET_IMP_ID,</span><br><span class="line">			<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ret.error)</span><br><span class="line">		<span class="keyword">if</span> (ret.value)</span><br><span class="line">			<span class="keyword">return</span> ret.value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_probe_extension() - Check if an SBI extension ID is supported or not.</span></span><br><span class="line"><span class="comment"> * @extid: The extension ID to be probed.</span></span><br><span class="line"><span class="comment"> *  探测SBI扩展功能 (FID #3) 基本拓展 EID = 0x10</span></span><br><span class="line"><span class="comment"> * Return: Extension specific nonzero value f yes, -1 otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_probe_extension</span><span class="params">(<span class="type">int</span> extid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">	ret = sbi_ecall(SBI_EXT_BASE, SBI_EXT_BASE_PROBE_EXT, extid,</span><br><span class="line">			<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ret.error)</span><br><span class="line">		<span class="keyword">if</span> (ret.value)</span><br><span class="line">			<span class="keyword">return</span> ret.value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_console_putchar() - Writes given character to the console device.</span></span><br><span class="line"><span class="comment"> * @ch: The data to be written to the console.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	sbi_ecall(SBI_EXT_0_1_CONSOLE_PUTCHAR, <span class="number">0</span>, ch, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_console_getchar() - Reads a byte from console device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the value read from console.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_console_getchar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">	ret = sbi_ecall(SBI_EXT_0_1_CONSOLE_GETCHAR, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret.error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_clear_ipi() - Clear any pending IPIs for the calling hart.</span></span><br><span class="line"><span class="comment"> * 清除IPI (EID #0x03) 清除任何挂起的IPI（处理器核间中断）。</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_clear_ipi</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	sbi_ecall(SBI_EXT_0_1_CLEAR_IPI, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_shutdown() - Remove all the harts from executing supervisor code.</span></span><br><span class="line"><span class="comment"> * 系统关闭 (EID #0x08)</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_shutdown</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	sbi_ecall(SBI_EXT_0_1_SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_send_ipi() - Send an IPI to any hart.</span></span><br><span class="line"><span class="comment"> * @hart_mask: A cpu mask containing all the target harts.</span></span><br><span class="line"><span class="comment"> * 向 hart_mask 中定义的所有 hart 发送跨处理器中断。</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_send_ipi</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span></span><br><span class="line">&#123;</span><br><span class="line">	sbi_ecall(SBI_EXT_SEND_IPI, SBI_FID_SEND_IPI, (<span class="type">unsigned</span> <span class="type">long</span>)hart_mask,</span><br><span class="line">		  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_remote_fence_i() - Execute FENCE.I instruction on given remote harts.</span></span><br><span class="line"><span class="comment"> * @hart_mask: A cpu mask containing all the target harts.</span></span><br><span class="line"><span class="comment"> * 远程指示harts执行FENCE.I指令</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_fence_i</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span></span><br><span class="line">&#123;</span><br><span class="line">	sbi_ecall(SBI_EXT_REMOTE_FENCE_I, SBI_FID_REMOTE_FENCE_I,</span><br><span class="line">		  (<span class="type">unsigned</span> <span class="type">long</span>)hart_mask, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_remote_sfence_vma() - Execute SFENCE.VMA instructions on given remote</span></span><br><span class="line"><span class="comment"> *			     harts for the specified virtual address range.</span></span><br><span class="line"><span class="comment"> * @hart_mask: A cpu mask containing all the target harts.</span></span><br><span class="line"><span class="comment"> * @start: Start of the virtual address</span></span><br><span class="line"><span class="comment"> * @size: Total size of the virtual address range.</span></span><br><span class="line"><span class="comment"> * 指示远程hart执行一个或多个SFENCE.VMA指令，覆盖从start到size的虚拟地址范围内的地址。</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_sfence_vma</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	sbi_ecall(SBI_EXT_REMOTE_SFENCE_VMA, SBI_FID_REMOTE_SFENCE_VMA,</span><br><span class="line">		  (<span class="type">unsigned</span> <span class="type">long</span>)hart_mask, start, size, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_remote_sfence_vma_asid() - Execute SFENCE.VMA instructions on given</span></span><br><span class="line"><span class="comment"> * remote harts for a virtual address range belonging to a specific ASID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @hart_mask: A cpu mask containing all the target harts.</span></span><br><span class="line"><span class="comment"> * @start: Start of the virtual address</span></span><br><span class="line"><span class="comment"> * @size: Total size of the virtual address range.</span></span><br><span class="line"><span class="comment"> * @asid: The value of address space identifier (ASID).</span></span><br><span class="line"><span class="comment"> * 指示远程hart执行一个或多个SFENCE.VMA指令，覆盖从start到size的虚拟地址范围内的地址。这仅涵盖给定的ASID。</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_sfence_vma_asid</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> size,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> asid)</span></span><br><span class="line">&#123;</span><br><span class="line">	sbi_ecall(SBI_EXT_REMOTE_SFENCE_VMA_ASID,</span><br><span class="line">		  SBI_FID_REMOTE_SFENCE_VMA_ASID,</span><br><span class="line">		  (<span class="type">unsigned</span> <span class="type">long</span>)hart_mask, start, size, asid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>riscv_reg.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RISCV_REG_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_REG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//__riscv_xlen 是编译器预定义的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGSIZE		4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGSHIFT	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD		lw</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STOR		sw</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGSIZE		8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGSHIFT	3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD		ld</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STOR		sd</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __riscv_xlen */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__riscv_xlen </code>是编译器预定义的宏，使用宏定义的方式来控制在32位和64位平台上编译的统一性</li>
<li>定义了加载和存储指令以及寄存器大小</li>
</ul>
<p><code>sbi_const.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SBI_CONST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SBI_CONST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*提供一种在汇编和C代码之间共享常量定义的便捷方法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AC(X,Y)	X</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AT(T,X)	X</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AC(X,Y)	(X##Y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AC(X,Y)	__AC(X,Y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AT(T,X)	((T)(X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 UL后缀，定义无符号长整型和无符号长长整型常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UL(x)		(_AC(x, UL))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ULL(x)		(_AC(x, ULL))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于生成位掩码，方便进行位操作，如设置、清除或检查某位。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BITUL(x)	(_UL(1) &lt;&lt; (x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BITULL(x)	(_ULL(1) &lt;&lt; (x))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UL(x)		(_UL(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL(x)		(_ULL(x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将宏参数转换成字符串</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STR(s)	#s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRINGIFY(s)	__STR(s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义了一些宏用于添加符号后缀、生成<code>bitmask</code>、宏参数转换成字符串等功能</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: BSD-2-Clause</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2019 Western Digital Corporation or its affiliates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Authors:</span></span><br><span class="line"><span class="comment"> *   Anup Patel &lt;anup.patel@wdc.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RISCV_ENCODING_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RISCV_ENCODING_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi_const.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clang-format off */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SIE			_UL(0x00000002)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MIE			_UL(0x00000008)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SPIE_SHIFT		5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SPIE			(_UL(1) &lt;&lt; MSTATUS_SPIE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_UBE			_UL(0x00000040)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPIE			_UL(0x00000080)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SPP_SHIFT		8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SPP			(_UL(1) &lt;&lt; MSTATUS_SPP_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP_SHIFT		11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP			(_UL(3) &lt;&lt; MSTATUS_MPP_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_FS			_UL(0x00006000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_XS			_UL(0x00018000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_VS			_UL(0x01800000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPRV			_UL(0x00020000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SUM			_UL(0x00040000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MXR			_UL(0x00080000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_TVM			_UL(0x00100000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_TW			_UL(0x00200000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_TSR			_UL(0x00400000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS32_SD			_UL(0x80000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_UXL			_ULL(0x0000000300000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SXL			_ULL(0x0000000C00000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SBE			_ULL(0x0000001000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MBE			_ULL(0x0000002000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPV			_ULL(0x0000008000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUSH_SBE			_UL(0x00000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUSH_MBE			_UL(0x00000020)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUSH_MPV			_UL(0x00000080)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS32_SD			_UL(0x80000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS64_SD			_ULL(0x8000000000000000)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SIE			MSTATUS_SIE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPIE_SHIFT		MSTATUS_SPIE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPIE			MSTATUS_SPIE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPP_SHIFT		MSTATUS_SPP_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPP			MSTATUS_SPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_FS			MSTATUS_FS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_XS			MSTATUS_XS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_VS			MSTATUS_VS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SUM			MSTATUS_SUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_MXR			MSTATUS_MXR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS32_SD			MSTATUS32_SD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS64_UXL			MSTATUS_UXL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS64_SD			MSTATUS64_SD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VSXL			_UL(0x300000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VSXL_SHIFT		32</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VTSR			_UL(0x00400000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VTW			_UL(0x00200000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VTVM			_UL(0x00100000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VGEIN			_UL(0x0003f000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VGEIN_SHIFT		12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_HU			_UL(0x00000200)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_SPVP			_UL(0x00000100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_SPV			_UL(0x00000080)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_GVA			_UL(0x00000040)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VSBE			_UL(0x00000020)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_S_SOFT			1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_VS_SOFT			2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_M_SOFT			3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_S_TIMER			5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_VS_TIMER			6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_M_TIMER			7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_S_EXT			9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_VS_EXT			10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_M_EXT			11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_S_GEXT			12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_SSIP			(_UL(1) &lt;&lt; IRQ_S_SOFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_VSSIP			(_UL(1) &lt;&lt; IRQ_VS_SOFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_MSIP			(_UL(1) &lt;&lt; IRQ_M_SOFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_STIP			(_UL(1) &lt;&lt; IRQ_S_TIMER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_VSTIP			(_UL(1) &lt;&lt; IRQ_VS_TIMER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_MTIP			(_UL(1) &lt;&lt; IRQ_M_TIMER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_SEIP			(_UL(1) &lt;&lt; IRQ_S_EXT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_VSEIP			(_UL(1) &lt;&lt; IRQ_VS_EXT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_MEIP			(_UL(1) &lt;&lt; IRQ_M_EXT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_SGEIP			(_UL(1) &lt;&lt; IRQ_S_GEXT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIP_SSIP			MIP_SSIP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIP_STIP			MIP_STIP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_U				_UL(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_S				_UL(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_M				_UL(3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP32_MODE			_UL(0x80000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP32_ASID			_UL(0x7FC00000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP32_PPN			_UL(0x003FFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP64_MODE			_ULL(0xF000000000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP64_ASID			_ULL(0x0FFFF00000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP64_PPN			_ULL(0x00000FFFFFFFFFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_OFF			_UL(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_SV32			_UL(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_SV39			_UL(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_SV48			_UL(9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_SV57			_UL(10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_SV64			_UL(11)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_OFF			_UL(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_SV32X4		_UL(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_SV39X4		_UL(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_SV48X4		_UL(9)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP32_MODE_SHIFT		31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP32_VMID_SHIFT		22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP32_VMID_MASK		_UL(0x1FC00000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP32_PPN			_UL(0x003FFFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP64_MODE_SHIFT		60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP64_VMID_SHIFT		44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP64_VMID_MASK		_ULL(0x03FFF00000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP64_PPN			_ULL(0x00000FFFFFFFFFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_R				_UL(0x01)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_W				_UL(0x02)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_X				_UL(0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_A				_UL(0x18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_A_TOR			_UL(0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_A_NA4			_UL(0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_A_NAPOT			_UL(0x18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_L				_UL(0x80)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_SHIFT			2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_COUNT			64</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_ADDR_MASK			((_ULL(0x1) &lt;&lt; 54) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_ADDR_MASK			_UL(0xFFFFFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SD			MSTATUS64_SD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SD			SSTATUS64_SD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE			SATP64_MODE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_PPN			HGATP64_PPN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_VMID_SHIFT		HGATP64_VMID_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_VMID_MASK			HGATP64_VMID_MASK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_SHIFT		HGATP64_MODE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SD			MSTATUS32_SD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SD			SSTATUS32_SD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE			SATP32_MODE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_PPN			HGATP32_PPN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_VMID_SHIFT		HGATP32_VMID_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_VMID_MASK			HGATP32_VMID_MASK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_SHIFT		HGATP32_MODE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== User-level CSRs ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Trap Setup (N-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_USTATUS			0x000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UIE				0x004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UTVEC			0x005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Trap Handling (N-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_USCRATCH			0x040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UEPC			0x041</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UCAUSE			0x042</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UTVAL			0x043</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UIP				0x044</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Floating-point CSRs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_FFLAGS			0x001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_FRM				0x002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_FCSR			0x003</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Counters/Timers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_CYCLE			0xc00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TIME			0xc01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_INSTRET			0xc02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER3			0xc03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER4			0xc04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER5			0xc05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER6			0xc06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER7			0xc07</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER8			0xc08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER9			0xc09</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER10		0xc0a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER11		0xc0b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER12		0xc0c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER13		0xc0d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER14		0xc0e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER15		0xc0f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER16		0xc10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER17		0xc11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER18		0xc12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER19		0xc13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER20		0xc14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER21		0xc15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER22		0xc16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER23		0xc17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER24		0xc18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER25		0xc19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER26		0xc1a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER27		0xc1b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER28		0xc1c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER29		0xc1d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER30		0xc1e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER31		0xc1f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_CYCLEH			0xc80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TIMEH			0xc81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_INSTRETH			0xc82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER3H		0xc83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER4H		0xc84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER5H		0xc85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER6H		0xc86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER7H		0xc87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER8H		0xc88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER9H		0xc89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER10H		0xc8a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER11H		0xc8b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER12H		0xc8c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER13H		0xc8d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER14H		0xc8e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER15H		0xc8f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER16H		0xc90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER17H		0xc91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER18H		0xc92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER19H		0xc93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER20H		0xc94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER21H		0xc95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER22H		0xc96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER23H		0xc97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER24H		0xc98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER25H		0xc99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER26H		0xc9a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER27H		0xc9b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER28H		0xc9c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER29H		0xc9d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER30H		0xc9e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER31H		0xc9f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Supervisor-level CSRs ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Trap Setup */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SSTATUS			0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SEDELEG			0x102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIDELEG			0x103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIE				0x104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_STVEC			0x105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SCOUNTEREN			0x106</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Trap Handling */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SSCRATCH			0x140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SEPC			0x141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SCAUSE			0x142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_STVAL			0x143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIP				0x144</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Protection and Translation */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SATP			0x180</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Hypervisor-level CSRs ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hypervisor Trap Setup (H-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HSTATUS			0x600</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HEDELEG			0x602</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HIDELEG			0x603</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HIE				0x604</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HCOUNTEREN			0x606</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HGEIE			0x607</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hypervisor Trap Handling (H-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HTVAL			0x643</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HIP				0x644</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HVIP			0x645</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HTINST			0x64a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HGEIP			0xe12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hypervisor Protection and Translation (H-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HGATP			0x680</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hypervisor Counter/Timer Virtualization Registers (H-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HTIMEDELTA			0x605</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HTIMEDELTAH			0x615</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Virtual Supervisor Registers (H-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSSTATUS			0x200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSIE			0x204</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSTVEC			0x205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSSCRATCH			0x240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSEPC			0x241</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSCAUSE			0x242</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSTVAL			0x243</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSIP			0x244</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSATP			0x280</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Machine-level CSRs ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Information Registers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MVENDORID			0xf11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MARCHID			0xf12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MIMPID			0xf13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHARTID			0xf14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Trap Setup */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSTATUS			0x300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MISA			0x301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MEDELEG			0x302</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MIDELEG			0x303</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MIE				0x304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MTVEC			0x305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCOUNTEREN			0x306</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSTATUSH			0x310</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Trap Handling */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSCRATCH			0x340</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MEPC			0x341</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCAUSE			0x342</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MTVAL			0x343</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MIP				0x344</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MTINST			0x34a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MTVAL2			0x34b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Memory Protection */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG0			0x3a0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG1			0x3a1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG2			0x3a2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG3			0x3a3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG4			0x3a4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG5			0x3a5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG6			0x3a6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG7			0x3a7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG8			0x3a8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG9			0x3a9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG10			0x3aa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG11			0x3ab</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG12			0x3ac</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG13			0x3ad</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG14			0x3ae</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG15			0x3af</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR0			0x3b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR1			0x3b1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR2			0x3b2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR3			0x3b3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR4			0x3b4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR5			0x3b5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR6			0x3b6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR7			0x3b7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR8			0x3b8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR9			0x3b9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR10			0x3ba</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR11			0x3bb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR12			0x3bc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR13			0x3bd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR14			0x3be</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR15			0x3bf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR16			0x3c0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR17			0x3c1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR18			0x3c2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR19			0x3c3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR20			0x3c4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR21			0x3c5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR22			0x3c6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR23			0x3c7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR24			0x3c8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR25			0x3c9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR26			0x3ca</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR27			0x3cb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR28			0x3cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR29			0x3cd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR30			0x3ce</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR31			0x3cf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR32			0x3d0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR33			0x3d1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR34			0x3d2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR35			0x3d3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR36			0x3d4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR37			0x3d5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR38			0x3d6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR39			0x3d7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR40			0x3d8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR41			0x3d9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR42			0x3da</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR43			0x3db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR44			0x3dc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR45			0x3dd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR46			0x3de</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR47			0x3df</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR48			0x3e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR49			0x3e1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR50			0x3e2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR51			0x3e3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR52			0x3e4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR53			0x3e5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR54			0x3e6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR55			0x3e7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR56			0x3e8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR57			0x3e9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR58			0x3ea</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR59			0x3eb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR60			0x3ec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR61			0x3ed</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR62			0x3ee</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR63			0x3ef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Counters/Timers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCYCLE			0xb00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MINSTRET			0xb02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER3		0xb03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER4		0xb04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER5		0xb05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER6		0xb06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER7		0xb07</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER8		0xb08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER9		0xb09</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER10		0xb0a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER11		0xb0b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER12		0xb0c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER13		0xb0d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER14		0xb0e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER15		0xb0f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER16		0xb10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER17		0xb11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER18		0xb12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER19		0xb13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER20		0xb14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER21		0xb15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER22		0xb16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER23		0xb17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER24		0xb18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER25		0xb19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER26		0xb1a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER27		0xb1b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER28		0xb1c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER29		0xb1d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER30		0xb1e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER31		0xb1f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCYCLEH			0xb80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MINSTRETH			0xb82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER3H		0xb83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER4H		0xb84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER5H		0xb85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER6H		0xb86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER7H		0xb87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER8H		0xb88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER9H		0xb89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER10H		0xb8a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER11H		0xb8b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER12H		0xb8c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER13H		0xb8d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER14H		0xb8e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER15H		0xb8f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER16H		0xb90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER17H		0xb91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER18H		0xb92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER19H		0xb93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER20H		0xb94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER21H		0xb95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER22H		0xb96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER23H		0xb97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER24H		0xb98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER25H		0xb99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER26H		0xb9a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER27H		0xb9b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER28H		0xb9c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER29H		0xb9d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER30H		0xb9e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER31H		0xb9f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Counter Setup */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCOUNTINHIBIT		0x320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT3			0x323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT4			0x324</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT5			0x325</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT6			0x326</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT7			0x327</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT8			0x328</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT9			0x329</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT10			0x32a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT11			0x32b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT12			0x32c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT13			0x32d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT14			0x32e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT15			0x32f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT16			0x330</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT17			0x331</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT18			0x332</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT19			0x333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT20			0x334</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT21			0x335</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT22			0x336</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT23			0x337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT24			0x338</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT25			0x339</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT26			0x33a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT27			0x33b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT28			0x33c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT29			0x33d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT30			0x33e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT31			0x33f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Debug/Trace Registers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TSELECT			0x7a0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TDATA1			0x7a1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TDATA2			0x7a2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TDATA3			0x7a3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Debug Mode Registers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_DCSR			0x7b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_DPC				0x7b1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_DSCRATCH0			0x7b2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_DSCRATCH1			0x7b3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Trap/Exception Causes ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_MISALIGNED_FETCH		0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_FETCH_ACCESS		0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_ILLEGAL_INSTRUCTION	0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_BREAKPOINT		0x3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_MISALIGNED_LOAD		0x4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_LOAD_ACCESS		0x5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_MISALIGNED_STORE		0x6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_STORE_ACCESS		0x7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_USER_ECALL		0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_SUPERVISOR_ECALL		0x9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_VIRTUAL_SUPERVISOR_ECALL	0xa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_MACHINE_ECALL		0xb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_FETCH_PAGE_FAULT		0xc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_LOAD_PAGE_FAULT		0xd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_STORE_PAGE_FAULT		0xf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_FETCH_GUEST_PAGE_FAULT	0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_LOAD_GUEST_PAGE_FAULT	0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_VIRTUAL_INST_FAULT	0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_STORE_GUEST_PAGE_FAULT	0x17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Instruction Encodings ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LB			0x3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LB			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LH			0x1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LH			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LW			0x2003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LW			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LD			0x3003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LD			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LBU			0x4003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LBU			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LHU			0x5003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LHU			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LWU			0x6003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LWU			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_SB			0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_SB			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_SH			0x1023</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_SH			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_SW			0x2023</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_SW			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_SD			0x3023</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_SD			0x707f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FLW			0x2007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FLW			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FLD			0x3007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FLD			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FLQ			0x4007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FLQ			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FSW			0x2027</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FSW			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FSD			0x3027</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FSD			0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FSQ			0x4027</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FSQ			0x707f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_LD			0x6000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_LD			0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_SD			0xe000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_SD			0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_LW			0x4000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_LW			0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_SW			0xc000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_SW			0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_LDSP		0x6002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_LDSP		0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_SDSP		0xe002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_SDSP		0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_LWSP		0x4002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_LWSP		0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_SWSP		0xc002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_SWSP		0xe003</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FLD		0x2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FLD			0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FLW		0x6000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FLW			0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FSD		0xa000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FSD			0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FSW		0xe000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FSW			0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FLDSP		0x2002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FLDSP		0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FSDSP		0xa002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FSDSP		0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FLWSP		0x6002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FLWSP		0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FSWSP		0xe002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FSWSP		0xe003</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_WFI			0xffffff00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_WFI			0x10500000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_16BIT_MASK			0x3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_32BIT_MASK			0x1c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_IS_16BIT(insn)		\</span></span><br><span class="line"><span class="meta">	(((insn) &amp; INSN_16BIT_MASK) != INSN_16BIT_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_IS_32BIT(insn)		\</span></span><br><span class="line"><span class="meta">	(((insn) &amp; INSN_16BIT_MASK) == INSN_16BIT_MASK &amp;&amp; \</span></span><br><span class="line"><span class="meta">	 ((insn) &amp; INSN_32BIT_MASK) != INSN_32BIT_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_LEN(insn)			(INSN_IS_16BIT(insn) ? 2 : 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_REGBYTES			3</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_REGBYTES			2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGBYTES			(1 &lt;&lt; LOG_REGBYTES)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SH_RD				7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SH_RS1				15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SH_RS2				20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SH_RS2C				2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RV_X(x, s, n)			(((x) &gt;&gt; (s)) &amp; ((1 &lt;&lt; (n)) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_LW_IMM(x)			((RV_X(x, 6, 1) &lt;&lt; 2) | \</span></span><br><span class="line"><span class="meta">					 (RV_X(x, 10, 3) &lt;&lt; 3) | \</span></span><br><span class="line"><span class="meta">					 (RV_X(x, 5, 1) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_LD_IMM(x)			((RV_X(x, 10, 3) &lt;&lt; 3) | \</span></span><br><span class="line"><span class="meta">					 (RV_X(x, 5, 2) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_LWSP_IMM(x)			((RV_X(x, 4, 3) &lt;&lt; 2) | \</span></span><br><span class="line"><span class="meta">					 (RV_X(x, 12, 1) &lt;&lt; 5) | \</span></span><br><span class="line"><span class="meta">					 (RV_X(x, 2, 2) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_LDSP_IMM(x)			((RV_X(x, 5, 2) &lt;&lt; 3) | \</span></span><br><span class="line"><span class="meta">					 (RV_X(x, 12, 1) &lt;&lt; 5) | \</span></span><br><span class="line"><span class="meta">					 (RV_X(x, 2, 3) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_SWSP_IMM(x)			((RV_X(x, 9, 4) &lt;&lt; 2) | \</span></span><br><span class="line"><span class="meta">					 (RV_X(x, 7, 2) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_SDSP_IMM(x)			((RV_X(x, 10, 3) &lt;&lt; 3) | \</span></span><br><span class="line"><span class="meta">					 (RV_X(x, 7, 3) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_RS1S(insn)			(8 + RV_X(insn, SH_RD, 3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_RS2S(insn)			(8 + RV_X(insn, SH_RS2C, 3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_RS2(insn)			RV_X(insn, SH_RS2C, 5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHIFT_RIGHT(x, y)		\</span></span><br><span class="line"><span class="meta">	((y) <span class="string">&lt; 0 ? ((x) &lt;&lt; -(y)) : ((x) &gt;</span>&gt; (y)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_MASK			\</span></span><br><span class="line"><span class="meta">	((1 &lt;&lt; (5 + LOG_REGBYTES)) - (1 &lt;&lt; LOG_REGBYTES))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_OFFSET(insn, pos)		\</span></span><br><span class="line"><span class="meta">	(SHIFT_RIGHT((insn), (pos) - LOG_REGBYTES) &amp; REG_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_PTR(insn, pos, regs)	\</span></span><br><span class="line"><span class="meta">	(ulong *)((ulong)(regs) + REG_OFFSET(insn, pos))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RM(insn)			(((insn) &gt;&gt; 12) &amp; 7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RS1(insn, regs)		(*REG_PTR(insn, SH_RS1, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RS2(insn, regs)		(*REG_PTR(insn, SH_RS2, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RS1S(insn, regs)		(*REG_PTR(RVC_RS1S(insn), 0, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RS2S(insn, regs)		(*REG_PTR(RVC_RS2S(insn), 0, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RS2C(insn, regs)		(*REG_PTR(insn, SH_RS2C, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SP(regs)			(*REG_PTR(2, 0, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_RD(insn, regs, val)		(*REG_PTR(insn, SH_RD, regs) = (val))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMM_I(insn)			((s32)(insn) &gt;&gt; 20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMM_S(insn)			(((s32)(insn) &gt;&gt; 25 &lt;&lt; 5) | \</span></span><br><span class="line"><span class="meta">					 (s32)(((insn) &gt;&gt; 7) &amp; 0x1f))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MASK_FUNCT3			0x7000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clang-format on */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义了和<code>riscv</code>架构寄存器相关的代码，在<code>riscv</code>架构中，各个特权级的控制寄存器是被统一映射到了一个确定的地址，可以直接操作这个地址来操作<code>csr</code>，可以在官方文档中找到<code>The RISC-V Instruction Set Manual</code>，我将此文档放在了<code>ref</code>目录下，举个例子</p>
</li>
<li><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240420173015169.png" alt="image-20240420173015169"></p>
</li>
<li><p>可以看见上面文档中定义了控制寄存器对应的映射地址，在<code>riscv_encoding.h</code>做了对应的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ===== Supervisor-level CSRs ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Trap Setup */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SSTATUS			0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SEDELEG			0x102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIDELEG			0x103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIE				0x104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_STVEC			0x105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SCOUNTEREN			0x106</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Trap Handling */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SSCRATCH			0x140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SEPC			0x141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SCAUSE			0x142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_STVAL			0x143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIP				0x144</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Protection and Translation */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SATP			0x180</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>riscv_encoding.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RISCV_ASM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RISCV_ASM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv_encoding.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clang-format off */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ASM_STR(x)	x</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ASM_STR(x)	#x</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __REG_SEL(a, b)	__ASM_STR(a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __riscv_xlen == 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __REG_SEL(a, b)	__ASM_STR(b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected __riscv_xlen&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT	(12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE	(_AC(1, UL) &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MASK	(~(PAGE_SIZE - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_L		__REG_SEL(ld, lw)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_S		__REG_SEL(sd, sw)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZREG		__REG_SEL(8, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LGREG		__REG_SEL(3, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __SIZEOF_POINTER__ == 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_PTR		.dword</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZPTR		8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGPTR		3</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_PTR		<span class="string">&quot;.dword&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZPTR		<span class="string">&quot;8&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGPTR		<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __SIZEOF_POINTER__ == 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_PTR		.word</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZPTR		4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGPTR		2</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_PTR		<span class="string">&quot;.word&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZPTR		<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGPTR		<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected __SIZEOF_POINTER__&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (__SIZEOF_INT__ == 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_INT		__ASM_STR(.word)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZINT		__ASM_STR(4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGINT		__ASM_STR(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected __SIZEOF_INT__&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (__SIZEOF_SHORT__ == 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SHORT		__ASM_STR(.half)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZSHORT		__ASM_STR(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGSHORT		__ASM_STR(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected __SIZEOF_SHORT__&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clang-format on */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换 csr 和 val 的值，csr的值读出后保存在变量 __v 中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_swap(csr, val)                                              \</span></span><br><span class="line"><span class="meta">	(&#123;                                                              \</span></span><br><span class="line"><span class="meta">		unsigned long __v = (unsigned long)(val);               \</span></span><br><span class="line"><span class="meta">		__asm__ __volatile__(<span class="string">&quot;csrrw %0, &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %1&quot;</span> \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;=r&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;rK&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;memory&quot;</span>);                       \</span></span><br><span class="line"><span class="meta">		__v;                                                    \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_read(csr)                                           \</span></span><br><span class="line"><span class="meta">	(&#123;                                                      \</span></span><br><span class="line"><span class="meta">		register unsigned long __v;                     \</span></span><br><span class="line"><span class="meta">		__asm__ __volatile__(<span class="string">&quot;csrr %0, &quot;</span> __ASM_STR(csr) \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;=r&quot;</span>(__v)                \</span></span><br><span class="line"><span class="meta">				     :                          \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;memory&quot;</span>);               \</span></span><br><span class="line"><span class="meta">		__v;                                            \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_write(csr, val)                                        \</span></span><br><span class="line"><span class="meta">	(&#123;                                                         \</span></span><br><span class="line"><span class="meta">		unsigned long __v = (unsigned long)(val);          \</span></span><br><span class="line"><span class="meta">		__asm__ __volatile__(<span class="string">&quot;csrw &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %0&quot;</span> \</span></span><br><span class="line"><span class="meta">				     :                             \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;rK&quot;</span>(__v)                   \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;memory&quot;</span>);                  \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_read_set(csr, val)                                          \</span></span><br><span class="line"><span class="meta">	(&#123;                                                              \</span></span><br><span class="line"><span class="meta">		unsigned long __v = (unsigned long)(val);               \</span></span><br><span class="line"><span class="meta">		__asm__ __volatile__(<span class="string">&quot;csrrs %0, &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %1&quot;</span> \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;=r&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;rK&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;memory&quot;</span>);                       \</span></span><br><span class="line"><span class="meta">		__v;                                                    \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_set(csr, val)                                          \</span></span><br><span class="line"><span class="meta">	(&#123;                                                         \</span></span><br><span class="line"><span class="meta">		unsigned long __v = (unsigned long)(val);          \</span></span><br><span class="line"><span class="meta">		__asm__ __volatile__(<span class="string">&quot;csrs &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %0&quot;</span> \</span></span><br><span class="line"><span class="meta">				     :                             \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;rK&quot;</span>(__v)                   \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;memory&quot;</span>);                  \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_read_clear(csr, val)                                        \</span></span><br><span class="line"><span class="meta">	(&#123;                                                              \</span></span><br><span class="line"><span class="meta">		unsigned long __v = (unsigned long)(val);               \</span></span><br><span class="line"><span class="meta">		__asm__ __volatile__(<span class="string">&quot;csrrc %0, &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %1&quot;</span> \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;=r&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;rK&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;memory&quot;</span>);                       \</span></span><br><span class="line"><span class="meta">		__v;                                                    \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_clear(csr, val)                                        \</span></span><br><span class="line"><span class="meta">	(&#123;                                                         \</span></span><br><span class="line"><span class="meta">		unsigned long __v = (unsigned long)(val);          \</span></span><br><span class="line"><span class="meta">		__asm__ __volatile__(<span class="string">&quot;csrc &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %0&quot;</span> \</span></span><br><span class="line"><span class="meta">				     :                             \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;rK&quot;</span>(__v)                   \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;memory&quot;</span>);                  \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*wfi（Wait For Interrupt）指令告诉处理器停止执行并等待直到一个中断或异常发生。</span></span><br><span class="line"><span class="comment">  在这个状态下，处理器可以降低功耗，直到被外部事件（如中断）唤醒。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wfi()                                             \</span></span><br><span class="line"><span class="meta">	do &#123;                                              \</span></span><br><span class="line"><span class="meta">		__asm__ __volatile__(<span class="string">&quot;wfi&quot;</span> ::: <span class="string">&quot;memory&quot;</span>); \</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get current HART id */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current_hartid()	((unsigned int)csr_read(CSR_MHARTID))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__ASSEMBLY__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义了一些读取控制寄存器的函数，使用内联汇编的方式来实现</li>
</ul>
<h2 id="3-FreeRTOS移植相关代码"><a href="#3-FreeRTOS移植相关代码" class="headerlink" title="3. FreeRTOS移植相关代码"></a>3. FreeRTOS移植相关代码</h2><h3 id="3-1-FreeRTOS源码组织"><a href="#3-1-FreeRTOS源码组织" class="headerlink" title="3.1 FreeRTOS源码组织"></a>3.1 <code>FreeRTOS</code>源码组织</h3><p>移植之前先看一下<code>FreeRTOS</code>的源码组织架构：</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421141951413.png" alt="image-20240421141951413"></p>
<ul>
<li><code>Demo</code>为各个架构平台的示例代码，可以整个删除掉</li>
<li><code>source/portable</code>：此文件夹下的文件就是<code>FreeRTOS</code>适配不同平台的代码</li>
</ul>
<p>以<code>STM32</code>为例子，源码目录构建如下</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421142343638.png" alt="image-20240421142343638"></p>
<p>我们的目标是为<code>riscv</code>做移植，因此只需要实现<code>portable</code>文件夹下所需文件，核心源文件和<code>include</code>文件架下的头文件复制即可，我们使用的GCC编译，不是使用<code>keil</code>、<code>IAR</code>这样的<code>IDE</code>平台，因此如下图<code>portable</code>文件夹下只需要保留两个文件夹的内容即可，其他全部删除</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421142732182.png" alt="image-20240421142732182"></p>
<p>在<code>GCC</code>目录下也有很多平台的实现，我们全部删除，新建一个<code>RISC-V</code>目录，我们移植相关的代码就放在此文件夹下，在<code>MenMang</code>目录下有5个用于分配内存的源文件，我们使用一个就行，保留<code>heap_4.c</code>，其余删除。剪枝后<code>trusted_domain</code>的代码目录为：</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421143248805.png" alt="image-20240421143248805"></p>
<h3 id="3-2-FreeRTOS配置"><a href="#3-2-FreeRTOS配置" class="headerlink" title="3.2 FreeRTOS配置"></a>3.2 FreeRTOS配置</h3><p><code> FreeRTOS</code>是支持很多配置的，需要实现定义一些宏，用于开启和关闭 <code>FreeRTOS</code>内核的某些功能，这些宏定义在<code>FreeRTOSConfig.h</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FREERTOS_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREERTOS_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Application specific definitions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These definitions should be adjusted for your particular hardware and</span></span><br><span class="line"><span class="comment"> * application requirements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THESE PARAMETERS ARE DESCRIBED WITHIN THE &#x27;CONFIGURATION&#x27; SECTION OF THE</span></span><br><span class="line"><span class="comment"> * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See http://www.freertos.org/a00110.html.</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* See https://www.freertos.org/Using-FreeRTOS-on-RISC-V.html */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMTIME_BASE_ADDRESS		( CLINT_ADDR + CLINT_MTIME )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMTIMECMP_BASE_ADDRESS		( CLINT_ADDR + CLINT_MTIMECMP )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PREEMPTION			1                       <span class="comment">// 任务抢占</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_IDLE_HOOK				0                       <span class="comment">// IDLE 任务钩子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICK_HOOK				0                       <span class="comment">// 时钟中断 钩子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ				( 10000000 )            <span class="comment">//RTC时钟频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ				( ( TickType_t ) 100 )  <span class="comment">//时钟中断频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES			( 7 )                   <span class="comment">//最高优先级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE		( ( unsigned short ) 512 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE			( ( size_t ) 64500 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_TASK_NAME_LEN			( 16 )                  <span class="comment">//任务名的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_16_BIT_TICKS			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES				1                       <span class="comment">//启用互斥锁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configQUEUE_REGISTRY_SIZE		8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCHECK_FOR_STACK_OVERFLOW	0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_RECURSIVE_MUTEXES		1                       <span class="comment">//启动递归互斥锁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MALLOC_FAILED_HOOK	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_APPLICATION_TASK_TAG	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_COUNTING_SEMAPHORES	1                       <span class="comment">//启用信号量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION 1               </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Co-routine definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_CO_ROUTINES 			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES ( 2 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Software timer definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TIMERS				1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_PRIORITY		( configMAX_PRIORITIES - 1 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_QUEUE_LENGTH		6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_STACK_DEPTH	( 110 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Run time and task stats gathering related definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configGENERATE_RUN_TIME_STATS           0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TRACE_FACILITY                1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS    1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* RISC-V definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configISR_STACK_SIZE_WORDS		2048</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task priorities.  Allow these to be overridden. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> uartPRIMARY_PRIORITY</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> uartPRIMARY_PRIORITY		( configMAX_PRIORITIES - 3 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the following definitions to 1 to include the API function, or zero</span></span><br><span class="line"><span class="comment">to exclude the API function. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskPrioritySet			1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskPriorityGet			1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete					1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskCleanUpResources		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskSuspend				1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelayUntil				1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelay					1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_eTaskGetState				1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTimerPendFunctionCall		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskAbortDelay				1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetHandle				1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xSemaphoreGetMutexHolder	1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* FREERTOS_CONFIG_H */</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比较重要的几个配置为：</p>
<ul>
<li><code>configCPU_CLOCK_HZ</code> ： RTC 的时钟频率</li>
<li><code>configTICK_RATE_HZ</code> ：时钟中断的频率</li>
<li><code>configUSE_PREEMPTION</code>：开启抢占式任务调度</li>
</ul>
<p>在<code>qemu</code>中<code>rtc</code>的时钟频率为设备树中定义的换算成10进制即<code>10000000</code>，时钟中断的频率可以配置。</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421144651536.png" alt="image-20240421144651536"></p>
<blockquote>
<p>关于时钟的使用和定义：<a target="_blank" rel="noopener" href="http://localhost:4000/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/">分时多任务系统与抢占式调度 | TimerのBlog</a></p>
</blockquote>
<h3 id="3-3-portable目录下移植文件"><a href="#3-3-portable目录下移植文件" class="headerlink" title="3.3 portable目录下移植文件"></a>3.3 <code>portable</code>目录下移植文件</h3><p>明确我们的目标是移植<code>FreeRTOS</code>到RISCV的S态运行，M态运行的是<code>OpenSBI</code>，在官方的移植文件中：<code>portable/GCC/RISC-V</code>目录下有移植的<code>Demo</code>，但是官方是移植<code>FreeRTOS</code>到M态运行，我们参考着官方的移植代码来进行实现S态的移植，移植的文件涉及到三个：<code>portmacro.h</code>、<code>port.c</code>、<code>portASM.S</code>，我先直接给出这三个和架构相关的移植代码，在下一小节中我们从FreeRTOS的启动依次来详细描述内部的函数细节</p>
<p><code>portmacro.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PORTMACRO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORTMACRO_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quard_star.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOSConfig.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Type definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portSTACK_TYPE			uint64_t</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portBASE_TYPE			int64_t</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portUBASE_TYPE			uint64_t</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portMAX_DELAY 			( TickType_t ) 0xffffffffffffffffUL</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portPOINTER_SIZE_TYPE 	uint64_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __riscv_xlen == 32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portSTACK_TYPE	uint32_t</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portBASE_TYPE	int32_t</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portUBASE_TYPE	uint32_t</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffffffffUL</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">error</span> Assembler did not <span class="keyword">define</span> __riscv_xlen</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据类型定义，分为32位 和 64 位</span></span><br><span class="line"><span class="keyword">typedef</span> portSTACK_TYPE StackType_t;  </span><br><span class="line"><span class="keyword">typedef</span> portBASE_TYPE BaseType_t;    </span><br><span class="line"><span class="keyword">typedef</span> portUBASE_TYPE UBaseType_t;</span><br><span class="line"><span class="keyword">typedef</span> portUBASE_TYPE TickType_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Legacy type definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCHAR		char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portFLOAT		float</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portDOUBLE		double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portLONG		long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSHORT		short</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do</span></span><br><span class="line"><span class="comment">not need to be guarded with a critical section. */</span></span><br><span class="line"><span class="comment">/*portTICK_TYPE_IS_ATOMIC这个宏定义的设定通常用于指示系统的tick计数类型是</span></span><br><span class="line"><span class="comment">否可以在不使用临界区（critical section）的情况下安全地读取。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portTICK_TYPE_IS_ATOMIC 1</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Architecture specifics. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSTACK_GROWTH			( -1 )  <span class="comment">//定义了栈的增长方向</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ ) <span class="comment">//操作系统的tick周期（以毫秒为单位）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __riscv64</span></span><br><span class="line">	<span class="meta">#<span class="keyword">error</span> This is the RV32 port that has not yet been adapted for 64.</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portBYTE_ALIGNMENT			16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portBYTE_ALIGNMENT			16   <span class="comment">//所有数据结构都应该按16字节对齐</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduler utilities. */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vTaskSwitchContext</span><span class="params">( <span class="type">void</span> )</span>; <span class="comment">//上下文调度函数，不同架构不同</span></span><br><span class="line"><span class="comment">/* 通过sbi触发自己核心的软中断 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sbi_send_ipi</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span>;</span><br><span class="line"><span class="comment">//#define portYIELD() __asm volatile( &quot;ecall&quot; );  原本是在m态通过ecall触发软中断</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portYIELD() sbi_send_ipi((const unsigned long *)(0x1&lt;&lt;PRIM_HART)) <span class="comment">//向hart发送中断信号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portEND_SWITCHING_ISR( xSwitchRequired ) <span class="keyword">if</span>( xSwitchRequired ) vTaskSwitchContext()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Critical section management. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCRITICAL_NESTING_IN_TCB					1</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vTaskEnterCritical</span><span class="params">( <span class="type">void</span> )</span>;   <span class="comment">//进入临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vTaskExitCritical</span><span class="params">( <span class="type">void</span> )</span>;    <span class="comment">//退出临界区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSET_INTERRUPT_MASK_FROM_ISR() 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* S模式下SIE全局中断控制  bit[1] 位SIE位用于控制s态中断*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portDISABLE_INTERRUPTS()	__asm volatile( <span class="string">&quot;csrc sstatus, 2&quot;</span> ) <span class="comment">//csr clear</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portENABLE_INTERRUPTS()		__asm volatile( <span class="string">&quot;csrs sstatus, 2&quot;</span> ) <span class="comment">//csr set</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portENTER_CRITICAL()	vTaskEnterCritical()    <span class="comment">//关中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portEXIT_CRITICAL()		vTaskExitCritical()     <span class="comment">//开中断</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */</span></span><br><span class="line"><span class="comment">/* Architecture specific optimisations. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> configUSE_PORT_OPTIMISED_TASK_SELECTION</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configUSE_PORT_OPTIMISED_TASK_SELECTION == 1 )</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check the configuration. */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configMAX_PRIORITIES &gt; 32 )</span></span><br><span class="line">		<span class="meta">#<span class="keyword">error</span> configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Store/clear the ready priorities in a bit map. */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL &lt;&lt; ( uxPriority ) )</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &amp;= ~( 1UL &lt;&lt; ( uxPriority ) )</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">	<span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">ucPortCountLeadingZeros</span><span class="params">(<span class="type">uint32_t</span> x)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint32_t</span> numZeros;</span><br><span class="line">		<span class="keyword">if</span> (!x)</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">8</span>);</span><br><span class="line">		numZeros = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!(x &amp; <span class="number">0x80000000</span>)) &#123;</span><br><span class="line">			numZeros++;</span><br><span class="line">			x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> numZeros;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_PORT_OPTIMISED_TASK_SELECTION */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task function macros as described on the FreeRTOS.org WEB site.  These are</span></span><br><span class="line"><span class="comment">not necessary for to use this port.  They are defined so the common demo files</span></span><br><span class="line"><span class="comment">(which build with all the ports) will build. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portNOP() __asm volatile 	( <span class="string">&quot; nop &quot;</span> ) <span class="comment">//无操作指令</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portINLINE	__inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> portFORCE_INLINE   <span class="comment">//强制内联</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portFORCE_INLINE inline __attribute__(( always_inline))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内存屏障指令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portMEMORY_BARRIER() __asm volatile( <span class="string">&quot;&quot;</span> ::: <span class="string">&quot;memory&quot;</span> )</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* PORTMACRO_H */</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里说几个有点坑的地方：</p>
<ul>
<li><p>一是使用<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>控制的使用一个<code>32bit</code>的位图来存储优先级的几个操作宏，如果位图中的某一位被置为了1，代表此优先级上有任务就绪</p>
<ul>
<li><p><code>portRECORD_READY_PRIORITY(uxPriority, uxReadyPriorities)</code>：设置位图中相应优先级的位，表示该优先级有任务就绪。</p>
</li>
<li><p><code>portRESET_READY_PRIORITY(uxPriority, uxReadyPriorities)</code>：清除位图中相应优先级的位，表示该优先级没有任务就绪。</p>
</li>
<li><p><code>portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) </code>这个宏用于确定位图中的最高的就绪优先级，因为在<code>FreeRTOS</code>中，数字越大优先级越高，那么在位图中从高位向低位搜寻判断即可，因此调用了<code>ucPortCountLeadingZeros(uint32_t x)</code>去计算前导0的个数，然后使用<code>31 </code>减去前导0的个数就可以知道此时最高的就绪优先级，在官方的移植代码中是使用编译器的一个函数<code>__builtin_clz</code>来计算前导0的个数的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - __builtin_clz( uxReadyPriorities ) )</span></span><br></pre></td></tr></table></figure>

<p>但是不知道为啥，会有问题，估计是编译器的问题，于是自定义了一个计算前导0的函数</p>
</li>
</ul>
</li>
<li><p>二是任务主动请求调度的函数，在M态的话直接使用<code>ecall</code>指令即可，此时就会触发软中断，但是如果在<code>S</code>态使用<code>ecall</code>则会导致特权级切换，而且S态不能直接访问或者控制中断控制器如CLINT或者PLIC，所以需要M态固件介入来处理跨HART的中断请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过sbi触发自己核心的软中断 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sbi_send_ipi</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span>;</span><br><span class="line"><span class="comment">//#define portYIELD() __asm volatile( &quot;ecall&quot; );  原本是在m态通过ecall触发软中断</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portYIELD() sbi_send_ipi((const unsigned long *)(0x1&lt;&lt;PRIM_HART)) <span class="comment">//向hart发送中断信号</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>在M态，可以通过设置M态的中断挂起寄存器（<code>mip</code>）中的SSIP位来请求S态的软件中断。这需要M态的代码（通常是固件或操作系统的更低层部分）显式进行。</li>
<li>SSIP位设置后，如果S态已经启用软中断（通过<code>sie</code>寄存器的SSIP位）且全局中断使能（通过<code>mstatus</code>或<code>sstatus</code>寄存器的全局中断使能位），则S态的软件中断被触发。</li>
<li>这里我就有个问题了，多核间的寄存器访问核设置<code>OpenSBI</code>是如何实现的，后面搞明白了在叙述吧，总之这里就是通过<code>sbi_send_ipi</code>就可以实现触发<code>(0x1&lt;&lt;PRIM_HART))</code>这个核心的软中断，即促发<code>cpu7</code>的软中断从而实现主动的任务切换。</li>
</ul>
</li>
</ul>
<p><code>portASM.S</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;riscv_encoding.h&quot;</span><br><span class="line"></span><br><span class="line">#if __riscv_xlen == 64</span><br><span class="line">	#define portWORD_SIZE 8</span><br><span class="line">	#define store_x sd</span><br><span class="line">	#define load_x ld</span><br><span class="line">#elif __riscv_xlen == 32</span><br><span class="line">	#define store_x sw</span><br><span class="line">	#define load_x lw</span><br><span class="line">	#define portWORD_SIZE 4</span><br><span class="line">#else</span><br><span class="line">	#error Assembler did not define __riscv_xlen</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define portCONTEXT_SIZE ( 30 * portWORD_SIZE )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.global xPortStartFirstTask</span><br><span class="line">.global freertos_risc_v_trap_handler</span><br><span class="line">.global pxPortInitialiseStack</span><br><span class="line">.extern pxCurrentTCB</span><br><span class="line">.extern ulPortTrapHandler</span><br><span class="line">.extern vTaskSwitchContext</span><br><span class="line">.extern xTaskIncrementTick</span><br><span class="line">.extern Timer_IRQHandler</span><br><span class="line">.extern pullMachineTimerCompareRegister</span><br><span class="line">.extern pullNextTime</span><br><span class="line">.extern uxTimerIncrementsForOneTick /* size_t type so 32-bit on 32-bit core and 64-bits on 64-bit core. */</span><br><span class="line">.extern xISRStackTop</span><br><span class="line">.extern portasmHANDLE_INTERRUPT</span><br><span class="line"></span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">freertos_risc_v_trap_handler:</span><br><span class="line">    // x2 为sp ，不需要保存</span><br><span class="line">	// x3 为gp，全局指针，基本不变也不需要保存</span><br><span class="line">	// x4 为tp，线程指针，中断上下文不需要保存</span><br><span class="line">	addi sp, sp, -portCONTEXT_SIZE</span><br><span class="line">	store_x x1, 1 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x5, 2 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x6, 3 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x7, 4 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x8, 5 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x9, 6 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x10, 7 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x11, 8 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x12, 9 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x13, 10 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x14, 11 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x15, 12 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x16, 13 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x17, 14 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x18, 15 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x19, 16 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x20, 17 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x21, 18 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x22, 19 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x23, 20 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x24, 21 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x25, 22 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x26, 23 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x27, 24 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x28, 25 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x29, 26 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x30, 27 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x31, 28 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">	csrr t0, sstatus					/* Required for SPIE bit. */</span><br><span class="line">	store_x t0, 29 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">	csrr t0, sepc  //sepc 存储了中断返回地址</span><br><span class="line">	store_x t0, 0 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">	load_x  t0, pxCurrentTCB			/*  加载当前任务的任务控制块（TCB）地址到t0寄存器。 */</span><br><span class="line">	store_x  sp, 0( t0 )				/*  将当前的堆栈指针sp的值保存到TCB的第一个成员变量中. */</span><br><span class="line"></span><br><span class="line">	csrr a0, scause</span><br><span class="line">	csrr a1, sepc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//判断是中断还是异常</span><br><span class="line">test_if_asynchronous:     				//参数为 scause的值，存放在a0寄存器中</span><br><span class="line">	srli a2, a0, __riscv_xlen - 1		/* MSB of mcause is 1 if handing an asynchronous interrupt - shift to LSB to clear other bits. */</span><br><span class="line">	beq a2, x0, handle_synchronous		/* Branch past interrupt handing if not asynchronous. */</span><br><span class="line">	store_x a1, 0( sp )					/* Asynch so save unmodified exception return address. */</span><br><span class="line"></span><br><span class="line">//异常</span><br><span class="line">handle_asynchronous:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_if_ipi:						 //参数为 scause的值，存放在a0寄存器中</span><br><span class="line">	addi t0, x0, 1</span><br><span class="line"></span><br><span class="line">	slli t0, t0, __riscv_xlen - 1   /* LSB is already set, shift into MSB.  Shift 31 on 32-bit or 63 on 64-bit cores. */</span><br><span class="line">	addi t1, t0, 1					/* 0x8000[]0001 == Supervisor ipi interrupt. */</span><br><span class="line">	bne a0, t1, test_if_mtimer      // 如果不是软件中断则跳转到 test_if_mtimer 处执行</span><br><span class="line"></span><br><span class="line">	load_x sp, xISRStackTop			/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">	jal vPortClearIpiInterrupt</span><br><span class="line">	jal vTaskSwitchContext          // </span><br><span class="line">	j processed_source</span><br><span class="line"></span><br><span class="line">test_if_mtimer:						/* If there is a CLINT then the mtimer is used to generate the tick interrupt. */</span><br><span class="line">	addi t1, t1, 4					/* 0x80000001 + 4 = 0x80000005 == Supervisor timer interrupt. */</span><br><span class="line">	bne a0, t1, test_if_external_interrupt  </span><br><span class="line">	/* 处理时钟中断 */</span><br><span class="line">	load_x sp, xISRStackTop			/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">	jal vPortSetupTimerInterrupt    /* 设置定时器中断计数 */</span><br><span class="line">	jal xTaskIncrementTick</span><br><span class="line">	beqz a0, processed_source		/* Don&#x27;t switch context if incrementing tick didn&#x27;t unblock a task. */</span><br><span class="line">	jal vTaskSwitchContext</span><br><span class="line">	j processed_source</span><br><span class="line"></span><br><span class="line">/* 外部中断处理函数 */</span><br><span class="line">test_if_external_interrupt:			/* If there is a CLINT and the mtimer interrupt is not pending then check to see if an external interrupt is pending. */</span><br><span class="line">	addi t1, t1, 4					/* 0x80000005 + 4 = 0x80000009 == Supervisor external interrupt. */</span><br><span class="line">	bne a0, t1, processed_trap   	/* Something as yet unhandled. */</span><br><span class="line">	//处理外部中断</span><br><span class="line">	load_x sp, xISRStackTop			/* Switch to ISR stack before function call. */</span><br><span class="line">	jal handle_interrupt	        /* Jump to the interrupt handler if there is no CLINT or if there is a CLINT and it has been determined that an external interrupt is pending. */</span><br><span class="line">	j processed_source</span><br><span class="line"></span><br><span class="line">handle_synchronous:</span><br><span class="line">	addi a1, a1, 4						/* Synchronous so updated exception return address to the instruction after the instruction that generated the exeption. */</span><br><span class="line">	store_x a1, 0( sp )					/* Save updated exception return address. */</span><br><span class="line"></span><br><span class="line">//其他中断</span><br><span class="line">processed_trap:</span><br><span class="line">	csrr a0, scause</span><br><span class="line">	csrr a1, sepc</span><br><span class="line">	csrr a2, stval</span><br><span class="line">	mv   a4, sp</span><br><span class="line">	load_x sp, xISRStackTop			/* Switch to ISR stack before function call. */</span><br><span class="line">	jal handle_trap	                /* Jump to the interrupt handler if there is no CLINT or if there is a CLINT and it has been determined that an external interrupt is pending. */</span><br><span class="line">	j processed_source</span><br><span class="line"></span><br><span class="line">//任务恢复</span><br><span class="line">processed_source:</span><br><span class="line">	load_x  t1, pxCurrentTCB		/* Load pxCurrentTCB. */</span><br><span class="line">	load_x  sp, 0( t1 )				/* Read sp from first TCB member. */</span><br><span class="line"></span><br><span class="line">	/* Load sret with the address of the next instruction in the task to run next. */</span><br><span class="line">	load_x t0,  0( sp )</span><br><span class="line">	csrw sepc, t0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Load mstatus with the interrupt enable bits used by the task. */</span><br><span class="line">	load_x  t0, 29 * portWORD_SIZE( sp )   //读取保存在栈中的sstatus寄存器的值</span><br><span class="line">	csrw sstatus, t0				/* Required for SPIE bit. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//从栈中恢复上下文寄存器</span><br><span class="line">	load_x  x1, 1 * portWORD_SIZE( sp )</span><br><span class="line">	load_x  x5, 2 * portWORD_SIZE( sp )		/* t0 */</span><br><span class="line">	load_x  x6, 3 * portWORD_SIZE( sp )		/* t1 */</span><br><span class="line">	load_x  x7, 4 * portWORD_SIZE( sp )		/* t2 */</span><br><span class="line">	load_x  x8, 5 * portWORD_SIZE( sp )		/* s0/fp */</span><br><span class="line">	load_x  x9, 6 * portWORD_SIZE( sp )		/* s1 */</span><br><span class="line">	load_x  x10, 7 * portWORD_SIZE( sp )	/* a0 */</span><br><span class="line">	load_x  x11, 8 * portWORD_SIZE( sp )	/* a1 */</span><br><span class="line">	load_x  x12, 9 * portWORD_SIZE( sp )	/* a2 */</span><br><span class="line">	load_x  x13, 10 * portWORD_SIZE( sp )	/* a3 */</span><br><span class="line">	load_x  x14, 11 * portWORD_SIZE( sp )	/* a4 */</span><br><span class="line">	load_x  x15, 12 * portWORD_SIZE( sp )	/* a5 */</span><br><span class="line">	load_x  x16, 13 * portWORD_SIZE( sp )	/* a6 */</span><br><span class="line">	load_x  x17, 14 * portWORD_SIZE( sp )	/* a7 */</span><br><span class="line">	load_x  x18, 15 * portWORD_SIZE( sp )	/* s2 */</span><br><span class="line">	load_x  x19, 16 * portWORD_SIZE( sp )	/* s3 */</span><br><span class="line">	load_x  x20, 17 * portWORD_SIZE( sp )	/* s4 */</span><br><span class="line">	load_x  x21, 18 * portWORD_SIZE( sp )	/* s5 */</span><br><span class="line">	load_x  x22, 19 * portWORD_SIZE( sp )	/* s6 */</span><br><span class="line">	load_x  x23, 20 * portWORD_SIZE( sp )	/* s7 */</span><br><span class="line">	load_x  x24, 21 * portWORD_SIZE( sp )	/* s8 */</span><br><span class="line">	load_x  x25, 22 * portWORD_SIZE( sp )	/* s9 */</span><br><span class="line">	load_x  x26, 23 * portWORD_SIZE( sp )	/* s10 */</span><br><span class="line">	load_x  x27, 24 * portWORD_SIZE( sp )	/* s11 */</span><br><span class="line">	load_x  x28, 25 * portWORD_SIZE( sp )	/* t3 */</span><br><span class="line">	load_x  x29, 26 * portWORD_SIZE( sp )	/* t4 */</span><br><span class="line">	load_x  x30, 27 * portWORD_SIZE( sp )	/* t5 */</span><br><span class="line">	load_x  x31, 28 * portWORD_SIZE( sp )	/* t6 */</span><br><span class="line">	addi sp, sp, portCONTEXT_SIZE</span><br><span class="line"></span><br><span class="line">	sret</span><br><span class="line">	.endfunc</span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">.weak handle_trap</span><br><span class="line">.func</span><br><span class="line">handle_trap:</span><br><span class="line">	j handle_trap</span><br><span class="line">	.endfunc</span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">.weak handle_interrupt</span><br><span class="line">.func</span><br><span class="line">handle_interrupt:</span><br><span class="line">	j handle_interrupt</span><br><span class="line">	ret</span><br><span class="line">	.endfunc</span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">xPortStartFirstTask:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	la t0, freertos_risc_v_trap_handler    //设置异常处理地址</span><br><span class="line">	csrw stvec, t0</span><br><span class="line"></span><br><span class="line">	//加载任务的TCB指针</span><br><span class="line">	load_x  sp, pxCurrentTCB			/* Load pxCurrentTCB. */</span><br><span class="line">	//加载此任务的栈地址</span><br><span class="line">	load_x  sp, 0( sp )				 	/* Read sp from first TCB member. */</span><br><span class="line"></span><br><span class="line">	load_x  x1, 0( sp ) /* Note for starting the scheduler the exception return address is used as the function return address. */</span><br><span class="line"></span><br><span class="line">	load_x  x6, 3 * portWORD_SIZE( sp )		/* t1 */</span><br><span class="line">	load_x  x7, 4 * portWORD_SIZE( sp )		/* t2 */</span><br><span class="line">	load_x  x8, 5 * portWORD_SIZE( sp )		/* s0/fp */</span><br><span class="line">	load_x  x9, 6 * portWORD_SIZE( sp )		/* s1 */</span><br><span class="line">	load_x  x10, 7 * portWORD_SIZE( sp )	/* a0 */</span><br><span class="line">	load_x  x11, 8 * portWORD_SIZE( sp )	/* a1 */</span><br><span class="line">	load_x  x12, 9 * portWORD_SIZE( sp )	/* a2 */</span><br><span class="line">	load_x  x13, 10 * portWORD_SIZE( sp )	/* a3 */</span><br><span class="line">	load_x  x14, 11 * portWORD_SIZE( sp )	/* a4 */</span><br><span class="line">	load_x  x15, 12 * portWORD_SIZE( sp )	/* a5 */</span><br><span class="line">	load_x  x16, 13 * portWORD_SIZE( sp )	/* a6 */</span><br><span class="line">	load_x  x17, 14 * portWORD_SIZE( sp )	/* a7 */</span><br><span class="line">	load_x  x18, 15 * portWORD_SIZE( sp )	/* s2 */</span><br><span class="line">	load_x  x19, 16 * portWORD_SIZE( sp )	/* s3 */</span><br><span class="line">	load_x  x20, 17 * portWORD_SIZE( sp )	/* s4 */</span><br><span class="line">	load_x  x21, 18 * portWORD_SIZE( sp )	/* s5 */</span><br><span class="line">	load_x  x22, 19 * portWORD_SIZE( sp )	/* s6 */</span><br><span class="line">	load_x  x23, 20 * portWORD_SIZE( sp )	/* s7 */</span><br><span class="line">	load_x  x24, 21 * portWORD_SIZE( sp )	/* s8 */</span><br><span class="line">	load_x  x25, 22 * portWORD_SIZE( sp )	/* s9 */</span><br><span class="line">	load_x  x26, 23 * portWORD_SIZE( sp )	/* s10 */</span><br><span class="line">	load_x  x27, 24 * portWORD_SIZE( sp )	/* s11 */</span><br><span class="line">	load_x  x28, 25 * portWORD_SIZE( sp )	/* t3 */</span><br><span class="line">	load_x  x29, 26 * portWORD_SIZE( sp )	/* t4 */</span><br><span class="line">	load_x  x30, 27 * portWORD_SIZE( sp )	/* t5 */</span><br><span class="line">	load_x  x31, 28 * portWORD_SIZE( sp )	/* t6 */</span><br><span class="line"></span><br><span class="line">	load_x  x5, 29 * portWORD_SIZE( sp )	/* Initial mstatus into x5 (t0) */</span><br><span class="line">	ori x5, x5, 0x2					    	/* Set SIE bit so the first task starts with interrupts enabled - required as returns with ret not eret. */</span><br><span class="line">	csrrw  x0, sstatus, x5					/* Interrupts enabled from here! */</span><br><span class="line">	load_x  x5, 2 * portWORD_SIZE( sp )		/* Initial x5 (t0) value. */</span><br><span class="line"></span><br><span class="line">	addi	sp, sp, portCONTEXT_SIZE</span><br><span class="line">	ret</span><br><span class="line">	.endfunc</span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Unlike other ports pxPortInitialiseStack() is written in assembly code as it</span><br><span class="line"> * needs access to the portasmADDITIONAL_CONTEXT_SIZE constant.  The prototype</span><br><span class="line"> * for the function is as per the other ports:</span><br><span class="line"> * StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters );</span><br><span class="line"> *</span><br><span class="line"> * As per the standard RISC-V ABI pxTopcOfStack is passed in in a0, pxCode in</span><br><span class="line"> * a1, and pvParameters in a2.  The new top of stack is passed out in a0.</span><br><span class="line"> *</span><br><span class="line"> * RISC-V maps registers to ABI names as follows (X1 to X31 integer registers</span><br><span class="line"> * for the &#x27;I&#x27; profile, X1 to X15 for the &#x27;E&#x27; profile, currently I assumed).</span><br><span class="line"> *</span><br><span class="line"> * Register		ABI Name	Description						Saver</span><br><span class="line"> * x0			zero		Hard-wired zero					-</span><br><span class="line"> * x1			ra			Return address					Caller</span><br><span class="line"> * x2			sp			Stack pointer					Callee</span><br><span class="line"> * x3			gp			Global pointer					-</span><br><span class="line"> * x4			tp			Thread pointer					-</span><br><span class="line"> * x5-7			t0-2		Temporaries						Caller</span><br><span class="line"> * x8			s0/fp		Saved register/Frame pointer	Callee</span><br><span class="line"> * x9			s1			Saved register					Callee</span><br><span class="line"> * x10-11		a0-1		Function Arguments/return values Caller</span><br><span class="line"> * x12-17		a2-7		Function arguments				Caller</span><br><span class="line"> * x18-27		s2-11		Saved registers					Callee</span><br><span class="line"> * x28-31		t3-6		Temporaries						Caller</span><br><span class="line"> *</span><br><span class="line"> * The RISC-V context is saved t FreeRTOS tasks in the following stack frame,</span><br><span class="line"> * where the global and thread pointers are currently assumed to be constant so</span><br><span class="line"> * are not saved:</span><br><span class="line"> *</span><br><span class="line"> * mstatus</span><br><span class="line"> * x31</span><br><span class="line"> * x30</span><br><span class="line"> * x29</span><br><span class="line"> * x28</span><br><span class="line"> * x27</span><br><span class="line"> * x26</span><br><span class="line"> * x25</span><br><span class="line"> * x24</span><br><span class="line"> * x23</span><br><span class="line"> * x22</span><br><span class="line"> * x21</span><br><span class="line"> * x20</span><br><span class="line"> * x19</span><br><span class="line"> * x18</span><br><span class="line"> * x17</span><br><span class="line"> * x16</span><br><span class="line"> * x15</span><br><span class="line"> * x14</span><br><span class="line"> * x13</span><br><span class="line"> * x12</span><br><span class="line"> * x11</span><br><span class="line"> * pvParameters</span><br><span class="line"> * x9</span><br><span class="line"> * x8</span><br><span class="line"> * x7</span><br><span class="line"> * x6</span><br><span class="line"> * x5</span><br><span class="line"> * portTASK_RETURN_ADDRESS</span><br><span class="line"> * [chip specific registers go here]</span><br><span class="line"> * pxCode</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">pxPortInitialiseStack:                  // 函数参数应该为栈的地址放入 a0 寄存器</span><br><span class="line">	csrr t0, sstatus					/* t0 = sstatus 保存当前sstatus寄存器的值到t0寄存器中 */</span><br><span class="line">	andi t0, t0, ~0x2					/* Ensure interrupts are disabled when the stack is restored within an ISR.  Required when a task is created after the schedulre has been started, otherwise interrupts would be disabled anyway. */</span><br><span class="line">	addi t1, x0, 0x120					/* Generate the value 0x120, which are the SPIE and SPP bits to set in mstatus. */</span><br><span class="line">	or t0, t0, t1						/* Set SPIE and SPP bits in sstatus value. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	addi a0, a0, -portWORD_SIZE</span><br><span class="line">	store_x t0, 0(a0)					/* sstatus onto the stack. */</span><br><span class="line">	addi a0, a0, -(22 * portWORD_SIZE)	/* Space for registers x11-x31. */</span><br><span class="line">	store_x a2, 0(a0)					/* Task parameters (pvParameters parameter) goes into register X10/a0 on the stack. */</span><br><span class="line">	addi a0, a0, -(6 * portWORD_SIZE)	/* Space for registers x5-x9. */</span><br><span class="line">	la t0, prvTaskExitError             /* 加载prvTaskExitError函数的地址到 t0 */</span><br><span class="line">	store_x t0, 0(a0)					/* Return address onto the stack, could be portTASK_RETURN_ADDRESS */</span><br><span class="line"></span><br><span class="line">	addi a0, a0, -portWORD_SIZE</span><br><span class="line">	store_x a1, 0(a0)					/* mret value (pxCode parameter) onto the stack. */</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	.endfunc</span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>portASM.S</code>是移植到riscv架构的核心文件，在FreeRTOS中，每个任务都有自己的栈，这是在创建任务的时候分配的，所谓的切换任务就是将当前任务的任务上下文即寄存器的值压入自己的栈中，然后取出下一个要运行的任务的地址，从此任务的栈中将任务上下文恢复，然后跳转执行。FreeRTOS和我们的<code>TimerOS</code>一样都是通过RTC中断来实现任务切换的，而不同架构由于寄存器组不一样因此需要在<code>portASM.S</code>实现任务压栈和出栈的汇编函数，以及和处理中断有关的函数</p>
<p><code>port.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Implementation of functions defined in portable.h for the RISC-V RV32 port.</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduler includes. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;portmacro.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns16550.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv_asm.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Standard includes. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> configTASK_RETURN_ADDRESS	</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portTASK_RETURN_ADDRESS	prvTaskExitError</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The stack used by interrupt service routines.  Set configISR_STACK_SIZE_WORDS</span></span><br><span class="line"><span class="comment">to use a statically allocated array as the interrupt stack.  Alternative leave</span></span><br><span class="line"><span class="comment">configISR_STACK_SIZE_WORDS undefined and update the linker script so that a</span></span><br><span class="line"><span class="comment">linker variable names __freertos_irq_stack_top has the same value as the top</span></span><br><span class="line"><span class="comment">of the stack used by main.  Using the linker script method will repurpose the</span></span><br><span class="line"><span class="comment">stack that was used by main before the scheduler was started for use as the</span></span><br><span class="line"><span class="comment">interrupt stack after the scheduler has started. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> configISR_STACK_SIZE_WORDS</span></span><br><span class="line">	<span class="type">static</span> __attribute__ ((aligned(<span class="number">16</span>))) StackType_t xISRStack[ configISR_STACK_SIZE_WORDS ] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">const</span> StackType_t xISRStackTop = ( StackType_t ) &amp;( xISRStack[ configISR_STACK_SIZE_WORDS &amp; ~portBYTE_ALIGNMENT_MASK ] );</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don&#x27;t use 0xa5 as the stack fill bytes as that is used by the kernerl for</span></span><br><span class="line"><span class="comment">	the task stacks, and so will legitimately appear in many positions within</span></span><br><span class="line"><span class="comment">	the ISR stack. */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portISR_STACK_FILL_BYTE	0xee</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint32_t</span> __freertos_irq_stack_top[];</span><br><span class="line">	<span class="type">const</span> StackType_t xISRStackTop = ( StackType_t ) __freertos_irq_stack_top;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup the timer to generate the tick interrupts.  The implementation in this</span></span><br><span class="line"><span class="comment"> * file is weak to allow application writers to change the timer used to</span></span><br><span class="line"><span class="comment"> * generate the tick interrupt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortSetupTimerInterrupt</span><span class="params">( <span class="type">void</span> )</span> __<span class="title function_">attribute__</span><span class="params">(( weak ))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used to program the machine timer compare register. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> uxTimerIncrementsForOneTick = ( <span class="type">size_t</span> ) ( ( configCPU_CLOCK_HZ ) / ( configTICK_RATE_HZ ) ); <span class="comment">/* Assumes increment won&#x27;t go over 32-bits. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set configCHECK_FOR_STACK_OVERFLOW to 3 to add ISR stack checking to task</span></span><br><span class="line"><span class="comment">stack checking.  A problem in the ISR stack will trigger an assert, not call the</span></span><br><span class="line"><span class="comment">stack overflow hook function (because the stack overflow hook is specific to a</span></span><br><span class="line"><span class="comment">task stack, not the ISR stack). */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined( configISR_STACK_SIZE_WORDS ) &amp;&amp; ( configCHECK_FOR_STACK_OVERFLOW &gt; 2 )</span></span><br><span class="line">	<span class="meta">#<span class="keyword">warning</span> This path not tested, or even compiled yet.</span></span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> ucExpectedStackBytes[] = &#123;</span><br><span class="line">									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\</span><br><span class="line">									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\</span><br><span class="line">									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\</span><br><span class="line">									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\</span><br><span class="line">									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE &#125;;	\</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portCHECK_ISR_STACK() configASSERT( ( memcmp( ( void * ) xISRStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) == 0 ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/* Define the function away. */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portCHECK_ISR_STACK()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configCHECK_FOR_STACK_OVERFLOW &gt; 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">get_ticks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">uint64_t</span> time_elapsed = <span class="number">0</span>;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;rdtime %0&quot;</span></span><br><span class="line">        : <span class="string">&quot;=r&quot;</span>(time_elapsed));</span><br><span class="line">    <span class="keyword">return</span> time_elapsed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortSetupTimerInterrupt</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 通过sbi设置下次tick中断 */</span></span><br><span class="line">	sbi_set_timer(get_ticks() + uxTimerIncrementsForOneTick);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortClearIpiInterrupt</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 通过sbi清除软中断，在软中断服务函数中调用 */</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sbi_clear_ipi</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">	sbi_clear_ipi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">BaseType_t <span class="title function_">xPortStartScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">xPortStartFirstTask</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configASSERT_DEFINED == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">uint32_t</span> stvec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check the least significant two bits of mtvec are 00 - indicating</span></span><br><span class="line"><span class="comment">		single vector mode. */</span></span><br><span class="line">		__asm <span class="title function_">volatile</span><span class="params">( <span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span>( stvec ) )</span>;</span><br><span class="line">		<span class="comment">//检查 stvec 设置的是直接访问还是向量访问</span></span><br><span class="line">		configASSERT( ( stvec &amp; <span class="number">0x03</span>UL ) == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check alignment of the interrupt stack - which is the same as the</span></span><br><span class="line"><span class="comment">		stack that was being used by main() prior to the scheduler being</span></span><br><span class="line"><span class="comment">		started. */</span></span><br><span class="line">		<span class="comment">//检查栈顶的地址是否是对齐了</span></span><br><span class="line">		configASSERT( ( xISRStackTop &amp; portBYTE_ALIGNMENT_MASK ) == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化栈中的数据为 0</span></span><br><span class="line">		<span class="meta">#<span class="keyword">ifdef</span> configISR_STACK_SIZE_WORDS</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>( ( <span class="type">void</span> * ) xISRStack, portISR_STACK_FILL_BYTE, <span class="keyword">sizeof</span>( xISRStack ) );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="keyword">endif</span>	 <span class="comment">/* configISR_STACK_SIZE_WORDS */</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configASSERT_DEFINED */</span></span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 通过sbi设置Timer为滴答时钟 */</span></span><br><span class="line">	vPortSetupTimerInterrupt();</span><br><span class="line">	_puts( <span class="string">&quot;Debug timer!\n&quot;</span>);</span><br><span class="line">   	<span class="comment">/* 使能SIE中S模式Timer中断和Soft中断，注意此处使能并不会立即响应</span></span><br><span class="line"><span class="comment">	xPortStartFirstTask中将打开全局使能 */</span></span><br><span class="line">    csr_set(CSR_SIE, SIP_STIP);</span><br><span class="line">    csr_set(CSR_SIE, SIP_SSIP);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//启动第一个任务</span></span><br><span class="line">	xPortStartFirstTask();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Should not get here as after calling xPortStartFirstTask() only tasks</span></span><br><span class="line"><span class="comment">	should be executing. */</span></span><br><span class="line">	<span class="keyword">return</span> pdFAIL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prvTaskExitError</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* A function that implements a task must not exit or attempt to return to</span></span><br><span class="line"><span class="comment">	its caller as there is nothing to return to.  If a task wants to exit it</span></span><br><span class="line"><span class="comment">	should instead call vTaskDelete( NULL ).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Artificially force an assert() to be triggered if configASSERT() is</span></span><br><span class="line"><span class="comment">	defined, then stop here so application writers can catch the error. */</span></span><br><span class="line">	configASSERT( ulPortInterruptNesting == ~<span class="number">0UL</span> );</span><br><span class="line">	<span class="comment">//关闭中断</span></span><br><span class="line">	portDISABLE_INTERRUPTS();</span><br><span class="line">	<span class="keyword">for</span>( ;; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortEndScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Not implemented. */</span></span><br><span class="line">	<span class="keyword">for</span>( ;; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-FreeRTOS启动过程"><a href="#4-FreeRTOS启动过程" class="headerlink" title="4. FreeRTOS启动过程"></a>4. FreeRTOS启动过程</h2><h3 id="4-1-FreeRTOS使用实例"><a href="#4-1-FreeRTOS使用实例" class="headerlink" title="4.1 FreeRTOS使用实例"></a>4.1 FreeRTOS使用实例</h3><p>我在<code>main.c</code>中创建了三个任务，三个任务之间会使用消息队列进行通信：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv_asm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="comment">//消息队列控制权柄</span></span><br><span class="line">QueueHandle_t xMyQueueHandle;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *p_arg)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> time = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;task1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        _puts(<span class="string">&quot;task1 send\n&quot;</span>);</span><br><span class="line">        xQueueSend(xMyQueueHandle,&amp;time,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> *p_arg)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> time = <span class="number">2</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;task2\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        _puts(<span class="string">&quot;task2 send\n&quot;</span>);</span><br><span class="line">        xQueueSend(xMyQueueHandle,&amp;time,<span class="number">0</span>);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">(<span class="type">void</span> *p_arg)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueReceive(xMyQueueHandle,&amp;time,portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">1</span>)&#123;</span><br><span class="line">            _puts(<span class="string">&quot;task1 receive\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">2</span>)&#123;</span><br><span class="line">            _puts(<span class="string">&quot;task2 receive\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vTaskCreate</span> <span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    xTaskCreate(task1,<span class="string">&quot;task1&quot;</span>,<span class="number">1024</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(task2,<span class="string">&quot;task2&quot;</span>,<span class="number">1024</span>,<span class="literal">NULL</span>,<span class="number">4</span>,<span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(task3,<span class="string">&quot;task2&quot;</span>,<span class="number">1024</span>,<span class="literal">NULL</span>,<span class="number">5</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">	_puts( <span class="string">&quot;Hello FreeRTOS!\n&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * str = <span class="string">&quot;taskn\n&quot;</span>;</span><br><span class="line">    xMyQueueHandle = xQueueCreate(<span class="number">20</span>,<span class="keyword">sizeof</span>(<span class="type">int32_t</span>));</span><br><span class="line"></span><br><span class="line">    vTaskCreate();</span><br><span class="line">	vTaskStartScheduler();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-编译和链接"><a href="#4-2-编译和链接" class="headerlink" title="4.2 编译和链接"></a>4.2 编译和链接</h3><p>首先来看<code>Makefile</code>，<code>Makefile</code>会将<code>trusted_domain</code>下的源文件编译生成一个固件，会对<code>FreeRTOS</code>内核的代码以及我们自己编写的源文件进行编译：<code>main.c</code> ，<code>startup.S</code>，<code>riscv/**</code>，<code>FreeRTOS-Kernel/**</code>，<code>driver/**</code>，编译后生成的固件会放在<code>build</code>目录下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">##########################################################################################################################</span></span><br><span class="line"><span class="comment"># trusted_domain GCC compiler Makefile</span></span><br><span class="line"><span class="comment">##########################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="comment"># Generic Makefile (based on gcc)</span></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># target</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line">TARGET = trusted_fw</span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># building variables</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># debug build?</span></span><br><span class="line">DEBUG = 1</span><br><span class="line"><span class="comment"># optimization</span></span><br><span class="line">OPT = -Og</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PROJECTBASE = <span class="variable">$(PWD)</span></span><br><span class="line"><span class="keyword">override</span> PROJECTBASE    := <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(PROJECTBASE)</span>)</span></span><br><span class="line">TOP_DIR = <span class="variable">$(PROJECTBASE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># binaries</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">CROSS_COMPILE = riscv64-unknown-elf-</span><br><span class="line">CC        = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">AS        = <span class="variable">$(CROSS_COMPILE)</span>gcc -x assembler-with-cpp</span><br><span class="line">OBJCOPY   = <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP   = <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line">AR        = <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">SZ        = <span class="variable">$(CROSS_COMPILE)</span>size</span><br><span class="line">LD        = <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">HEX       = <span class="variable">$(OBJCOPY)</span> -O ihex</span><br><span class="line">BIN       = <span class="variable">$(OBJCOPY)</span> -O binary -S</span><br><span class="line">GDB       = <span class="variable">$(CROSS_COMPILE)</span>gdb</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># paths</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># firmware library path</span></span><br><span class="line">PERIFLIB_PATH =</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build path</span></span><br><span class="line">BUILD_DIR = build</span><br><span class="line">OBJ_DIR = <span class="variable">$(BUILD_DIR)</span>/obj</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># source</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># C sources</span></span><br><span class="line">C_SOURCES =  \</span><br><span class="line">		$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/*.c&#125; \</span><br><span class="line">		$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/portable/GCC/RISC-V/*.c&#125; \</span><br><span class="line">		$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/portable/MemMang/heap_4.c&#125; \</span><br><span class="line">		$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/driver/*.c&#125; \</span><br><span class="line">		$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/riscv/*.c&#125; \</span><br><span class="line">		$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/*.c&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ASM sources</span></span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">		$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/*.S&#125; \</span><br><span class="line">		$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/portable/GCC/RISC-V/*.S&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># firmware library</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line">PERIFLIB_SOURCES =</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># CFLAGS</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">MCU = -march=rv64imad -mcmodel=medany -msmall-data-limit=8 -fmessage-length=0 -fsigned-char</span><br><span class="line"></span><br><span class="line"><span class="comment"># macros for gcc</span></span><br><span class="line"><span class="comment"># AS defines</span></span><br><span class="line">AS_DEFS = </span><br><span class="line"></span><br><span class="line"><span class="comment"># C defines</span></span><br><span class="line">C_DEFS = </span><br><span class="line"></span><br><span class="line"><span class="comment"># AS includes</span></span><br><span class="line">AS_INCLUDES = \</span><br><span class="line">		-I <span class="variable">$(TOP_DIR)</span>/riscv \</span><br><span class="line">		-I <span class="variable">$(TOP_DIR)</span>/driver</span><br><span class="line"></span><br><span class="line"><span class="comment"># C includes</span></span><br><span class="line">C_INCLUDES = \</span><br><span class="line">		-I <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/<span class="keyword">include</span> \</span><br><span class="line">		-I <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/portable/GCC/RISC-V \</span><br><span class="line">		-I <span class="variable">$(TOP_DIR)</span>/riscv \</span><br><span class="line">		-I <span class="variable">$(TOP_DIR)</span>/driver \</span><br><span class="line">		-I <span class="variable">$(TOP_DIR)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># compile gcc flags</span></span><br><span class="line">ASFLAGS = <span class="variable">$(MCU)</span> <span class="variable">$(AS_DEFS)</span> <span class="variable">$(AS_INCLUDES)</span> <span class="variable">$(OPT)</span> -Wall -fdata-sections -ffunction-sections</span><br><span class="line"></span><br><span class="line">CFLAGS = <span class="variable">$(MCU)</span> <span class="variable">$(C_DEFS)</span> <span class="variable">$(C_INCLUDES)</span> <span class="variable">$(OPT)</span> -Wall -fdata-sections -ffunction-sections</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>, 1)</span><br><span class="line">CFLAGS += -g -gdwarf-2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate dependency information</span></span><br><span class="line">CFLAGS += -MMD -MP -MF<span class="string">&quot;$(@:%.o=%.d)&quot;</span> -MT<span class="string">&quot;$(@:%.o=%.d)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># LDFLAGS</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># link script</span></span><br><span class="line">LD_FILE = link.lds</span><br><span class="line">LDSCRIPT = <span class="variable">$(PROJECTBASE)</span>/<span class="variable">$(LD_FILE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libraries</span></span><br><span class="line">LIBS = -lm </span><br><span class="line">LIBDIR =</span><br><span class="line">LDFLAGS = <span class="variable">$(MCU)</span> -nostartfiles -T<span class="variable">$(LDSCRIPT)</span> <span class="variable">$(LIBDIR)</span> <span class="variable">$(LIBS)</span> -Wl,-Map=<span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.map -Wl,--gc-sections</span><br><span class="line"></span><br><span class="line"><span class="comment"># default action: build all</span></span><br><span class="line"><span class="section">all: <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.elf <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.hex <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.bin <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.lst</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># build the application</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># list of objects</span></span><br><span class="line">OBJECTS = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OBJ_DIR)</span>/,$(<span class="built_in">notdir</span> $(C_SOURCES:.c=.o)</span>))</span><br><span class="line"><span class="keyword">vpath</span> %.c <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(C_SOURCES)</span>)</span>)</span><br><span class="line"><span class="comment"># list of ASM program objects</span></span><br><span class="line">OBJECTS += <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OBJ_DIR)</span>/,$(<span class="built_in">notdir</span> $(ASM_SOURCES:.S=.o)</span>))</span><br><span class="line"><span class="keyword">vpath</span> %.S <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(ASM_SOURCES)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>/%.o: %.c Makefile | <span class="variable">$(OBJ_DIR)</span></span><br><span class="line">	@echo CC <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	@<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> -Wa,-a,-ad,-alms=<span class="variable">$(OBJ_DIR)</span>/<span class="variable">$(<span class="built_in">notdir</span> $(&lt;:.c=.lst)</span>) <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>/%.o: %.S Makefile | <span class="variable">$(OBJ_DIR)</span></span><br><span class="line">	@echo AS <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	@<span class="variable">$(AS)</span> -c <span class="variable">$(ASFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.elf: <span class="variable">$(OBJECTS)</span> <span class="variable">$(LDSCRIPT)</span> Makefile </span><br><span class="line">	@echo LD <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	@<span class="variable">$(CC)</span> <span class="variable">$(OBJECTS)</span> <span class="variable">$(LDFLAGS)</span> -Wl,-Map=freertos.map -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.hex: <span class="variable">$(BUILD_DIR)</span>/%.elf | <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">	@echo OBJCOPY <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	@<span class="variable">$(HEX)</span> <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.bin: <span class="variable">$(BUILD_DIR)</span>/%.elf | <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">	@echo OBJCOPY <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	@<span class="variable">$(BIN)</span> <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.lst: <span class="variable">$(BUILD_DIR)</span>/%.elf | <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">	@echo OBJDUMP <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> --source --demangle --disassemble --reloc --wide <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br><span class="line">	@<span class="variable">$(SZ)</span> --format=berkeley <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>:</span><br><span class="line">	mkdir <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(OBJ_DIR)</span>, <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(OBJ_DIR)</span>)</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>:<span class="variable">$(BUILD_DIR)</span></span><br><span class="line">	mkdir <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># clean up</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -fR <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># use gdb debug</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">	<span class="variable">$(GDB)</span> <span class="variable">$(BUILD_DIR)</span>/trusted_fw.elf -x  ./gdbinit</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># dependencies</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment">#-include $(shell mkdir .dep 2&gt;/dev/null) $(wildcard .dep/*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** EOF ***</span></span><br></pre></td></tr></table></figure>

<p>链接脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line"></span><br><span class="line">ENTRY( _start )</span><br><span class="line"></span><br><span class="line">__stack_size = 0x4000;</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123; </span><br><span class="line">	/* Fake ROM area */</span><br><span class="line">	rom (rxa) : ORIGIN = 0xBF800000, LENGTH = 1M</span><br><span class="line">	ram (wxa) : ORIGIN = 0xBF900000, LENGTH = 6M</span><br><span class="line">&#125;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .init :</span><br><span class="line">	&#123;</span><br><span class="line">		_text = .;</span><br><span class="line">		KEEP (*(SORT_NONE(.init)))</span><br><span class="line">	&#125; &gt;rom AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .text :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.text.unlikely .text.unlikely.*)</span><br><span class="line">		*(.text.startup .text.startup.*)</span><br><span class="line">		*(.text .text.*)</span><br><span class="line">		*(.gnu.linkonce.t.*)</span><br><span class="line">	&#125; &gt;rom AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .fini :</span><br><span class="line">	&#123;</span><br><span class="line">		KEEP (*(SORT_NONE(.fini)))</span><br><span class="line">		_etext = .;</span><br><span class="line">	&#125; &gt;rom AT&gt;rom</span><br><span class="line">  /* 四字节对齐 */</span><br><span class="line">	.rodata.align :</span><br><span class="line">	&#123;</span><br><span class="line">		. = ALIGN(4);</span><br><span class="line">		_rodata = .;</span><br><span class="line">	&#125; &gt;rom AT&gt;rom</span><br><span class="line"></span><br><span class="line">  /*  标记 rodata的链接地址*/</span><br><span class="line">	.rodata.start :</span><br><span class="line">	&#123;</span><br><span class="line">		_rodata_lma = LOADADDR(.rodata.start);</span><br><span class="line">	&#125; &gt;rom AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .data.align :</span><br><span class="line">	&#123;</span><br><span class="line">		. = ALIGN(4);</span><br><span class="line">		_data = .;</span><br><span class="line">	&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .data.start :</span><br><span class="line">	&#123;</span><br><span class="line">		_data_lma = LOADADDR(.data.start);</span><br><span class="line">	&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .data :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.data .data.*)</span><br><span class="line">		*(.gnu.linkonce.d.*)</span><br><span class="line">		. = ALIGN(8);</span><br><span class="line">		PROVIDE( __global_pointer$ = . + 0x800 );</span><br><span class="line">		*(.sdata .sdata.*)</span><br><span class="line">		*(.sdata2 .sdata2.*)</span><br><span class="line">		*(.gnu.linkonce.s.*)</span><br><span class="line">		. = ALIGN(8);</span><br><span class="line">		*(.srodata.cst16)</span><br><span class="line">		*(.srodata.cst8)</span><br><span class="line">		*(.srodata.cst4)</span><br><span class="line">		*(.srodata.cst2)</span><br><span class="line">		*(.srodata .srodata.*)</span><br><span class="line"></span><br><span class="line">		. = ALIGN(4);</span><br><span class="line">		_edata = .;</span><br><span class="line">	&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line">	.bss.align :</span><br><span class="line">	&#123;</span><br><span class="line">		. = ALIGN(4);</span><br><span class="line">		_bss = .;</span><br><span class="line">	&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .bss.start :</span><br><span class="line">	&#123;</span><br><span class="line">		_bss_lma = LOADADDR(.bss.start);</span><br><span class="line">	&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .bss :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.sbss*)</span><br><span class="line">		*(.gnu.linkonce.sb.*)</span><br><span class="line">		*(.bss .bss.*)</span><br><span class="line">		*(.gnu.linkonce.b.*)</span><br><span class="line">		*(COMMON)</span><br><span class="line"></span><br><span class="line">		. = ALIGN(4);</span><br><span class="line">		_ebss = .;</span><br><span class="line">	&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	. = ALIGN(8);</span><br><span class="line">	_end = .;</span><br><span class="line"></span><br><span class="line">  .stack :</span><br><span class="line">	&#123;</span><br><span class="line">		. = ALIGN(16);</span><br><span class="line">		. += __stack_size;</span><br><span class="line">		_stack_top = .;</span><br><span class="line">	&#125; &gt;ram AT&gt;ram</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>指定了程序入口地址为<code>_start</code>为<code>start.S</code>中的代码</p>
</li>
<li><p>写入的内存区域有两部分：</p>
<ul>
<li><code>rom (rxa) : ORIGIN = 0xBF800000, LENGTH = 1M</code>：可读可执行，起始地址为<code>0xBF800000</code>，大小为1M</li>
<li><code>ram (wxa) : ORIGIN = 0xBF900000, LENGTH = 6M</code>：可写可执行，起始地址为<code>0xBF900000</code>，大小为6M</li>
</ul>
</li>
<li><p>链接脚本中<code>AT</code>的是用来定义各个节应该在哪里被加载（LMA），而节的位置（放置位置，VMA）则是通过 <code>&gt;</code> 指定的，例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> .data.start :</span><br><span class="line">&#123;</span><br><span class="line">	_data_lma = LOADADDR(.data.start);</span><br><span class="line">&#125; &gt;ram AT&gt;rom</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.data</code> 节包含了初始化的全局变量，它在运行时应位于 RAM（通过 <code>&gt;ram</code> 指定）。</li>
<li>然而，在程序加载时，这些数据的初始值存储在 ROM 中（通过 <code>AT&gt;rom</code> 指定）。</li>
<li>简单来说就是数据段的数据是放在<code>rom</code>中的，代码段的程序在运行时需要去<code>rom</code>中拿到数据后加载到<code>ram</code>处执行，<code>.data</code>段和<code>.bss</code>段都是这样的特性</li>
</ul>
</li>
<li><p>在链接脚本最后定义了内核程序使用的主栈栈顶起始地址<code>_stack_top</code>，栈大小为<code>__stack_size = 0x4000</code></p>
</li>
</ul>
<h3 id="4-3-启动代码"><a href="#4-3-启动代码" class="headerlink" title="4.3 启动代码"></a>4.3 启动代码</h3><p><code>startup.S</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;riscv_encoding.h&quot;</span><br><span class="line">#include &quot;quard_star.h&quot;</span><br><span class="line">#include &quot;riscv_reg.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	.section .init</span><br><span class="line">	.globl _start</span><br><span class="line">	.type _start,@function</span><br><span class="line">_start:  #程序入口地址</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	.cfi_undefined ra</span><br><span class="line">.option push</span><br><span class="line">.option norelax  #取消汇编器的&quot;relaxation&quot;优化</span><br><span class="line">	la  gp, __global_pointer$   #设置全局指针</span><br><span class="line">.option pop</span><br><span class="line">	// Continue primary hart</span><br><span class="line">	li   a1, PRIM_HART     #将核心号加载到a1寄存器中</span><br><span class="line">	bne  a0, a1, secondary #比较核心号是否相等，如果不等，跳转到secondary处执行</span><br><span class="line"></span><br><span class="line">  	csrw sie, 0     	   #sie寄存器用于控制中断，禁用所有中断</span><br><span class="line">  	csrw sip, 0            #sip用于标识中断中断标志位，清楚所有的中断的标志位</span><br><span class="line">	/* set to disable FPU */</span><br><span class="line">	li t0, SSTATUS_FS</span><br><span class="line">	csrc sstatus, t0</span><br><span class="line">	li t0, SSTATUS_SUM // SUM in sstatus</span><br><span class="line">	csrs sstatus, t0</span><br><span class="line"></span><br><span class="line">	// Primary hart  设置主栈指针</span><br><span class="line">	la sp, _stack_top</span><br><span class="line">	csrw sscratch, sp  //将栈指针写入sscratch寄存器</span><br><span class="line"></span><br><span class="line">	// Load data section</span><br><span class="line">	la a0, _data_lma    //data数据在物理内存中的地址</span><br><span class="line">	la a1, _data        //数据段起始地址</span><br><span class="line">	la a2, _edata       //数据段结束地址</span><br><span class="line">	bgeu a1, a2, 2f     //</span><br><span class="line">1:   //将数据段的数据从物理内存复制到dram</span><br><span class="line">	LOAD t0, (a0)</span><br><span class="line">	STOR t0, (a1)</span><br><span class="line">	addi a0, a0, REGSIZE</span><br><span class="line">	addi a1, a1, REGSIZE</span><br><span class="line">	bltu a1, a2, 1b       //b代表向上寻找最近的同名标签</span><br><span class="line"></span><br><span class="line">2:</span><br><span class="line">	// Clear bss section</span><br><span class="line">	la a0, _bss</span><br><span class="line">	la a1, _ebss</span><br><span class="line">	bgeu a0, a1, 2f      //f代表向下寻找最近的同名标签</span><br><span class="line">1:  //清空bss段</span><br><span class="line">	STOR zero, (a0)</span><br><span class="line">	addi a0, a0, REGSIZE</span><br><span class="line">	bltu a0, a1, 1b    </span><br><span class="line">2:</span><br><span class="line"></span><br><span class="line">	// argc, argv, envp is 0</span><br><span class="line">	li  a0, 0</span><br><span class="line">	li  a1, 0</span><br><span class="line">	li  a2, 0</span><br><span class="line">	jal main</span><br><span class="line">1:</span><br><span class="line">	wfi</span><br><span class="line">	j 1b</span><br><span class="line"></span><br><span class="line">ecall_err:</span><br><span class="line">	wfi</span><br><span class="line">	j ecall_err</span><br><span class="line">	</span><br><span class="line">secondary:</span><br><span class="line">	// TODO: Multicore is not supported</span><br><span class="line">	wfi</span><br><span class="line">	j secondary</span><br><span class="line">	.cfi_endproc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>启动代码主要做一些初始化工作：首先禁用所有中断，然后设置主栈指针，加载<code>rom</code>上的数据段到<code>ram</code>里，将<code>bss</code>段清零。<code>bss</code>段通常放的都是未初始化的全局变量，因此os手动清零</li>
<li>跳转到<code>main</code>函数开始执行：<code>jal main</code></li>
</ul>
<h3 id="4-4-FreeRTOS任务启动"><a href="#4-4-FreeRTOS任务启动" class="headerlink" title="4.4 FreeRTOS任务启动"></a>4.4 FreeRTOS任务启动</h3><p>在<code>main</code>函数中可以看见当创建完成任务后，会调用<code>vTaskStartScheduler()</code>函数来开启任务调度：</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421215337861.png" alt="image-20240421215337861"></p>
<p>我们进入<code>vTaskStartScheduler()</code>内部，可以看见首先创建了一个<code>IDLE</code>任务，即空闲任务，如果我们用户没用手动创建任务，那么<code>IDLE</code>任务会一直运行，此任务被设置为最低优先级0</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421215700843.png" alt="image-20240421215700843"></p>
<p>然后就会开启时钟中断，然后启动第一个任务：</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421220103518.png" alt="image-20240421220103518"></p>
<ul>
<li><p>先调用<code>portDISABLE_INTERRUPTS()</code>这个宏来关闭中断，然后在<code>xPortStartScheduler()</code>函数中构建好第一个任务执行的上下文后，会打开中断，这两个和cpu架构有关的宏或者函数就是定义在之前<code>portable</code>文件夹下的</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421220331304.png" alt="image-20240421220331304"></p>
</li>
</ul>
<p><code>xPortStartScheduler()</code>定义在<code>port.c</code>中，在此函数中会恢复第一个要执行任务的任务上下文，开启时钟中断，开始执行调度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">BaseType_t <span class="title function_">xPortStartScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">xPortStartFirstTask</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configASSERT_DEFINED == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">uint32_t</span> stvec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check the least significant two bits of mtvec are 00 - indicating</span></span><br><span class="line"><span class="comment">		single vector mode. */</span></span><br><span class="line">		__asm <span class="title function_">volatile</span><span class="params">( <span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span>( stvec ) )</span>;</span><br><span class="line">		<span class="comment">//检查 stvec 设置的是直接访问还是向量访问</span></span><br><span class="line">		configASSERT( ( stvec &amp; <span class="number">0x03</span>UL ) == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check alignment of the interrupt stack - which is the same as the</span></span><br><span class="line"><span class="comment">		stack that was being used by main() prior to the scheduler being</span></span><br><span class="line"><span class="comment">		started. */</span></span><br><span class="line">		<span class="comment">//检查栈顶的地址是否是对齐了</span></span><br><span class="line">		configASSERT( ( xISRStackTop &amp; portBYTE_ALIGNMENT_MASK ) == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化栈中的数据为 0</span></span><br><span class="line">		<span class="meta">#<span class="keyword">ifdef</span> configISR_STACK_SIZE_WORDS</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>( ( <span class="type">void</span> * ) xISRStack, portISR_STACK_FILL_BYTE, <span class="keyword">sizeof</span>( xISRStack ) );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="keyword">endif</span>	 <span class="comment">/* configISR_STACK_SIZE_WORDS */</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configASSERT_DEFINED */</span></span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 通过sbi设置Timer为滴答时钟 */</span></span><br><span class="line">	vPortSetupTimerInterrupt();</span><br><span class="line">   	<span class="comment">/* 使能SIE中S模式Timer中断和Soft中断，注意此处使能并不会立即响应</span></span><br><span class="line"><span class="comment">	xPortStartFirstTask中将打开全局使能 */</span></span><br><span class="line">    csr_set(CSR_SIE, SIP_STIP);</span><br><span class="line">    csr_set(CSR_SIE, SIP_SSIP);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//启动第一个任务</span></span><br><span class="line">	xPortStartFirstTask();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Should not get here as after calling xPortStartFirstTask() only tasks</span></span><br><span class="line"><span class="comment">	should be executing. */</span></span><br><span class="line">	<span class="keyword">return</span> pdFAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用<code>vPortSetupTimerInterrupt();</code>设置下次时钟中断的计数值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> uxTimerIncrementsForOneTick = ( <span class="type">size_t</span> ) ( ( configCPU_CLOCK_HZ ) / ( configTICK_RATE_HZ ) ); <span class="comment">/* Assumes increment won&#x27;t go over 32-bits. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortSetupTimerInterrupt</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 通过sbi设置下次tick中断 */</span></span><br><span class="line">	sbi_set_timer(get_ticks() + uxTimerIncrementsForOneTick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uxTimerIncrementsForOneTick</code>为下次时钟中断到来时的计数值，通过时钟频率和在<code>FreeRTOSConfig.h</code>中定义的时钟中断频率来计算</p>
</li>
<li><p>使能SIE中S模式Timer中断和Soft中断，此时用于没有开启S态的全局中断，所以不会立即响应，会在<code>xPortStartFirstTask();</code>函数中恢复第一个任务的上下文后才开启</p>
</li>
</ul>
<p><code>xPortStartFirstTask()</code>定义在<code>portASM.S</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">xPortStartFirstTask:</span><br><span class="line"></span><br><span class="line">	la t0, freertos_risc_v_trap_handler    //设置异常处理地址</span><br><span class="line">	csrw stvec, t0</span><br><span class="line"></span><br><span class="line">	//加载任务的TCB指针</span><br><span class="line">	load_x  sp, pxCurrentTCB			/* Load pxCurrentTCB. */</span><br><span class="line">	//加载此任务的栈地址</span><br><span class="line">	load_x  sp, 0( sp )				 	/* Read sp from first TCB member. */</span><br><span class="line"></span><br><span class="line">	load_x  x1, 0( sp ) /* Note for starting the scheduler the exception return address is used as the function return address. */</span><br><span class="line"></span><br><span class="line">	load_x  x6, 3 * portWORD_SIZE( sp )		/* t1 */</span><br><span class="line">	load_x  x7, 4 * portWORD_SIZE( sp )		/* t2 */</span><br><span class="line">	load_x  x8, 5 * portWORD_SIZE( sp )		/* s0/fp */</span><br><span class="line">	load_x  x9, 6 * portWORD_SIZE( sp )		/* s1 */</span><br><span class="line">	load_x  x10, 7 * portWORD_SIZE( sp )	/* a0 */</span><br><span class="line">	load_x  x11, 8 * portWORD_SIZE( sp )	/* a1 */</span><br><span class="line">	load_x  x12, 9 * portWORD_SIZE( sp )	/* a2 */</span><br><span class="line">	load_x  x13, 10 * portWORD_SIZE( sp )	/* a3 */</span><br><span class="line">	load_x  x14, 11 * portWORD_SIZE( sp )	/* a4 */</span><br><span class="line">	load_x  x15, 12 * portWORD_SIZE( sp )	/* a5 */</span><br><span class="line">	load_x  x16, 13 * portWORD_SIZE( sp )	/* a6 */</span><br><span class="line">	load_x  x17, 14 * portWORD_SIZE( sp )	/* a7 */</span><br><span class="line">	load_x  x18, 15 * portWORD_SIZE( sp )	/* s2 */</span><br><span class="line">	load_x  x19, 16 * portWORD_SIZE( sp )	/* s3 */</span><br><span class="line">	load_x  x20, 17 * portWORD_SIZE( sp )	/* s4 */</span><br><span class="line">	load_x  x21, 18 * portWORD_SIZE( sp )	/* s5 */</span><br><span class="line">	load_x  x22, 19 * portWORD_SIZE( sp )	/* s6 */</span><br><span class="line">	load_x  x23, 20 * portWORD_SIZE( sp )	/* s7 */</span><br><span class="line">	load_x  x24, 21 * portWORD_SIZE( sp )	/* s8 */</span><br><span class="line">	load_x  x25, 22 * portWORD_SIZE( sp )	/* s9 */</span><br><span class="line">	load_x  x26, 23 * portWORD_SIZE( sp )	/* s10 */</span><br><span class="line">	load_x  x27, 24 * portWORD_SIZE( sp )	/* s11 */</span><br><span class="line">	load_x  x28, 25 * portWORD_SIZE( sp )	/* t3 */</span><br><span class="line">	load_x  x29, 26 * portWORD_SIZE( sp )	/* t4 */</span><br><span class="line">	load_x  x30, 27 * portWORD_SIZE( sp )	/* t5 */</span><br><span class="line">	load_x  x31, 28 * portWORD_SIZE( sp )	/* t6 */</span><br><span class="line"></span><br><span class="line">	load_x  x5, 29 * portWORD_SIZE( sp )	/* Initial mstatus into x5 (t0) */</span><br><span class="line">	ori x5, x5, 0x2					    	/* Set SIE bit so the first task starts with interrupts enabled - required as returns with ret not eret. */</span><br><span class="line">	csrrw  x0, sstatus, x5					/* Interrupts enabled from here! */</span><br><span class="line">	load_x  x5, 2 * portWORD_SIZE( sp )		/* Initial x5 (t0) value. */</span><br><span class="line"></span><br><span class="line">	addi	sp, sp, portCONTEXT_SIZE</span><br><span class="line">	ret</span><br><span class="line">	.endfunc</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先设置异常处理地址，即设置<code>stvec</code>寄存器的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">la t0, freertos_risc_v_trap_handler    //设置异常处理地址</span><br><span class="line">csrw stvec, t0</span><br></pre></td></tr></table></figure>

<p>下一次<code>trap</code>来临时就会进入<code>freertos_risc_v_trap_handler </code>这个地址去进行处理，和我们<code>TimerOS</code>实现类似，在<code>freertos_risc_v_trap_handler</code>函数内部会判断是什么类型的异常，比如时钟中断、外部中断、异常等等，如果是时钟中断，则会去执行任务切换</p>
</li>
<li><p>然后是根据当前任务的<code>TCB</code>的指针，拿到此任务的栈地址，根据任务<code>TCB</code>的定义发现栈指针是放在<code>TCB</code>最开始的位置</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421223228120.png" alt="image-20240421223228120"></p>
</li>
<li><p>所以先取出<code>TCB</code>的指针，再从<code>TCB</code>的第一个地址取出任务栈，从此任务的栈中恢复任务上下文，<code>pxCurrentTCB</code>是<code>FreeRTOS</code>中定义的一个全局指针，用来指向当前正在执行的任务的<code>TCB</code>，由于我们最后创建的任务是<code>IDLE</code>任务，所以此时<code>pxCurrentTCB</code>肯定是指向<code>IDLE</code>任务的<code>TCB</code>的，<code>xTaskCreate</code>内部会去调用<code>prvAddNewTaskToReadyList</code>来初始化设置<code>pxCurrentTCB</code>的值</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421222608370.png" alt="image-20240421222608370"></p>
</li>
<li><p>此时你可能有一个疑问，既然要从栈中恢复任务上下文，是不是在创建任务的时候需要先为每个任务初始化任务上下文，那就对了，<code>xTaskCreate</code>内部会去调用<code>prvInitialiseNewTask</code>函数，而中<code>prvInitialiseNewTask</code>会去调用<code>pxPortInitialiseStack</code>函数来初始化任务栈</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421222924490.png" alt="image-20240421222924490"></p>
</li>
</ul>
<p><code>pxPortInitialiseStack</code>此函数用于初始化一个任务的任务栈，定义在<code>portASM.S</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">pxPortInitialiseStack:                  // 函数参数应该为栈的地址放入 a0 寄存器</span><br><span class="line">	csrr t0, sstatus					/* t0 = sstatus 保存当前sstatus寄存器的值到t0寄存器中 */</span><br><span class="line">	andi t0, t0, ~0x2					/* Ensure interrupts are disabled when the stack is restored within an ISR.  Required when a task is created after the schedulre has been started, otherwise interrupts would be disabled anyway. */</span><br><span class="line">	addi t1, x0, 0x120					/* Generate the value 0x120, which are the SPIE and SPP bits to set in sstatus. */</span><br><span class="line">	or t0, t0, t1						/* Set SPIE and SPP bits in sstatus value. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	addi a0, a0, -portWORD_SIZE</span><br><span class="line">	store_x t0, 0(a0)					/* sstatus onto the stack. */</span><br><span class="line">	addi a0, a0, -(22 * portWORD_SIZE)	/* Space for registers x11-x31. */</span><br><span class="line">	store_x a2, 0(a0)					/* Task parameters (pvParameters parameter) goes into register X10/a0 on the stack. */</span><br><span class="line">	addi a0, a0, -(6 * portWORD_SIZE)	/* Space for registers x5-x9. */</span><br><span class="line">	la t0, prvTaskExitError             /* 加载prvTaskExitError函数的地址到 t0 */</span><br><span class="line">	store_x t0, 0(a0)					/* Return address onto the stack, could be portTASK_RETURN_ADDRESS */</span><br><span class="line"></span><br><span class="line">	addi a0, a0, -portWORD_SIZE</span><br><span class="line">	store_x a1, 0(a0)					/* sret value (pxCode parameter) onto the stack. */</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	.endfunc</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先来看调用此函数的调用时传入的参数和返回值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>pxTopOfStack</code>：任务栈的栈顶地址，<code>portSTACK_GROWTH</code>这个宏用于判断栈的增长方向，此宏在<code>portmacro.h</code>中被定义成了<code>-1</code>，因此往地址增长，<code>pxTopOfStack</code>指向了栈顶地址，</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422120342433.png" alt="image-20240422120342433"></p>
<img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422121813632.png" alt="image-20240422121813632" style="zoom:50%;">

<p>注意：<code>pxTopOfStack</code>是个临时变量，指向此时栈的最低地址，不是<code>TCB</code>结构体顶部的那个<code>pxTopOfStack</code></p>
</li>
<li><p><code>pxTopOfStack</code>会被放入<code>a0</code>寄存器中，<code>pxTaskCode</code>放入<code>a1</code>寄存器中，<code>pvParameters</code>放入<code>a2</code>寄存器中</p>
</li>
</ul>
</li>
<li><p><code>pxPortInitialiseStack</code>函数内部会依次压栈初始化任务上下文，栈中的数据如下：</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422130449205.png" alt="image-20240422130449205"></p>
</li>
<li><p>此时再来回看<code>xPortStartFirstTask</code>中的恢复第一个任务的上下文就很清晰了，上面提到<code>xPortStartFirstTask</code>函数内部会在恢复上下文后开启全局中断，这一步就发生在<code>csrrw  x0, sstatus, x5					/* Interrupts enabled from here! */</code>，我们在初始化任务上下文时会构造一个<code>sstatus</code>的初始值，会去设置相应的bit位来开启S态的全局中断，这样将<code>ssatus</code>的值从栈中恢复时就会开启全局中断了，从而开启基于RTC中断的任务调度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csrr t0, sstatus					/* t0 = sstatus 保存当前sstatus寄存器的值到t0寄存器中 */</span><br><span class="line">andi t0, t0, ~0x2					/* Ensure interrupts are disabled when the stack is restored within an ISR.  Required when a task is created after the schedulre has been started, otherwise interrupts would be disabled anyway. */</span><br><span class="line">addi t1, x0, 0x120					/* Generate the value 0x120, which are the SPIE and SPP bits to set in sstatus. */</span><br><span class="line">or t0, t0, t1						/* Set SPIE and SPP bits in sstatus value. */</span><br></pre></td></tr></table></figure></li>
</ul>
<p>回顾一下整个启动流程：</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422145110158.png" alt="image-20240422145110158"></p>
<h3 id="4-5-内核启动后的任务切换"><a href="#4-5-内核启动后的任务切换" class="headerlink" title="4.5 内核启动后的任务切换"></a>4.5 内核启动后的任务切换</h3><p>​		在调用<code>xPortStartFirstTask()</code>之后，此时会启动<code>IDLE</code>任务，同时开启了时钟中断，那么在下一次时钟中断到来时，我们需要去进行处理，在<code>xPortStartFirstTask()</code>函数的开头我们设置了<code>stvec</code>的值，当产生<code>trap</code>时会跳转到<code>stvec</code>寄存器指向的地址处执行，这个地址是<code>freertos_risc_v_trap_handler</code>，这个函数定义在<code>portASM</code>的开头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">freertos_risc_v_trap_handler:</span><br><span class="line">    // x2 为sp ，不需要保存</span><br><span class="line">	// x3 为gp，全局指针，基本不变也不需要保存</span><br><span class="line">	// x4 为tp，线程指针，不需要保存</span><br><span class="line">	addi sp, sp, -portCONTEXT_SIZE</span><br><span class="line">	store_x x1, 1 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x5, 2 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x6, 3 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x7, 4 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x8, 5 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x9, 6 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x10, 7 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x11, 8 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x12, 9 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x13, 10 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x14, 11 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x15, 12 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x16, 13 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x17, 14 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x18, 15 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x19, 16 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x20, 17 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x21, 18 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x22, 19 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x23, 20 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x24, 21 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x25, 22 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x26, 23 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x27, 24 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x28, 25 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x29, 26 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x30, 27 * portWORD_SIZE( sp )</span><br><span class="line">	store_x x31, 28 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">	csrr t0, sstatus					/* Required for SPIE bit. */</span><br><span class="line">	store_x t0, 29 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">	csrr t0, sepc  //sepc 存储了中断返回地址</span><br><span class="line">	store_x t0, 0 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">	load_x  t0, pxCurrentTCB			/*  加载当前任务的任务控制块（TCB）地址到t0寄存器。 */</span><br><span class="line">	store_x  sp, 0( t0 )				/*  将当前的堆栈指针sp的值保存到TCB的第一个成员变量中. */</span><br><span class="line"></span><br><span class="line">	csrr a0, scause</span><br><span class="line">	csrr a1, sepc</span><br><span class="line"></span><br><span class="line">//判断是中断还是异常</span><br><span class="line">test_if_asynchronous:     				//参数为 scause的值，存放在a0寄存器中</span><br><span class="line">	srli a2, a0, __riscv_xlen - 1		/* MSB of mcause is 1 if handing an asynchronous interrupt - shift to LSB to clear other bits. */</span><br><span class="line">	beq a2, x0, handle_synchronous		/* Branch past interrupt handing if not asynchronous. */</span><br><span class="line">	store_x a1, 0( sp )					/* Asynch so save unmodified exception return address. */</span><br><span class="line"></span><br><span class="line">//异常</span><br><span class="line">handle_asynchronous:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_if_ipi:						 //参数为 scause的值，存放在a0寄存器中</span><br><span class="line">	addi t0, x0, 1</span><br><span class="line"></span><br><span class="line">	slli t0, t0, __riscv_xlen - 1   /* LSB is already set, shift into MSB.  Shift 31 on 32-bit or 63 on 64-bit cores. */</span><br><span class="line">	addi t1, t0, 1					/* 0x8000[]0001 == Supervisor ipi interrupt. */</span><br><span class="line">	bne a0, t1, test_if_mtimer      // 如果不是软件中断则跳转到 test_if_mtimer 处执行</span><br><span class="line"></span><br><span class="line">	load_x sp, xISRStackTop			/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">	jal vPortClearIpiInterrupt</span><br><span class="line">	jal vTaskSwitchContext          // </span><br><span class="line">	j processed_source</span><br><span class="line"></span><br><span class="line">test_if_mtimer:						/* If there is a CLINT then the mtimer is used to generate the tick interrupt. */</span><br><span class="line">	addi t1, t1, 4					/* 0x80000001 + 4 = 0x80000005 == Supervisor timer interrupt. */</span><br><span class="line">	bne a0, t1, test_if_external_interrupt  </span><br><span class="line">	/* 处理时钟中断 */</span><br><span class="line">	load_x sp, xISRStackTop			/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">	jal vPortSetupTimerInterrupt    /* 设置定时器中断计数 */</span><br><span class="line">	jal xTaskIncrementTick</span><br><span class="line">	beqz a0, processed_source		/* Don&#x27;t switch context if incrementing tick didn&#x27;t unblock a task. */</span><br><span class="line">	jal vTaskSwitchContext</span><br><span class="line">	j processed_source</span><br><span class="line"></span><br><span class="line">/* 外部中断处理函数 */</span><br><span class="line">test_if_external_interrupt:			/* If there is a CLINT and the mtimer interrupt is not pending then check to see if an external interrupt is pending. */</span><br><span class="line">	addi t1, t1, 4					/* 0x80000005 + 4 = 0x80000009 == Supervisor external interrupt. */</span><br><span class="line">	bne a0, t1, processed_trap   	/* Something as yet unhandled. */</span><br><span class="line">	//处理外部中断</span><br><span class="line">	load_x sp, xISRStackTop			/* Switch to ISR stack before function call. */</span><br><span class="line">	jal handle_interrupt	        /* Jump to the interrupt handler if there is no CLINT or if there is a CLINT and it has been determined that an external interrupt is pending. */</span><br><span class="line">	j processed_source</span><br><span class="line"></span><br><span class="line">handle_synchronous:</span><br><span class="line">	addi a1, a1, 4						/* Synchronous so updated exception return address to the instruction after the instruction that generated the exeption. */</span><br><span class="line">	store_x a1, 0( sp )					/* Save updated exception return address. */</span><br><span class="line"></span><br><span class="line">//其他中断</span><br><span class="line">processed_trap:</span><br><span class="line">	csrr a0, scause</span><br><span class="line">	csrr a1, sepc</span><br><span class="line">	csrr a2, stval</span><br><span class="line">	mv   a4, sp</span><br><span class="line">	load_x sp, xISRStackTop			/* Switch to ISR stack before function call. */</span><br><span class="line">	jal handle_trap	                /* Jump to the interrupt handler if there is no CLINT or if there is a CLINT and it has been determined that an external interrupt is pending. */</span><br><span class="line">	j processed_source</span><br><span class="line"></span><br><span class="line">//任务恢复</span><br><span class="line">processed_source:</span><br><span class="line">	load_x  t1, pxCurrentTCB		/* Load pxCurrentTCB. */</span><br><span class="line">	load_x  sp, 0( t1 )				/* Read sp from first TCB member. */</span><br><span class="line"></span><br><span class="line">	/* Load sret with the address of the next instruction in the task to run next. */</span><br><span class="line">	load_x t0,  0( sp )</span><br><span class="line">	csrw sepc, t0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Load mstatus with the interrupt enable bits used by the task. */</span><br><span class="line">	load_x  t0, 29 * portWORD_SIZE( sp )   //读取保存在栈中的sstatus寄存器的值</span><br><span class="line">	csrw sstatus, t0				/* Required for SPIE bit. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//从栈中恢复上下文寄存器</span><br><span class="line">	load_x  x1, 1 * portWORD_SIZE( sp )</span><br><span class="line">	load_x  x5, 2 * portWORD_SIZE( sp )		/* t0 */</span><br><span class="line">	load_x  x6, 3 * portWORD_SIZE( sp )		/* t1 */</span><br><span class="line">	load_x  x7, 4 * portWORD_SIZE( sp )		/* t2 */</span><br><span class="line">	load_x  x8, 5 * portWORD_SIZE( sp )		/* s0/fp */</span><br><span class="line">	load_x  x9, 6 * portWORD_SIZE( sp )		/* s1 */</span><br><span class="line">	load_x  x10, 7 * portWORD_SIZE( sp )	/* a0 */</span><br><span class="line">	load_x  x11, 8 * portWORD_SIZE( sp )	/* a1 */</span><br><span class="line">	load_x  x12, 9 * portWORD_SIZE( sp )	/* a2 */</span><br><span class="line">	load_x  x13, 10 * portWORD_SIZE( sp )	/* a3 */</span><br><span class="line">	load_x  x14, 11 * portWORD_SIZE( sp )	/* a4 */</span><br><span class="line">	load_x  x15, 12 * portWORD_SIZE( sp )	/* a5 */</span><br><span class="line">	load_x  x16, 13 * portWORD_SIZE( sp )	/* a6 */</span><br><span class="line">	load_x  x17, 14 * portWORD_SIZE( sp )	/* a7 */</span><br><span class="line">	load_x  x18, 15 * portWORD_SIZE( sp )	/* s2 */</span><br><span class="line">	load_x  x19, 16 * portWORD_SIZE( sp )	/* s3 */</span><br><span class="line">	load_x  x20, 17 * portWORD_SIZE( sp )	/* s4 */</span><br><span class="line">	load_x  x21, 18 * portWORD_SIZE( sp )	/* s5 */</span><br><span class="line">	load_x  x22, 19 * portWORD_SIZE( sp )	/* s6 */</span><br><span class="line">	load_x  x23, 20 * portWORD_SIZE( sp )	/* s7 */</span><br><span class="line">	load_x  x24, 21 * portWORD_SIZE( sp )	/* s8 */</span><br><span class="line">	load_x  x25, 22 * portWORD_SIZE( sp )	/* s9 */</span><br><span class="line">	load_x  x26, 23 * portWORD_SIZE( sp )	/* s10 */</span><br><span class="line">	load_x  x27, 24 * portWORD_SIZE( sp )	/* s11 */</span><br><span class="line">	load_x  x28, 25 * portWORD_SIZE( sp )	/* t3 */</span><br><span class="line">	load_x  x29, 26 * portWORD_SIZE( sp )	/* t4 */</span><br><span class="line">	load_x  x30, 27 * portWORD_SIZE( sp )	/* t5 */</span><br><span class="line">	load_x  x31, 28 * portWORD_SIZE( sp )	/* t6 */</span><br><span class="line">	addi sp, sp, portCONTEXT_SIZE</span><br><span class="line"></span><br><span class="line">	sret</span><br><span class="line">	.endfunc</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我当前有一个任务正在暂用<code>cpu</code>运行，此时时钟中断来临，会打断当前任务的执行，然后执行任务切换，因此在中断处理函数中，需要先保存当前任务的上下文，<code>x2、x3、x4</code>不需要保存，保存任务上下文时先增加<code>sp</code>的值，增加的大小为<code>portCONTEXT_SIZE</code>，使用<code>store_x</code>依次保存寄存器后，将此时任务的栈顶地址保存到<code>pxNewTCB-&gt;pxTopOfStack</code>中，用于在任务恢复时找到栈顶</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portCONTEXT_SIZE ( 30 * portWORD_SIZE )   <span class="comment">//任务上下文占用内存大小</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>保存完毕任务上下文后，将<code>scause</code>写入了<code>a0</code>寄存器，<code>sepc</code>寄存器写入了<code>a1</code>寄存器，用于后续针对不同类型的异常进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断是中断还是异常</span><br><span class="line">test_if_asynchronous:     				//参数为 scause的值，存放在a0寄存器中</span><br><span class="line">	srli a2, a0, __riscv_xlen - 1		/* MSB of mcause is 1 if handing an asynchronous interrupt - shift to LSB to clear other bits. */</span><br><span class="line">	beq a2, x0, handle_synchronous		/* Branch past interrupt handing if not asynchronous. */</span><br><span class="line">	store_x a1, 0( sp )	</span><br></pre></td></tr></table></figure>

<ul>
<li><code>srli</code>是右移位指令，<code>scause</code>的最高位表明了此次<code>trap</code>是中断还是异常，因此将<code>a0</code>寄存器右移<code>__riscv_xlen - 1</code>位后保存到<code>a2</code>寄存器中，此时<code>a2</code>寄存器中就保存了<code>scause</code>的最高位</li>
<li>如果<code>a2 == 0</code>则表示是异常，跳转到<code>handle_synchronous</code>处执行可以看见为空，否则为中断，将<code>sepc</code>寄存器的值写入到栈顶位置</li>
</ul>
</li>
<li><p>如果为中断则会继续向下执行<code>test_if_ipi</code>标签处的代码，这里会根据<code>scause</code>的最后一位判断是软件中断还是其他中断，如果是软件中断则会执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load_x sp, xISRStackTop			/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">jal vPortClearIpiInterrupt</span><br><span class="line">jal vTaskSwitchContext          // </span><br><span class="line">j processed_source</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果是软件中断会切换到<code>ISR</code>专用的栈：<code>xISRStackTop</code>，这是在<code>port.c</code>中定义的一片内存的最高地址。</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422152624416.png" alt="image-20240422152624416"></p>
</li>
<li><p>然后跳转到<code>vPortClearIpiInterrupt</code>函数处执行，此函数也是定义在<code>port.c</code>中</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422152807737.png" alt="image-20240422152807737"></p>
</li>
<li><p>上面提到过任务可以通过调用<code>portYIELD()</code>来手动触发软中断，从而实现任务切换，此时就是这样的情况，在清楚软中断的标志位后，就会去执行任务切换，调用<code>vTaskSwitchContext</code>，这是<code>FreeRTOS</code>内部定义的选择下一个可执行任务上下文的函数，去看源码就发发现此函数从就绪链表中挑选出最高优先级的任务，然后将全局任务指针<code>pxCurrentTCB</code>指向此任务的<code>TCB</code>，然后就可以从此要执行任务的栈中恢复上下文了，然后跳转执行，恢复任务上下文的函数是<code>processed_source</code></p>
</li>
</ul>
</li>
<li><p>如果不是主动触发的软中断，则就跳转到<code>test_if_mtimer</code>处执行，此时会判断是时钟中断还是其他外部中断，如果是时钟中断，此时也要进行任务切换，同样切换ISR专用栈，不过需要设置下一次时钟中断到来的计数值，通过调用<code>vPortSetupTimerInterrupt</code>函数实现，然后调用<code>FreeRTOS</code>内部定义的<code>xTaskIncrementTick</code>函数，此函数用于告知系统增加了依次时钟计数，其内部机制我们暂不剖析，主要是用于延时和任务调度相关的。然后调用<code>vTaskSwitchContext</code>选择下一个就绪任务，恢复任务上下文，跳转执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test_if_mtimer:						/* If there is a CLINT then the mtimer is used to generate the tick interrupt. */</span><br><span class="line">	addi t1, t1, 4					/* 0x80000001 + 4 = 0x80000005 == Supervisor timer interrupt. */</span><br><span class="line">	bne a0, t1, test_if_external_interrupt  </span><br><span class="line">	/* 处理时钟中断 */</span><br><span class="line">	load_x sp, xISRStackTop			/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">	jal vPortSetupTimerInterrupt    /* 设置定时器中断计数 */</span><br><span class="line">	jal xTaskIncrementTick</span><br><span class="line">	beqz a0, processed_source		/* Don&#x27;t switch context if incrementing tick didn&#x27;t unblock a task. */</span><br><span class="line">	jal vTaskSwitchContext</span><br><span class="line">	j processed_source</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是外部中断的话，会跳转到<code>handle_interrupt</code>进行处理，如果是其他中断会跳转到<code>processed_trap</code>处理</p>
</li>
<li><p>我们重点来看任务恢复函数<code>processed_source</code>，通过执行<code>vTaskSwitchContext</code>，将<code>pxCurrentTCB</code>指向了下一个要执行任务的<code>TCB</code>，通过<code>pxCurrentTCB</code>指针就可以访问到要执行任务的任务上下文的栈空间，因此恢复任务上下文，通过<code>sret</code>指令会跳转到<code>sepc</code>寄存器的地址执行，<code>sepc</code>寄存器在任务被中断后会自动设置，保存了中断返回后指令地址，在<code>freertos_risc_v_trap_handler</code>函数中进行了压栈，因此从栈中恢复后，<code>sret</code>指令就能跳转到正确的地址执行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processed_source:</span><br><span class="line">	load_x  t1, pxCurrentTCB		/* Load pxCurrentTCB. */</span><br><span class="line">	load_x  sp, 0( t1 )				/* Read sp from first TCB member. */</span><br><span class="line"></span><br><span class="line">	/* Load sret with the address of the next instruction in the task to run next. */</span><br><span class="line">	load_x t0,  0( sp )</span><br><span class="line">	csrw sepc, t0</span><br><span class="line"></span><br><span class="line">	/* Load mstatus with the interrupt enable bits used by the task. */</span><br><span class="line">	load_x  t0, 29 * portWORD_SIZE( sp )   //读取保存在栈中的sstatus寄存器的值</span><br><span class="line">	csrw sstatus, t0				/* Required for SPIE bit. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//从栈中恢复上下文寄存器</span><br><span class="line">	load_x  x1, 1 * portWORD_SIZE( sp )</span><br><span class="line">	load_x  x5, 2 * portWORD_SIZE( sp )		/* t0 */</span><br><span class="line">	load_x  x6, 3 * portWORD_SIZE( sp )		/* t1 */</span><br><span class="line">	load_x  x7, 4 * portWORD_SIZE( sp )		/* t2 */</span><br><span class="line">	load_x  x8, 5 * portWORD_SIZE( sp )		/* s0/fp */</span><br><span class="line">	load_x  x9, 6 * portWORD_SIZE( sp )		/* s1 */</span><br><span class="line">	load_x  x10, 7 * portWORD_SIZE( sp )	/* a0 */</span><br><span class="line">	load_x  x11, 8 * portWORD_SIZE( sp )	/* a1 */</span><br><span class="line">	load_x  x12, 9 * portWORD_SIZE( sp )	/* a2 */</span><br><span class="line">	load_x  x13, 10 * portWORD_SIZE( sp )	/* a3 */</span><br><span class="line">	load_x  x14, 11 * portWORD_SIZE( sp )	/* a4 */</span><br><span class="line">	load_x  x15, 12 * portWORD_SIZE( sp )	/* a5 */</span><br><span class="line">	load_x  x16, 13 * portWORD_SIZE( sp )	/* a6 */</span><br><span class="line">	load_x  x17, 14 * portWORD_SIZE( sp )	/* a7 */</span><br><span class="line">	load_x  x18, 15 * portWORD_SIZE( sp )	/* s2 */</span><br><span class="line">	load_x  x19, 16 * portWORD_SIZE( sp )	/* s3 */</span><br><span class="line">	load_x  x20, 17 * portWORD_SIZE( sp )	/* s4 */</span><br><span class="line">	load_x  x21, 18 * portWORD_SIZE( sp )	/* s5 */</span><br><span class="line">	load_x  x22, 19 * portWORD_SIZE( sp )	/* s6 */</span><br><span class="line">	load_x  x23, 20 * portWORD_SIZE( sp )	/* s7 */</span><br><span class="line">	load_x  x24, 21 * portWORD_SIZE( sp )	/* s8 */</span><br><span class="line">	load_x  x25, 22 * portWORD_SIZE( sp )	/* s9 */</span><br><span class="line">	load_x  x26, 23 * portWORD_SIZE( sp )	/* s10 */</span><br><span class="line">	load_x  x27, 24 * portWORD_SIZE( sp )	/* s11 */</span><br><span class="line">	load_x  x28, 25 * portWORD_SIZE( sp )	/* t3 */</span><br><span class="line">	load_x  x29, 26 * portWORD_SIZE( sp )	/* t4 */</span><br><span class="line">	load_x  x30, 27 * portWORD_SIZE( sp )	/* t5 */</span><br><span class="line">	load_x  x31, 28 * portWORD_SIZE( sp )	/* t6 */</span><br><span class="line">	addi sp, sp, portCONTEXT_SIZE</span><br><span class="line"></span><br><span class="line">	sret</span><br><span class="line">	.endfunc</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-编译运行测试"><a href="#5-编译运行测试" class="headerlink" title="5. 编译运行测试"></a>5. 编译运行测试</h2><p>在<code>build.sh</code>中需要将执行编译<code>trusted_domain</code>，并将生成的固件打包，主要修改的地方为：</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422155222221.png" alt="image-20240422155222221"></p>
<p>固件打包的地方不用修改，还是写入到原本的地址</p>
<p>运行测试：如下三个任务，两个任务写队列，一个任务接收队列消息，运行成功</p>
<p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/GIF%202024-4-22%2015-55-01.gif" alt="GIF 2024-4-22 15-55-01"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://quard-star-tutorial.readthedocs.io/zh-cn/latest/ch21.html">基于qemu-riscv从0开始构建嵌入式linux系统ch21. 实时操作系统FreeRTOS移植RISCV-S模式 — 主页 (quard-star-tutorial.readthedocs.io)</a></li>
<li><a target="_blank" rel="noopener" href="https://rvoslab.github.io/step_by_step_doc/interrupt/plic.html">PLIC · Code an OS Handbook (rvoslab.github.io)</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yanglianoo.github.io">Timer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yanglianoo.github.io/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/">https://yanglianoo.github.io/2024/04/17/为Quard-star移植FreeRTOS-移植代码构建/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yanglianoo.github.io" target="_blank">TimerのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/qemu/">qemu</a><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/riscv/">riscv</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422130449205.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="Linux内核中同步机制的底层实现"><img class="cover" src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/barriers-12a.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux内核中同步机制的底层实现</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/" title="为Quard-star移植FreeRTOS-FreeRTOS内部机制剖析"><img class="cover" src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATW9uc3RlciB4bg==,size_20,color_FFFFFF,t_70,g_se,x_16.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">为Quard-star移植FreeRTOS-FreeRTOS内部机制剖析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="sys_exec的实现"><img class="cover" src="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231020210202183.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-20</div><div class="title">sys_exec的实现</div></div></a></div><div><a href="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="sys_fork的实现"><img class="cover" src="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231008205605214.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-08</div><div class="title">sys_fork的实现</div></div></a></div><div><a href="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/" title="为Quard-star移植FreeRTOS-FreeRTOS内部机制剖析"><img class="cover" src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATW9uc3RlciB4bg==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-14</div><div class="title">为Quard-star移植FreeRTOS-FreeRTOS内部机制剖析</div></div></a></div><div><a href="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/" title="内核和用户程序的映射逻辑"><img class="cover" src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/v2-9c287c7d7384525eae9a37022322fd78_720w.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-12</div><div class="title">内核和用户程序的映射逻辑</div></div></a></div><div><a href="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/" title="分时多任务系统与抢占式调度"><img class="cover" src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820143746426.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-20</div><div class="title">分时多任务系统与抢占式调度</div></div></a></div><div><a href="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" title="协作式多任务调度"><img class="cover" src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20230811150744675.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-10</div><div class="title">协作式多任务调度</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Timer</div><div class="author-info__description">没有一个健康的身体，如何支撑我龌龊的灵魂!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yanglianoo"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yanglianoo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">个人微信：13699648817</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%BB%E6%A4%8DFreeRTOS"><span class="toc-text">移植FreeRTOS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84"><span class="toc-text">1. 内存布局与移植代码架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%86%85%E5%AD%98%E5%90%AF%E5%8A%A8%E5%9C%B0%E5%9D%80%E4%BF%AE%E6%94%B9"><span class="toc-text">1.1 内存启动地址修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%A7%BB%E6%A4%8D%E6%96%87%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-text">1.2 移植文件架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">2. 平台架构相关代码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-driver"><span class="toc-text">2.1 driver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-riscv"><span class="toc-text">2.2 riscv</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-FreeRTOS%E7%A7%BB%E6%A4%8D%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="toc-text">3. FreeRTOS移植相关代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-FreeRTOS%E6%BA%90%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-text">3.1 FreeRTOS源码组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-FreeRTOS%E9%85%8D%E7%BD%AE"><span class="toc-text">3.2 FreeRTOS配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-portable%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%A7%BB%E6%A4%8D%E6%96%87%E4%BB%B6"><span class="toc-text">3.3 portable目录下移植文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-FreeRTOS%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">4. FreeRTOS启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-FreeRTOS%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text">4.1 FreeRTOS使用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-text">4.2 编译和链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%90%AF%E5%8A%A8%E4%BB%A3%E7%A0%81"><span class="toc-text">4.3 启动代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-FreeRTOS%E4%BB%BB%E5%8A%A1%E5%90%AF%E5%8A%A8"><span class="toc-text">4.4 FreeRTOS任务启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%90%8E%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><span class="toc-text">4.5 内核启动后的任务切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-text">5. 编译运行测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="Linux内核中同步机制的底层实现"><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/barriers-12a.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux内核中同步机制的底层实现"/></a><div class="content"><a class="title" href="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="Linux内核中同步机制的底层实现">Linux内核中同步机制的底层实现</a><time datetime="2024-05-07T09:38:31.000Z" title="发表于 2024-05-07 17:38:31">2024-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/" title="为Quard-star移植FreeRTOS-移植代码构建"><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422130449205.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="为Quard-star移植FreeRTOS-移植代码构建"/></a><div class="content"><a class="title" href="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/" title="为Quard-star移植FreeRTOS-移植代码构建">为Quard-star移植FreeRTOS-移植代码构建</a><time datetime="2024-04-17T09:14:47.000Z" title="发表于 2024-04-17 17:14:47">2024-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/" title="为Quard-star移植FreeRTOS-FreeRTOS内部机制剖析"><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATW9uc3RlciB4bg==,size_20,color_FFFFFF,t_70,g_se,x_16.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="为Quard-star移植FreeRTOS-FreeRTOS内部机制剖析"/></a><div class="content"><a class="title" href="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/" title="为Quard-star移植FreeRTOS-FreeRTOS内部机制剖析">为Quard-star移植FreeRTOS-FreeRTOS内部机制剖析</a><time datetime="2024-04-14T06:08:49.000Z" title="发表于 2024-04-14 14:08:49">2024-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/" title="使用原始套接字剖析TCP"><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221161712911.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用原始套接字剖析TCP"/></a><div class="content"><a class="title" href="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/" title="使用原始套接字剖析TCP">使用原始套接字剖析TCP</a><time datetime="2024-02-21T04:43:48.000Z" title="发表于 2024-02-21 12:43:48">2024-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/" title="CyberRt源码分析-对象池"><img src="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/image-20231202111140335.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CyberRt源码分析-对象池"/></a><div class="content"><a class="title" href="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/" title="CyberRt源码分析-对象池">CyberRt源码分析-对象池</a><time datetime="2023-12-01T08:13:05.000Z" title="发表于 2023-12-01 16:13:05">2023-12-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/background.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Timer</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>