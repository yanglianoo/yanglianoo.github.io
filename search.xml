<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux内核启动流程分析</title>
      <link href="/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核启动流程分析"><a href="#Linux内核启动流程分析" class="headerlink" title="Linux内核启动流程分析"></a>Linux内核启动流程分析</h1><p>我在学习Linux驱动的时候总感觉蒙着一层雾，让我看不清Linux内核的核心，Linux内核有很多子系统，我觉得有必要先从<code>Linux Kernel</code>的启动去宏观的看一下各个子系统是哪个时刻被启动的，我主要以<code>ARM64</code>为例子来分析Linux 内核的启动流程。我们知道在<code>Linux</code>内核启动之前是<code>uboot</code>，<code>uboot</code>会做一些初始化工作，如初始化ddr，我使用的内核源码版本为<code>4.19.232</code></p><h2 id="1-内核链接文件"><a href="#1-内核链接文件" class="headerlink" title="1. 内核链接文件"></a>1. 内核链接文件</h2><p>​内核编译后生成的目标文件是ELF格式的vmlinux，vmlinux文件是各个源代码按照<code>vmlinux.lds</code>设定的规则，链接后得到的Object文件，并不是一个可执行的文件，不能在ARM平台上运行；通常会对其压缩，生成zImage或bzImage；通常内核映像以压缩格式存储，并不是一个可执行的内核；因此内核阶段需要先对内核映像自解压，他们的文件头部打包有解压缩程序</p><p>​<code>Linux</code>内核的链接文件目录在<code>arch/arm64/kernel/vmlinux.lds.S</code>，内核在编译时会根据<code>vmlinux.lds.S</code>生成<code>vmlinux.lds</code>，<code>vmlinux.lds</code>就是内核最后的链接脚本，会用于链接生成内核镜像<code>vmlinux</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//arch/arm64/kernel/vmlinux.lds.S</span><br><span class="line">/* SPDX-License-Identifier: GPL-2.0 */</span><br><span class="line">/*</span><br><span class="line"> * ld script to make ARM Linux kernel</span><br><span class="line"> * taken from the i386 version by Russell King</span><br><span class="line"> * Written by Martin Mares &lt;mj@atrey.karlin.mff.cuni.cz&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;asm-generic/vmlinux.lds.h&gt;</span><br><span class="line">#include &lt;asm/cache.h&gt;</span><br><span class="line">#include &lt;asm/kernel-pgtable.h&gt;</span><br><span class="line">#include &lt;asm/thread_info.h&gt;</span><br><span class="line">#include &lt;asm/memory.h&gt;</span><br><span class="line">#include &lt;asm/page.h&gt;</span><br><span class="line">#include &lt;asm/pgtable.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;image.h&quot;</span><br><span class="line"></span><br><span class="line">/* .exit.text needed in case of alternative patching */</span><br><span class="line">#define ARM_EXIT_KEEP(x)x</span><br><span class="line">#define ARM_EXIT_DISCARD(x)</span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_text)</span><br><span class="line"></span><br><span class="line">jiffies = jiffies_64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define HYPERVISOR_EXTABLE\</span><br><span class="line">. = ALIGN(SZ_8);\</span><br><span class="line">__start___kvm_ex_table = .;\</span><br><span class="line">*(__kvm_ex_table)\</span><br><span class="line">__stop___kvm_ex_table = .;</span><br><span class="line"></span><br><span class="line">#define HYPERVISOR_TEXT\</span><br><span class="line">/*\</span><br><span class="line"> * Align to 4 KB so that\</span><br><span class="line"> * a) the HYP vector table is at its minimum\</span><br><span class="line"> *    alignment of 2048 bytes\</span><br><span class="line"> * b) the HYP init code will not cross a page\</span><br><span class="line"> *    boundary if its size does not exceed\</span><br><span class="line"> *    4 KB (see related ASSERT() below)\</span><br><span class="line"> */\</span><br><span class="line">. = ALIGN(SZ_4K);\</span><br><span class="line">__hyp_idmap_text_start = .;\</span><br><span class="line">*(.hyp.idmap.text)\</span><br><span class="line">__hyp_idmap_text_end = .;\</span><br><span class="line">__hyp_text_start = .;\</span><br><span class="line">*(.hyp.text)\</span><br><span class="line">HYPERVISOR_EXTABLE\</span><br><span class="line">__hyp_text_end = .;</span><br><span class="line"></span><br><span class="line">#define IDMAP_TEXT\</span><br><span class="line">. = ALIGN(SZ_4K);\</span><br><span class="line">__idmap_text_start = .;\</span><br><span class="line">*(.idmap.text)\</span><br><span class="line">__idmap_text_end = .;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_HIBERNATION</span><br><span class="line">#define HIBERNATE_TEXT\</span><br><span class="line">. = ALIGN(SZ_4K);\</span><br><span class="line">__hibernate_exit_text_start = .;\</span><br><span class="line">*(.hibernate_exit.text)\</span><br><span class="line">__hibernate_exit_text_end = .;</span><br><span class="line">#else</span><br><span class="line">#define HIBERNATE_TEXT</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span><br><span class="line">#define TRAMP_TEXT\</span><br><span class="line">. = ALIGN(PAGE_SIZE);\</span><br><span class="line">__entry_tramp_text_start = .;\</span><br><span class="line">*(.entry.tramp.text)\</span><br><span class="line">. = ALIGN(PAGE_SIZE);\</span><br><span class="line">__entry_tramp_text_end = .;</span><br><span class="line">#else</span><br><span class="line">#define TRAMP_TEXT</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The size of the PE/COFF section that covers the kernel image, which</span><br><span class="line"> * runs from stext to _edata, must be a round multiple of the PE/COFF</span><br><span class="line"> * FileAlignment, which we set to its minimum value of 0x200. &#x27;stext&#x27;</span><br><span class="line"> * itself is 4 KB aligned, so padding out _edata to a 0x200 aligned</span><br><span class="line"> * boundary should be sufficient.</span><br><span class="line"> */</span><br><span class="line">PECOFF_FILE_ALIGNMENT = 0x200;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">#define PECOFF_EDATA_PADDING\</span><br><span class="line">.pecoff_edata_padding : &#123; BYTE(0); . = ALIGN(PECOFF_FILE_ALIGNMENT); &#125;</span><br><span class="line">#else</span><br><span class="line">#define PECOFF_EDATA_PADDING</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line"> * XXX: The linker does not define how output sections are</span><br><span class="line"> * assigned to input sections when there are multiple statements</span><br><span class="line"> * matching the same input section name.  There is no documented</span><br><span class="line"> * order of matching.</span><br><span class="line"> */</span><br><span class="line">/DISCARD/ : &#123;</span><br><span class="line">ARM_EXIT_DISCARD(EXIT_TEXT)</span><br><span class="line">ARM_EXIT_DISCARD(EXIT_DATA)</span><br><span class="line">EXIT_CALL</span><br><span class="line">*(.discard)</span><br><span class="line">*(.discard.*)</span><br><span class="line">*(.interp .dynamic)</span><br><span class="line">*(.dynsym .dynstr .hash .gnu.hash)</span><br><span class="line">*(.eh_frame)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = KIMAGE_VADDR + TEXT_OFFSET;</span><br><span class="line"></span><br><span class="line">.head.text : &#123;</span><br><span class="line">_text = .;</span><br><span class="line">HEAD_TEXT</span><br><span class="line">&#125;</span><br><span class="line">.text : &#123;/* Real text segment*/</span><br><span class="line">_stext = .;/* Text and read-only data*/</span><br><span class="line">__exception_text_start = .;</span><br><span class="line">*(.exception.text)</span><br><span class="line">__exception_text_end = .;</span><br><span class="line">IRQENTRY_TEXT</span><br><span class="line">SOFTIRQENTRY_TEXT</span><br><span class="line">ENTRY_TEXT</span><br><span class="line">TEXT_TEXT</span><br><span class="line">SCHED_TEXT</span><br><span class="line">CPUIDLE_TEXT</span><br><span class="line">LOCK_TEXT</span><br><span class="line">KPROBES_TEXT</span><br><span class="line">HYPERVISOR_TEXT</span><br><span class="line">IDMAP_TEXT</span><br><span class="line">HIBERNATE_TEXT</span><br><span class="line">TRAMP_TEXT</span><br><span class="line">*(.fixup)</span><br><span class="line">*(.gnu.warning)</span><br><span class="line">. = ALIGN(16);</span><br><span class="line">*(.got)/* Global offset table*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">_etext = .;/* End of text section */</span><br><span class="line"></span><br><span class="line">RO_DATA(PAGE_SIZE)/* everything from this point to     */</span><br><span class="line">EXCEPTION_TABLE(8)/* __init_begin will be marked RO NX */</span><br><span class="line">NOTES</span><br><span class="line"></span><br><span class="line">. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">__init_begin = .;</span><br><span class="line">__inittext_begin = .;</span><br><span class="line"></span><br><span class="line">INIT_TEXT_SECTION(8)</span><br><span class="line">.exit.text : &#123;</span><br><span class="line">ARM_EXIT_KEEP(EXIT_TEXT)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = ALIGN(4);</span><br><span class="line">.altinstructions : &#123;</span><br><span class="line">__alt_instructions = .;</span><br><span class="line">*(.altinstructions)</span><br><span class="line">__alt_instructions_end = .;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = ALIGN(PAGE_SIZE);</span><br><span class="line">__inittext_end = .;</span><br><span class="line">__initdata_begin = .;</span><br><span class="line"></span><br><span class="line">.init.data : &#123;</span><br><span class="line">INIT_DATA</span><br><span class="line">INIT_SETUP(16)</span><br><span class="line">INIT_CALLS</span><br><span class="line">CON_INITCALL</span><br><span class="line">SECURITY_INITCALL</span><br><span class="line">INIT_RAM_FS</span><br><span class="line">*(.init.rodata.* .init.bss)/* from the EFI stub */</span><br><span class="line">&#125;</span><br><span class="line">.exit.data : &#123;</span><br><span class="line">ARM_EXIT_KEEP(EXIT_DATA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PERCPU_SECTION(L1_CACHE_BYTES)</span><br><span class="line"></span><br><span class="line">.rela.dyn : ALIGN(8) &#123;</span><br><span class="line">*(.rela .rela*)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__rela_offset= ABSOLUTE(ADDR(.rela.dyn) - KIMAGE_VADDR);</span><br><span class="line">__rela_size= SIZEOF(.rela.dyn);</span><br><span class="line"></span><br><span class="line">. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">__initdata_end = .;</span><br><span class="line">__init_end = .;</span><br><span class="line"></span><br><span class="line">_data = .;</span><br><span class="line">_sdata = .;</span><br><span class="line">RW_DATA_SECTION(L1_CACHE_BYTES, PAGE_SIZE, THREAD_ALIGN)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Data written with the MMU off but read with the MMU on requires</span><br><span class="line"> * cache lines to be invalidated, discarding up to a Cache Writeback</span><br><span class="line"> * Granule (CWG) of data from the cache. Keep the section that</span><br><span class="line"> * requires this type of maintenance to be in its own Cache Writeback</span><br><span class="line"> * Granule (CWG) area so the cache maintenance operations don&#x27;t</span><br><span class="line"> * interfere with adjacent data.</span><br><span class="line"> */</span><br><span class="line">.mmuoff.data.write : ALIGN(SZ_2K) &#123;</span><br><span class="line">__mmuoff_data_start = .;</span><br><span class="line">*(.mmuoff.data.write)</span><br><span class="line">&#125;</span><br><span class="line">. = ALIGN(SZ_2K);</span><br><span class="line">.mmuoff.data.read : &#123;</span><br><span class="line">*(.mmuoff.data.read)</span><br><span class="line">__mmuoff_data_end = .;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PECOFF_EDATA_PADDING</span><br><span class="line">__pecoff_data_rawsize = ABSOLUTE(. - __initdata_begin);</span><br><span class="line">_edata = .;</span><br><span class="line"></span><br><span class="line">BSS_SECTION(0, 0, 0)</span><br><span class="line"></span><br><span class="line">. = ALIGN(PAGE_SIZE);</span><br><span class="line">idmap_pg_dir = .;</span><br><span class="line">. += IDMAP_DIR_SIZE;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span><br><span class="line">tramp_pg_dir = .;</span><br><span class="line">. += PAGE_SIZE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_SW_TTBR0_PAN</span><br><span class="line">reserved_ttbr0 = .;</span><br><span class="line">. += RESERVED_TTBR0_SIZE;</span><br><span class="line">#endif</span><br><span class="line">swapper_pg_dir = .;</span><br><span class="line">. += SWAPPER_DIR_SIZE;</span><br><span class="line">swapper_pg_end = .;</span><br><span class="line"></span><br><span class="line">__pecoff_data_size = ABSOLUTE(. - __initdata_begin);</span><br><span class="line">_end = .;</span><br><span class="line"></span><br><span class="line">STABS_DEBUG</span><br><span class="line"></span><br><span class="line">HEAD_SYMBOLS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The HYP init code and ID map text can&#x27;t be longer than a page each,</span><br><span class="line"> * and should not cross a page boundary.</span><br><span class="line"> */</span><br><span class="line">ASSERT(__hyp_idmap_text_end - (__hyp_idmap_text_start &amp; ~(SZ_4K - 1)) &lt;= SZ_4K,</span><br><span class="line">&quot;HYP init code too big or misaligned&quot;)</span><br><span class="line">ASSERT(__idmap_text_end - (__idmap_text_start &amp; ~(SZ_4K - 1)) &lt;= SZ_4K,</span><br><span class="line">&quot;ID map text too big or misaligned&quot;)</span><br><span class="line">#ifdef CONFIG_HIBERNATION</span><br><span class="line">ASSERT(__hibernate_exit_text_end - (__hibernate_exit_text_start &amp; ~(SZ_4K - 1))</span><br><span class="line">&lt;= SZ_4K, &quot;Hibernate exit text too big or misaligned&quot;)</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span><br><span class="line">ASSERT((__entry_tramp_text_end - __entry_tramp_text_start) == PAGE_SIZE,</span><br><span class="line">&quot;Entry trampoline text too big&quot;)</span><br><span class="line">#endif</span><br><span class="line">/*</span><br><span class="line"> * If padding is applied before .head.text, virt&lt;-&gt;phys conversions will fail.</span><br><span class="line"> */</span><br><span class="line">ASSERT(_text == (KIMAGE_VADDR + TEXT_OFFSET), &quot;HEAD is misaligned&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>在此文件的开头指定了输出的架构以及内核入口地址为<code>_text</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_text)</span><br></pre></td></tr></table></figure></li><li><p><code>_text</code>是代码段的起始地址，定义在下面的<code>SECTIONS</code>部分，可以看见<code>_text</code>即为<code>.head_text</code>段，地址为：</p><p><code>KIMAGE_VADDR + TEXT_OFFSET</code>，这两个宏定义在<code>arch/arm64/include/asm/memory.h</code>中</p><p><img src="/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20240607140937077.png" alt="image-20240607140937077"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">. = KIMAGE_VADDR + TEXT_OFFSET;</span><br><span class="line"></span><br><span class="line">.head.text : &#123;</span><br><span class="line">_text = .;</span><br><span class="line">HEAD_TEXT</span><br><span class="line">&#125;</span><br><span class="line">.text : &#123;/* Real text segment*/</span><br><span class="line">_stext = .;/* Text and read-only data*/</span><br><span class="line">__exception_text_start = .;</span><br><span class="line">*(.exception.text)</span><br><span class="line">__exception_text_end = .;</span><br><span class="line">IRQENTRY_TEXT</span><br><span class="line">SOFTIRQENTRY_TEXT</span><br><span class="line">ENTRY_TEXT</span><br><span class="line">TEXT_TEXT</span><br><span class="line">SCHED_TEXT</span><br><span class="line">CPUIDLE_TEXT</span><br><span class="line">LOCK_TEXT</span><br><span class="line">KPROBES_TEXT</span><br><span class="line">HYPERVISOR_TEXT</span><br><span class="line">IDMAP_TEXT</span><br><span class="line">HIBERNATE_TEXT</span><br><span class="line">TRAMP_TEXT</span><br><span class="line">*(.fixup)</span><br><span class="line">*(.gnu.warning)</span><br><span class="line">. = ALIGN(16);</span><br><span class="line">*(.got)/* Global offset table*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-内核启动第一阶段"><a href="#2-内核启动第一阶段" class="headerlink" title="2. 内核启动第一阶段"></a>2. 内核启动第一阶段</h2><h3 id="2-1-内核启动入口点"><a href="#2-1-内核启动入口点" class="headerlink" title="2.1 内核启动入口点"></a>2.1 内核启动入口点</h3><p>我手上有一块迅为的RK3588的板子，我们来将编译好的<code>vmlinux</code>的<code>elf</code>文件读一下看一下入口地址是多少：</p><p><img src="/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20240607141148612.png" alt="image-20240607141148612"></p><p>使用迅为提供的编译器将其反汇编，在得到的汇编文件<code>vmlinux.s</code>中查找入口地址：<code>0xffffffc008000000</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmlinux:     file format elf64-littleaarch64</span><br><span class="line">vmlinux</span><br><span class="line">architecture: aarch64, flags 0x00000150:</span><br><span class="line">HAS_SYMS, DYNAMIC, D_PAGED</span><br><span class="line">start address 0xffffffc008000000</span><br><span class="line"></span><br><span class="line">Disassembly of section .head.text:</span><br><span class="line"></span><br><span class="line">ffffffc008000000 &lt;_text&gt;:</span><br><span class="line">ffffffc008000000:91005a4d addx13, x18, #0x16</span><br><span class="line">ffffffc008000004:146c7fff bffffffc009b20000 &lt;primary_entry&gt;</span><br></pre></td></tr></table></figure><p>由上面的反汇编文件可知，<code>Linux</code>内核的第一条指令是<code>add x13, x18, #0x16</code>，对应的符号是<code>.head.text</code>，在<code>include/linux/init.h</code>中有如下定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* For assembly routines */</span><br><span class="line">#define __HEAD.section&quot;.head.text&quot;,&quot;ax&quot;</span><br><span class="line">#define __INIT.section&quot;.init.text&quot;,&quot;ax&quot;</span><br></pre></td></tr></table></figure><p>即<code>__HEAD</code>这个宏代表的就是<code>.head.text</code>这个段，所以去寻找<code>__HEAD</code>这个宏看哪里使用了，在<code>arch/arm64/kernel/head.S</code>中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Kernel startup entry point.</span><br><span class="line"> * ---------------------------</span><br><span class="line"> *</span><br><span class="line"> * The requirements are:</span><br><span class="line"> *   MMU = off, D-cache = off, I-cache = on or off,</span><br><span class="line"> *   x0 = physical address to the FDT blob.</span><br><span class="line"> *</span><br><span class="line"> * This code is mostly position independent so you call this at</span><br><span class="line"> * __pa(PAGE_OFFSET).</span><br><span class="line"> *</span><br><span class="line"> * Note that the callee-saved registers are used for storing variables</span><br><span class="line"> * that are useful before the MMU is enabled. The allocations are described</span><br><span class="line"> * in the entry routines.</span><br><span class="line"> */</span><br><span class="line">__HEAD</span><br><span class="line">_head:</span><br><span class="line">/*</span><br><span class="line"> * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span><br><span class="line"> */</span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">/*</span><br><span class="line"> * This add instruction has no meaningful effect except that</span><br><span class="line"> * its opcode forms the magic &quot;MZ&quot; signature required by UEFI.</span><br><span class="line"> */</span><br><span class="line">addx13, x18, #0x16</span><br><span class="line">bprimary_entry</span><br><span class="line">#else</span><br><span class="line">bprimary_entry// branch to kernel start, magic</span><br><span class="line">.long0// reserved</span><br><span class="line">#endif</span><br><span class="line">.quad0// Image load offset from start of RAM, little-endian</span><br><span class="line">le64sym_kernel_size_le// Effective size of kernel image, little-endian</span><br><span class="line">le64sym_kernel_flags_le// Informative flags, little-endian</span><br><span class="line">.quad0// reserved</span><br><span class="line">.quad0// reserved</span><br><span class="line">.quad0// reserved</span><br><span class="line">.asciiARM64_IMAGE_MAGIC// Magic number</span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">.longpe_header - _head// Offset to the PE header.</span><br><span class="line"></span><br><span class="line">pe_header:</span><br><span class="line">__EFI_PE_HEADER</span><br><span class="line">#else</span><br><span class="line">.long0// reserved</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这里就是内核的启动点，在上面的注释中说了<code>linux</code>内核启动之前需要关闭<code>MMU</code>以及<code>D-cache</code>，<code>I-cache</code>可以开启或者关闭，同时<code>x0</code>为<code>FDT blob</code>的物理地址</p><ul><li><code>D-cache</code>是数据缓存</li><li><code>I-cache</code>是指令缓存</li><li><code>FDT </code>是<code>uboot</code>使用的扁平设备树，flatted device tree，</li></ul><blockquote><p>数据缓存有可能缓存了bootloader的数据，如果不清除，可能导致内核访问错误的数据。而bootloader的指令与内核指令无关，所以可以不关闭指令缓存。</p></blockquote><p>&#96;&#96;add x13, x18, #0x16<code> 用于形成 &quot;MZ&quot; 签名。主要是为了满足 UEFI 固件对映像文件格式的要求，而不是为了执行任何有意义的计算。其作用是确保生成的机器码包含必要的 &quot;MZ&quot; 签名，使得内核映像可以被 UEFI 识别和启动。相当于一个魔数。然后执行</code>bprimary_entry<code>跳转到</code>primary_entry&#96;函数执行：</p><h3 id="2-2-primary-entry函数"><a href="#2-2-primary-entry函数" class="headerlink" title="2.2 primary_entry函数"></a>2.2 primary_entry函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__INIT</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The following callee saved general purpose registers are used on the</span><br><span class="line"> * primary lowlevel boot path:</span><br><span class="line"> *</span><br><span class="line"> *  Register   Scope                      Purpose</span><br><span class="line"> *  x21        primary_entry() .. start_kernel()        FDT pointer passed at boot in x0</span><br><span class="line"> *  x23        primary_entry() .. start_kernel()        physical misalignment/KASLR offset</span><br><span class="line"> *  x28        __create_page_tables()                   callee preserved temp register</span><br><span class="line"> *  x19/x20    __primary_switch()                       callee preserved temp registers</span><br><span class="line"> *  x24        __primary_switch() .. relocate_kernel()  current RELR displacement</span><br><span class="line"> */</span><br><span class="line">SYM_CODE_START(primary_entry)</span><br><span class="line">blpreserve_boot_args</span><br><span class="line">blinit_kernel_el// w0=cpu_boot_mode</span><br><span class="line">adrpx23, __PHYS_OFFSET</span><br><span class="line">andx23, x23, MIN_KIMG_ALIGN - 1// KASLR offset, defaults to 0</span><br><span class="line">blset_cpu_boot_mode_flag</span><br><span class="line">bl__create_page_tables</span><br><span class="line">/*</span><br><span class="line"> * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span><br><span class="line"> * details.</span><br><span class="line"> * On return, the CPU will be ready for the MMU to be turned on and</span><br><span class="line"> * the TCR will have been set.</span><br><span class="line"> */</span><br><span class="line">bl__cpu_setup// initialise processor</span><br><span class="line">b__primary_switch</span><br><span class="line">SYM_CODE_END(primary_entry)</span><br></pre></td></tr></table></figure><h4 id="2-2-1-preserve-boot-args"><a href="#2-2-1-preserve-boot-args" class="headerlink" title="2.2.1 preserve_boot_args"></a>2.2.1 preserve_boot_args</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Preserve the arguments passed by the bootloader in x0 .. x3</span><br><span class="line"> */</span><br><span class="line">SYM_CODE_START_LOCAL(preserve_boot_args)</span><br><span class="line">movx21, x0// x21=FDT，// 将dtb的地址暂存在x21寄存器，释放出x0使用</span><br><span class="line"></span><br><span class="line">adr_lx0, boot_args// 将boot_args数组的地址保存到x0中</span><br><span class="line">stpx21, x1, [x0]// 保存x21、x1的值到boot_args[0]、boot_args[1]</span><br><span class="line">stpx2, x3, [x0, #16]       // 将x2、x3的值保存到boot_args[2]、boot_args[3</span><br><span class="line"></span><br><span class="line">dmbsy// needed before dc ivac with 内存屏障</span><br><span class="line">// MMU off</span><br><span class="line"></span><br><span class="line">movx1, #0x20// 4 x 8 bytes  x1 = 32</span><br><span class="line">b__inval_dcache_area// tail call 无效化数据缓存区域</span><br><span class="line">SYM_CODE_END(preserve_boot_args)</span><br></pre></td></tr></table></figure><ul><li><p><code>boot_args</code>定义在<code>arch/arm64/setup.c</code>中，用于保存内核启动时的参数，是一个数组</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The recorded values of x0 .. x3 upon kernel entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u64 __cacheline_aligned boot_args[<span class="number">4</span>];</span><br></pre></td></tr></table></figure></li><li><p><code>stp</code> 是一个存储配对指令，将两个寄存器的值存储到连续的内存位置。</p></li></ul><h4 id="2-2-2-init-kernel-el"><a href="#2-2-2-init-kernel-el" class="headerlink" title="2.2.2 init_kernel_el"></a>2.2.2 init_kernel_el</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Starting from EL2 or EL1, configure the CPU to execute at the highest</span><br><span class="line"> * reachable EL supported by the kernel in a chosen default state. If dropping</span><br><span class="line"> * from EL2 to EL1, configure EL2 before configuring EL1.</span><br><span class="line"> *</span><br><span class="line"> * Since we cannot always rely on ERET synchronizing writes to sysregs (e.g. if</span><br><span class="line"> * SCTLR_ELx.EOS is clear), we place an ISB prior to ERET.</span><br><span class="line"> *</span><br><span class="line"> * Returns either BOOT_CPU_MODE_EL1 or BOOT_CPU_MODE_EL2 in w0 if</span><br><span class="line"> * booted in EL1 or EL2 respectively.</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START(init_kernel_el)</span><br><span class="line">mov_qx0, INIT_SCTLR_EL1_MMU_OFF  #将 INIT_SCTLR_EL1_MMU_OFF 常量加载到寄存器 x0 中</span><br><span class="line">msrsctlr_el1, x0    #将寄存器 x0 的值写入 sctlr_el1 寄存器，配置 EL1 的系统控制寄存器。</span><br><span class="line"></span><br><span class="line">mrsx0, CurrentEL    # 读取当前的异常级别（EL）到寄存器 x0 中。</span><br><span class="line">cmpx0, #CurrentEL_EL2  #比较当前 EL 是否为 EL2。</span><br><span class="line">b.eqinit_el2      #如果当前EL是EL2，则跳转到 init_el2 标签。</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(init_el1, SYM_L_LOCAL)</span><br><span class="line">isb</span><br><span class="line">mov_qx0, INIT_PSTATE_EL1 #将INIT_PSTATE_EL1常量加载到寄存器x0中，这个常量用于初始化 PSTATE 寄存器。</span><br><span class="line">msrspsr_el1, x0#将寄存器x0的值写入spsr_el1寄存器，配置EL1的Saved Program Status Register。</span><br><span class="line">msrelr_el1, lr #将链接寄存器（lr）的值写入 elr_el1 寄存器，配置 EL1 的 Exception Link Register。</span><br><span class="line">movw0, #BOOT_CPU_MODE_EL1 #将 BOOT_CPU_MODE_EL1 常量加载到寄存器 w0 中，表示当前的 CPU 模式为 EL1。</span><br><span class="line">eret</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(init_el2, SYM_L_LOCAL)</span><br><span class="line">mov_qx0, HCR_HOST_NVHE_FLAGS #将 HCR_HOST_NVHE_FLAGS 常量加载到寄存器 x0 中，用于配置 EL2 的 Hypervisor Configuration Register。</span><br><span class="line">msrhcr_el2, x0 #将寄存器 x0 的值写入 hcr_el2 寄存器。</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">init_el2_state</span><br><span class="line"></span><br><span class="line">/* Hypervisor stub */</span><br><span class="line">adr_lx0, __hyp_stub_vectors #使用 adr_l 宏将 __hyp_stub_vectors 的地址加载到寄存器 x0 中。__hyp_stub_vectors 是 EL2 的异常向量表地址。</span><br><span class="line">msrvbar_el2, x0 #将寄存器 x0 的值写入 vbar_el2 寄存器，设置 EL2 的向量基址寄存器。</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">msrelr_el2, lr #将链接寄存器（lr）的值写入 elr_el2 寄存器，配置 EL2 的 Exception Link Register。</span><br><span class="line">movw0, #BOOT_CPU_MODE_EL2  #将 BOOT_CPU_MODE_EL2 常量加载到寄存器 w0 中，表示当前的 CPU 模式为 EL2。</span><br><span class="line">eret</span><br><span class="line">SYM_FUNC_END(init_kernel_el)</span><br><span class="line"></span><br><span class="line">//arch/arm64/include/asm/virt.h</span><br><span class="line">#define BOOT_CPU_MODE_EL1(0xe11)</span><br><span class="line">#define BOOT_CPU_MODE_EL2(0xe12)</span><br></pre></td></tr></table></figure><p>这段代码实现了在不同异常级别（EL2 或 EL1）下对处理器进行初始化，并根据当前的启动级别设置相应的寄存器和状态，以便内核能够正确执行。主要步骤包括：</p><ol><li><strong>配置 EL1 的系统控制寄存器</strong>。</li><li><strong>检查当前异常级别</strong>。</li><li><strong>如果是 EL1</strong><ul><li>配置 PSTATE 和异常链接寄存器。</li><li>切换到 EL1 并继续执行。</li></ul></li><li><strong>如果是 EL2</strong><ul><li>配置 Hypervisor Configuration Register。</li><li>进一步初始化 EL2 状态。</li><li>设置异常向量基址。</li><li>切换到 EL2 并继续执行</li></ul></li></ol><h4 id="2-2-3-set-cpu-boot-mode-flag"><a href="#2-2-3-set-cpu-boot-mode-flag" class="headerlink" title="2.2.3 set_cpu_boot_mode_flag"></a>2.2.3 set_cpu_boot_mode_flag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Sets the __boot_cpu_mode flag depending on the CPU boot mode passed</span><br><span class="line"> * in w0. See arch/arm64/include/asm/virt.h for more info.</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(set_cpu_boot_mode_flag)</span><br><span class="line">adr_lx1, __boot_cpu_mode #将 __boot_cpu_mode 的地址加载到寄存器 x1 中</span><br><span class="line">cmpw0, #BOOT_CPU_MODE_EL2  #如果为不为EL2则跳转到标签1处</span><br><span class="line">b.ne1f</span><br><span class="line">addx1, x1, #4  #如果 w0 中的值等于 BOOT_CPU_MODE_EL2，则将 x1（即 __boot_cpu_mode 的地址）加上 4，以指向下一个 4 字节对齐的位置。</span><br><span class="line">1:strw0, [x1]// 将寄存器 w0 的值存储到内存地址 x1 指向的位置</span><br><span class="line">dmbsy</span><br><span class="line">dcivac, x1// Invalidate potentially stale cache line</span><br><span class="line">ret</span><br><span class="line">SYM_FUNC_END(set_cpu_boot_mode_flag)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * We need to find out the CPU boot mode long after boot, so we need to</span><br><span class="line"> * store it in a writable variable.</span><br><span class="line"> *</span><br><span class="line"> * This is not in .bss, because we set it sufficiently early that the boot-time</span><br><span class="line"> * zeroing of .bss would clobber it.</span><br><span class="line"> */</span><br><span class="line">SYM_DATA_START(__boot_cpu_mode)</span><br><span class="line">.longBOOT_CPU_MODE_EL2</span><br><span class="line">.longBOOT_CPU_MODE_EL1</span><br><span class="line">SYM_DATA_END(__boot_cpu_mode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//arch/arm64/include/asm/virt.h</span><br><span class="line">#define BOOT_CPU_MODE_EL1(0xe11)</span><br><span class="line">#define BOOT_CPU_MODE_EL2(0xe12)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>w0</code>寄存器保存了cpu的启动模式</li><li><code>__boot_cpu_mode</code>是一个<code>int64</code>的全局变量保存cpu的启动模式，前面四个字节的值为<code>0xe11</code>，后面四个字节的值为<code>0xe12</code></li></ul><h4 id="2-2-4-create-page-tables"><a href="#2-2-4-create-page-tables" class="headerlink" title="2.2.4 __create_page_tables"></a>2.2.4 __create_page_tables</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Setup the initial page tables. We only setup the barest amount which is</span><br><span class="line"> * required to get the kernel running. The following sections are required:</span><br><span class="line"> *   - identity mapping to enable the MMU (low address, TTBR0)</span><br><span class="line"> *   - first few MB of the kernel linear mapping to jump to once the MMU has</span><br><span class="line"> *     been enabled</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(__create_page_tables)</span><br><span class="line">movx28, lr</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Invalidate the init page tables to avoid potential dirty cache lines</span><br><span class="line"> * being evicted. Other page tables are allocated in rodata as part of</span><br><span class="line"> * the kernel image, and thus are clean to the PoC per the boot</span><br><span class="line"> * protocol.</span><br><span class="line"> */</span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">adrpx1, init_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Clear the init page tables.</span><br><span class="line"> */</span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">adrpx1, init_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">1:stpxzr, xzr, [x0], #16</span><br><span class="line">stpxzr, xzr, [x0], #16</span><br><span class="line">stpxzr, xzr, [x0], #16</span><br><span class="line">stpxzr, xzr, [x0], #16</span><br><span class="line">subsx1, x1, #64</span><br><span class="line">b.ne1b</span><br><span class="line"></span><br><span class="line">movx7, SWAPPER_MM_MMUFLAGS</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Create the identity mapping.</span><br><span class="line"> */</span><br><span class="line">adrpx0, idmap_pg_dir</span><br><span class="line">adrpx3, __idmap_text_start// __pa(__idmap_text_start)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_VA_BITS_52</span><br><span class="line">mrs_sx6, SYS_ID_AA64MMFR2_EL1</span><br><span class="line">andx6, x6, #(0xf &lt;&lt; ID_AA64MMFR2_LVA_SHIFT)</span><br><span class="line">movx5, #52</span><br><span class="line">cbnzx6, 1f</span><br><span class="line">#endif</span><br><span class="line">movx5, #VA_BITS_MIN</span><br><span class="line">1:</span><br><span class="line">adr_lx6, vabits_actual</span><br><span class="line">strx5, [x6]</span><br><span class="line">dmbsy</span><br><span class="line">dcivac, x6// Invalidate potentially stale cache line</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * VA_BITS may be too small to allow for an ID mapping to be created</span><br><span class="line"> * that covers system RAM if that is located sufficiently high in the</span><br><span class="line"> * physical address space. So for the ID map, use an extended virtual</span><br><span class="line"> * range in that case, and configure an additional translation level</span><br><span class="line"> * if needed.</span><br><span class="line"> *</span><br><span class="line"> * Calculate the maximum allowed value for TCR_EL1.T0SZ so that the</span><br><span class="line"> * entire ID map region can be mapped. As T0SZ == (64 - #bits used),</span><br><span class="line"> * this number conveniently equals the number of leading zeroes in</span><br><span class="line"> * the physical address of __idmap_text_end.</span><br><span class="line"> */</span><br><span class="line">adrpx5, __idmap_text_end</span><br><span class="line">clzx5, x5</span><br><span class="line">cmpx5, TCR_T0SZ(VA_BITS_MIN) // default T0SZ small enough?</span><br><span class="line">b.ge1f// .. then skip VA range extension</span><br><span class="line"></span><br><span class="line">adr_lx6, idmap_t0sz</span><br><span class="line">strx5, [x6]</span><br><span class="line">dmbsy</span><br><span class="line">dcivac, x6// Invalidate potentially stale cache line</span><br><span class="line"></span><br><span class="line">#if (VA_BITS &lt; 48)</span><br><span class="line">#define EXTRA_SHIFT(PGDIR_SHIFT + PAGE_SHIFT - 3)</span><br><span class="line">#define EXTRA_PTRS(1 &lt;&lt; (PHYS_MASK_SHIFT - EXTRA_SHIFT))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * If VA_BITS &lt; 48, we have to configure an additional table level.</span><br><span class="line"> * First, we have to verify our assumption that the current value of</span><br><span class="line"> * VA_BITS was chosen such that all translation levels are fully</span><br><span class="line"> * utilised, and that lowering T0SZ will always result in an additional</span><br><span class="line"> * translation level to be configured.</span><br><span class="line"> */</span><br><span class="line">#if VA_BITS != EXTRA_SHIFT</span><br><span class="line">#error &quot;Mismatch between VA_BITS and page size/number of translation levels&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">movx4, EXTRA_PTRS</span><br><span class="line">create_table_entry x0, x3, EXTRA_SHIFT, x4, x5, x6</span><br><span class="line">#else</span><br><span class="line">/*</span><br><span class="line"> * If VA_BITS == 48, we don&#x27;t have to configure an additional</span><br><span class="line"> * translation level, but the top-level table has more entries.</span><br><span class="line"> */</span><br><span class="line">movx4, #1 &lt;&lt; (PHYS_MASK_SHIFT - PGDIR_SHIFT)</span><br><span class="line">str_lx4, idmap_ptrs_per_pgd, x5</span><br><span class="line">#endif</span><br><span class="line">1:</span><br><span class="line">ldr_lx4, idmap_ptrs_per_pgd</span><br><span class="line">movx5, x3// __pa(__idmap_text_start)</span><br><span class="line">adr_lx6, __idmap_text_end// __pa(__idmap_text_end)</span><br><span class="line"></span><br><span class="line">map_memory x0, x1, x3, x6, x7, x3, x4, x10, x11, x12, x13, x14</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Map the kernel image (starting with PHYS_OFFSET).</span><br><span class="line"> */</span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">mov_qx5, KIMAGE_VADDR// compile time __va(_text)</span><br><span class="line">addx5, x5, x23// add KASLR displacement</span><br><span class="line">movx4, PTRS_PER_PGD</span><br><span class="line">adrpx6, _end// runtime __pa(_end)</span><br><span class="line">adrpx3, _text// runtime __pa(_text)</span><br><span class="line">subx6, x6, x3// _end - _text</span><br><span class="line">addx6, x6, x5// runtime __va(_end)</span><br><span class="line"></span><br><span class="line">map_memory x0, x1, x5, x6, x7, x3, x4, x10, x11, x12, x13, x14</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Since the page tables have been populated with non-cacheable</span><br><span class="line"> * accesses (MMU disabled), invalidate those tables again to</span><br><span class="line"> * remove any speculatively loaded cache lines.</span><br><span class="line"> */</span><br><span class="line">dmbsy</span><br><span class="line"></span><br><span class="line">adrpx0, idmap_pg_dir</span><br><span class="line">adrpx1, idmap_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">adrpx1, init_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line">retx28</span><br><span class="line">SYM_FUNC_END(__create_page_tables)</span><br></pre></td></tr></table></figure><p>页表的映射比较复杂，后面再分析，主要是的功能时缓存无效化、页表清空、虚拟地址配置，然后把内核进行了映射。</p><h4 id="2-2-5-cpu-setup"><a href="#2-2-5-cpu-setup" class="headerlink" title="2.2.5 __cpu_setup"></a>2.2.5 __cpu_setup</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//arch/arm64/mm/proc.S</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *__cpu_setup</span><br><span class="line"> *</span><br><span class="line"> *Initialise the processor for turning the MMU on.</span><br><span class="line"> *</span><br><span class="line"> * Output:</span><br><span class="line"> *Return in x0 the value of the SCTLR_EL1 register.</span><br><span class="line"> */</span><br><span class="line">.pushsection &quot;.idmap.text&quot;, &quot;awx&quot;</span><br><span class="line">SYM_FUNC_START(__cpu_setup)</span><br><span class="line">tlbivmalle1// 通过 tlbi 指令无效化本地 TLB,刷新tlb，用于后续映射</span><br><span class="line">dsbnsh</span><br><span class="line"></span><br><span class="line">movx1, #3 &lt;&lt; 20</span><br><span class="line">msrcpacr_el1, x1// Enable FP/ASIMD</span><br><span class="line">movx1, #1 &lt;&lt; 12// Reset mdscr_el1 and disable</span><br><span class="line">msrmdscr_el1, x1// access to the DCC from EL0</span><br><span class="line">isb// Unmask debug exceptions now,</span><br><span class="line">enable_dbg// since this is per-cpu</span><br><span class="line">reset_pmuserenr_el0 x1// Disable PMU access from EL0</span><br><span class="line">reset_amuserenr_el0 x1// Disable AMU access from EL0</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Memory region attributes</span><br><span class="line"> */</span><br><span class="line">mov_qx5, MAIR_EL1_SET #内存属性配置值写入 MAIR_EL1 寄存器，设置内存区域的属性</span><br><span class="line">msrmair_el1, x5</span><br><span class="line">/*</span><br><span class="line"> * Set/prepare TCR and TTBR. TCR_EL1.T1SZ gets further</span><br><span class="line"> * adjusted if the kernel is compiled with 52bit VA support.</span><br><span class="line"> */</span><br><span class="line">mov_qx10, TCR_TxSZ(VA_BITS) | TCR_CACHE_FLAGS | TCR_SMP_FLAGS | \</span><br><span class="line">TCR_TG_FLAGS | TCR_KASLR_FLAGS | TCR_ASID16 | \</span><br><span class="line">TCR_TBI0 | TCR_A1 | TCR_KASAN_SW_FLAGS | TCR_MTE_FLAGS</span><br><span class="line"></span><br><span class="line">tcr_clear_errata_bits x10, x9, x5</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_VA_BITS_52</span><br><span class="line">ldr_lx9, vabits_actual</span><br><span class="line">subx9, xzr, x9</span><br><span class="line">addx9, x9, #64</span><br><span class="line">tcr_set_t1szx10, x9</span><br><span class="line">#else</span><br><span class="line">ldr_lx9, idmap_t0sz</span><br><span class="line">#endif</span><br><span class="line">tcr_set_t0szx10, x9</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set the IPS bits in TCR_EL1.</span><br><span class="line"> */</span><br><span class="line">tcr_compute_pa_size x10, #TCR_IPS_SHIFT, x5, x6</span><br><span class="line">#ifdef CONFIG_ARM64_HW_AFDBM</span><br><span class="line">/*</span><br><span class="line"> * Enable hardware update of the Access Flags bit.</span><br><span class="line"> * Hardware dirty bit management is enabled later,</span><br><span class="line"> * via capabilities.</span><br><span class="line"> */</span><br><span class="line">mrsx9, ID_AA64MMFR1_EL1</span><br><span class="line">andx9, x9, #0xf</span><br><span class="line">cbzx9, 1f</span><br><span class="line">orrx10, x10, #TCR_HA// hardware Access flag update</span><br><span class="line">1:</span><br><span class="line">#endif/* CONFIG_ARM64_HW_AFDBM */</span><br><span class="line">msrtcr_el1, x10</span><br><span class="line">/*</span><br><span class="line"> * Prepare SCTLR</span><br><span class="line"> */</span><br><span class="line">mov_qx0, INIT_SCTLR_EL1_MMU_ON</span><br><span class="line">ret// return to head.S</span><br><span class="line">SYM_FUNC_END(__cpu_setup)</span><br></pre></td></tr></table></figure><p><code>__cpu_setup</code>定义在<code>arch/arm64/mm/proc.S</code>中，这段代码通过一系列步骤初始化处理器，以便安全地开启内存管理单元（MMU）。主要步骤包括：</p><ol><li>无效化本地 TLB</li><li>启用浮点和 SIMD 单元</li><li>设置调试寄存器</li><li>配置内存属性寄存器</li><li>配置翻译控制寄存器和基址寄存器</li><li>设置物理地址大小和硬件访问标志</li><li>准备系统控制寄存器并返回</li></ol><p>这些步骤确保处理器在启用 MMU 时能正确处理内存访问和管理</p><h4 id="2-2-6-primary-switch"><a href="#2-2-6-primary-switch" class="headerlink" title="2.2.6 __primary_switch"></a>2.2.6 __primary_switch</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SYM_FUNC_START_LOCAL(__primary_switch)</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">movx19, x0// preserve new SCTLR_EL1 value</span><br><span class="line">mrsx20, sctlr_el1// preserve old SCTLR_EL1 value</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">adrpx1, init_pg_dir</span><br><span class="line">bl__enable_mmu</span><br><span class="line">#ifdef CONFIG_RELOCATABLE</span><br><span class="line">#ifdef CONFIG_RELR</span><br><span class="line">movx24, #0// no RELR displacement yet</span><br><span class="line">#endif</span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">blrx8</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * If we return here, we have a KASLR displacement in x23 which we need</span><br><span class="line"> * to take into account by discarding the current kernel mapping and</span><br><span class="line"> * creating a new one.</span><br><span class="line"> */</span><br><span class="line">pre_disable_mmu_workaround</span><br><span class="line">msrsctlr_el1, x20// disable the MMU</span><br><span class="line">isb</span><br><span class="line">bl__create_page_tables// recreate kernel mapping</span><br><span class="line"></span><br><span class="line">tlbivmalle1// Remove any stale TLB entries</span><br><span class="line">dsbnsh</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">set_sctlr_el1x19// re-enable the MMU</span><br><span class="line"></span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">brx8</span><br><span class="line">SYM_FUNC_END(__primary_switch)</span><br></pre></td></tr></table></figure><p>这段代码主要是用于内核映射的重定位，如果内核地址需要重定位则需要查询页表进行重新映射，然后在最后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">brx8</span><br></pre></td></tr></table></figure><p>跳转到<code>__primary_switched</code>函数继续执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following fragment of code is executed with the MMU enabled.</span><br><span class="line"> *</span><br><span class="line"> *   x0 = __PHYS_OFFSET</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(__primary_switched)</span><br><span class="line">adrpx4, init_thread_union</span><br><span class="line">addsp, x4, #THREAD_SIZE</span><br><span class="line">adr_lx5, init_task</span><br><span class="line">msrsp_el0, x5// Save thread_info</span><br><span class="line"></span><br><span class="line">adr_lx8, vectors// load VBAR_EL1 with virtual</span><br><span class="line">msrvbar_el1, x8// vector table address</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">stpxzr, x30, [sp, #-16]!</span><br><span class="line">movx29, sp</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SHADOW_CALL_STACK</span><br><span class="line">adr_lscs_sp, init_shadow_call_stack// Set shadow call stack</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">str_lx21, __fdt_pointer, x5// Save FDT pointer</span><br><span class="line"></span><br><span class="line">ldr_lx4, kimage_vaddr// Save the offset between</span><br><span class="line">subx4, x4, x0// the kernel virtual and</span><br><span class="line">str_lx4, kimage_voffset, x5// physical mappings</span><br><span class="line"></span><br><span class="line">// Clear BSS</span><br><span class="line">adr_lx0, __bss_start</span><br><span class="line">movx1, xzr</span><br><span class="line">adr_lx2, __bss_stop</span><br><span class="line">subx2, x2, x0</span><br><span class="line">bl__pi_memset</span><br><span class="line">dsbishst// Make zero page visible to PTW</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)</span><br><span class="line">blkasan_early_init</span><br><span class="line">#endif</span><br><span class="line">movx0, x21// pass FDT address in x0</span><br><span class="line">blearly_fdt_map// Try mapping the FDT early</span><br><span class="line">blinit_feature_override// Parse cpu feature overrides</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">tstx23, ~(MIN_KIMG_ALIGN - 1)// already running randomized?</span><br><span class="line">b.ne0f</span><br><span class="line">blkaslr_early_init// parse FDT for KASLR options</span><br><span class="line">cbzx0, 0f// KASLR disabled? just proceed</span><br><span class="line">orrx23, x23, x0// record KASLR offset</span><br><span class="line">ldpx29, x30, [sp], #16// we must enable KASLR, return</span><br><span class="line">ret// to __primary_switch()</span><br><span class="line">0:</span><br><span class="line">#endif</span><br><span class="line">blswitch_to_vhe// Prefer VHE if possible</span><br><span class="line">addsp, sp, #16</span><br><span class="line">movx29, #0</span><br><span class="line">movx30, #0</span><br><span class="line">bstart_kernel</span><br><span class="line">SYM_FUNC_END(__primary_switched)</span><br></pre></td></tr></table></figure><p>此函数在启用 MMU 后执行，负责初始化各种系统寄存器和数据结构，清空 BSS 段，处理设备树和特性覆盖，并根据需要处理内核地址空间布局随机化（KASLR）。最后，它跳转到 <code>start_kernel</code> 函数，开始内核的主要启动过程。</p><h2 id="3-内核启动第二阶段"><a href="#3-内核启动第二阶段" class="headerlink" title="3. 内核启动第二阶段"></a>3. 内核启动第二阶段</h2><p>Linux内核启动的第二阶段也就是常说的C语言阶段，从start_kernel()函数开始；start_kernel()函数是所有Linux平台进入系统内核初始化后的入口函数；主要完成剩余的与硬件平台相关的初始化工作，这些初始化操作，有的是公共的，有的是需要配置才会执行的；内核工作需要的模块的初始化依次被调用，如：内存管理、调度系统、异常处理等；</p><h3 id="3-1-start-kernel"><a href="#3-1-start-kernel" class="headerlink" title="3.1 start_kernel"></a>3.1 start_kernel</h3><p>start_kernel()函数在init&#x2F;main.c文件中，主要完成Linux子系统的初始化工作；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">casmlinkage __visible <span class="type">void</span> __init __no_sanitize_address <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *command_line;</span><br><span class="line"><span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">smp_setup_processor_id();</span><br><span class="line">debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">cgroup_init_early();</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line">early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts are still disabled. Do necessary setups, then</span></span><br><span class="line"><span class="comment"> * enable them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">boot_cpu_init();</span><br><span class="line">page_address_init();</span><br><span class="line">pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);</span><br><span class="line">early_security_init();</span><br><span class="line">setup_arch(&amp;command_line);</span><br><span class="line">setup_boot_config(command_line);</span><br><span class="line">setup_command_line(command_line);</span><br><span class="line">setup_nr_cpu_ids();</span><br><span class="line">setup_per_cpu_areas();</span><br><span class="line">smp_prepare_boot_cpu();<span class="comment">/* arch-specific boot-cpu hooks */</span></span><br><span class="line">boot_cpu_hotplug_init();</span><br><span class="line"></span><br><span class="line">build_all_zonelists(<span class="literal">NULL</span>);</span><br><span class="line">page_alloc_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_ROCKCHIP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *s = saved_command_line;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *e = &amp;saved_command_line[<span class="built_in">strlen</span>(saved_command_line)];</span><br><span class="line"><span class="type">int</span> n =</span><br><span class="line">    pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, saved_command_line);</span><br><span class="line">n -= <span class="built_in">strlen</span>(<span class="string">&quot;Kernel command line: &quot;</span>);</span><br><span class="line">s += n;</span><br><span class="line"><span class="comment">/* command line maybe too long to print one time */</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; s &lt; e) &#123;</span><br><span class="line">n = pr_cont(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">s += n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, saved_command_line);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* parameters may set static keys */</span></span><br><span class="line">jump_label_init();</span><br><span class="line">parse_early_param();</span><br><span class="line">after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">  static_command_line, __start___param,</span><br><span class="line">  __stop___param - __start___param,</span><br><span class="line">  <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, &amp;unknown_bootoption);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">parse_args(<span class="string">&quot;Setting init args&quot;</span>, after_dashes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">   <span class="literal">NULL</span>, set_init_arg);</span><br><span class="line"><span class="keyword">if</span> (extra_init_args)</span><br><span class="line">parse_args(<span class="string">&quot;Setting extra init args&quot;</span>, extra_init_args,</span><br><span class="line">   <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, set_init_arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment"> * kmem_cache_init()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup_log_buf(<span class="number">0</span>);</span><br><span class="line">vfs_caches_init_early();</span><br><span class="line">sort_main_extable();</span><br><span class="line">trap_init();</span><br><span class="line">mm_init();</span><br><span class="line">poking_init();</span><br><span class="line">ftrace_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* trace_printk can be enabled here */</span></span><br><span class="line">early_trace_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the scheduler prior starting any interrupts (such as the</span></span><br><span class="line"><span class="comment"> * timer interrupt). Full topology setup happens at smp_init()</span></span><br><span class="line"><span class="comment"> * time - but meanwhile we still have a functioning scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sched_init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN(!irqs_disabled(),</span><br><span class="line"> <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line">local_irq_disable();</span><br><span class="line">radix_tree_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up housekeeping before setting up workqueues to allow the unbound</span></span><br><span class="line"><span class="comment"> * workqueue to take non-housekeeping into account.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">housekeeping_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allow workqueue creation and work item queueing/cancelling</span></span><br><span class="line"><span class="comment"> * early.  Work item execution depends on kthreads and starts after</span></span><br><span class="line"><span class="comment"> * workqueue_init().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">workqueue_init_early();</span><br><span class="line"></span><br><span class="line">rcu_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Trace events are available after this */</span></span><br><span class="line">trace_init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (initcall_debug)</span><br><span class="line">initcall_debug_enable();</span><br><span class="line"></span><br><span class="line">context_tracking_init();</span><br><span class="line"><span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">early_irq_init();</span><br><span class="line">init_IRQ();</span><br><span class="line">tick_init();</span><br><span class="line">rcu_init_nohz();</span><br><span class="line">init_timers();</span><br><span class="line">hrtimers_init();</span><br><span class="line">softirq_init();</span><br><span class="line">timekeeping_init();</span><br><span class="line">kfence_init();</span><br><span class="line">time_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For best initial stack canary entropy, prepare it after:</span></span><br><span class="line"><span class="comment"> * - setup_arch() for any UEFI RNG entropy and boot cmdline access</span></span><br><span class="line"><span class="comment"> * - timekeeping_init() for ktime entropy used in random_init()</span></span><br><span class="line"><span class="comment"> * - time_init() for making random_get_entropy() work on some platforms</span></span><br><span class="line"><span class="comment"> * - random_init() to initialize the RNG from from early entropy sources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">random_init(command_line);</span><br><span class="line">boot_init_stack_canary();</span><br><span class="line"></span><br><span class="line">perf_event_init();</span><br><span class="line">profile_init();</span><br><span class="line">call_function_init();</span><br><span class="line">WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line">kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HACK ALERT! This is early. We&#x27;re enabling the console before</span></span><br><span class="line"><span class="comment"> * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span></span><br><span class="line"><span class="comment"> * this. But we do want output early, in case something goes wrong.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">console_init();</span><br><span class="line"><span class="keyword">if</span> (panic_later)</span><br><span class="line">panic(<span class="string">&quot;Too many boot %s vars at `%s&#x27;&quot;</span>, panic_later,</span><br><span class="line">      panic_param);</span><br><span class="line"></span><br><span class="line">lockdep_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Need to run this when irqs are enabled, because it wants</span></span><br><span class="line"><span class="comment"> * to self-test [hard/soft]-irqs on/off lock inversion bugs</span></span><br><span class="line"><span class="comment"> * too:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">locking_selftest();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line"><span class="keyword">if</span> (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">pr_crit(<span class="string">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;</span>,</span><br><span class="line">    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)),</span><br><span class="line">    min_low_pfn);</span><br><span class="line">initrd_start = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">setup_per_cpu_pageset();</span><br><span class="line">numa_policy_init();</span><br><span class="line">acpi_early_init();</span><br><span class="line"><span class="keyword">if</span> (late_time_init)</span><br><span class="line">late_time_init();</span><br><span class="line">sched_clock_init();</span><br><span class="line">calibrate_delay();</span><br><span class="line"></span><br><span class="line">arch_cpu_finalize_init();</span><br><span class="line"></span><br><span class="line">pid_idr_init();</span><br><span class="line">anon_vma_init();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line"><span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">efi_enter_virtual_mode();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">thread_stack_cache_init();</span><br><span class="line">cred_init();</span><br><span class="line">fork_init();</span><br><span class="line">proc_caches_init();</span><br><span class="line">uts_ns_init();</span><br><span class="line">buffer_init();</span><br><span class="line">key_init();</span><br><span class="line">security_init();</span><br><span class="line">dbg_late_init();</span><br><span class="line">vfs_caches_init();</span><br><span class="line">pagecache_init();</span><br><span class="line">signals_init();</span><br><span class="line">seq_file_init();</span><br><span class="line">proc_root_init();</span><br><span class="line">nsfs_init();</span><br><span class="line">cpuset_init();</span><br><span class="line">cgroup_init();</span><br><span class="line">taskstats_init_early();</span><br><span class="line">delayacct_init();</span><br><span class="line"></span><br><span class="line">acpi_subsystem_init();</span><br><span class="line">arch_post_acpi_subsys_init();</span><br><span class="line">sfi_init_late();</span><br><span class="line">kcsan_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">arch_call_rest_init();</span><br><span class="line"></span><br><span class="line">prevent_tail_call_optimization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见依次调用了很多的初始化函数</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://mshrimp.github.io/2020/04/19/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EARM64/">Linux内核启动流程-基于ARM64 | Mshrimp blog</a></li><li><a href="https://b2qtatgfkp.feishu.cn/docx/CttXdvBEuomVmmxQcw5cqh5jnJg">05 Linux 内核 - 飞书云文档 (feishu.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> ARM64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核中同步机制的底层实现</title>
      <link href="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核同步机制剖析"><a href="#Linux内核同步机制剖析" class="headerlink" title="Linux内核同步机制剖析"></a>Linux内核同步机制剖析</h1><p>在Linux内核中提供了四种处理并发和竞争的方法，分别是原子操作、自旋锁、信号量、互斥量，事先说明下我使用的<code>linux</code>内核为版本为<code>4.19.232</code></p><h2 id="1-原子变量"><a href="#1-原子变量" class="headerlink" title="1. 原子变量"></a>1. 原子变量</h2><p>在了解原子变量在linux内核中是如何实现之前，建议先了解以下<code>SMP</code>系统和<code>UP</code>系统的不同，然后学习以下<code>cache</code>一致性相关知识，这里给出一个参考链接</p><blockquote><p><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#cpu-cache-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">2.4 CPU 缓存一致性 | 小林coding (xiaolincoding.com)</a></p></blockquote><p>原子操作又可以进一步细分为“整型原子操作”和“位原子操作”，这里首先对<strong>整型原子操作</strong>进行讲解。在 Linux 内核中使用 <code>atomic_t</code> 和<code> atomic64_t</code> 结构体分别来完成 32 位系统和 64 位系统的整形数据原子操作，两个结构体定义在内核源码<code>/include/linux/types.h</code>文件中，具体定义如下：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508114202431.png" alt="image-20240508114202431"></p><p>对整型原子变量的操作有以下一些函数，定义在内核源码的<code>/include/linux/atomic.h</code>中，</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>ATOMIC_INIT(int i)</code></td><td>定义原子变量的时候对其初始化，赋值为 i</td></tr><tr><td><code>int atomic_read(atomic_t *v)</code></td><td>读取 v 的值，并且返回。</td></tr><tr><td><code>void atomic_set(atomic_t *v, int i)</code></td><td>向原子变量 v 写入 i 值。</td></tr><tr><td><code>void atomic_add(int i, atomic_t *v)</code></td><td>原子变量 v 加上 i 值。</td></tr><tr><td><code>void atomic_sub(int i, atomic_t *v)</code></td><td>原子变量 v 减去 i 值。</td></tr><tr><td><code>void atomic_inc(atomic_t *v)</code></td><td>原子变量 v 加 1</td></tr><tr><td><code>void atomic_dec(atomic_t *v)</code></td><td>原子变量 v 减 1</td></tr><tr><td><code>int atomic_dec_return(atomic_t *v)</code></td><td>原子变量 v 减 1，并返回 v 的值。</td></tr><tr><td><code>int atomic_inc_return(atomic_t *v)</code></td><td>原子变量 v 加 1，并返回 v 的值。</td></tr><tr><td><code>int atomic_sub_and_test(int i, atomic_t *v)</code></td><td>原子变量 v 减 i，如果结果为 0 就返回真，否则返回假</td></tr><tr><td><code>int atomic_dec_and_test(atomic_t *v)</code></td><td>原子变量 v 减 1，如果结果为 0 就返回真，否则返回假</td></tr><tr><td><code>int atomic_inc_and_test(atomic_t *v)</code></td><td>原子变量 v 加 1，如果结果为 0 就返回真，否则返回假</td></tr><tr><td><code>int atomic_add_negative(int i, atomic_t *v)</code></td><td>原子变量 v 加 i，如果结果为负就返回真，否则返回假</td></tr></tbody></table><p>对原子位操作的函数有如下，和原子整形变量不同，原子位操作没有 <code>atomic_t </code>的数据结构，原子位操作是直接对内存进行操作</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>void set_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位置 1</td></tr><tr><td><code>void clear_bit(int nr,void *p)</code></td><td>将 p 地址的第 nr 位清零</td></tr><tr><td><code>void change_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位进行翻转</td></tr><tr><td><code>int test_bit(int nr, void *p)</code></td><td>获取 p 地址的第 nr 位的值</td></tr><tr><td><code>int test_and_set_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值</td></tr><tr><td><code>int test_and_clear_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位清零，并且返回 nr 位原来的值</td></tr><tr><td><code>int test_and_change_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值</td></tr></tbody></table><p>我们以原子变量加操作的源码来分析，原子变量的操作在不同体系架构下是不同的，假设我现在定义一个原子变量，然后对其执行加操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> v = ATOMIC_INIT(<span class="number">1</span>);<span class="comment">//初始化原子类型变量 v,并设置为 1</span></span><br><span class="line"><span class="type">atomic_inc</span>(v);   <span class="comment">//将原子变量+1</span></span><br></pre></td></tr></table></figure><p><code>atomic_inc</code>这个宏定义在<code>linux/atomic.h</code>中：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508223825378.png" alt="image-20240508223825378"></p><p>可以看见<code>atomic_inc</code>实际上会去调用<code>atomic_add</code>来使得原子变量加一，<code>atomic_add</code>是一个和体系架构相关的宏函数，我们以<code>x86</code>平台和<code>arm</code>平台为例子，对于<code>linux/atomic.h</code>这个文件无论哪种架构都会去包含<code>\#include &lt;asm/atomic.h&gt;</code>这个头文件，不同的架构这个头文件内容是不一样的。</p><h3 id="1-1-X86平台原子操作的底层实现"><a href="#1-1-X86平台原子操作的底层实现" class="headerlink" title="1.1 X86平台原子操作的底层实现"></a>1.1 X86平台原子操作的底层实现</h3><p>我们首先来分析<code>x86</code>架构，<code>&lt;asm/atomic.h&gt;</code>这个头文件位于<code>arch/x86/include/asm/atomic.h</code>，在这个文件的最底部包含了一个头文件：<code>&lt;asm-generic/atomic-instrumented.h&gt;</code></p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508225051741.png" alt="image-20240508225051741"></p><p>在<code>&lt;asm-generic/atomic-instrumented.h&gt;</code>中定义了和<code>x86</code>架构下原子变量操作的函数</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508225142115.png" alt="image-20240508225142115"></p><p>例如<code>atomic_add</code>会去调用<code>arch_atomic_add</code>，而<code>arch_atomic_add</code>就定义在<code>arch/x86/include/asm/atomic.h</code>中：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508225332327.png" alt="image-20240508225332327"></p><p><code>arch_atomic_add</code>这个函数内部做的操作就是原子变量加一，它是如何做的呢，先来看<code>LOCK_PREFIX</code>这个宏，定义在<code>arch/x86/include/asm/alternative-asm.h</code>中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">.macro LOCK_PREFIX</span><br><span class="line"><span class="number">672</span>:lock</span><br><span class="line">.pushsection .smp_locks,<span class="string">&quot;a&quot;</span></span><br><span class="line">.balign <span class="number">4</span></span><br><span class="line">.<span class="type">long</span> <span class="number">672b</span> - .</span><br><span class="line">.popsection</span><br><span class="line">.endm</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">.macro LOCK_PREFIX</span><br><span class="line">.endm</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看见只有在<code>SMP</code>系统下此宏才会被定义，在<code>SMP</code>系统下涉及到多核之间的<code>cache</code>数据同步与竞争关系，此时才会去定义这个宏，在不是<code>SMP</code>的系统下此宏为空，即单核情况下，这个宏为空，在单核情况下，上面的<code>arch_atomic_add</code>函数就变成了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;addl %1,%0&quot;</span></span></span><br><span class="line"><span class="params">     : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span><br><span class="line"><span class="params">     : <span class="string">&quot;ir&quot;</span> (i) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>addl</code>指令用于执行32位整数加法操作，<code>%1</code>代表i这个参数，<code>%0</code>代表<code>v-&gt;vounter</code>这个参数，<code>addl</code>指令有三个步骤</p><ul><li><strong>取值</strong>：汇编指令首先从 <code>%1</code>（即 <code>i</code>）获取一个整数值。</li><li><strong>加法运算</strong>：将从 <code>%1</code> 取得的值加到 <code>%0</code>（即 <code>v-&gt;counter</code> 内存位置的当前值）上。</li><li><strong>存储结果</strong>：将加法的结果写回 <code>%0</code>，也就是更新 <code>v-&gt;counter</code> 的值。</li></ul></li><li><p>而这三个步骤在单核情况下就是一条<code>addl</code>指令，在单核情况下是原子的，<code>addl</code>在执行时不会被打断</p></li></ul><p>在<code>SMP</code>系统下，由于每个核心都有自己的<code>cache</code>，因此通过锁总线的方式来保证<code>addl</code>指令在多核情况下对同一块内存的操作是一个cpu独占的，在读写完成后再通过<code>cache</code>一致性协议同步，上面这个<code>LOCK_PREFIX</code>宏定义了一些前缀，具体什么意思可以参照下面这个博客，总之就是使用<code>lock</code>指令进行了锁总线的操作，从而实现<code>addl</code>指令在多核情况下的原子性</p><blockquote><p><a href="https://blog.csdn.net/ture010love/article/details/7663008">Linux 内核 LOCK_PREFIX 的含义-CSDN博客</a></p></blockquote><h3 id="1-2-ARM架构的原子操作底层实现"><a href="#1-2-ARM架构的原子操作底层实现" class="headerlink" title="1.2 ARM架构的原子操作底层实现"></a>1.2 ARM架构的原子操作底层实现</h3><p><code>arm</code>架构会有一些不同，<code>ARMv3</code>至<code>ARMv7</code>支持32位寻址空间。<code>ARMv8-A</code>开始支持64位寻址空间，32位的<code>arm</code>架构和64位的<code>arm</code>架构在实现原子操作时是存在一些指令上的不同的。在<code>ARMv8.1</code>之前，为实现原子操作采用的方法主要是<code>LL/SC(Load-Link/Store-Conditional)</code>。ARMv7中实现<code>LL/SC</code>的指令是<code>LDREX/STREX</code>，其实就是比基础的<code>LDR</code>和<code>STR</code>指令多了一个”EX”，”EX”表示exclusive（独占）。具体说来就是，当用<code>LDREX</code>指令从内存某个地址取出数据放到寄存器后，一个硬件的<code>monitor</code>会将此地址标记为<code>exclusive</code>。</p><h4 id="1-2-1-ARM32原子操作"><a href="#1-2-1-ARM32原子操作" class="headerlink" title="1.2.1 ARM32原子操作"></a>1.2.1 ARM32原子操作</h4><p>我们先来看<code>ARMV7</code>是如何做的，还是以<code>atomic_add</code>这个宏为例子，<code>ARMV7</code>及以前的代码是放在<code>arch/arm</code>目录下，我们去<code>arch/arm/include/asm/atomic.h</code>中查找：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509135911099.png" alt="image-20240509135911099"></p><p>在此文件中首先定义了一个宏<code>__LINUX_ARM_ARCH__</code>如果<code>ARM</code>的架构版本大于等于6则说明是支持SMP系统的，如果<code>ARM</code>架构的版本小于<code>ARMV7</code>说明是不支持SMP系统的，多核情况下支持锁内存这样的指令，而单核情况下是不支持的，因此原子操作实际上是通过关闭中断来实现的</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509140147787.png" alt="image-20240509140147787"></p><p>在此文件的下半部分定义了一些宏：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509140456071.png" alt="image-20240509140456071"></p><p><code>ATOMIC_OPS</code>这个宏展开后会去依次调用<code>ATOMIC_OP</code>，<code>ATOMIC_OP_RETURN</code>，<code>ATOMIC_FETCH_OP</code>，在上面的代码中调用了<code>ATOMIC_OPS(add, +=, add)</code>，就相当于：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ATOMIC_OP(add, += , add)</span><br><span class="line">ATOMIC_OP(add, += , add)</span><br><span class="line">ATOMIC_FETCH_OP(op, c_op, asm_op)</span><br></pre></td></tr></table></figure><p>这三个宏都是在上面定义的，以SMP系统下的<code>ATOMIC_OP</code>为例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ARMv6 UP and SMP safe atomic ops.  We use load exclusive and</span></span><br><span class="line"><span class="comment"> * store exclusive to ensure that these are atomic.  We may loop</span></span><br><span class="line"><span class="comment"> * to ensure that the update happens.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, c_op, asm_op)\</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">unsigned long tmp;\</span></span><br><span class="line"><span class="meta">int result;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">prefetchw(&amp;v-&gt;counter);\</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;@ atomic_&quot;</span> #op <span class="string">&quot;\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;1:ldrex%0, [%3]\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;&quot;</span> #asm_op <span class="string">&quot;%0, %0, %4\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;strex%1, %0, [%3]\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;teq%1, #0\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bne1b&quot;</span>\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;=&amp;r&quot;</span> (result), <span class="string">&quot;=&amp;r&quot;</span> (tmp), <span class="string">&quot;+Qo&quot;</span> (v-&gt;counter)\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;r&quot;</span> (&amp;v-&gt;counter), <span class="string">&quot;Ir&quot;</span> (i)\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;cc&quot;</span>);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>展开后这个宏函数的名字就变成了，可以看见就是我们需要的<code>atomic_add</code>函数，其余的宏展开后同理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp;\</span><br><span class="line"><span class="type">int</span> result;\</span><br><span class="line">\</span><br><span class="line">prefetchw(&amp;v-&gt;counter);\</span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;@ atomic_add&quot;</span>\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">1</span>:ldrex%<span class="number">0</span>, [%<span class="number">3</span>]\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>add%<span class="number">0</span>, %<span class="number">0</span>, %<span class="number">4</span>\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>strex%<span class="number">1</span>, %<span class="number">0</span>, [%<span class="number">3</span>]\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>teq%<span class="number">1</span>, #<span class="number">0</span>\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>bne<span class="number">1b</span><span class="string">&quot;\</span></span><br><span class="line"><span class="string">: &quot;</span>=&amp;r<span class="string">&quot; (result), &quot;</span>=&amp;r<span class="string">&quot; (tmp), &quot;</span>+Qo<span class="string">&quot; (v-&gt;counter)\</span></span><br><span class="line"><span class="string">: &quot;</span>r<span class="string">&quot; (&amp;v-&gt;counter), &quot;</span>Ir<span class="string">&quot; (i)\</span></span><br><span class="line"><span class="string">: &quot;</span>cc<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>unsigned long tmp;</code> 和 <code>int result;</code> 定义了两个变量，分别用于存储临时数据和操作结果。</p></li><li><p><code>prefetchw(&amp;v-&gt;counter);</code> 用于预取 <code>v-&gt;counter</code> 的写操作，这可能帮助提高性能。</p></li><li><p>定义了一个内联汇编块，用于实现原子操作。</p><ul><li><code>&quot;@ atomic_&quot; #op &quot;\n&quot;</code> 是一个注释，标识了操作类型。</li><li><code>&quot;ldrex %0, [%3]\n&quot;</code> 使用 <code>ldrex</code> 指令加载 <code>v-&gt;counter</code> 的值到 <code>result</code>，这是一个独占读取。</li><li><code>&quot;#asm_op %0, %0, %4\n&quot;</code> 执行指定的操作，如 <code>add</code>，结果存回 <code>result</code>。</li><li><code>&quot;strex %1, %0, [%3]\n&quot;</code> 使用 <code>strex</code> 尝试将 <code>result</code> 的新值存回 <code>v-&gt;counter</code>。如果在此期间 <code>v-&gt;counter</code> 被其他处理器修改过，则 <code>strex</code> 返回非零值。</li><li><code>&quot;teq %1, #0\n&quot;</code> 测试 <code>strex</code> 的结果是否为 0（表示成功）。</li><li><code>&quot;bne 1b&quot;</code> 如果 <code>strex</code> 失败（<code>tmp</code> 不为 0），则跳回标签 <code>1</code> 重新执行。</li></ul></li><li><p><code>&quot;+Qo&quot; (v-&gt;counter)</code> 表示 <code>v-&gt;counter</code> 是一个输入输出操作数（既被读也被写）。</p></li><li><p><code>&quot;r&quot; (&amp;v-&gt;counter)</code> 和 <code>&quot;Ir&quot; (i)</code> 分别传入 <code>v-&gt;counter</code> 的地址和整数 <code>i</code> 作为输入。</p></li><li><p><code>&quot;cc&quot;</code> 表示这段代码会修改条件寄存器。</p></li></ul><p>这段汇编代码的逻辑如下图所示：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/barriers-12a.png" alt="barriers-12a"></p><p>假设CPU A先进行load操作，并标记了变量v所在的内存地址为exclusive，在CPU A进行下一步的store操作之前，CPU B也进行了对变量v的load操作，那么这个内存地址的exclusive就成了CPU B标记的了。之后CPU A使用STREX进行store操作，它会测试store的目标地址的exclusive是不是自己标记的（是否为自己独占），结果不是，那么store失败。接下来CPU B也执行STREX，因为exclusive是自己标记的，所以可以store成功，exclusive标记也同步失效。此时CPU A会再次尝试一轮LL&#x2F;SC的操作，直到store成功。</p><p>而对于非SMP系统即单核系统：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, c_op, asm_op)\</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">unsigned long flags;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">raw_local_irq_save(flags);\</span></span><br><span class="line"><span class="meta">v-&gt;counter c_op i;\</span></span><br><span class="line"><span class="meta">raw_local_irq_restore(flags);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>可以看见直接使用开关中断的方式来实现</li></ul><h4 id="1-2-2-ARM64原子操作"><a href="#1-2-2-ARM64原子操作" class="headerlink" title="1.2.2 ARM64原子操作"></a>1.2.2 ARM64原子操作</h4><p><code>ARM64</code>原子操作相关的代码定义在<code>arch/arm64/include/atomic.h</code>，在此文件的开头有一个包含头文件的操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM64_LSE_ATOMICS) &amp;&amp; defined(CONFIG_AS_LSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/atomic_lse.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/atomic_ll_sc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>CONFIG_ARM64_LSE_ATOMICS</code>这个宏是在 ARMv8.1 架构中引入的一组增强的原子操作（LSE，Large System Extensions），这些操作提供了更高效的原子指令支持。</li><li><code>CONFIG_AS_LSE</code> 可能表示汇编器支持 <code>LSE</code> 指令集。</li><li>因此如果是<code>ARMv8.1</code>架构以后的使用的是<code>&lt;asm/atomic_lse.h&gt;</code>这个头文件，<code>ARMv8.1</code>以前大于<code>ARMV7</code>的使用的是<code>&lt;asm/atomic_ll_sc.h&gt;</code>头文件</li></ul><p>我们先来看<code>&lt;asm/atomic_ll_sc.h&gt;</code>文件即不支持<code>LSE</code>的原子操作是如何实现的：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509142531497.png" alt="image-20240509142531497"></p><p>和<code>ARMV7</code>一样调用<code>ATOMIC_OPS(and, and, )</code>，</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509142631493.png" alt="image-20240509142631493"></p><p>展开后变成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, asm_op, constraint)\</span></span><br><span class="line"><span class="meta">__LL_SC_INLINE void\</span></span><br><span class="line"><span class="meta">__LL_SC_PREFIX(atomic_add(int i, atomic_t *v))\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">unsigned long tmp;\</span></span><br><span class="line"><span class="meta">int result;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">asm volatile(<span class="string">&quot;// atomic_add &quot;</span>\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>prfmpstl1strm, %2\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>1:ldxr%w0, %2\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>add%w0, %w0, %w3\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>stxr%w1, %w0, %2\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>cbnz%w1, 1b<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">: &quot;</span>=&amp;r<span class="string">&quot; (result), &quot;</span>=&amp;r<span class="string">&quot; (tmp), &quot;</span>+Q<span class="string">&quot; (v-&gt;counter)\</span></span></span><br><span class="line"><span class="string"><span class="meta">: #constraint &quot;</span>r<span class="string">&quot; (i));\</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;\</span></span></span><br><span class="line"><span class="string"><span class="meta">__LL_SC_EXPORT(atomic_##op);</span></span></span><br></pre></td></tr></table></figure><ul><li><p><code>ldxr</code>和<code>ldrex</code>都是实现原子操作的 Load-Exclusive 指令，但它们适用于不同的 ARM 架构版本。</p></li><li><p>汇编指令详细执行原子操作：</p><ul><li><code>prfm pstl1strm, %2</code>：预取指令，为存储预取数据到一级流式存储器。</li><li><code>ldxr %w0, %2</code>：使用 Load-Exclusive 指令从 <code>v-&gt;counter</code> 加载数据到寄存器 <code>%w0</code>。</li><li><code>#asm_op %w0, %w0, %w3</code>：执行如加法、减法等操作，结果存回 <code>%w0</code>。</li><li><code>stxr %w1, %w0, %2</code>：使用 Store-Exclusive 指令尝试将 <code>%w0</code> 的值存回 <code>v-&gt;counter</code>。</li><li><code>cbnz %w1, 1b</code>：如果 <code>stxr</code> 指示存储失败（寄存器 <code>%w1</code> 不为零），则跳回标签 <code>1</code> 重新尝试。</li></ul></li><li><p>寄存器 <code>result</code> 和 <code>tmp</code> 分别用于存储操作的结果和临时数据。</p></li><li><p>约束 <code>&quot;+Q&quot; (v-&gt;counter)</code> 表示 <code>v-&gt;counter</code> 是一个读写操作数。</p></li><li><p><code>#constraint &quot;r&quot; (i)</code> 表示输入 <code>i</code> 作为寄存器输入，具体的约束由宏的调用者提供。</p></li></ul><p>对于<code>ARMv8.1 </code>架构及以后支持<code>LSE</code>指令集的原子操作实现需要去查看<code>&lt;asm/atomic_lse.h&gt;</code>，在上面的原子实现中，如果<code>stxr</code>指令失败会导致重试，重试一次还好，如果CPU之间竞争比较激烈，可能导致重试的次数较多，所以从2014年的ARMv8.1开始，ARM推出了用于原子操作的LSE(Large System Extension)指令集扩展，新增的指令包括CAS, SWP和LD<OP>, ST<OP>等，其中<OP>可以是ADD, CLR, EOR, SET等。</OP></OP></OP></p><p>来看看代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LL_SC_ATOMIC(op)__LL_SC_CALL(atomic_##op)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, asm_op)\</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">register int w0 asm (<span class="string">&quot;w0&quot;</span>) = i;\</span></span><br><span class="line"><span class="meta">register atomic_t *x1 asm (<span class="string">&quot;x1&quot;</span>) = v;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">asm volatile(\</span></span><br><span class="line"><span class="meta">__LSE_PREAMBLE\</span></span><br><span class="line"><span class="meta">ARM64_LSE_ATOMIC_INSN(__LL_SC_ATOMIC(op),\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;&quot;</span> #asm_op <span class="string">&quot;%w[i], %[v]\n&quot;</span>)\</span></span><br><span class="line"><span class="meta">: [i] <span class="string">&quot;+r&quot;</span> (w0), [v] <span class="string">&quot;+Q&quot;</span> (v-&gt;counter)\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;r&quot;</span> (x1)\</span></span><br><span class="line"><span class="meta">: __LL_SC_CLOBBERS);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line">ATOMIC_OP(andnot, stclr)</span><br><span class="line">ATOMIC_OP(or, stset)</span><br><span class="line">ATOMIC_OP(xor, steor)</span><br><span class="line">ATOMIC_OP(add, stadd)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>展开后为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define __LL_SC_ATOMIC(op)__LL_SC_CALL(atomic_##op)</span><br><span class="line">#define ATOMIC_OP(op, asm_op)\</span><br><span class="line">static inline void atomic_add(int i, atomic_t *v)\</span><br><span class="line">&#123;\</span><br><span class="line">register int w0 asm (&quot;w0&quot;) = i;\</span><br><span class="line">register atomic_t *x1 asm (&quot;x1&quot;) = v;\</span><br><span class="line">\</span><br><span class="line">asm volatile(\</span><br><span class="line">__LSE_PREAMBLE\</span><br><span class="line">ARM64_LSE_ATOMIC_INSN(__LL_SC_ATOMIC(add),\</span><br><span class="line">&quot;&quot; stdadd&quot;%w[i], %[v]\n&quot;)\</span><br><span class="line">: [i] &quot;+r&quot; (w0), [v] &quot;+Q&quot; (v-&gt;counter)\</span><br><span class="line">: &quot;r&quot; (x1)\</span><br><span class="line">: __LL_SC_CLOBBERS);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ATOMIC_OP(andnot, stclr)</span><br><span class="line">ATOMIC_OP(or, stset)</span><br><span class="line">ATOMIC_OP(xor, steor)</span><br><span class="line">ATOMIC_OP(add, stadd)</span><br></pre></td></tr></table></figure><p>寄存器绑定：</p><ul><li>变量 <code>w0</code> 和 <code>x1</code> 分别绑定到 ARM64 寄存器 <code>w0</code> 和 <code>x1</code>。<code>w0</code> 是用来存储整数 <code>i</code>，而 <code>x1</code> 是用来存储指针 <code>v</code> 的地址。</li><li>使用 <code>asm</code> 关键字显式指定使用哪个寄存器，这有助于在内联汇编代码中直接引用这些寄存器。</li></ul><p>内联汇编：</p><ul><li><code>&quot; &quot; #asm_op &quot; %w[i], %[v]\n&quot;</code>：这是实际执行的原子操作指令，<code>#asm_op</code> 将被替换为传入的汇编操作符，如 <code>stadd</code>。</li><li>输出列表 (<code>[i] &quot;+r&quot; (w0), [v] &quot;+Q&quot; (v-&gt;counter)</code>)：定义了内联汇编修改的变量。<code>+r</code> 表示变量既是输入又是输出，<code>+Q</code> 表示内存操作数，也是读写的。</li><li>输入列表 (<code>&quot;r&quot; (x1)</code>)：提供给汇编的输入。</li><li>被破坏列表 (<code>__LL_SC_CLOBBERS</code>)：可能是一组被这段内联汇编修改的其他寄存器，以确保调用者能够保存和恢复这些寄存器的状态。</li></ul><p>直接一条指令实现了原子操作，类似于x86的lock指令</p><h2 id="2-自旋锁"><a href="#2-自旋锁" class="headerlink" title="2.自旋锁"></a>2.自旋锁</h2><p>自旋锁（spin lock）是一种非阻塞锁，也就是说，如果某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗 CPU 的时间，不停的试图获取锁。</p><p>内核中以 <code>spinlock_t </code>结构体来表示自旋锁，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock_types.h” 文件中，如下所示</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u8 __padding[LOCK_PADSIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line"><span class="type">arch_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> magic, owner_cpu;</span><br><span class="line"><span class="type">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure><ul><li><code>spinlock_t</code>这个结构体实际使用的是<code>raw_spinlock_t</code></li><li><code>raw_spinlock_t</code>内部使用的是<code>arch_spinlock_t</code>，一看就是一个和体系结构相关的自旋锁</li></ul><p>自旋锁相关 <code>API</code> 函数定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中，部分 API 函数如下所示</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>DEFINE_SPINLOCK(spinlock_t lock)</td><td>定义并初始化自旋锁</td></tr><tr><td>int spin_lock_init(spinlock_t *lock)</td><td>初始化自旋锁</td></tr><tr><td>void spin_lock(spinlock_t *lock)</td><td>获取指定的自旋锁，也叫做加锁</td></tr><tr><td>void spin_unlock(spinlock_t *lock)</td><td>释放指定的自旋锁</td></tr><tr><td>int spin_trylock(spinlock_t *lock)</td><td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td></tr><tr><td>int spin_is_locked(spinlock_t *lock)</td><td>检查指定的自旋锁是否被获取，如果没有被获取就返回非 0，否则返回0</td></tr></tbody></table><p>自旋锁的使用步骤：</p><ul><li><p>在访问临界资源的时候先申请自旋锁</p></li><li><p>获取到自旋锁之后就进入临界区，获取不到自旋锁就“原地等待”。</p></li><li><p>退出临界区的时候要释放自旋锁。</p></li></ul><p>我们要去分析自旋锁的代码实际上就是要去看<code>arch_spinlock_t</code>的相关操作，回到“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock_types.h”的最上面即<code>raw_spinlock_t</code>定义的地方<br><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240510171732998.png" alt="image-20240510171732998"></p><ul><li>如果是<code>SMP</code>系统使用的是<code>&lt;asm/spinlock_types.h&gt;</code>，否则使用的是<code>&lt;linux/spinlock_types_up.h&gt;</code></li></ul><p>到这里就到了自旋锁的分水岭，单核情况和多核情况自旋锁是完全不同的，这里先引入一个概念，关于抢占式内核与非抢占式内核：</p><ul><li><p>在非抢占式内核中，如果一个进程在内核态运行，其只有在以下两种情况会被切换：</p><ol><li>其运行完成（返回用户空间）</li><li>主动让出cpu（即主动调用schedule或内核中的任务阻塞——这同样也会导致调用schedule）</li></ol></li><li><p>在抢占式内核中，如果一个进程在内核态运行，其只有在以下四种情况会被切换：</p></li></ul><ol><li>其运行完成（返回用户空间）</li><li>主动让出cpu（即主动调用schedule或内核中的任务阻塞——这同样也会导致调用schedule）</li><li>当从中断处理程序正在执行，且返回内核空间之前（此时可抢占标志premptcount须为0）</li><li>当内核代码再一次具有可抢占性的时候，如解锁及使能软中断等。</li></ol><p><code>linux</code>内核是一个可抢占的内核， 在单cpu，可抢占内核中，自旋锁实现为“禁止内核抢占”，并不实现“自旋”。禁止内核抢占只是关闭“可抢占标志”，而不是禁止进程切换。显式使用schedule或进程阻塞（此也会导致调用schedule）时，还是会发生进程调度的。这也符合自旋锁的作用，加上自旋锁的线程是不会被阻塞的，禁止抢占会防止线程从运行态被切换。在多cpu，可抢占内核中，自旋锁实现为“禁止内核抢占” + “自旋”。</p><h3 id="2-1-单核情况下自旋锁的实现"><a href="#2-1-单核情况下自旋锁的实现" class="headerlink" title="2.1 单核情况下自旋锁的实现"></a>2.1 单核情况下自旋锁的实现</h3><p>有了上面的概念我们再来看单核情况下自旋锁的实现，上面说到我们需要去<code>&lt;linux/spinlock_types_up.h&gt;</code>寻找<code>arch_spinlock_t</code>的定义：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240518113330340.png" alt="image-20240518113330340"></p><p>可以看见是一个空的结构体，然后我们来看加锁函数<code>spin_lock</code>，定义在<code>include/linux/spinlock.h</code>中，此函数会去掉用<code>raw_spin_lock</code>的宏，这个宏也在此头文件中，然后会去调用<code>_raw_spin_lock</code>，此宏定义在<code>include/linux/spinlock_api_up.h</code>中，它会去调用<code>__LOCK</code>宏，<code>__LOCK</code>会调用<code>___LOCK</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/spinlock_api_up.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock)__LOCK(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___LOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; __acquire(lock); (void)(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; preempt_disable(); ___LOCK(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/compiler_types.h</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __acquire(x) (void)0</span></span><br></pre></td></tr></table></figure><ul><li>可以看见先做了<code>preempt_disable();</code>操作，用于禁止抢占</li><li>然后执行<code>__acquire(lock);</code>，可以看见就是将<code>lock</code>置为0，然后<code>(void)(lock);</code>置为空</li><li>所以在单核情况下自旋锁除了关闭内核抢占，什么都没做</li></ul><p>对于锁的释放<code>spin_unlock</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_unlock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_unlock(lock)_raw_spin_unlock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/spinlock_api_up.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_unlock(lock)__UNLOCK(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UNLOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; preempt_enable(); ___UNLOCK(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___UNLOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; (void)(lock); &#125; while (0)</span></span><br></pre></td></tr></table></figure><ul><li>调用<code> preempt_enable();</code>重新开启cpu的内核抢占</li></ul><h3 id="2-2-多核情况下自旋锁的实现"><a href="#2-2-多核情况下自旋锁的实现" class="headerlink" title="2.2 多核情况下自旋锁的实现"></a>2.2 多核情况下自旋锁的实现</h3><p>在多核情况下<code>arch_spinlock_t</code>的需要包含<code>&lt;asm/spinlock_types.h&gt;</code>中，这是一个和体系架构相关的头文件，在<code>x86</code>、<code>ARM32</code>、<code>ARM64</code>下的实现是不一样的，</p><h4 id="2-2-1-ARM32"><a href="#2-2-1-ARM32" class="headerlink" title="2.2.1 ARM32"></a>2.2.1 ARM32</h4><p>首先来看<code>ARM32</code>的实现，用到的头文件为“内核源码&#x2F;arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;spinlock_types.h”</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TICKET_SHIFT16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">u32 slock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">raw_tickets</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARMEB__</span></span><br><span class="line">u16 next;</span><br><span class="line">u16 owner;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">u16 owner;</span><br><span class="line">u16 next;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; tickets;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="type">arch_spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED&#123; &#123; 0 &#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>arch_spinlock_t</code>结构体内部是一个联合体，简单来说就是存放一个<code>u32</code>类型的数据，把一个<code>u32</code>拆分成两个<code>u16</code>，分别为<code>next</code>和 <code>owner</code></p><ul><li><code>owner</code>表示持有这个数字的线程可以获取自旋锁</li><li><code>next</code>表示如果后续再有线程请求获取这个自旋锁，就为此线程分配这个数字</li></ul></li><li><p><code>__ARMEB__</code>这个宏是标识大端和小端的</p></li><li><p><code>next</code>和<code>owner</code>设计的原因是为了保证<code>spinlock</code>的公平性，先申请持有锁的线程先拿到锁，举个例子</p><p>1.刚开始<code>owner=next=0</code>;<br>2.第一个thread获取<code>spinlock</code>，可获取成功，此时<code>owner=0,next=0</code><br>3.第二个thread获取spinlock,如果第一个thread 还没有释放spinlock，则next++,next变为1;</p><p>4.第三个thread获取spinlock,如果第一个thread 还没有释放spinlock，则next++,next变为2;</p><p>5.此时第一个thread释放spinlock，则执行<code>owner++,owner=1;</code></p><p>6.虽然此时第二个thread和第三个thread都在等待spinlock,但是因为第二个thread的next&#x3D;owner,所以第二个thread可以获取到spinlock，第三个thread则继续等待。</p><p>这样保证了spinlock的唤醒机制是先到先唤醒，后到后唤醒保证了公平性。</p></li></ul><p>基于上面的设计我们来看一下加锁操作，在<code>内核源码/include/linux/spinlock.h</code>中：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240519123433508.png" alt="image-20240519123433508"></p><p>初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spin_lock_init(_lock)\</span></span><br><span class="line"><span class="meta">do &#123;\</span></span><br><span class="line"><span class="meta">spinlock_check(_lock);\</span></span><br><span class="line"><span class="meta">raw_spin_lock_init(&amp;(_lock)-&gt;rlock);\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> raw_spin_lock_init(lock)\</span></span><br><span class="line"><span class="meta">do &#123; *(lock) = __RAW_SPIN_LOCK_UNLOCKED(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  include/linux/spinlock_types.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RAW_SPIN_LOCK_INITIALIZER(lockname)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,\</span></span><br><span class="line"><span class="meta">SPIN_DEBUG_INIT(lockname)\</span></span><br><span class="line"><span class="meta">SPIN_DEP_MAP_INIT(lockname) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RAW_SPIN_LOCK_UNLOCKED(lockname)\</span></span><br><span class="line"><span class="meta">(raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER(lockname)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  arch/arm/include/asm/spinlock_types.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED&#123; &#123; 0 &#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>可以看见初始化锁最后会调用到<code>arch/arm/include/asm/spinlock_types.h</code>文件中的<code>__ARCH_SPIN_LOCK_UNLOCKED</code>来将自旋锁中的<code>.raw_lock</code>成员初始化为0，在上面的自旋锁的定义中<code>arch_spinlock_t raw_lock;</code>最后实际上就是将<code>arch_spinlock_t</code>结构体中的<code>u32</code>变成了0，即初始化时<code>next=0 , owner=0</code></li></ul><p>加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include\linux\spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock) __raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">acquires</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">__acquire(lock);</span><br><span class="line">arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  arch/arm/include/asm/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_spin_lock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line">u32 newval;</span><br><span class="line"><span class="type">arch_spinlock_t</span> lockval;</span><br><span class="line"></span><br><span class="line">prefetchw(&amp;lock-&gt;slock);</span><br><span class="line">__asm__ __volatile__(</span><br><span class="line"><span class="string">&quot;1:ldrex%0, [%3]\n&quot;</span></span><br><span class="line"><span class="string">&quot;add%1, %0, %4\n&quot;</span></span><br><span class="line"><span class="string">&quot;strex%2, %1, [%3]\n&quot;</span></span><br><span class="line"><span class="string">&quot;teq%2, #0\n&quot;</span></span><br><span class="line"><span class="string">&quot;bne1b&quot;</span></span><br><span class="line">: <span class="string">&quot;=&amp;r&quot;</span> (lockval), <span class="string">&quot;=&amp;r&quot;</span> (newval), <span class="string">&quot;=&amp;r&quot;</span> (tmp)</span><br><span class="line">: <span class="string">&quot;r&quot;</span> (&amp;lock-&gt;slock), <span class="string">&quot;I&quot;</span> (<span class="number">1</span> &lt;&lt; TICKET_SHIFT)</span><br><span class="line">: <span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (lockval.tickets.next != lockval.tickets.owner) &#123;</span><br><span class="line">wfe();</span><br><span class="line">lockval.tickets.owner = READ_ONCE(lock-&gt;tickets.owner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smp_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>spin_lock</code>加锁，对于<code>ARM32</code>最终会调用到<code>arch_spin_lock</code></p></li><li><p><code>ldrex %0, [%3]</code>：将 <code>[lock-&gt;slock]</code> 的值加载到 <code>lockval</code> 中，并设置一个独占标志。就是加载锁的那个<code>u32</code>的值到<code>lockval</code>中。存储一个锁的值的本地副本<code>lockval</code></p></li><li><p><code>add %1, %0, %4</code>：将 <code>lockval</code> 和 <code>1 &lt;&lt; TICKET_SHIFT</code> 相加，结果存储在 <code>newval</code> 中。<code>TICKET_SHIFT</code>的值为<code>16</code>，即将高16位加一，那么<code>newval</code>的<code>next</code>就加一了</p></li><li><p><code>strex %2, %1, [%3]</code>：将 <code>newval</code> 写入到 <code>[lock-&gt;slock]</code> 中，如果成功（即 <code>tmp</code> 为 0），则表示锁获取成功，否则重试。</p></li><li><p>执行完毕上面的操作后就是将锁的<code>u32</code>的值的<code>next</code>加一了，然后保存了一个本地的副本值，<code>lockval</code>的<code>next</code>值是上一次未加一的值</p></li><li><p>然后下面有个<code>while</code>循环会去判断<code>lockval</code>的<code>owner</code>值和<code>next</code>值是否相等，如果不等，则去加载最新的<code>lock</code>的<code>owner</code>的值，上面提到如果有线程释放锁了，会去将<code>lock</code>的<code>owner</code>值加一，因此如果最新的<code>owner</code>值和本地线程维护的<code>next</code>值相等了就说明本地线程可以不用循环等待了</p></li><li><p>在循环内部会调用一个<code>wfe()</code>函数，这个函数是用于使当前的cpu处于低功耗状态，如果说其他核心上的线程还在持有锁并没有释放，我们可以让当前线程不用一直自旋，直接使其进入低功耗状态，当锁释放时再唤醒</p></li></ul><p>解锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_unlock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_unlock(lock)_raw_spin_unlock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include\linux\spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_unlock(lock) __raw_spin_unlock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_unlock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">spin_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">do_raw_spin_unlock(lock);</span><br><span class="line">preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_unlock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">releases</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">arch_spin_unlock(&amp;lock-&gt;raw_lock);</span><br><span class="line">__release(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  arch/arm/include/asm/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_spin_unlock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">smp_mb();</span><br><span class="line">lock-&gt;tickets.owner++;</span><br><span class="line">dsb_sev();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可以看见解锁操作就是将<code>owner</code>的值加一</li><li>然后唤醒，上面提到其余没有拿到锁的线程会自旋然后进入低功耗状态，调用<code>dsb_sev();</code>就可以唤醒cpu，因为此时<code>owner</code>的值加一了</li></ul><h4 id="2-2-2-ARM64和X86"><a href="#2-2-2-ARM64和X86" class="headerlink" title="2.2.2 ARM64和X86"></a>2.2.2 ARM64和X86</h4><p>在<code>ARM64</code>和<code>x86</code>平台下，先要去找<code>arch_spinlock_t</code>的定义，去<code>arch/arm64/include/asm/spinlock_types.h</code>中寻找：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240519134302875.png" alt="image-20240519134302875"></p><p>可以看见会去包含：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/qspinlock_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/qrwlock_types.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>进入<code>/include/asm-generic/qspinlock_types.h</code>，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qspinlock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">atomic_t</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By using the whole 2nd least significant byte for the</span></span><br><span class="line"><span class="comment"> * pending bit, we can allow better optimization of the lock</span></span><br><span class="line"><span class="comment"> * acquisition for the pending bit holder.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LITTLE_ENDIAN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u8locked;</span><br><span class="line">u8pending;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u16locked_pending;</span><br><span class="line">u16tail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u16tail;</span><br><span class="line">u16locked_pending;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u8reserved[<span class="number">2</span>];</span><br><span class="line">u8pending;</span><br><span class="line">u8locked;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="type">arch_spinlock_t</span>;</span><br></pre></td></tr></table></figure><p>在这里定义了<code>arch_spinlock_t</code>，<code>__LITTLE_ENDIAN</code>用于判断大端和小端，可以看见使用了一个32位的原子变量</p><p>来看加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include\linux\spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock) __raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">acquires</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">__acquire(lock);</span><br><span class="line">arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include\asm-generic\qspinlock.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_spin_lock(l)queued_spin_lock(l)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">queued_spin_lock</span><span class="params">(<span class="keyword">struct</span> qspinlock *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 val;</span><br><span class="line"></span><br><span class="line">val = atomic_cmpxchg_acquire(&amp;lock-&gt;val, <span class="number">0</span>, _Q_LOCKED_VAL);</span><br><span class="line"><span class="keyword">if</span> (likely(val == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">queued_spin_lock_slowpath(lock, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现十分复杂，后续再分析……</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * queued_spin_lock_slowpath - acquire the queued spinlock</span></span><br><span class="line"><span class="comment"> * @lock: Pointer to queued spinlock structure</span></span><br><span class="line"><span class="comment"> * @val: Current value of the queued spinlock 32-bit word</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (queue tail, pending bit, lock value)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              fast     :    slow                                  :    unlock</span></span><br><span class="line"><span class="comment"> *                       :                                          :</span></span><br><span class="line"><span class="comment"> * uncontended  (0,0,0) -:--&gt; (0,0,1) ------------------------------:--&gt; (*,*,0)</span></span><br><span class="line"><span class="comment"> *                       :       | ^--------.------.             /  :</span></span><br><span class="line"><span class="comment"> *                       :       v           \      \            |  :</span></span><br><span class="line"><span class="comment"> * pending               :    (0,1,1) +--&gt; (0,1,0)   \           |  :</span></span><br><span class="line"><span class="comment"> *                       :       | ^--&#x27;              |           |  :</span></span><br><span class="line"><span class="comment"> *                       :       v                   |           |  :</span></span><br><span class="line"><span class="comment"> * uncontended           :    (n,x,y) +--&gt; (n,0,0) --&#x27;           |  :</span></span><br><span class="line"><span class="comment"> *   queue               :       | ^--&#x27;                          |  :</span></span><br><span class="line"><span class="comment"> *                       :       v                               |  :</span></span><br><span class="line"><span class="comment"> * contended             :    (*,x,y) +--&gt; (*,0,0) ---&gt; (*,0,1) -&#x27;  :</span></span><br><span class="line"><span class="comment"> *   queue               :         ^--&#x27;                             :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queued_spin_lock_slowpath</span><span class="params">(<span class="keyword">struct</span> qspinlock *lock, u32 val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mcs_spinlock</span> *<span class="title">prev</span>, *<span class="title">next</span>, *<span class="title">node</span>;</span></span><br><span class="line">u32 old, tail;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">BUILD_BUG_ON(CONFIG_NR_CPUS &gt;= (<span class="number">1U</span> &lt;&lt; _Q_TAIL_CPU_BITS));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pv_enabled())</span><br><span class="line"><span class="keyword">goto</span> pv_queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (virt_spin_lock(lock))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait for in-progress pending-&gt;locked hand-overs with a bounded</span></span><br><span class="line"><span class="comment"> * number of spins so that we guarantee forward progress.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,1,0 -&gt; 0,0,1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (val == _Q_PENDING_VAL) &#123;</span><br><span class="line"><span class="type">int</span> cnt = _Q_PENDING_LOOPS;</span><br><span class="line">val = atomic_cond_read_relaxed(&amp;lock-&gt;val,</span><br><span class="line">       (VAL != _Q_PENDING_VAL) || !cnt--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we observe any contention; queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (val &amp; ~_Q_LOCKED_MASK)</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * trylock || pending</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,0,0 -&gt; 0,0,1 ; trylock</span></span><br><span class="line"><span class="comment"> * 0,0,1 -&gt; 0,1,1 ; pending</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">val = queued_fetch_set_pending_acquire(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we observe any contention; undo and queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(val &amp; ~_Q_LOCKED_MASK)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(val &amp; _Q_PENDING_MASK))</span><br><span class="line">clear_pending(lock);</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We&#x27;re pending, wait for the owner to go away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,1,1 -&gt; 0,1,0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this wait loop must be a load-acquire such that we match the</span></span><br><span class="line"><span class="comment"> * store-release that clears the locked bit and create lock</span></span><br><span class="line"><span class="comment"> * sequentiality; this is because not all</span></span><br><span class="line"><span class="comment"> * clear_pending_set_locked() implementations imply full</span></span><br><span class="line"><span class="comment"> * barriers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (val &amp; _Q_LOCKED_MASK)</span><br><span class="line">atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_MASK));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * take ownership and clear the pending bit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,1,0 -&gt; 0,0,1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clear_pending_set_locked(lock);</span><br><span class="line">qstat_inc(qstat_lock_pending, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * End of pending bit optimistic spinning and beginning of MCS</span></span><br><span class="line"><span class="comment"> * queuing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">queue</span>:</span><br><span class="line">qstat_inc(qstat_lock_slowpath, <span class="literal">true</span>);</span><br><span class="line">pv_queue:</span><br><span class="line">node = this_cpu_ptr(&amp;mcs_nodes[<span class="number">0</span>]);</span><br><span class="line">idx = node-&gt;count++;</span><br><span class="line">tail = encode_tail(smp_processor_id(), idx);</span><br><span class="line"></span><br><span class="line">node += idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure that we increment the head node-&gt;count before initialising</span></span><br><span class="line"><span class="comment"> * the actual node. If the compiler is kind enough to reorder these</span></span><br><span class="line"><span class="comment"> * stores, then an IRQ could overwrite our assignments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">barrier();</span><br><span class="line"></span><br><span class="line">node-&gt;locked = <span class="number">0</span>;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">pv_init_node(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We touched a (possibly) cold cacheline in the per-cpu queue node;</span></span><br><span class="line"><span class="comment"> * attempt the trylock once more in the hope someone let go while we</span></span><br><span class="line"><span class="comment"> * weren&#x27;t watching.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (queued_spin_trylock(lock))</span><br><span class="line"><span class="keyword">goto</span> release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure that the initialisation of @node is complete before we</span></span><br><span class="line"><span class="comment"> * publish the updated tail via xchg_tail() and potentially link</span></span><br><span class="line"><span class="comment"> * @node into the waitqueue via WRITE_ONCE(prev-&gt;next, node) below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">smp_wmb();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Publish the updated tail.</span></span><br><span class="line"><span class="comment"> * We have already touched the queueing cacheline; don&#x27;t bother with</span></span><br><span class="line"><span class="comment"> * pending stuff.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * p,*,* -&gt; n,*,*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">old = xchg_tail(lock, tail);</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * if there was a previous node; link it and wait until reaching the</span></span><br><span class="line"><span class="comment"> * head of the waitqueue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (old &amp; _Q_TAIL_MASK) &#123;</span><br><span class="line">prev = decode_tail(old);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Link @node into the waitqueue. */</span></span><br><span class="line">WRITE_ONCE(prev-&gt;next, node);</span><br><span class="line"></span><br><span class="line">pv_wait_node(node, prev);</span><br><span class="line">arch_mcs_spin_lock_contended(&amp;node-&gt;locked);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While waiting for the MCS lock, the next pointer may have</span></span><br><span class="line"><span class="comment"> * been set by another lock waiter. We optimistically load</span></span><br><span class="line"><span class="comment"> * the next pointer &amp; prefetch the cacheline for writing</span></span><br><span class="line"><span class="comment"> * to reduce latency in the upcoming MCS unlock operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">next = READ_ONCE(node-&gt;next);</span><br><span class="line"><span class="keyword">if</span> (next)</span><br><span class="line">prefetchw(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * we&#x27;re at the head of the waitqueue, wait for the owner &amp; pending to</span></span><br><span class="line"><span class="comment"> * go away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * *,x,y -&gt; *,0,0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this wait loop must use a load-acquire such that we match the</span></span><br><span class="line"><span class="comment"> * store-release that clears the locked bit and create lock</span></span><br><span class="line"><span class="comment"> * sequentiality; this is because the set_locked() function below</span></span><br><span class="line"><span class="comment"> * does not imply a full barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The PV pv_wait_head_or_lock function, if active, will acquire</span></span><br><span class="line"><span class="comment"> * the lock and return a non-zero value. So we have to skip the</span></span><br><span class="line"><span class="comment"> * atomic_cond_read_acquire() call. As the next PV queue head hasn&#x27;t</span></span><br><span class="line"><span class="comment"> * been designated yet, there is no way for the locked value to become</span></span><br><span class="line"><span class="comment"> * _Q_SLOW_VAL. So both the set_locked() and the</span></span><br><span class="line"><span class="comment"> * atomic_cmpxchg_relaxed() calls will be safe.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If PV isn&#x27;t active, 0 will be returned instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((val = pv_wait_head_or_lock(lock, node)))</span><br><span class="line"><span class="keyword">goto</span> locked;</span><br><span class="line"></span><br><span class="line">val = atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_PENDING_MASK));</span><br><span class="line"></span><br><span class="line">locked:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * claim the lock:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * n,0,0 -&gt; 0,0,1 : lock, uncontended</span></span><br><span class="line"><span class="comment"> * *,*,0 -&gt; *,*,1 : lock, contended</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the queue head is the only one in the queue (lock value == tail)</span></span><br><span class="line"><span class="comment"> * and nobody is pending, clear the tail code and grab the lock.</span></span><br><span class="line"><span class="comment"> * Otherwise, we only need to grab the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In the PV case we might already have _Q_LOCKED_VAL set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The atomic_cond_read_acquire() call above has provided the</span></span><br><span class="line"><span class="comment"> * necessary acquire semantics required for locking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (((val &amp; _Q_TAIL_MASK) == tail) &amp;&amp;</span><br><span class="line">    atomic_try_cmpxchg_relaxed(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL))</span><br><span class="line"><span class="keyword">goto</span> release; <span class="comment">/* No contention */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Either somebody is queued behind us or _Q_PENDING_VAL is set */</span></span><br><span class="line">set_locked(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * contended path; wait for next if not observed yet, release.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!next)</span><br><span class="line">next = smp_cond_load_relaxed(&amp;node-&gt;next, (VAL));</span><br><span class="line"></span><br><span class="line">arch_mcs_spin_unlock_contended(&amp;next-&gt;locked);</span><br><span class="line">pv_kick_node(lock, next);</span><br><span class="line"></span><br><span class="line">release:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * release the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__this_cpu_dec(mcs_nodes[<span class="number">0</span>].count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h2><p><code>Linux</code> 内核使用 <code>semaphore</code> 结构体来表示信号量，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;semaphore.h”文件内</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Please don&#x27;t access any members of this structure directly */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line"><span class="type">raw_spinlock_t</span>lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与信号量相关的 API 函数同样定义在 semaphore.h 文件内，部分常用 API 函数如下所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_SEAMPHORE(name)</code></td><td>定义信号量，并且设置信号量的值为 1。</td></tr><tr><td><code>void sema_init(struct semaphore *sem, int val)</code></td><td>初始化信号量 sem，设置信号量值为 val。</td></tr><tr><td><code>void down(struct semaphore *sem)</code></td><td>获取信号量，不能被中断打断，如 ctrl+c</td></tr><tr><td><code>int down_interruptible(struct semaphore *sem)</code></td><td>获取信号量，可以被中断打断，如 ctrl+c</td></tr><tr><td><code>void up(struct semaphore *sem)</code></td><td>释放信号量</td></tr><tr><td><code>int down_trylock(struct semaphore *sem);</code></td><td>尝试获取信号量，如果能获取到信号量就获取，并且返回 0</td></tr></tbody></table><p>在<code>semaphore</code> 结构体的定义中，包含一个自旋锁，一个计数的<code>count</code>值，一个双向链表</p><p>先来看定义信号量的宏以及初始化函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/semaphore.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SEMAPHORE_INITIALIZER(name, n)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">.lock= __RAW_SPIN_LOCK_UNLOCKED((name).lock),\</span></span><br><span class="line"><span class="meta">.count= n,\</span></span><br><span class="line"><span class="meta">.wait_list= LIST_HEAD_INIT((name).wait_list),\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SEMAPHORE(name)\</span></span><br><span class="line"><span class="meta">struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">*sem = (<span class="keyword">struct</span> semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">&quot;semaphore-&gt;lock&quot;</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化了自旋锁</li><li>然后初始化了<code>count</code>值</li><li>初始化了双向链表，这个链表用于挂载阻塞在此信号量上的线程的结构体指针</li></ul><p>加锁函数即<code>down</code>函数，获取一个锁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/semaphore.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">sem-&gt;count--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__down(sem);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __down(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __sched __down_common(<span class="keyword">struct</span> semaphore *sem, <span class="type">long</span> state,</span><br><span class="line"><span class="type">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"></span><br><span class="line">list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list);</span><br><span class="line">waiter.task = current;</span><br><span class="line">waiter.up = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (signal_pending_state(state, current))</span><br><span class="line"><span class="keyword">goto</span> interrupted;</span><br><span class="line"><span class="keyword">if</span> (unlikely(timeout &lt;= <span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> timed_out;</span><br><span class="line">__set_current_state(state);</span><br><span class="line">raw_spin_unlock_irq(&amp;sem-&gt;lock);</span><br><span class="line">timeout = schedule_timeout(timeout);</span><br><span class="line">raw_spin_lock_irq(&amp;sem-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (waiter.up)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> timed_out:</span><br><span class="line">list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line"> interrupted:</span><br><span class="line">list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>raw_spin_lock_irqsave</code>加锁</p></li><li><p>如果<code>count</code>的值大于0，则将信号量的<code>count</code>值减一，如果<code>count</code>的值小于等于0，则会去执行<code>__down</code>函数，最终会去调用到<code>__down_common</code>函数，传入的参数为<code>TASK_UNINTERRUPTIBLE</code>和<code>MAX_SCHEDULE_TIMEOUT</code></p><ul><li><code>TASK_UNINTERRUPTIBLE</code>：线程已经进入睡眠状态，且不可被打断</li><li><code>MAX_SCHEDULE_TIMEOUT</code>：线程调度超时时间</li></ul></li><li><p>如果进入了<code>__down_common</code>函数就说明当前的线程拿不到信号量，那么当前线程应该干嘛呢，肯定不能傻傻的干等，因此当前线程会休眠，当持有信号量的线程释放信号量后再通知阻塞在此信号量的线程从而将其唤醒去执行，<code>__down_common</code>函数就是在做这一件事情</p><ul><li><p>首先定了一个<code>semaphore_waiter</code>，包含一个链表节点和一个<code>task_struct</code>，<code>task_struct</code>可用于代表当前线程，<code>current</code>就代表了当前线程的<code>task_struct</code>的指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="type">bool</span> up;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">waiter.task = current;</span><br><span class="line">waiter.up = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后调用<code>list_add_tail(&amp;waiter.list, &amp;*sem*-&gt;wait_list);</code>将这个<code>semaphore_waiter</code>挂载在信号量的<code>wait_list</code>链表上，因此当持有信号量的线程释放后就可以通过这个等待链表去唤醒其他阻塞的线程，唤醒其实就是将这个<code>bool</code>的<code>up</code>值置为<code>true</code></p></li><li><p>在<code>for</code>循环内部，会先去调用<code>signal_pending_state</code>去检测线程在当前状态下是否有信号需要处理，我们出入的进程状态为<code>TASK_UNINTERRUPTIBLE</code>，即在此状态下有信号需要处理也需要返回。</p></li><li><p>然后由于传入的<code>MAX_SCHEDULE_TIMEOUT</code>是一个很大的值，因此<code>timed_out</code>应该也是不会超时的</p></li><li><p>调用<code>__set_current_state</code>来设置当前线程的状态</p></li><li><p><code>raw_spin_unlock_irq</code>解锁，这里为什么要先解锁呢，那是因为下面执行的<code>schedule_timeout</code>会导致当前的线程睡眠，而自旋锁保护的临界资源是不允许睡眠的，<code>schedule_timeout</code>是去执行调度切换当前线程，再次切换回来后会去执行<code>raw_spin_lock_irq</code>加锁操作，然后去判断<code>waiter.up</code>是否为<code>true</code>如果为<code>true</code>说明当前线程被唤醒否则继续执行<code>for</code>循环一直等</p></li></ul></li><li><p>调用<code>raw_spin_unlock_irqrestore</code>开锁</p></li></ul><p>解锁操作，即<code>up</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/semaphore.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list)))</span><br><span class="line">sem-&gt;count++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__up(sem);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __up(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> =</span> list_first_entry(&amp;sem-&gt;wait_list,</span><br><span class="line"><span class="keyword">struct</span> semaphore_waiter, <span class="built_in">list</span>);</span><br><span class="line">list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">waiter-&gt;up = <span class="literal">true</span>;</span><br><span class="line">wake_up_process(waiter-&gt;task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先判断信号量的等待链表是否为空，如果等待的线程为空则直接将<code>count</code>值加一</li><li>不为空去执行<code>__up</code>函数，可以看见在此函数内部就是从等待链表上先取出一个等待的线程，然后从等待链表中删除，将此线程的<code>up </code>置为<code>true</code>，最后去唤醒此线程</li></ul><p>最后说一下这里的加锁操作我们使用的是<code>raw_spin_lock_irqsave</code>，它和我们上面讲自旋锁使用的<code>spin_unlock</code>的区别就在于加了<code>irq</code>的会去禁用本地中断，我们以多核系统为例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock_irq(lock)_raw_spin_lock_irq(lock)</span></span><br><span class="line"><span class="comment">// spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock_irq(lock) __raw_spin_lock_irq(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock_irq(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">local_irq_disable();</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">acquires</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">__acquire(lock);</span><br><span class="line">arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看见只是在<code>__raw_spin_lock_irq</code>中会去调用<code>local_irq_disable();</code>禁止本地中断，然后最后会去调用<code>arch_spin_lock</code>加锁</li><li>在使用<code>spin_lock</code>时要明确知道该锁不会在中断处理程序中使用,如果在中断处理程序中也使用了&#96;&#96;spin_lock<code>就会导致死锁，在任何情况下使用</code>spin_lock_irq&#96;都是安全的。因为它既禁止本地中断，又禁止内核抢占。</li></ul><h2 id="4-互斥锁"><a href="#4-互斥锁" class="headerlink" title="4. 互斥锁"></a>4. 互斥锁</h2><p>内核中以<code>mutex</code>结构体来表示互斥体，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;mutex.h”文件中，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line"><span class="type">atomic_long_t</span>owner;</span><br><span class="line"><span class="type">spinlock_t</span>wait_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line"><span class="type">void</span>*magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span><span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>可以看见互斥锁的实现其实和信号量类似，不同的是互斥锁在任何时刻只会有一个线程可以持有锁，而信号量可以多个，在互斥锁的内部同样有一个挂载等待线程的链表<code>wait_list</code>，以及一个原子变量<code>owner</code></li><li>包含一个互斥锁用于加锁操作</li></ul><p>一些和互斥体相关的 API 函数也定义在 <code>mutex.h</code> 文件中，常用 API 函数如下所示</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_MUTEX(name)</code></td><td>定义并初始化一个 mutex 变量。</td></tr><tr><td><code>void mutex_init(mutex *lock)</code></td><td>初始化 mutex。</td></tr><tr><td><code>void mutex_lock(struct mutex *lock)</code></td><td>获取 mutex，也就是给 mutex 上锁。</td></tr><tr><td><code>void mutex_unlock(struct mutex *lock)</code></td><td>释放 mutex，也就给 mutex 解锁。</td></tr><tr><td><code>int mutex_is_locked(struct mutex *lock)</code></td><td>判断 mutex 是否被获取，如果是的话就返回1，否则返回0</td></tr></tbody></table><p>初始化和加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/mutex.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">&#123; .owner = ATOMIC_LONG_INIT(0) \</span></span><br><span class="line"><span class="meta">, .wait_lock = __SPIN_LOCK_UNLOCKED(lockname.wait_lock) \</span></span><br><span class="line"><span class="meta">, .wait_list = LIST_HEAD_INIT(lockname.wait_list) \</span></span><br><span class="line"><span class="meta">__DEBUG_MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">__DEP_MAP_MUTEX_INITIALIZER(lockname) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_MUTEX(mutexname) \</span></span><br><span class="line"><span class="meta">struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mutex_init(mutex)\</span></span><br><span class="line"><span class="meta">do &#123;\</span></span><br><span class="line"><span class="meta">static struct lock_class_key __key;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">__mutex_init((mutex), #mutex, &amp;__key);\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line"><span class="type">void</span> __mutex_init(<span class="keyword">struct</span> mutex *lock, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">atomic_long_set(&amp;lock-&gt;owner, <span class="number">0</span>);</span><br><span class="line">spin_lock_init(&amp;lock-&gt;wait_lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;lock-&gt;wait_list);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">osq_lock_init(&amp;lock-&gt;osq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">debug_mutex_init(lock, name, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DEFINE_MUTEX</code>宏会去调用<code>__MUTEX_INITIALIZER</code>来定义和初始化一个互斥锁，将互斥锁的<code>owner</code>赋值为0，初始化互斥锁和等待链表</li><li><code>mutex_init</code>宏会去调用<code>__mutex_init</code>，同样内部会先将<code>owner</code>的值设置为0，初始化互斥锁，初始化等待链表</li></ul><p>加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_lock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!__mutex_trylock_fast(lock))</span><br><span class="line">__mutex_lock_slowpath(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span> __mutex_trylock_fast(<span class="keyword">struct</span> mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> curr = (<span class="type">unsigned</span> <span class="type">long</span>)current;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> zero = <span class="number">0UL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (atomic_long_try_cmpxchg_acquire(&amp;lock-&gt;owner, &amp;zero, curr))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched</span><br><span class="line">__mutex_lock_slowpath(<span class="keyword">struct</span> mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">__mutex_lock(lock, TASK_UNINTERRUPTIBLE, <span class="number">0</span>, <span class="literal">NULL</span>, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __sched</span><br><span class="line">__mutex_lock(<span class="keyword">struct</span> mutex *lock, <span class="type">long</span> state, <span class="type">unsigned</span> <span class="type">int</span> subclass,</span><br><span class="line">     <span class="keyword">struct</span> lockdep_map *nest_lock, <span class="type">unsigned</span> <span class="type">long</span> ip)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __mutex_lock_common(lock, state, subclass, nest_lock, ip, <span class="literal">NULL</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>might_sleep();</code>不用管，如果没有调试的需要(没有定义CONFIG_DEBUG_ATOMIC_SLEEP)，这个宏&#x2F;函数什么事情都不，might_sleep就是一个空函数，所以平常看code的时候可以忽略。内核只是用它来提醒开发人员，调用该函数的函数可能会sleep。</p></li><li><p>然后调用<code>__mutex_trylock_fast(*lock*)</code>去快速加锁</p><p>fast 部分的代码相对比较简单，主要是两步：</p><ul><li>获取当前进程的<code> task_stuct</code> 指针，<code>current</code>是当前线程的<code>tcb</code>指针</li><li>调用 <code>atomic_long_cmpxchg_acquire</code> 函数尝试更新<code> lock-&gt;owner</code>,这个函数是一个原子操作函数，因为 <code>lock-&gt;owner</code> 是全局变量，所以这里需要用到原子操作。这个接口的定义为：将 p1 (第一个参数)和 p2 作比较，如果相等，则 p1&#x3D;p3，返回 p2，否则不执行赋值，直接返回 p1，类似于c++的CAS操作</li></ul><p>当 <code>lock-&gt;owner</code> 为 0 时，表示既没有其它进程获取锁也没有等待者,就可以直接获取到锁并返回。否则就代表有其他线程持有锁。此时就需要加上慢锁了</p></li><li><p><code>__mutex_lock_slowpath</code>会去调用<code>__mutex_lock</code>，然后调用<code>__mutex_lock_common</code>，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock a mutex (possibly interruptible), slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> __sched</span><br><span class="line">__mutex_lock_common(<span class="keyword">struct</span> mutex *lock, <span class="type">long</span> state, <span class="type">unsigned</span> <span class="type">int</span> subclass,</span><br><span class="line">    <span class="keyword">struct</span> lockdep_map *nest_lock, <span class="type">unsigned</span> <span class="type">long</span> ip,</span><br><span class="line">    <span class="keyword">struct</span> ww_acquire_ctx *ww_ctx, <span class="type">const</span> <span class="type">bool</span> use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ww_mutex</span> *<span class="title">ww</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx)</span><br><span class="line">ww_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line">ww = container_of(lock, <span class="keyword">struct</span> ww_mutex, base);</span><br><span class="line"><span class="keyword">if</span> (ww_ctx) &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(ww_ctx == READ_ONCE(ww-&gt;ctx)))</span><br><span class="line"><span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the wounded flag after a kill. No other process can</span></span><br><span class="line"><span class="comment"> * race and wound us here since they can&#x27;t have a valid owner</span></span><br><span class="line"><span class="comment"> * pointer if we don&#x27;t have any locks held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ww_ctx-&gt;acquired == <span class="number">0</span>)</span><br><span class="line">ww_ctx-&gt;wounded = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preempt_disable();</span><br><span class="line">mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    mutex_optimistic_spin(lock, ww_ctx, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="comment">/* got the lock, yay! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">ww_mutex_set_context_fastpath(ww, ww_ctx);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After waiting to acquire the wait_lock, try again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> skip_wait;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx) &#123;</span><br><span class="line"><span class="comment">/* add waiting tasks to the end of the waitqueue (FIFO): */</span></span><br><span class="line">__mutex_add_waiter(lock, &amp;waiter, &amp;lock-&gt;wait_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">waiter.ww_ctx = MUTEX_POISON_WW_CTX;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add in stamp order, waking up waiters that must kill</span></span><br><span class="line"><span class="comment"> * themselves.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = __ww_mutex_add_waiter(&amp;waiter, lock, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_early_kill;</span><br><span class="line"></span><br><span class="line">waiter.ww_ctx = ww_ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waiter.task = current;</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">bool</span> first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Once we hold wait_lock, we&#x27;re serialized against</span></span><br><span class="line"><span class="comment"> * mutex_unlock() handing the lock off to us, do a trylock</span></span><br><span class="line"><span class="comment"> * before testing the error conditions to make sure we pick up</span></span><br><span class="line"><span class="comment"> * the handoff.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock))</span><br><span class="line"><span class="keyword">goto</span> acquired;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check for signals and kill conditions while holding</span></span><br><span class="line"><span class="comment"> * wait_lock. This ensures the lock cancellation is ordered</span></span><br><span class="line"><span class="comment"> * against mutex_unlock() and wake-ups do not go missing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal_pending_state(state, current))) &#123;</span><br><span class="line">ret = -EINTR;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx) &#123;</span><br><span class="line">ret = __ww_mutex_check_kill(lock, &amp;waiter, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line"></span><br><span class="line">first = __mutex_waiter_is_first(lock, &amp;waiter);</span><br><span class="line"><span class="keyword">if</span> (first)</span><br><span class="line">__mutex_set_flag(lock, MUTEX_FLAG_HANDOFF);</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Here we order against unlock; we must either see it change</span></span><br><span class="line"><span class="comment"> * state back to RUNNING and fall through the next schedule(),</span></span><br><span class="line"><span class="comment"> * or we must see its unlock and acquire.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    (first &amp;&amp; mutex_optimistic_spin(lock, ww_ctx, &amp;waiter)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">&#125;</span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">acquired:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wound-Wait; we stole the lock (!first_waiter), check the</span></span><br><span class="line"><span class="comment"> * waiters as anyone might want to wound us.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ww_ctx-&gt;is_wait_die &amp;&amp;</span><br><span class="line">    !__mutex_waiter_is_first(lock, &amp;waiter))</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__mutex_remove_waiter(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line"></span><br><span class="line">skip_wait:</span><br><span class="line"><span class="comment">/* got the lock - cleanup and rejoice! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">ww_mutex_lock_acquired(ww, ww_ctx);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">__mutex_remove_waiter(lock, &amp;waiter);</span><br><span class="line">err_early_kill:</span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于此函数的分析请参考如下博文，后续有时间再去看代码</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/364130923">linux同步机制 - mutex lock - 知乎 (zhihu.com)</a></p></blockquote></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://blog.csdn.net/weixin_42135087/article/details/123165545">02-Linux Kernel(armv8-aarch64)的原子操作的底层实现</a></li><li><a href="https://www.zhihu.com/tardis/zm/art/89299392?source_id=1005">读写一气呵成 - Linux中的原子操作 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/weixin_42135087/article/details/123165545">02-Linux Kernel(armv8-aarch64)的原子操作的底层实现_在aarch64多核体系结构中,以下哪一条汇编指令可以用于进行原子操作-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/115748853">Linux 单&#x2F;多处理器下的内核同步与实现—自旋锁 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/wh_19910525/article/details/11536279">Linux内核spin_lock、spin_lock_irq 和 spin_lock_irqsave 分析-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 原子变量 </tag>
            
            <tag> 自旋锁 </tag>
            
            <tag> 信号量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Quard-star移植FreeRTOS-移植代码构建</title>
      <link href="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/"/>
      <url>/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="移植FreeRTOS"><a href="#移植FreeRTOS" class="headerlink" title="移植FreeRTOS"></a>移植FreeRTOS</h1><h2 id="1-内存布局与移植代码架构"><a href="#1-内存布局与移植代码架构" class="headerlink" title="1. 内存布局与移植代码架构"></a>1. 内存布局与移植代码架构</h2><h3 id="1-1-内存启动地址修改"><a href="#1-1-内存启动地址修改" class="headerlink" title="1.1 内存启动地址修改"></a>1.1 内存启动地址修改</h3><p>之前我们通过<code>OpenSBI</code>划分了<code>Domain</code>，<code>HART7</code>是留给<code>FreeRTOS</code>的，起始地址设置为了<code>0xb0000000</code>，我们修改一下，将<code>FreeRTOS</code>的起始地址设置为<code>0xBF800000</code>，第一个修改的代码为<code>boot</code>的<code>start.s</code></p><blockquote><p><a href="https://yanglianoo.github.io/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/">基于opensbi为quard_star创建domain | TimerのBlog (yanglianoo.github.io)</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//load trusted_fw.bin</span><br><span class="line">//[0x20400000:0x20800000] --&gt; [0xBF800000:0xBFC00000]</span><br><span class="line">   lia0,0x204</span><br><span class="line">sllia0,a0, 20      //a0 = 0x20400000</span><br><span class="line">   lia1,0xbf8</span><br><span class="line">sllia1,a1, 20      //a1 = 0xbf800000</span><br><span class="line">   lia2,0xbfc</span><br><span class="line">sllia2,a2, 20      //a2 = 0xbfc00000</span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure><p><code>trusted_fw.bin</code>我们是写入到<code>flash</code>的<code>0x20400000</code>地址处的，大小为<code>4k</code></p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240419174122744.png" alt="image-20240419174122744"></p><p>然后需要对应修改设备树的下级跳转地址：</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240419174900634.png" alt="image-20240419174900634"></p><p>可以看见在设备树中将<code>trusted-domain</code>的启动地址设置成了<code>0xBF800000</code>，启动的核为<code>cpu7</code>，<code>next-mode = 1</code>代表下级程序启动的<code>cpu</code>模式为<code>s</code>模式，我们是将<code>FreeRTOS</code>移植到<code>S</code>态而不是<code>M</code>态</p><h3 id="1-2-移植文件架构"><a href="#1-2-移植文件架构" class="headerlink" title="1.2 移植文件架构"></a>1.2 移植文件架构</h3><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240419175317425.png" alt="image-20240419175317425"></p><p>原本<code>trusted_domain</code>目录下就只有<code>statup.S</code>和一个<code>Makefile</code>用于在<code>uart2</code>上输出一些字符，添加移植文件后文件夹中文件如上图：</p><ul><li><code>driver</code>：串口驱动代码</li><li><code>FreeRTOS-Kernel</code>: FreeRTOS内核代码</li><li><code>riscv</code>：和<code>riscv</code>架构相关的代码</li><li><code>FreeRTOSConfig.h</code>：FreeRTOS的配置文件</li><li><code>main.c</code>：主应用程序</li><li><code>Makefile，link.lds</code>：编译<code>trusted_domain</code>编译规则和链接文件</li><li><code>startup.S</code>：启动汇编，执行一些初始化工作然后跳转到FreeRTOS内核</li></ul><h2 id="2-平台架构相关代码剖析"><a href="#2-平台架构相关代码剖析" class="headerlink" title="2. 平台架构相关代码剖析"></a>2. 平台架构相关代码剖析</h2><h3 id="2-1-driver"><a href="#2-1-driver" class="headerlink" title="2.1 driver"></a>2.1 driver</h3><p>在进行<code>domain</code>划分时，设备树文件有这样一个配置：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stdout</span>-path = <span class="string">&quot;/soc/uart0@10000000&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里是告知<code>OpenSBI</code>标准输出将被重定向到位于内存地址 <code>0x10000000</code> 的UART设备上，这个<code>uart</code>设备我们在下面定义了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uart0: uart0@<span class="number">10000000</span> &#123;</span><br><span class="line">interrupts = &lt;<span class="number">0xa</span>&gt;;</span><br><span class="line">interrupt-parent = &lt;<span class="number">0x11</span>&gt;;</span><br><span class="line">clock-frequency = &lt;<span class="number">0x384000</span>&gt;;</span><br><span class="line">reg = &lt;<span class="number">0x0</span> <span class="number">0x10000000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">compatible = <span class="string">&quot;ns16550a&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>cpu7</code>即<code>trusted_domain</code>的配置中，我们使用的是<code>uart2</code>，因此我们需要手动编写<code>uart2</code>的串口驱动代码而不是使用<code>OpenSBI</code>的标准输入输出串口，<code>uart0</code>已经被我们的<code>TimerOS</code>使用了，根据设备树可知，<code>uart2</code>是<code>ns16550a</code>这款芯片，<code>qemu</code>默认的虚拟串口也是使用的这款芯片，我们先来看看这款串口芯片的芯片手册：</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240420150457253.png" alt="image-20240420150457253"></p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240420145859088.png" alt="image-20240420145859088"></p><ul><li>总共有10个寄存器，但是有的寄存器是可以复用的，<code>A2 A1 A0</code>代表此寄存器的映射地址，实际去操作此寄存器的时候需要加上串口设备的偏移地址，这里是<code>uart2 : 0x10002000</code>，每个寄存器都是8个bit</li></ul><blockquote><p><code>ns16550a</code>串口芯片的编程手册我放在了<code>ref</code>目录下，可以去看看这个视频：<a href="https://www.bilibili.com/video/BV1Q5411w7z5?p=17&vd_source=1325a6af2d360c06e8e0c5e177802b1b">第7章（下）-Hello RVOS_哔哩哔哩_bilibili</a></p></blockquote><p>接下来来看看<code>driver</code>目录下的代码：</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240420151441701.png" alt="image-20240420151441701"></p><p><code>quard_star.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUARD_STAR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONS(NUM, TYPE)NUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONS(NUM, TYPE)NUM##TYPE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIM_HART7   <span class="comment">//cpu的启动核</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_ADDRCONS(0x02000000, UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MSIPCONS(0x0000, UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECMPCONS(0x4000, UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECONS(0xbff8, UL)</span></span><br><span class="line"><span class="comment">//NS16550 串口映射的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NS16550_ADDRCONS(0x10002000, UL)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>定义了一些宏定义的值，主要是<code>#define NS16550_ADDRCONS(0x10002000, UL)</code>定义了串口的映射地址</li></ul><p><code>ns16550.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns16550.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 寄存器定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_RBR0x00 <span class="comment">/* Receiver buffer reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_THR0x00 <span class="comment">/* Transmitter holding reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_IER0x01 <span class="comment">/* Interrupt enable reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_IIR0x02 <span class="comment">/* Interrupt ID reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_FCR0x02 <span class="comment">/* FIFO control reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_LCR0x03 <span class="comment">/* Line control reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_MCR0x04 <span class="comment">/* Modem control reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_LSR0x05 <span class="comment">/* Line status reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_MSR0x06 <span class="comment">/* Modem status reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_SCR0x07 <span class="comment">/* Scratch reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_BRDL0x00 <span class="comment">/* Divisor latch (LSB) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_BRDH0x01 <span class="comment">/* Divisor latch (MSB) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Line status */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_DR 0x01  <span class="comment">/* Data ready */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_OE 0x02  <span class="comment">/* Overrun error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_PE 0x04  <span class="comment">/* Parity error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_FE 0x08  <span class="comment">/* Framing error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_BI 0x10  <span class="comment">/* Break interrupt */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_THRE 0x20 <span class="comment">/* Transmitter holding register empty */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TEMT 0x40 <span class="comment">/* Transmitter empty */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_EIRF 0x80 <span class="comment">/* Error in RCVR FIFO */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从一个地址读入一个字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">readb</span><span class="params">( <span class="type">uintptr_t</span> addr )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *( (<span class="type">uint8_t</span> *) addr );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向一个地址写入一个字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">writeb</span><span class="params">( <span class="type">uint8_t</span> b, <span class="type">uintptr_t</span> addr )</span></span><br><span class="line">&#123;</span><br><span class="line">*( (<span class="type">uint8_t</span> *) addr ) = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns16550_tx</span><span class="params">(<span class="type">uintptr_t</span> addr, <span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读数据和写数据用的同一个寄存器</span></span><br><span class="line">    <span class="keyword">while</span> ((readb(addr + REG_LSR) &amp; LSR_THRE) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//正在读，轮询等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    writeb(c, addr + REG_THR);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>定义了<code>ns16550_tx</code>函数来向串口写入一个字节的数据，<code>NS16550</code>的数据寄存器为<code>RHR</code>和<code>THR</code>，他们都在偏移地址为0处，可复用为读模式和写模式</p></li><li><p><code>LSR</code>寄存器有8个bit位，用于反应串口的硬件状态，<code>bit5</code>具体代表“Transmitter Holding Register Empty”，当<code>LSR_THRE</code>为1时，它表示发送保持寄存器为空，UART准备好接受新的字节进行发送。因此在<code>ns16550_tx</code>发送数据时需要先判断此bit位，当此bit位为1时说明可以写入新的字节数据，<code>THR</code>8个bit刚好代表一个字节，写入的一个字节数据就放入了<code>THR</code></p></li></ul><p><code>debug_log.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quard_star.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns16550.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_LOG_BUFF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _puts(<span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*str &amp;&amp; (counter &lt; UART_LOG_BUFF_SIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        ns16550_tx( NS16550_ADDR, <span class="string">&#x27;\r&#x27;</span> );</span><br><span class="line">    ns16550_tx( NS16550_ADDR, *str++ );</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>debug_log.c</code>中定义了一个<code> _puts</code>函数用于将一个字符串一个字节一个字节的写入到串口中进行输出，返回输出的字符数</li></ul><h3 id="2-2-riscv"><a href="#2-2-riscv" class="headerlink" title="2.2 riscv"></a>2.2 riscv</h3><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240420164504237.png" alt="image-20240420164504237"></p><p><code>riscv</code>目录下是和架构以及<code>OpenSBI</code>相关的代码，我们在移植FreeRTOS到<code>cpu7</code>的S态时需要用到<code>OpenSBI</code>的一些和中断相关的功能，因此需要首先添加调用<code>OpenSBI</code>服务的代码：<code>sbi.c</code>和<code>sbi.h</code>，这里我直接给出代码，和之前<code>Timeros</code>一样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_RISCV_SBI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_RISCV_SBI_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_id</span> &#123;</span></span><br><span class="line">SBI_EXT_0_1_SET_TIMER = <span class="number">0x0</span>,</span><br><span class="line">SBI_EXT_0_1_CONSOLE_PUTCHAR = <span class="number">0x1</span>,</span><br><span class="line">SBI_EXT_0_1_CONSOLE_GETCHAR = <span class="number">0x2</span>,</span><br><span class="line">SBI_EXT_0_1_CLEAR_IPI = <span class="number">0x3</span>,</span><br><span class="line">SBI_EXT_0_1_SEND_IPI = <span class="number">0x4</span>,</span><br><span class="line">SBI_EXT_0_1_REMOTE_FENCE_I = <span class="number">0x5</span>,</span><br><span class="line">SBI_EXT_0_1_REMOTE_SFENCE_VMA = <span class="number">0x6</span>,</span><br><span class="line">SBI_EXT_0_1_REMOTE_SFENCE_VMA_ASID = <span class="number">0x7</span>,</span><br><span class="line">SBI_EXT_0_1_SHUTDOWN = <span class="number">0x8</span>,</span><br><span class="line">SBI_EXT_BASE = <span class="number">0x10</span>,</span><br><span class="line">SBI_EXT_TIME = <span class="number">0x54494D45</span>,</span><br><span class="line">SBI_EXT_IPI = <span class="number">0x735049</span>,</span><br><span class="line">SBI_EXT_RFENCE = <span class="number">0x52464E43</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_base_fid</span> &#123;</span></span><br><span class="line">SBI_EXT_BASE_GET_SPEC_VERSION = <span class="number">0</span>,</span><br><span class="line">SBI_EXT_BASE_GET_IMP_ID,</span><br><span class="line">SBI_EXT_BASE_GET_IMP_VERSION,</span><br><span class="line">SBI_EXT_BASE_PROBE_EXT,</span><br><span class="line">SBI_EXT_BASE_GET_MVENDORID,</span><br><span class="line">SBI_EXT_BASE_GET_MARCHID,</span><br><span class="line">SBI_EXT_BASE_GET_MIMPID,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_time_fid</span> &#123;</span></span><br><span class="line">SBI_EXT_TIME_SET_TIMER = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_ipi_fid</span> &#123;</span></span><br><span class="line">SBI_EXT_IPI_SEND_IPI = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_rfence_fid</span> &#123;</span></span><br><span class="line">SBI_EXT_RFENCE_REMOTE_FENCE_I = <span class="number">0</span>,</span><br><span class="line">SBI_EXT_RFENCE_REMOTE_SFENCE_VMA,</span><br><span class="line">SBI_EXT_RFENCE_REMOTE_SFENCE_VMA_ASID,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_EXT_SET_TIMERSBI_EXT_TIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_SET_TIMERSBI_EXT_TIME_SET_TIMER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_EXT_SEND_IPISBI_EXT_IPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_SEND_IPISBI_EXT_IPI_SEND_IPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_EXT_REMOTE_FENCE_ISBI_EXT_RFENCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_REMOTE_FENCE_ISBI_EXT_RFENCE_REMOTE_FENCE_I</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_EXT_REMOTE_SFENCE_VMASBI_EXT_RFENCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_REMOTE_SFENCE_VMASBI_EXT_RFENCE_REMOTE_SFENCE_VMA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_EXT_REMOTE_SFENCE_VMA_ASIDSBI_EXT_RFENCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_REMOTE_SFENCE_VMA_ASIDSBI_EXT_RFENCE_REMOTE_SFENCE_VMA_ASID</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SBI return error codes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_SUCCESS         0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_ERR_FAILURE    -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_ERR_NOT_SUPPORTED-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_ERR_INVALID_PARAM-3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_ERR_DENIED    -4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_ERR_INVALID_ADDRESS-5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> &#123;</span></span><br><span class="line"><span class="type">long</span> error;</span><br><span class="line"><span class="type">long</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> sbiret <span class="title function_">sbi_ecall</span><span class="params">(<span class="type">int</span> ext, <span class="type">int</span> fid, <span class="type">unsigned</span> <span class="type">long</span> arg0,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg1, <span class="type">unsigned</span> <span class="type">long</span> arg2,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg3, <span class="type">unsigned</span> <span class="type">long</span> arg4,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_console_getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_set_timer</span><span class="params">(<span class="type">uint64_t</span> stime_value)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">sbi_get_spec_version</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_get_impl_id</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_probe_extension</span><span class="params">(<span class="type">int</span> ext)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_clear_ipi</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_shutdown</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_send_ipi</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_fence_i</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_sfence_vma</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_sfence_vma_asid</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> size,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> asid)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> sbiret <span class="title function_">sbi_ecall</span><span class="params">(<span class="type">int</span> ext, <span class="type">int</span> fid, <span class="type">unsigned</span> <span class="type">long</span> arg0,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg1, <span class="type">unsigned</span> <span class="type">long</span> arg2,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg3, <span class="type">unsigned</span> <span class="type">long</span> arg4,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg5)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用GCC的扩展语法，用于将一个值存储到RISC-V架构中的寄存器a0中。</span></span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a0 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a0&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg0);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a1 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a1&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg1);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a2 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a2&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg2);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a3 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a3&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg3);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a4 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a4&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg4);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a5 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a5&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg5);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a6 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a6&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(fid);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a7 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a7&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(ext);</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ecall&quot;</span></span></span><br><span class="line"><span class="params">      : <span class="string">&quot;+r&quot;</span> (a0), <span class="string">&quot;+r&quot;</span> (a1)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a3), <span class="string">&quot;r&quot;</span> (a4), <span class="string">&quot;r&quot;</span> (a5), <span class="string">&quot;r&quot;</span> (a6), <span class="string">&quot;r&quot;</span> (a7)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">ret.error = a0;</span><br><span class="line">ret.value = a1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_set_timer() - Program the timer for next timer event.</span></span><br><span class="line"><span class="comment"> * @stime_value: The value after which next timer event should fire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_set_timer</span><span class="params">(<span class="type">uint64_t</span> stime_value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 32</span></span><br><span class="line">sbi_ecall(SBI_EXT_SET_TIMER, SBI_FID_SET_TIMER, stime_value,</span><br><span class="line">  stime_value &gt;&gt; <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">sbi_ecall(SBI_EXT_SET_TIMER, SBI_FID_SET_TIMER, stime_value,</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_get_spec_version() - get current SBI specification version</span></span><br><span class="line"><span class="comment"> * 获取SBI规范版本 (FID #0)</span></span><br><span class="line"><span class="comment"> * Return: version id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sbi_get_spec_version</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">ret = sbi_ecall(SBI_EXT_BASE, SBI_EXT_BASE_GET_SPEC_VERSION,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret.error)</span><br><span class="line"><span class="keyword">if</span> (ret.value)</span><br><span class="line"><span class="keyword">return</span> ret.value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_get_impl_id() - get SBI implementation ID</span></span><br><span class="line"><span class="comment"> * 获取SBI规范版本 (FID #0)  基本拓展 EID = 0x10</span></span><br><span class="line"><span class="comment"> * Return: implementation ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_get_impl_id</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">ret = sbi_ecall(SBI_EXT_BASE, SBI_EXT_BASE_GET_IMP_ID,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret.error)</span><br><span class="line"><span class="keyword">if</span> (ret.value)</span><br><span class="line"><span class="keyword">return</span> ret.value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_probe_extension() - Check if an SBI extension ID is supported or not.</span></span><br><span class="line"><span class="comment"> * @extid: The extension ID to be probed.</span></span><br><span class="line"><span class="comment"> *  探测SBI扩展功能 (FID #3) 基本拓展 EID = 0x10</span></span><br><span class="line"><span class="comment"> * Return: Extension specific nonzero value f yes, -1 otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_probe_extension</span><span class="params">(<span class="type">int</span> extid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">ret = sbi_ecall(SBI_EXT_BASE, SBI_EXT_BASE_PROBE_EXT, extid,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret.error)</span><br><span class="line"><span class="keyword">if</span> (ret.value)</span><br><span class="line"><span class="keyword">return</span> ret.value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_console_putchar() - Writes given character to the console device.</span></span><br><span class="line"><span class="comment"> * @ch: The data to be written to the console.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_0_1_CONSOLE_PUTCHAR, <span class="number">0</span>, ch, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_console_getchar() - Reads a byte from console device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the value read from console.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_console_getchar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">ret = sbi_ecall(SBI_EXT_0_1_CONSOLE_GETCHAR, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret.error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_clear_ipi() - Clear any pending IPIs for the calling hart.</span></span><br><span class="line"><span class="comment"> * 清除IPI (EID #0x03) 清除任何挂起的IPI（处理器核间中断）。</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_clear_ipi</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_0_1_CLEAR_IPI, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_shutdown() - Remove all the harts from executing supervisor code.</span></span><br><span class="line"><span class="comment"> * 系统关闭 (EID #0x08)</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_shutdown</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_0_1_SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_send_ipi() - Send an IPI to any hart.</span></span><br><span class="line"><span class="comment"> * @hart_mask: A cpu mask containing all the target harts.</span></span><br><span class="line"><span class="comment"> * 向 hart_mask 中定义的所有 hart 发送跨处理器中断。</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_send_ipi</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_SEND_IPI, SBI_FID_SEND_IPI, (<span class="type">unsigned</span> <span class="type">long</span>)hart_mask,</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_remote_fence_i() - Execute FENCE.I instruction on given remote harts.</span></span><br><span class="line"><span class="comment"> * @hart_mask: A cpu mask containing all the target harts.</span></span><br><span class="line"><span class="comment"> * 远程指示harts执行FENCE.I指令</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_fence_i</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_REMOTE_FENCE_I, SBI_FID_REMOTE_FENCE_I,</span><br><span class="line">  (<span class="type">unsigned</span> <span class="type">long</span>)hart_mask, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_remote_sfence_vma() - Execute SFENCE.VMA instructions on given remote</span></span><br><span class="line"><span class="comment"> *     harts for the specified virtual address range.</span></span><br><span class="line"><span class="comment"> * @hart_mask: A cpu mask containing all the target harts.</span></span><br><span class="line"><span class="comment"> * @start: Start of the virtual address</span></span><br><span class="line"><span class="comment"> * @size: Total size of the virtual address range.</span></span><br><span class="line"><span class="comment"> * 指示远程hart执行一个或多个SFENCE.VMA指令，覆盖从start到size的虚拟地址范围内的地址。</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_sfence_vma</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_REMOTE_SFENCE_VMA, SBI_FID_REMOTE_SFENCE_VMA,</span><br><span class="line">  (<span class="type">unsigned</span> <span class="type">long</span>)hart_mask, start, size, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_remote_sfence_vma_asid() - Execute SFENCE.VMA instructions on given</span></span><br><span class="line"><span class="comment"> * remote harts for a virtual address range belonging to a specific ASID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @hart_mask: A cpu mask containing all the target harts.</span></span><br><span class="line"><span class="comment"> * @start: Start of the virtual address</span></span><br><span class="line"><span class="comment"> * @size: Total size of the virtual address range.</span></span><br><span class="line"><span class="comment"> * @asid: The value of address space identifier (ASID).</span></span><br><span class="line"><span class="comment"> * 指示远程hart执行一个或多个SFENCE.VMA指令，覆盖从start到size的虚拟地址范围内的地址。这仅涵盖给定的ASID。</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_remote_sfence_vma_asid</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> size,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> asid)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_REMOTE_SFENCE_VMA_ASID,</span><br><span class="line">  SBI_FID_REMOTE_SFENCE_VMA_ASID,</span><br><span class="line">  (<span class="type">unsigned</span> <span class="type">long</span>)hart_mask, start, size, asid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>riscv_reg.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RISCV_REG_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_REG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//__riscv_xlen 是编译器预定义的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGSIZE4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGSHIFT2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOADlw</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORsw</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGSIZE8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGSHIFT3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOADld</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORsd</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __riscv_xlen */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>__riscv_xlen </code>是编译器预定义的宏，使用宏定义的方式来控制在32位和64位平台上编译的统一性</li><li>定义了加载和存储指令以及寄存器大小</li></ul><p><code>sbi_const.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SBI_CONST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SBI_CONST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*提供一种在汇编和C代码之间共享常量定义的便捷方法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AC(X,Y)X</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AT(T,X)X</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AC(X,Y)(X##Y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AC(X,Y)__AC(X,Y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AT(T,X)((T)(X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 UL后缀，定义无符号长整型和无符号长长整型常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UL(x)(_AC(x, UL))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ULL(x)(_AC(x, ULL))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于生成位掩码，方便进行位操作，如设置、清除或检查某位。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BITUL(x)(_UL(1) &lt;&lt; (x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BITULL(x)(_ULL(1) &lt;&lt; (x))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UL(x)(_UL(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL(x)(_ULL(x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将宏参数转换成字符串</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STR(s)#s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRINGIFY(s)__STR(s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>定义了一些宏用于添加符号后缀、生成<code>bitmask</code>、宏参数转换成字符串等功能</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: BSD-2-Clause</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2019 Western Digital Corporation or its affiliates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Authors:</span></span><br><span class="line"><span class="comment"> *   Anup Patel &lt;anup.patel@wdc.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RISCV_ENCODING_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RISCV_ENCODING_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi_const.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clang-format off */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SIE_UL(0x00000002)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MIE_UL(0x00000008)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SPIE_SHIFT5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SPIE(_UL(1) &lt;&lt; MSTATUS_SPIE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_UBE_UL(0x00000040)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPIE_UL(0x00000080)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SPP_SHIFT8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SPP(_UL(1) &lt;&lt; MSTATUS_SPP_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP_SHIFT11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP(_UL(3) &lt;&lt; MSTATUS_MPP_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_FS_UL(0x00006000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_XS_UL(0x00018000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_VS_UL(0x01800000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPRV_UL(0x00020000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SUM_UL(0x00040000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MXR_UL(0x00080000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_TVM_UL(0x00100000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_TW_UL(0x00200000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_TSR_UL(0x00400000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS32_SD_UL(0x80000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_UXL_ULL(0x0000000300000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SXL_ULL(0x0000000C00000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SBE_ULL(0x0000001000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MBE_ULL(0x0000002000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPV_ULL(0x0000008000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUSH_SBE_UL(0x00000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUSH_MBE_UL(0x00000020)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUSH_MPV_UL(0x00000080)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS32_SD_UL(0x80000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS64_SD_ULL(0x8000000000000000)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SIEMSTATUS_SIE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPIE_SHIFTMSTATUS_SPIE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPIEMSTATUS_SPIE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPP_SHIFTMSTATUS_SPP_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPPMSTATUS_SPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_FSMSTATUS_FS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_XSMSTATUS_XS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_VSMSTATUS_VS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SUMMSTATUS_SUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_MXRMSTATUS_MXR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS32_SDMSTATUS32_SD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS64_UXLMSTATUS_UXL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS64_SDMSTATUS64_SD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VSXL_UL(0x300000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VSXL_SHIFT32</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VTSR_UL(0x00400000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VTW_UL(0x00200000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VTVM_UL(0x00100000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VGEIN_UL(0x0003f000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VGEIN_SHIFT12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_HU_UL(0x00000200)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_SPVP_UL(0x00000100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_SPV_UL(0x00000080)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_GVA_UL(0x00000040)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HSTATUS_VSBE_UL(0x00000020)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_S_SOFT1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_VS_SOFT2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_M_SOFT3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_S_TIMER5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_VS_TIMER6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_M_TIMER7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_S_EXT9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_VS_EXT10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_M_EXT11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_S_GEXT12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_SSIP(_UL(1) &lt;&lt; IRQ_S_SOFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_VSSIP(_UL(1) &lt;&lt; IRQ_VS_SOFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_MSIP(_UL(1) &lt;&lt; IRQ_M_SOFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_STIP(_UL(1) &lt;&lt; IRQ_S_TIMER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_VSTIP(_UL(1) &lt;&lt; IRQ_VS_TIMER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_MTIP(_UL(1) &lt;&lt; IRQ_M_TIMER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_SEIP(_UL(1) &lt;&lt; IRQ_S_EXT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_VSEIP(_UL(1) &lt;&lt; IRQ_VS_EXT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_MEIP(_UL(1) &lt;&lt; IRQ_M_EXT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIP_SGEIP(_UL(1) &lt;&lt; IRQ_S_GEXT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIP_SSIPMIP_SSIP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIP_STIPMIP_STIP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_U_UL(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_S_UL(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_M_UL(3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP32_MODE_UL(0x80000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP32_ASID_UL(0x7FC00000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP32_PPN_UL(0x003FFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP64_MODE_ULL(0xF000000000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP64_ASID_ULL(0x0FFFF00000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP64_PPN_ULL(0x00000FFFFFFFFFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_OFF_UL(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_SV32_UL(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_SV39_UL(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_SV48_UL(9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_SV57_UL(10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODE_SV64_UL(11)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_OFF_UL(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_SV32X4_UL(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_SV39X4_UL(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_SV48X4_UL(9)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP32_MODE_SHIFT31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP32_VMID_SHIFT22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP32_VMID_MASK_UL(0x1FC00000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP32_PPN_UL(0x003FFFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP64_MODE_SHIFT60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP64_VMID_SHIFT44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP64_VMID_MASK_ULL(0x03FFF00000000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP64_PPN_ULL(0x00000FFFFFFFFFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_R_UL(0x01)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_W_UL(0x02)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_X_UL(0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_A_UL(0x18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_A_TOR_UL(0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_A_NA4_UL(0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_A_NAPOT_UL(0x18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_L_UL(0x80)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_SHIFT2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_COUNT64</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_ADDR_MASK((_ULL(0x1) &lt;&lt; 54) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMP_ADDR_MASK_UL(0xFFFFFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SDMSTATUS64_SD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SDSSTATUS64_SD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODESATP64_MODE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_PPNHGATP64_PPN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_VMID_SHIFTHGATP64_VMID_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_VMID_MASKHGATP64_VMID_MASK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_SHIFTHGATP64_MODE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_SDMSTATUS32_SD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SDSSTATUS32_SD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_MODESATP32_MODE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_PPNHGATP32_PPN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_VMID_SHIFTHGATP32_VMID_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_VMID_MASKHGATP32_VMID_MASK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HGATP_MODE_SHIFTHGATP32_MODE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== User-level CSRs ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Trap Setup (N-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_USTATUS0x000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UIE0x004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UTVEC0x005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Trap Handling (N-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_USCRATCH0x040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UEPC0x041</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UCAUSE0x042</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UTVAL0x043</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_UIP0x044</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Floating-point CSRs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_FFLAGS0x001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_FRM0x002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_FCSR0x003</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Counters/Timers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_CYCLE0xc00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TIME0xc01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_INSTRET0xc02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER30xc03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER40xc04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER50xc05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER60xc06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER70xc07</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER80xc08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER90xc09</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER100xc0a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER110xc0b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER120xc0c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER130xc0d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER140xc0e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER150xc0f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER160xc10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER170xc11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER180xc12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER190xc13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER200xc14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER210xc15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER220xc16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER230xc17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER240xc18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER250xc19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER260xc1a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER270xc1b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER280xc1c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER290xc1d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER300xc1e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER310xc1f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_CYCLEH0xc80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TIMEH0xc81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_INSTRETH0xc82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER3H0xc83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER4H0xc84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER5H0xc85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER6H0xc86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER7H0xc87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER8H0xc88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER9H0xc89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER10H0xc8a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER11H0xc8b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER12H0xc8c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER13H0xc8d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER14H0xc8e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER15H0xc8f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER16H0xc90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER17H0xc91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER18H0xc92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER19H0xc93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER20H0xc94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER21H0xc95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER22H0xc96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER23H0xc97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER24H0xc98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER25H0xc99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER26H0xc9a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER27H0xc9b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER28H0xc9c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER29H0xc9d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER30H0xc9e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HPMCOUNTER31H0xc9f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Supervisor-level CSRs ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Trap Setup */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SSTATUS0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SEDELEG0x102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIDELEG0x103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIE0x104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_STVEC0x105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SCOUNTEREN0x106</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Trap Handling */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SSCRATCH0x140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SEPC0x141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SCAUSE0x142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_STVAL0x143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIP0x144</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Protection and Translation */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SATP0x180</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Hypervisor-level CSRs ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hypervisor Trap Setup (H-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HSTATUS0x600</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HEDELEG0x602</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HIDELEG0x603</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HIE0x604</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HCOUNTEREN0x606</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HGEIE0x607</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hypervisor Trap Handling (H-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HTVAL0x643</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HIP0x644</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HVIP0x645</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HTINST0x64a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HGEIP0xe12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hypervisor Protection and Translation (H-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HGATP0x680</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hypervisor Counter/Timer Virtualization Registers (H-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HTIMEDELTA0x605</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_HTIMEDELTAH0x615</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Virtual Supervisor Registers (H-extension) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSSTATUS0x200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSIE0x204</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSTVEC0x205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSSCRATCH0x240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSEPC0x241</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSCAUSE0x242</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSTVAL0x243</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSIP0x244</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_VSATP0x280</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Machine-level CSRs ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Information Registers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MVENDORID0xf11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MARCHID0xf12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MIMPID0xf13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHARTID0xf14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Trap Setup */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSTATUS0x300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MISA0x301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MEDELEG0x302</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MIDELEG0x303</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MIE0x304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MTVEC0x305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCOUNTEREN0x306</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSTATUSH0x310</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Trap Handling */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSCRATCH0x340</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MEPC0x341</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCAUSE0x342</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MTVAL0x343</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MIP0x344</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MTINST0x34a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MTVAL20x34b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Memory Protection */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG00x3a0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG10x3a1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG20x3a2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG30x3a3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG40x3a4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG50x3a5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG60x3a6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG70x3a7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG80x3a8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG90x3a9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG100x3aa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG110x3ab</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG120x3ac</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG130x3ad</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG140x3ae</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPCFG150x3af</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR00x3b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR10x3b1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR20x3b2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR30x3b3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR40x3b4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR50x3b5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR60x3b6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR70x3b7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR80x3b8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR90x3b9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR100x3ba</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR110x3bb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR120x3bc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR130x3bd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR140x3be</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR150x3bf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR160x3c0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR170x3c1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR180x3c2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR190x3c3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR200x3c4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR210x3c5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR220x3c6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR230x3c7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR240x3c8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR250x3c9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR260x3ca</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR270x3cb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR280x3cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR290x3cd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR300x3ce</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR310x3cf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR320x3d0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR330x3d1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR340x3d2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR350x3d3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR360x3d4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR370x3d5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR380x3d6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR390x3d7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR400x3d8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR410x3d9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR420x3da</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR430x3db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR440x3dc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR450x3dd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR460x3de</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR470x3df</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR480x3e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR490x3e1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR500x3e2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR510x3e3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR520x3e4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR530x3e5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR540x3e6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR550x3e7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR560x3e8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR570x3e9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR580x3ea</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR590x3eb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR600x3ec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR610x3ed</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR620x3ee</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_PMPADDR630x3ef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Counters/Timers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCYCLE0xb00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MINSTRET0xb02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER30xb03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER40xb04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER50xb05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER60xb06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER70xb07</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER80xb08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER90xb09</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER100xb0a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER110xb0b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER120xb0c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER130xb0d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER140xb0e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER150xb0f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER160xb10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER170xb11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER180xb12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER190xb13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER200xb14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER210xb15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER220xb16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER230xb17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER240xb18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER250xb19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER260xb1a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER270xb1b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER280xb1c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER290xb1d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER300xb1e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER310xb1f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCYCLEH0xb80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MINSTRETH0xb82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER3H0xb83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER4H0xb84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER5H0xb85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER6H0xb86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER7H0xb87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER8H0xb88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER9H0xb89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER10H0xb8a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER11H0xb8b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER12H0xb8c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER13H0xb8d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER14H0xb8e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER15H0xb8f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER16H0xb90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER17H0xb91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER18H0xb92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER19H0xb93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER20H0xb94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER21H0xb95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER22H0xb96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER23H0xb97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER24H0xb98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER25H0xb99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER26H0xb9a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER27H0xb9b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER28H0xb9c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER29H0xb9d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER30H0xb9e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMCOUNTER31H0xb9f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Machine Counter Setup */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCOUNTINHIBIT0x320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT30x323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT40x324</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT50x325</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT60x326</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT70x327</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT80x328</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT90x329</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT100x32a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT110x32b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT120x32c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT130x32d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT140x32e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT150x32f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT160x330</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT170x331</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT180x332</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT190x333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT200x334</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT210x335</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT220x336</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT230x337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT240x338</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT250x339</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT260x33a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT270x33b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT280x33c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT290x33d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT300x33e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MHPMEVENT310x33f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Debug/Trace Registers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TSELECT0x7a0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TDATA10x7a1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TDATA20x7a2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_TDATA30x7a3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Debug Mode Registers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_DCSR0x7b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_DPC0x7b1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_DSCRATCH00x7b2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_DSCRATCH10x7b3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Trap/Exception Causes ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_MISALIGNED_FETCH0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_FETCH_ACCESS0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_ILLEGAL_INSTRUCTION0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_BREAKPOINT0x3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_MISALIGNED_LOAD0x4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_LOAD_ACCESS0x5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_MISALIGNED_STORE0x6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_STORE_ACCESS0x7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_USER_ECALL0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_SUPERVISOR_ECALL0x9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_VIRTUAL_SUPERVISOR_ECALL0xa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_MACHINE_ECALL0xb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_FETCH_PAGE_FAULT0xc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_LOAD_PAGE_FAULT0xd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_STORE_PAGE_FAULT0xf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_FETCH_GUEST_PAGE_FAULT0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_LOAD_GUEST_PAGE_FAULT0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_VIRTUAL_INST_FAULT0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAUSE_STORE_GUEST_PAGE_FAULT0x17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Instruction Encodings ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LB0x3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LB0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LH0x1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LH0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LW0x2003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LW0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LD0x3003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LD0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LBU0x4003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LBU0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LHU0x5003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LHU0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_LWU0x6003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_LWU0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_SB0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_SB0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_SH0x1023</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_SH0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_SW0x2023</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_SW0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_SD0x3023</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_SD0x707f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FLW0x2007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FLW0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FLD0x3007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FLD0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FLQ0x4007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FLQ0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FSW0x2027</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FSW0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FSD0x3027</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FSD0x707f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_FSQ0x4027</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_FSQ0x707f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_LD0x6000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_LD0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_SD0xe000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_SD0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_LW0x4000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_LW0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_SW0xc000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_SW0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_LDSP0x6002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_LDSP0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_SDSP0xe002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_SDSP0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_LWSP0x4002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_LWSP0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_SWSP0xc002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_SWSP0xe003</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FLD0x2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FLD0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FLW0x6000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FLW0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FSD0xa000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FSD0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FSW0xe000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FSW0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FLDSP0x2002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FLDSP0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FSDSP0xa002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FSDSP0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FLWSP0x6002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FLWSP0xe003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_C_FSWSP0xe002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_C_FSWSP0xe003</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MASK_WFI0xffffff00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_MATCH_WFI0x10500000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_16BIT_MASK0x3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_32BIT_MASK0x1c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_IS_16BIT(insn)\</span></span><br><span class="line"><span class="meta">(((insn) &amp; INSN_16BIT_MASK) != INSN_16BIT_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_IS_32BIT(insn)\</span></span><br><span class="line"><span class="meta">(((insn) &amp; INSN_16BIT_MASK) == INSN_16BIT_MASK &amp;&amp; \</span></span><br><span class="line"><span class="meta"> ((insn) &amp; INSN_32BIT_MASK) != INSN_32BIT_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSN_LEN(insn)(INSN_IS_16BIT(insn) ? 2 : 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_REGBYTES3</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_REGBYTES2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGBYTES(1 &lt;&lt; LOG_REGBYTES)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SH_RD7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SH_RS115</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SH_RS220</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SH_RS2C2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RV_X(x, s, n)(((x) &gt;&gt; (s)) &amp; ((1 &lt;&lt; (n)) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_LW_IMM(x)((RV_X(x, 6, 1) &lt;&lt; 2) | \</span></span><br><span class="line"><span class="meta"> (RV_X(x, 10, 3) &lt;&lt; 3) | \</span></span><br><span class="line"><span class="meta"> (RV_X(x, 5, 1) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_LD_IMM(x)((RV_X(x, 10, 3) &lt;&lt; 3) | \</span></span><br><span class="line"><span class="meta"> (RV_X(x, 5, 2) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_LWSP_IMM(x)((RV_X(x, 4, 3) &lt;&lt; 2) | \</span></span><br><span class="line"><span class="meta"> (RV_X(x, 12, 1) &lt;&lt; 5) | \</span></span><br><span class="line"><span class="meta"> (RV_X(x, 2, 2) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_LDSP_IMM(x)((RV_X(x, 5, 2) &lt;&lt; 3) | \</span></span><br><span class="line"><span class="meta"> (RV_X(x, 12, 1) &lt;&lt; 5) | \</span></span><br><span class="line"><span class="meta"> (RV_X(x, 2, 3) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_SWSP_IMM(x)((RV_X(x, 9, 4) &lt;&lt; 2) | \</span></span><br><span class="line"><span class="meta"> (RV_X(x, 7, 2) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_SDSP_IMM(x)((RV_X(x, 10, 3) &lt;&lt; 3) | \</span></span><br><span class="line"><span class="meta"> (RV_X(x, 7, 3) &lt;&lt; 6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_RS1S(insn)(8 + RV_X(insn, SH_RD, 3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_RS2S(insn)(8 + RV_X(insn, SH_RS2C, 3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RVC_RS2(insn)RV_X(insn, SH_RS2C, 5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHIFT_RIGHT(x, y)\</span></span><br><span class="line"><span class="meta">((y) <span class="string">&lt; 0 ? ((x) &lt;&lt; -(y)) : ((x) &gt;</span>&gt; (y)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_MASK\</span></span><br><span class="line"><span class="meta">((1 &lt;&lt; (5 + LOG_REGBYTES)) - (1 &lt;&lt; LOG_REGBYTES))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_OFFSET(insn, pos)\</span></span><br><span class="line"><span class="meta">(SHIFT_RIGHT((insn), (pos) - LOG_REGBYTES) &amp; REG_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_PTR(insn, pos, regs)\</span></span><br><span class="line"><span class="meta">(ulong *)((ulong)(regs) + REG_OFFSET(insn, pos))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RM(insn)(((insn) &gt;&gt; 12) &amp; 7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RS1(insn, regs)(*REG_PTR(insn, SH_RS1, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RS2(insn, regs)(*REG_PTR(insn, SH_RS2, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RS1S(insn, regs)(*REG_PTR(RVC_RS1S(insn), 0, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RS2S(insn, regs)(*REG_PTR(RVC_RS2S(insn), 0, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_RS2C(insn, regs)(*REG_PTR(insn, SH_RS2C, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SP(regs)(*REG_PTR(2, 0, regs))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_RD(insn, regs, val)(*REG_PTR(insn, SH_RD, regs) = (val))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMM_I(insn)((s32)(insn) &gt;&gt; 20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMM_S(insn)(((s32)(insn) &gt;&gt; 25 &lt;&lt; 5) | \</span></span><br><span class="line"><span class="meta"> (s32)(((insn) &gt;&gt; 7) &amp; 0x1f))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MASK_FUNCT30x7000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clang-format on */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><p>定义了和<code>riscv</code>架构寄存器相关的代码，在<code>riscv</code>架构中，各个特权级的控制寄存器是被统一映射到了一个确定的地址，可以直接操作这个地址来操作<code>csr</code>，可以在官方文档中找到<code>The RISC-V Instruction Set Manual</code>，我将此文档放在了<code>ref</code>目录下，举个例子</p></li><li><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240420173015169.png" alt="image-20240420173015169"></p></li><li><p>可以看见上面文档中定义了控制寄存器对应的映射地址，在<code>riscv_encoding.h</code>做了对应的定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ===== Supervisor-level CSRs ===== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Trap Setup */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SSTATUS0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SEDELEG0x102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIDELEG0x103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIE0x104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_STVEC0x105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SCOUNTEREN0x106</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Trap Handling */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SSCRATCH0x140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SEPC0x141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SCAUSE0x142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_STVAL0x143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SIP0x144</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Supervisor Protection and Translation */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_SATP0x180</span></span><br></pre></td></tr></table></figure></li></ul><p><code>riscv_encoding.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RISCV_ASM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RISCV_ASM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv_encoding.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clang-format off */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ASM_STR(x)x</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ASM_STR(x)#x</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __REG_SEL(a, b)__ASM_STR(a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __riscv_xlen == 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __REG_SEL(a, b)__ASM_STR(b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected __riscv_xlen&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT(12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE(_AC(1, UL) &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MASK(~(PAGE_SIZE - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_L__REG_SEL(ld, lw)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG_S__REG_SEL(sd, sw)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZREG__REG_SEL(8, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LGREG__REG_SEL(3, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __SIZEOF_POINTER__ == 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_PTR.dword</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZPTR8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGPTR3</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_PTR<span class="string">&quot;.dword&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZPTR<span class="string">&quot;8&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGPTR<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __SIZEOF_POINTER__ == 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_PTR.word</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZPTR4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGPTR2</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_PTR<span class="string">&quot;.word&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZPTR<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGPTR<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected __SIZEOF_POINTER__&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (__SIZEOF_INT__ == 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_INT__ASM_STR(.word)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZINT__ASM_STR(4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGINT__ASM_STR(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected __SIZEOF_INT__&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (__SIZEOF_SHORT__ == 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SHORT__ASM_STR(.half)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_SZSHORT__ASM_STR(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RISCV_LGSHORT__ASM_STR(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected __SIZEOF_SHORT__&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clang-format on */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换 csr 和 val 的值，csr的值读出后保存在变量 __v 中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_swap(csr, val)                                              \</span></span><br><span class="line"><span class="meta">(&#123;                                                              \</span></span><br><span class="line"><span class="meta">unsigned long __v = (unsigned long)(val);               \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;csrrw %0, &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %1&quot;</span> \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;=r&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;rK&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;memory&quot;</span>);                       \</span></span><br><span class="line"><span class="meta">__v;                                                    \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_read(csr)                                           \</span></span><br><span class="line"><span class="meta">(&#123;                                                      \</span></span><br><span class="line"><span class="meta">register unsigned long __v;                     \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;csrr %0, &quot;</span> __ASM_STR(csr) \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;=r&quot;</span>(__v)                \</span></span><br><span class="line"><span class="meta">     :                          \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;memory&quot;</span>);               \</span></span><br><span class="line"><span class="meta">__v;                                            \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_write(csr, val)                                        \</span></span><br><span class="line"><span class="meta">(&#123;                                                         \</span></span><br><span class="line"><span class="meta">unsigned long __v = (unsigned long)(val);          \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;csrw &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %0&quot;</span> \</span></span><br><span class="line"><span class="meta">     :                             \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;rK&quot;</span>(__v)                   \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;memory&quot;</span>);                  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_read_set(csr, val)                                          \</span></span><br><span class="line"><span class="meta">(&#123;                                                              \</span></span><br><span class="line"><span class="meta">unsigned long __v = (unsigned long)(val);               \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;csrrs %0, &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %1&quot;</span> \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;=r&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;rK&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;memory&quot;</span>);                       \</span></span><br><span class="line"><span class="meta">__v;                                                    \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_set(csr, val)                                          \</span></span><br><span class="line"><span class="meta">(&#123;                                                         \</span></span><br><span class="line"><span class="meta">unsigned long __v = (unsigned long)(val);          \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;csrs &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %0&quot;</span> \</span></span><br><span class="line"><span class="meta">     :                             \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;rK&quot;</span>(__v)                   \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;memory&quot;</span>);                  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_read_clear(csr, val)                                        \</span></span><br><span class="line"><span class="meta">(&#123;                                                              \</span></span><br><span class="line"><span class="meta">unsigned long __v = (unsigned long)(val);               \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;csrrc %0, &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %1&quot;</span> \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;=r&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;rK&quot;</span>(__v)                        \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;memory&quot;</span>);                       \</span></span><br><span class="line"><span class="meta">__v;                                                    \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> csr_clear(csr, val)                                        \</span></span><br><span class="line"><span class="meta">(&#123;                                                         \</span></span><br><span class="line"><span class="meta">unsigned long __v = (unsigned long)(val);          \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;csrc &quot;</span> __ASM_STR(csr) <span class="string">&quot;, %0&quot;</span> \</span></span><br><span class="line"><span class="meta">     :                             \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;rK&quot;</span>(__v)                   \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;memory&quot;</span>);                  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*wfi（Wait For Interrupt）指令告诉处理器停止执行并等待直到一个中断或异常发生。</span></span><br><span class="line"><span class="comment">  在这个状态下，处理器可以降低功耗，直到被外部事件（如中断）唤醒。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wfi()                                             \</span></span><br><span class="line"><span class="meta">do &#123;                                              \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;wfi&quot;</span> ::: <span class="string">&quot;memory&quot;</span>); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get current HART id */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current_hartid()((unsigned int)csr_read(CSR_MHARTID))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__ASSEMBLY__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>定义了一些读取控制寄存器的函数，使用内联汇编的方式来实现</li></ul><h2 id="3-FreeRTOS移植相关代码"><a href="#3-FreeRTOS移植相关代码" class="headerlink" title="3. FreeRTOS移植相关代码"></a>3. FreeRTOS移植相关代码</h2><h3 id="3-1-FreeRTOS源码组织"><a href="#3-1-FreeRTOS源码组织" class="headerlink" title="3.1 FreeRTOS源码组织"></a>3.1 <code>FreeRTOS</code>源码组织</h3><p>移植之前先看一下<code>FreeRTOS</code>的源码组织架构：</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421141951413.png" alt="image-20240421141951413"></p><ul><li><code>Demo</code>为各个架构平台的示例代码，可以整个删除掉</li><li><code>source/portable</code>：此文件夹下的文件就是<code>FreeRTOS</code>适配不同平台的代码</li></ul><p>以<code>STM32</code>为例子，源码目录构建如下</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421142343638.png" alt="image-20240421142343638"></p><p>我们的目标是为<code>riscv</code>做移植，因此只需要实现<code>portable</code>文件夹下所需文件，核心源文件和<code>include</code>文件架下的头文件复制即可，我们使用的GCC编译，不是使用<code>keil</code>、<code>IAR</code>这样的<code>IDE</code>平台，因此如下图<code>portable</code>文件夹下只需要保留两个文件夹的内容即可，其他全部删除</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421142732182.png" alt="image-20240421142732182"></p><p>在<code>GCC</code>目录下也有很多平台的实现，我们全部删除，新建一个<code>RISC-V</code>目录，我们移植相关的代码就放在此文件夹下，在<code>MenMang</code>目录下有5个用于分配内存的源文件，我们使用一个就行，保留<code>heap_4.c</code>，其余删除。剪枝后<code>trusted_domain</code>的代码目录为：</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421143248805.png" alt="image-20240421143248805"></p><h3 id="3-2-FreeRTOS配置"><a href="#3-2-FreeRTOS配置" class="headerlink" title="3.2 FreeRTOS配置"></a>3.2 FreeRTOS配置</h3><p><code> FreeRTOS</code>是支持很多配置的，需要实现定义一些宏，用于开启和关闭 <code>FreeRTOS</code>内核的某些功能，这些宏定义在<code>FreeRTOSConfig.h</code>中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FREERTOS_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREERTOS_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Application specific definitions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These definitions should be adjusted for your particular hardware and</span></span><br><span class="line"><span class="comment"> * application requirements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THESE PARAMETERS ARE DESCRIBED WITHIN THE &#x27;CONFIGURATION&#x27; SECTION OF THE</span></span><br><span class="line"><span class="comment"> * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See http://www.freertos.org/a00110.html.</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* See https://www.freertos.org/Using-FreeRTOS-on-RISC-V.html */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMTIME_BASE_ADDRESS( CLINT_ADDR + CLINT_MTIME )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMTIMECMP_BASE_ADDRESS( CLINT_ADDR + CLINT_MTIMECMP )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PREEMPTION1                       <span class="comment">// 任务抢占</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_IDLE_HOOK0                       <span class="comment">// IDLE 任务钩子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICK_HOOK0                       <span class="comment">// 时钟中断 钩子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ( 10000000 )            <span class="comment">//RTC时钟频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ( ( TickType_t ) 100 )  <span class="comment">//时钟中断频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES( 7 )                   <span class="comment">//最高优先级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE( ( unsigned short ) 512 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE( ( size_t ) 64500 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_TASK_NAME_LEN( 16 )                  <span class="comment">//任务名的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_16_BIT_TICKS0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES1                       <span class="comment">//启用互斥锁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configQUEUE_REGISTRY_SIZE8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCHECK_FOR_STACK_OVERFLOW0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_RECURSIVE_MUTEXES1                       <span class="comment">//启动递归互斥锁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MALLOC_FAILED_HOOK0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_APPLICATION_TASK_TAG0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_COUNTING_SEMAPHORES1                       <span class="comment">//启用信号量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION 1               </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Co-routine definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_CO_ROUTINES 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES ( 2 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Software timer definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TIMERS1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_PRIORITY( configMAX_PRIORITIES - 1 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_QUEUE_LENGTH6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_STACK_DEPTH( 110 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Run time and task stats gathering related definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configGENERATE_RUN_TIME_STATS           0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TRACE_FACILITY                1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS    1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* RISC-V definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configISR_STACK_SIZE_WORDS2048</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task priorities.  Allow these to be overridden. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> uartPRIMARY_PRIORITY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uartPRIMARY_PRIORITY( configMAX_PRIORITIES - 3 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the following definitions to 1 to include the API function, or zero</span></span><br><span class="line"><span class="comment">to exclude the API function. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskPrioritySet1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskPriorityGet1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskCleanUpResources1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskSuspend1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelayUntil1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelay1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_eTaskGetState1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTimerPendFunctionCall1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskAbortDelay1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetHandle1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xSemaphoreGetMutexHolder1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* FREERTOS_CONFIG_H */</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比较重要的几个配置为：</p><ul><li><code>configCPU_CLOCK_HZ</code> ： RTC 的时钟频率</li><li><code>configTICK_RATE_HZ</code> ：时钟中断的频率</li><li><code>configUSE_PREEMPTION</code>：开启抢占式任务调度</li></ul><p>在<code>qemu</code>中<code>rtc</code>的时钟频率为设备树中定义的换算成10进制即<code>10000000</code>，时钟中断的频率可以配置。</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421144651536.png" alt="image-20240421144651536"></p><blockquote><p>关于时钟的使用和定义：<a href="http://localhost:4000/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/">分时多任务系统与抢占式调度 | TimerのBlog</a></p></blockquote><h3 id="3-3-portable目录下移植文件"><a href="#3-3-portable目录下移植文件" class="headerlink" title="3.3 portable目录下移植文件"></a>3.3 <code>portable</code>目录下移植文件</h3><p>明确我们的目标是移植<code>FreeRTOS</code>到RISCV的S态运行，M态运行的是<code>OpenSBI</code>，在官方的移植文件中：<code>portable/GCC/RISC-V</code>目录下有移植的<code>Demo</code>，但是官方是移植<code>FreeRTOS</code>到M态运行，我们参考着官方的移植代码来进行实现S态的移植，移植的文件涉及到三个：<code>portmacro.h</code>、<code>port.c</code>、<code>portASM.S</code>，我先直接给出这三个和架构相关的移植代码，在下一小节中我们从FreeRTOS的启动依次来详细描述内部的函数细节</p><p><code>portmacro.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PORTMACRO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORTMACRO_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quard_star.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOSConfig.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Type definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __riscv_xlen == 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSTACK_TYPEuint64_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portBASE_TYPEint64_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portUBASE_TYPEuint64_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portPOINTER_SIZE_TYPE uint64_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __riscv_xlen == 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSTACK_TYPEuint32_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portBASE_TYPEint32_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portUBASE_TYPEuint32_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffffffffUL</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Assembler did not <span class="keyword">define</span> __riscv_xlen</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据类型定义，分为32位 和 64 位</span></span><br><span class="line"><span class="keyword">typedef</span> portSTACK_TYPE StackType_t;  </span><br><span class="line"><span class="keyword">typedef</span> portBASE_TYPE BaseType_t;    </span><br><span class="line"><span class="keyword">typedef</span> portUBASE_TYPE UBaseType_t;</span><br><span class="line"><span class="keyword">typedef</span> portUBASE_TYPE TickType_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Legacy type definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCHARchar</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portFLOATfloat</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portDOUBLEdouble</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portLONGlong</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSHORTshort</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do</span></span><br><span class="line"><span class="comment">not need to be guarded with a critical section. */</span></span><br><span class="line"><span class="comment">/*portTICK_TYPE_IS_ATOMIC这个宏定义的设定通常用于指示系统的tick计数类型是</span></span><br><span class="line"><span class="comment">否可以在不使用临界区（critical section）的情况下安全地读取。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portTICK_TYPE_IS_ATOMIC 1</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Architecture specifics. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSTACK_GROWTH( -1 )  <span class="comment">//定义了栈的增长方向</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portTICK_PERIOD_MS( ( TickType_t ) 1000 / configTICK_RATE_HZ ) <span class="comment">//操作系统的tick周期（以毫秒为单位）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __riscv64</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> This is the RV32 port that has not yet been adapted for 64.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portBYTE_ALIGNMENT16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portBYTE_ALIGNMENT16   <span class="comment">//所有数据结构都应该按16字节对齐</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduler utilities. */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vTaskSwitchContext</span><span class="params">( <span class="type">void</span> )</span>; <span class="comment">//上下文调度函数，不同架构不同</span></span><br><span class="line"><span class="comment">/* 通过sbi触发自己核心的软中断 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sbi_send_ipi</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span>;</span><br><span class="line"><span class="comment">//#define portYIELD() __asm volatile( &quot;ecall&quot; );  原本是在m态通过ecall触发软中断</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portYIELD() sbi_send_ipi((const unsigned long *)(0x1&lt;&lt;PRIM_HART)) <span class="comment">//向hart发送中断信号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portEND_SWITCHING_ISR( xSwitchRequired ) <span class="keyword">if</span>( xSwitchRequired ) vTaskSwitchContext()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Critical section management. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCRITICAL_NESTING_IN_TCB1</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vTaskEnterCritical</span><span class="params">( <span class="type">void</span> )</span>;   <span class="comment">//进入临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vTaskExitCritical</span><span class="params">( <span class="type">void</span> )</span>;    <span class="comment">//退出临界区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSET_INTERRUPT_MASK_FROM_ISR() 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* S模式下SIE全局中断控制  bit[1] 位SIE位用于控制s态中断*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portDISABLE_INTERRUPTS()__asm volatile( <span class="string">&quot;csrc sstatus, 2&quot;</span> ) <span class="comment">//csr clear</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portENABLE_INTERRUPTS()__asm volatile( <span class="string">&quot;csrs sstatus, 2&quot;</span> ) <span class="comment">//csr set</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portENTER_CRITICAL()vTaskEnterCritical()    <span class="comment">//关中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portEXIT_CRITICAL()vTaskExitCritical()     <span class="comment">//开中断</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */</span></span><br><span class="line"><span class="comment">/* Architecture specific optimisations. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> configUSE_PORT_OPTIMISED_TASK_SELECTION</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configUSE_PORT_OPTIMISED_TASK_SELECTION == 1 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the configuration. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configMAX_PRIORITIES &gt; 32 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store/clear the ready priorities in a bit map. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL &lt;&lt; ( uxPriority ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &amp;= ~( 1UL &lt;&lt; ( uxPriority ) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">ucPortCountLeadingZeros</span><span class="params">(<span class="type">uint32_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> numZeros;</span><br><span class="line"><span class="keyword">if</span> (!x)</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">8</span>);</span><br><span class="line">numZeros = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!(x &amp; <span class="number">0x80000000</span>)) &#123;</span><br><span class="line">numZeros++;</span><br><span class="line">x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> numZeros;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_PORT_OPTIMISED_TASK_SELECTION */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task function macros as described on the FreeRTOS.org WEB site.  These are</span></span><br><span class="line"><span class="comment">not necessary for to use this port.  They are defined so the common demo files</span></span><br><span class="line"><span class="comment">(which build with all the ports) will build. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portNOP() __asm volatile ( <span class="string">&quot; nop &quot;</span> ) <span class="comment">//无操作指令</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portINLINE__inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> portFORCE_INLINE   <span class="comment">//强制内联</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portFORCE_INLINE inline __attribute__(( always_inline))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内存屏障指令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portMEMORY_BARRIER() __asm volatile( <span class="string">&quot;&quot;</span> ::: <span class="string">&quot;memory&quot;</span> )</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* PORTMACRO_H */</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里说几个有点坑的地方：</p><ul><li><p>一是使用<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>控制的使用一个<code>32bit</code>的位图来存储优先级的几个操作宏，如果位图中的某一位被置为了1，代表此优先级上有任务就绪</p><ul><li><p><code>portRECORD_READY_PRIORITY(uxPriority, uxReadyPriorities)</code>：设置位图中相应优先级的位，表示该优先级有任务就绪。</p></li><li><p><code>portRESET_READY_PRIORITY(uxPriority, uxReadyPriorities)</code>：清除位图中相应优先级的位，表示该优先级没有任务就绪。</p></li><li><p><code>portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) </code>这个宏用于确定位图中的最高的就绪优先级，因为在<code>FreeRTOS</code>中，数字越大优先级越高，那么在位图中从高位向低位搜寻判断即可，因此调用了<code>ucPortCountLeadingZeros(uint32_t x)</code>去计算前导0的个数，然后使用<code>31 </code>减去前导0的个数就可以知道此时最高的就绪优先级，在官方的移植代码中是使用编译器的一个函数<code>__builtin_clz</code>来计算前导0的个数的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - __builtin_clz( uxReadyPriorities ) )</span></span><br></pre></td></tr></table></figure><p>但是不知道为啥，会有问题，估计是编译器的问题，于是自定义了一个计算前导0的函数</p></li></ul></li><li><p>二是任务主动请求调度的函数，在M态的话直接使用<code>ecall</code>指令即可，此时就会触发软中断，但是如果在<code>S</code>态使用<code>ecall</code>则会导致特权级切换，而且S态不能直接访问或者控制中断控制器如CLINT或者PLIC，所以需要M态固件介入来处理跨HART的中断请求。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过sbi触发自己核心的软中断 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sbi_send_ipi</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *hart_mask)</span>;</span><br><span class="line"><span class="comment">//#define portYIELD() __asm volatile( &quot;ecall&quot; );  原本是在m态通过ecall触发软中断</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portYIELD() sbi_send_ipi((const unsigned long *)(0x1&lt;&lt;PRIM_HART)) <span class="comment">//向hart发送中断信号</span></span></span><br></pre></td></tr></table></figure><ul><li>在M态，可以通过设置M态的中断挂起寄存器（<code>mip</code>）中的SSIP位来请求S态的软件中断。这需要M态的代码（通常是固件或操作系统的更低层部分）显式进行。</li><li>SSIP位设置后，如果S态已经启用软中断（通过<code>sie</code>寄存器的SSIP位）且全局中断使能（通过<code>mstatus</code>或<code>sstatus</code>寄存器的全局中断使能位），则S态的软件中断被触发。</li><li>这里我就有个问题了，多核间的寄存器访问核设置<code>OpenSBI</code>是如何实现的，后面搞明白了在叙述吧，总之这里就是通过<code>sbi_send_ipi</code>就可以实现触发<code>(0x1&lt;&lt;PRIM_HART))</code>这个核心的软中断，即促发<code>cpu7</code>的软中断从而实现主动的任务切换。</li></ul></li></ul><p><code>portASM.S</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;riscv_encoding.h&quot;</span><br><span class="line"></span><br><span class="line">#if __riscv_xlen == 64</span><br><span class="line">#define portWORD_SIZE 8</span><br><span class="line">#define store_x sd</span><br><span class="line">#define load_x ld</span><br><span class="line">#elif __riscv_xlen == 32</span><br><span class="line">#define store_x sw</span><br><span class="line">#define load_x lw</span><br><span class="line">#define portWORD_SIZE 4</span><br><span class="line">#else</span><br><span class="line">#error Assembler did not define __riscv_xlen</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define portCONTEXT_SIZE ( 30 * portWORD_SIZE )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.global xPortStartFirstTask</span><br><span class="line">.global freertos_risc_v_trap_handler</span><br><span class="line">.global pxPortInitialiseStack</span><br><span class="line">.extern pxCurrentTCB</span><br><span class="line">.extern ulPortTrapHandler</span><br><span class="line">.extern vTaskSwitchContext</span><br><span class="line">.extern xTaskIncrementTick</span><br><span class="line">.extern Timer_IRQHandler</span><br><span class="line">.extern pullMachineTimerCompareRegister</span><br><span class="line">.extern pullNextTime</span><br><span class="line">.extern uxTimerIncrementsForOneTick /* size_t type so 32-bit on 32-bit core and 64-bits on 64-bit core. */</span><br><span class="line">.extern xISRStackTop</span><br><span class="line">.extern portasmHANDLE_INTERRUPT</span><br><span class="line"></span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">freertos_risc_v_trap_handler:</span><br><span class="line">    // x2 为sp ，不需要保存</span><br><span class="line">// x3 为gp，全局指针，基本不变也不需要保存</span><br><span class="line">// x4 为tp，线程指针，中断上下文不需要保存</span><br><span class="line">addi sp, sp, -portCONTEXT_SIZE</span><br><span class="line">store_x x1, 1 * portWORD_SIZE( sp )</span><br><span class="line">store_x x5, 2 * portWORD_SIZE( sp )</span><br><span class="line">store_x x6, 3 * portWORD_SIZE( sp )</span><br><span class="line">store_x x7, 4 * portWORD_SIZE( sp )</span><br><span class="line">store_x x8, 5 * portWORD_SIZE( sp )</span><br><span class="line">store_x x9, 6 * portWORD_SIZE( sp )</span><br><span class="line">store_x x10, 7 * portWORD_SIZE( sp )</span><br><span class="line">store_x x11, 8 * portWORD_SIZE( sp )</span><br><span class="line">store_x x12, 9 * portWORD_SIZE( sp )</span><br><span class="line">store_x x13, 10 * portWORD_SIZE( sp )</span><br><span class="line">store_x x14, 11 * portWORD_SIZE( sp )</span><br><span class="line">store_x x15, 12 * portWORD_SIZE( sp )</span><br><span class="line">store_x x16, 13 * portWORD_SIZE( sp )</span><br><span class="line">store_x x17, 14 * portWORD_SIZE( sp )</span><br><span class="line">store_x x18, 15 * portWORD_SIZE( sp )</span><br><span class="line">store_x x19, 16 * portWORD_SIZE( sp )</span><br><span class="line">store_x x20, 17 * portWORD_SIZE( sp )</span><br><span class="line">store_x x21, 18 * portWORD_SIZE( sp )</span><br><span class="line">store_x x22, 19 * portWORD_SIZE( sp )</span><br><span class="line">store_x x23, 20 * portWORD_SIZE( sp )</span><br><span class="line">store_x x24, 21 * portWORD_SIZE( sp )</span><br><span class="line">store_x x25, 22 * portWORD_SIZE( sp )</span><br><span class="line">store_x x26, 23 * portWORD_SIZE( sp )</span><br><span class="line">store_x x27, 24 * portWORD_SIZE( sp )</span><br><span class="line">store_x x28, 25 * portWORD_SIZE( sp )</span><br><span class="line">store_x x29, 26 * portWORD_SIZE( sp )</span><br><span class="line">store_x x30, 27 * portWORD_SIZE( sp )</span><br><span class="line">store_x x31, 28 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">csrr t0, sstatus/* Required for SPIE bit. */</span><br><span class="line">store_x t0, 29 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">csrr t0, sepc  //sepc 存储了中断返回地址</span><br><span class="line">store_x t0, 0 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">load_x  t0, pxCurrentTCB/*  加载当前任务的任务控制块（TCB）地址到t0寄存器。 */</span><br><span class="line">store_x  sp, 0( t0 )/*  将当前的堆栈指针sp的值保存到TCB的第一个成员变量中. */</span><br><span class="line"></span><br><span class="line">csrr a0, scause</span><br><span class="line">csrr a1, sepc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//判断是中断还是异常</span><br><span class="line">test_if_asynchronous:     //参数为 scause的值，存放在a0寄存器中</span><br><span class="line">srli a2, a0, __riscv_xlen - 1/* MSB of mcause is 1 if handing an asynchronous interrupt - shift to LSB to clear other bits. */</span><br><span class="line">beq a2, x0, handle_synchronous/* Branch past interrupt handing if not asynchronous. */</span><br><span class="line">store_x a1, 0( sp )/* Asynch so save unmodified exception return address. */</span><br><span class="line"></span><br><span class="line">//异常</span><br><span class="line">handle_asynchronous:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_if_ipi: //参数为 scause的值，存放在a0寄存器中</span><br><span class="line">addi t0, x0, 1</span><br><span class="line"></span><br><span class="line">slli t0, t0, __riscv_xlen - 1   /* LSB is already set, shift into MSB.  Shift 31 on 32-bit or 63 on 64-bit cores. */</span><br><span class="line">addi t1, t0, 1/* 0x8000[]0001 == Supervisor ipi interrupt. */</span><br><span class="line">bne a0, t1, test_if_mtimer      // 如果不是软件中断则跳转到 test_if_mtimer 处执行</span><br><span class="line"></span><br><span class="line">load_x sp, xISRStackTop/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">jal vPortClearIpiInterrupt</span><br><span class="line">jal vTaskSwitchContext          // </span><br><span class="line">j processed_source</span><br><span class="line"></span><br><span class="line">test_if_mtimer:/* If there is a CLINT then the mtimer is used to generate the tick interrupt. */</span><br><span class="line">addi t1, t1, 4/* 0x80000001 + 4 = 0x80000005 == Supervisor timer interrupt. */</span><br><span class="line">bne a0, t1, test_if_external_interrupt  </span><br><span class="line">/* 处理时钟中断 */</span><br><span class="line">load_x sp, xISRStackTop/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">jal vPortSetupTimerInterrupt    /* 设置定时器中断计数 */</span><br><span class="line">jal xTaskIncrementTick</span><br><span class="line">beqz a0, processed_source/* Don&#x27;t switch context if incrementing tick didn&#x27;t unblock a task. */</span><br><span class="line">jal vTaskSwitchContext</span><br><span class="line">j processed_source</span><br><span class="line"></span><br><span class="line">/* 外部中断处理函数 */</span><br><span class="line">test_if_external_interrupt:/* If there is a CLINT and the mtimer interrupt is not pending then check to see if an external interrupt is pending. */</span><br><span class="line">addi t1, t1, 4/* 0x80000005 + 4 = 0x80000009 == Supervisor external interrupt. */</span><br><span class="line">bne a0, t1, processed_trap   /* Something as yet unhandled. */</span><br><span class="line">//处理外部中断</span><br><span class="line">load_x sp, xISRStackTop/* Switch to ISR stack before function call. */</span><br><span class="line">jal handle_interrupt        /* Jump to the interrupt handler if there is no CLINT or if there is a CLINT and it has been determined that an external interrupt is pending. */</span><br><span class="line">j processed_source</span><br><span class="line"></span><br><span class="line">handle_synchronous:</span><br><span class="line">addi a1, a1, 4/* Synchronous so updated exception return address to the instruction after the instruction that generated the exeption. */</span><br><span class="line">store_x a1, 0( sp )/* Save updated exception return address. */</span><br><span class="line"></span><br><span class="line">//其他中断</span><br><span class="line">processed_trap:</span><br><span class="line">csrr a0, scause</span><br><span class="line">csrr a1, sepc</span><br><span class="line">csrr a2, stval</span><br><span class="line">mv   a4, sp</span><br><span class="line">load_x sp, xISRStackTop/* Switch to ISR stack before function call. */</span><br><span class="line">jal handle_trap                /* Jump to the interrupt handler if there is no CLINT or if there is a CLINT and it has been determined that an external interrupt is pending. */</span><br><span class="line">j processed_source</span><br><span class="line"></span><br><span class="line">//任务恢复</span><br><span class="line">processed_source:</span><br><span class="line">load_x  t1, pxCurrentTCB/* Load pxCurrentTCB. */</span><br><span class="line">load_x  sp, 0( t1 )/* Read sp from first TCB member. */</span><br><span class="line"></span><br><span class="line">/* Load sret with the address of the next instruction in the task to run next. */</span><br><span class="line">load_x t0,  0( sp )</span><br><span class="line">csrw sepc, t0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Load mstatus with the interrupt enable bits used by the task. */</span><br><span class="line">load_x  t0, 29 * portWORD_SIZE( sp )   //读取保存在栈中的sstatus寄存器的值</span><br><span class="line">csrw sstatus, t0/* Required for SPIE bit. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//从栈中恢复上下文寄存器</span><br><span class="line">load_x  x1, 1 * portWORD_SIZE( sp )</span><br><span class="line">load_x  x5, 2 * portWORD_SIZE( sp )/* t0 */</span><br><span class="line">load_x  x6, 3 * portWORD_SIZE( sp )/* t1 */</span><br><span class="line">load_x  x7, 4 * portWORD_SIZE( sp )/* t2 */</span><br><span class="line">load_x  x8, 5 * portWORD_SIZE( sp )/* s0/fp */</span><br><span class="line">load_x  x9, 6 * portWORD_SIZE( sp )/* s1 */</span><br><span class="line">load_x  x10, 7 * portWORD_SIZE( sp )/* a0 */</span><br><span class="line">load_x  x11, 8 * portWORD_SIZE( sp )/* a1 */</span><br><span class="line">load_x  x12, 9 * portWORD_SIZE( sp )/* a2 */</span><br><span class="line">load_x  x13, 10 * portWORD_SIZE( sp )/* a3 */</span><br><span class="line">load_x  x14, 11 * portWORD_SIZE( sp )/* a4 */</span><br><span class="line">load_x  x15, 12 * portWORD_SIZE( sp )/* a5 */</span><br><span class="line">load_x  x16, 13 * portWORD_SIZE( sp )/* a6 */</span><br><span class="line">load_x  x17, 14 * portWORD_SIZE( sp )/* a7 */</span><br><span class="line">load_x  x18, 15 * portWORD_SIZE( sp )/* s2 */</span><br><span class="line">load_x  x19, 16 * portWORD_SIZE( sp )/* s3 */</span><br><span class="line">load_x  x20, 17 * portWORD_SIZE( sp )/* s4 */</span><br><span class="line">load_x  x21, 18 * portWORD_SIZE( sp )/* s5 */</span><br><span class="line">load_x  x22, 19 * portWORD_SIZE( sp )/* s6 */</span><br><span class="line">load_x  x23, 20 * portWORD_SIZE( sp )/* s7 */</span><br><span class="line">load_x  x24, 21 * portWORD_SIZE( sp )/* s8 */</span><br><span class="line">load_x  x25, 22 * portWORD_SIZE( sp )/* s9 */</span><br><span class="line">load_x  x26, 23 * portWORD_SIZE( sp )/* s10 */</span><br><span class="line">load_x  x27, 24 * portWORD_SIZE( sp )/* s11 */</span><br><span class="line">load_x  x28, 25 * portWORD_SIZE( sp )/* t3 */</span><br><span class="line">load_x  x29, 26 * portWORD_SIZE( sp )/* t4 */</span><br><span class="line">load_x  x30, 27 * portWORD_SIZE( sp )/* t5 */</span><br><span class="line">load_x  x31, 28 * portWORD_SIZE( sp )/* t6 */</span><br><span class="line">addi sp, sp, portCONTEXT_SIZE</span><br><span class="line"></span><br><span class="line">sret</span><br><span class="line">.endfunc</span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">.weak handle_trap</span><br><span class="line">.func</span><br><span class="line">handle_trap:</span><br><span class="line">j handle_trap</span><br><span class="line">.endfunc</span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">.weak handle_interrupt</span><br><span class="line">.func</span><br><span class="line">handle_interrupt:</span><br><span class="line">j handle_interrupt</span><br><span class="line">ret</span><br><span class="line">.endfunc</span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">xPortStartFirstTask:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">la t0, freertos_risc_v_trap_handler    //设置异常处理地址</span><br><span class="line">csrw stvec, t0</span><br><span class="line"></span><br><span class="line">//加载任务的TCB指针</span><br><span class="line">load_x  sp, pxCurrentTCB/* Load pxCurrentTCB. */</span><br><span class="line">//加载此任务的栈地址</span><br><span class="line">load_x  sp, 0( sp ) /* Read sp from first TCB member. */</span><br><span class="line"></span><br><span class="line">load_x  x1, 0( sp ) /* Note for starting the scheduler the exception return address is used as the function return address. */</span><br><span class="line"></span><br><span class="line">load_x  x6, 3 * portWORD_SIZE( sp )/* t1 */</span><br><span class="line">load_x  x7, 4 * portWORD_SIZE( sp )/* t2 */</span><br><span class="line">load_x  x8, 5 * portWORD_SIZE( sp )/* s0/fp */</span><br><span class="line">load_x  x9, 6 * portWORD_SIZE( sp )/* s1 */</span><br><span class="line">load_x  x10, 7 * portWORD_SIZE( sp )/* a0 */</span><br><span class="line">load_x  x11, 8 * portWORD_SIZE( sp )/* a1 */</span><br><span class="line">load_x  x12, 9 * portWORD_SIZE( sp )/* a2 */</span><br><span class="line">load_x  x13, 10 * portWORD_SIZE( sp )/* a3 */</span><br><span class="line">load_x  x14, 11 * portWORD_SIZE( sp )/* a4 */</span><br><span class="line">load_x  x15, 12 * portWORD_SIZE( sp )/* a5 */</span><br><span class="line">load_x  x16, 13 * portWORD_SIZE( sp )/* a6 */</span><br><span class="line">load_x  x17, 14 * portWORD_SIZE( sp )/* a7 */</span><br><span class="line">load_x  x18, 15 * portWORD_SIZE( sp )/* s2 */</span><br><span class="line">load_x  x19, 16 * portWORD_SIZE( sp )/* s3 */</span><br><span class="line">load_x  x20, 17 * portWORD_SIZE( sp )/* s4 */</span><br><span class="line">load_x  x21, 18 * portWORD_SIZE( sp )/* s5 */</span><br><span class="line">load_x  x22, 19 * portWORD_SIZE( sp )/* s6 */</span><br><span class="line">load_x  x23, 20 * portWORD_SIZE( sp )/* s7 */</span><br><span class="line">load_x  x24, 21 * portWORD_SIZE( sp )/* s8 */</span><br><span class="line">load_x  x25, 22 * portWORD_SIZE( sp )/* s9 */</span><br><span class="line">load_x  x26, 23 * portWORD_SIZE( sp )/* s10 */</span><br><span class="line">load_x  x27, 24 * portWORD_SIZE( sp )/* s11 */</span><br><span class="line">load_x  x28, 25 * portWORD_SIZE( sp )/* t3 */</span><br><span class="line">load_x  x29, 26 * portWORD_SIZE( sp )/* t4 */</span><br><span class="line">load_x  x30, 27 * portWORD_SIZE( sp )/* t5 */</span><br><span class="line">load_x  x31, 28 * portWORD_SIZE( sp )/* t6 */</span><br><span class="line"></span><br><span class="line">load_x  x5, 29 * portWORD_SIZE( sp )/* Initial mstatus into x5 (t0) */</span><br><span class="line">ori x5, x5, 0x2    /* Set SIE bit so the first task starts with interrupts enabled - required as returns with ret not eret. */</span><br><span class="line">csrrw  x0, sstatus, x5/* Interrupts enabled from here! */</span><br><span class="line">load_x  x5, 2 * portWORD_SIZE( sp )/* Initial x5 (t0) value. */</span><br><span class="line"></span><br><span class="line">addisp, sp, portCONTEXT_SIZE</span><br><span class="line">ret</span><br><span class="line">.endfunc</span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Unlike other ports pxPortInitialiseStack() is written in assembly code as it</span><br><span class="line"> * needs access to the portasmADDITIONAL_CONTEXT_SIZE constant.  The prototype</span><br><span class="line"> * for the function is as per the other ports:</span><br><span class="line"> * StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters );</span><br><span class="line"> *</span><br><span class="line"> * As per the standard RISC-V ABI pxTopcOfStack is passed in in a0, pxCode in</span><br><span class="line"> * a1, and pvParameters in a2.  The new top of stack is passed out in a0.</span><br><span class="line"> *</span><br><span class="line"> * RISC-V maps registers to ABI names as follows (X1 to X31 integer registers</span><br><span class="line"> * for the &#x27;I&#x27; profile, X1 to X15 for the &#x27;E&#x27; profile, currently I assumed).</span><br><span class="line"> *</span><br><span class="line"> * RegisterABI NameDescriptionSaver</span><br><span class="line"> * x0zeroHard-wired zero-</span><br><span class="line"> * x1raReturn addressCaller</span><br><span class="line"> * x2spStack pointerCallee</span><br><span class="line"> * x3gpGlobal pointer-</span><br><span class="line"> * x4tpThread pointer-</span><br><span class="line"> * x5-7t0-2TemporariesCaller</span><br><span class="line"> * x8s0/fpSaved register/Frame pointerCallee</span><br><span class="line"> * x9s1Saved registerCallee</span><br><span class="line"> * x10-11a0-1Function Arguments/return values Caller</span><br><span class="line"> * x12-17a2-7Function argumentsCaller</span><br><span class="line"> * x18-27s2-11Saved registersCallee</span><br><span class="line"> * x28-31t3-6TemporariesCaller</span><br><span class="line"> *</span><br><span class="line"> * The RISC-V context is saved t FreeRTOS tasks in the following stack frame,</span><br><span class="line"> * where the global and thread pointers are currently assumed to be constant so</span><br><span class="line"> * are not saved:</span><br><span class="line"> *</span><br><span class="line"> * mstatus</span><br><span class="line"> * x31</span><br><span class="line"> * x30</span><br><span class="line"> * x29</span><br><span class="line"> * x28</span><br><span class="line"> * x27</span><br><span class="line"> * x26</span><br><span class="line"> * x25</span><br><span class="line"> * x24</span><br><span class="line"> * x23</span><br><span class="line"> * x22</span><br><span class="line"> * x21</span><br><span class="line"> * x20</span><br><span class="line"> * x19</span><br><span class="line"> * x18</span><br><span class="line"> * x17</span><br><span class="line"> * x16</span><br><span class="line"> * x15</span><br><span class="line"> * x14</span><br><span class="line"> * x13</span><br><span class="line"> * x12</span><br><span class="line"> * x11</span><br><span class="line"> * pvParameters</span><br><span class="line"> * x9</span><br><span class="line"> * x8</span><br><span class="line"> * x7</span><br><span class="line"> * x6</span><br><span class="line"> * x5</span><br><span class="line"> * portTASK_RETURN_ADDRESS</span><br><span class="line"> * [chip specific registers go here]</span><br><span class="line"> * pxCode</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">pxPortInitialiseStack:                  // 函数参数应该为栈的地址放入 a0 寄存器</span><br><span class="line">csrr t0, sstatus/* t0 = sstatus 保存当前sstatus寄存器的值到t0寄存器中 */</span><br><span class="line">andi t0, t0, ~0x2/* Ensure interrupts are disabled when the stack is restored within an ISR.  Required when a task is created after the schedulre has been started, otherwise interrupts would be disabled anyway. */</span><br><span class="line">addi t1, x0, 0x120/* Generate the value 0x120, which are the SPIE and SPP bits to set in mstatus. */</span><br><span class="line">or t0, t0, t1/* Set SPIE and SPP bits in sstatus value. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addi a0, a0, -portWORD_SIZE</span><br><span class="line">store_x t0, 0(a0)/* sstatus onto the stack. */</span><br><span class="line">addi a0, a0, -(22 * portWORD_SIZE)/* Space for registers x11-x31. */</span><br><span class="line">store_x a2, 0(a0)/* Task parameters (pvParameters parameter) goes into register X10/a0 on the stack. */</span><br><span class="line">addi a0, a0, -(6 * portWORD_SIZE)/* Space for registers x5-x9. */</span><br><span class="line">la t0, prvTaskExitError             /* 加载prvTaskExitError函数的地址到 t0 */</span><br><span class="line">store_x t0, 0(a0)/* Return address onto the stack, could be portTASK_RETURN_ADDRESS */</span><br><span class="line"></span><br><span class="line">addi a0, a0, -portWORD_SIZE</span><br><span class="line">store_x a1, 0(a0)/* mret value (pxCode parameter) onto the stack. */</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.endfunc</span><br><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>portASM.S</code>是移植到riscv架构的核心文件，在FreeRTOS中，每个任务都有自己的栈，这是在创建任务的时候分配的，所谓的切换任务就是将当前任务的任务上下文即寄存器的值压入自己的栈中，然后取出下一个要运行的任务的地址，从此任务的栈中将任务上下文恢复，然后跳转执行。FreeRTOS和我们的<code>TimerOS</code>一样都是通过RTC中断来实现任务切换的，而不同架构由于寄存器组不一样因此需要在<code>portASM.S</code>实现任务压栈和出栈的汇编函数，以及和处理中断有关的函数</p><p><code>port.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Implementation of functions defined in portable.h for the RISC-V RV32 port.</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduler includes. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;portmacro.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns16550.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv_asm.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Standard includes. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> configTASK_RETURN_ADDRESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portTASK_RETURN_ADDRESSconfigTASK_RETURN_ADDRESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portTASK_RETURN_ADDRESSprvTaskExitError</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The stack used by interrupt service routines.  Set configISR_STACK_SIZE_WORDS</span></span><br><span class="line"><span class="comment">to use a statically allocated array as the interrupt stack.  Alternative leave</span></span><br><span class="line"><span class="comment">configISR_STACK_SIZE_WORDS undefined and update the linker script so that a</span></span><br><span class="line"><span class="comment">linker variable names __freertos_irq_stack_top has the same value as the top</span></span><br><span class="line"><span class="comment">of the stack used by main.  Using the linker script method will repurpose the</span></span><br><span class="line"><span class="comment">stack that was used by main before the scheduler was started for use as the</span></span><br><span class="line"><span class="comment">interrupt stack after the scheduler has started. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> configISR_STACK_SIZE_WORDS</span></span><br><span class="line"><span class="type">static</span> __attribute__ ((aligned(<span class="number">16</span>))) StackType_t xISRStack[ configISR_STACK_SIZE_WORDS ] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">const</span> StackType_t xISRStackTop = ( StackType_t ) &amp;( xISRStack[ configISR_STACK_SIZE_WORDS &amp; ~portBYTE_ALIGNMENT_MASK ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Don&#x27;t use 0xa5 as the stack fill bytes as that is used by the kernerl for</span></span><br><span class="line"><span class="comment">the task stacks, and so will legitimately appear in many positions within</span></span><br><span class="line"><span class="comment">the ISR stack. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portISR_STACK_FILL_BYTE0xee</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint32_t</span> __freertos_irq_stack_top[];</span><br><span class="line"><span class="type">const</span> StackType_t xISRStackTop = ( StackType_t ) __freertos_irq_stack_top;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup the timer to generate the tick interrupts.  The implementation in this</span></span><br><span class="line"><span class="comment"> * file is weak to allow application writers to change the timer used to</span></span><br><span class="line"><span class="comment"> * generate the tick interrupt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortSetupTimerInterrupt</span><span class="params">( <span class="type">void</span> )</span> __<span class="title function_">attribute__</span><span class="params">(( weak ))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used to program the machine timer compare register. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> uxTimerIncrementsForOneTick = ( <span class="type">size_t</span> ) ( ( configCPU_CLOCK_HZ ) / ( configTICK_RATE_HZ ) ); <span class="comment">/* Assumes increment won&#x27;t go over 32-bits. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set configCHECK_FOR_STACK_OVERFLOW to 3 to add ISR stack checking to task</span></span><br><span class="line"><span class="comment">stack checking.  A problem in the ISR stack will trigger an assert, not call the</span></span><br><span class="line"><span class="comment">stack overflow hook function (because the stack overflow hook is specific to a</span></span><br><span class="line"><span class="comment">task stack, not the ISR stack). */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined( configISR_STACK_SIZE_WORDS ) &amp;&amp; ( configCHECK_FOR_STACK_OVERFLOW &gt; 2 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">warning</span> This path not tested, or even compiled yet.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> ucExpectedStackBytes[] = &#123;</span><br><span class="line">portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,\</span><br><span class="line">portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,\</span><br><span class="line">portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,\</span><br><span class="line">portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,\</span><br><span class="line">portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE &#125;;\</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCHECK_ISR_STACK() configASSERT( ( memcmp( ( void * ) xISRStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) == 0 ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/* Define the function away. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCHECK_ISR_STACK()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configCHECK_FOR_STACK_OVERFLOW &gt; 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">get_ticks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">uint64_t</span> time_elapsed = <span class="number">0</span>;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;rdtime %0&quot;</span></span><br><span class="line">        : <span class="string">&quot;=r&quot;</span>(time_elapsed));</span><br><span class="line">    <span class="keyword">return</span> time_elapsed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortSetupTimerInterrupt</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 通过sbi设置下次tick中断 */</span></span><br><span class="line">sbi_set_timer(get_ticks() + uxTimerIncrementsForOneTick);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortClearIpiInterrupt</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 通过sbi清除软中断，在软中断服务函数中调用 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sbi_clear_ipi</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">sbi_clear_ipi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">BaseType_t <span class="title function_">xPortStartScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">xPortStartFirstTask</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configASSERT_DEFINED == 1 )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> stvec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the least significant two bits of mtvec are 00 - indicating</span></span><br><span class="line"><span class="comment">single vector mode. */</span></span><br><span class="line">__asm <span class="title function_">volatile</span><span class="params">( <span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span>( stvec ) )</span>;</span><br><span class="line"><span class="comment">//检查 stvec 设置的是直接访问还是向量访问</span></span><br><span class="line">configASSERT( ( stvec &amp; <span class="number">0x03</span>UL ) == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check alignment of the interrupt stack - which is the same as the</span></span><br><span class="line"><span class="comment">stack that was being used by main() prior to the scheduler being</span></span><br><span class="line"><span class="comment">started. */</span></span><br><span class="line"><span class="comment">//检查栈顶的地址是否是对齐了</span></span><br><span class="line">configASSERT( ( xISRStackTop &amp; portBYTE_ALIGNMENT_MASK ) == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈中的数据为 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> configISR_STACK_SIZE_WORDS</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>( ( <span class="type">void</span> * ) xISRStack, portISR_STACK_FILL_BYTE, <span class="keyword">sizeof</span>( xISRStack ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configISR_STACK_SIZE_WORDS */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configASSERT_DEFINED */</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 通过sbi设置Timer为滴答时钟 */</span></span><br><span class="line">vPortSetupTimerInterrupt();</span><br><span class="line">_puts( <span class="string">&quot;Debug timer!\n&quot;</span>);</span><br><span class="line">   <span class="comment">/* 使能SIE中S模式Timer中断和Soft中断，注意此处使能并不会立即响应</span></span><br><span class="line"><span class="comment">xPortStartFirstTask中将打开全局使能 */</span></span><br><span class="line">    csr_set(CSR_SIE, SIP_STIP);</span><br><span class="line">    csr_set(CSR_SIE, SIP_SSIP);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动第一个任务</span></span><br><span class="line">xPortStartFirstTask();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Should not get here as after calling xPortStartFirstTask() only tasks</span></span><br><span class="line"><span class="comment">should be executing. */</span></span><br><span class="line"><span class="keyword">return</span> pdFAIL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prvTaskExitError</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* A function that implements a task must not exit or attempt to return to</span></span><br><span class="line"><span class="comment">its caller as there is nothing to return to.  If a task wants to exit it</span></span><br><span class="line"><span class="comment">should instead call vTaskDelete( NULL ).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Artificially force an assert() to be triggered if configASSERT() is</span></span><br><span class="line"><span class="comment">defined, then stop here so application writers can catch the error. */</span></span><br><span class="line">configASSERT( ulPortInterruptNesting == ~<span class="number">0UL</span> );</span><br><span class="line"><span class="comment">//关闭中断</span></span><br><span class="line">portDISABLE_INTERRUPTS();</span><br><span class="line"><span class="keyword">for</span>( ;; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortEndScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Not implemented. */</span></span><br><span class="line"><span class="keyword">for</span>( ;; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-FreeRTOS启动过程"><a href="#4-FreeRTOS启动过程" class="headerlink" title="4. FreeRTOS启动过程"></a>4. FreeRTOS启动过程</h2><h3 id="4-1-FreeRTOS使用实例"><a href="#4-1-FreeRTOS使用实例" class="headerlink" title="4.1 FreeRTOS使用实例"></a>4.1 FreeRTOS使用实例</h3><p>我在<code>main.c</code>中创建了三个任务，三个任务之间会使用消息队列进行通信：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv_asm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="comment">//消息队列控制权柄</span></span><br><span class="line">QueueHandle_t xMyQueueHandle;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *p_arg)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> time = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;task1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        _puts(<span class="string">&quot;task1 send\n&quot;</span>);</span><br><span class="line">        xQueueSend(xMyQueueHandle,&amp;time,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> *p_arg)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> time = <span class="number">2</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;task2\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        _puts(<span class="string">&quot;task2 send\n&quot;</span>);</span><br><span class="line">        xQueueSend(xMyQueueHandle,&amp;time,<span class="number">0</span>);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">(<span class="type">void</span> *p_arg)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueReceive(xMyQueueHandle,&amp;time,portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">1</span>)&#123;</span><br><span class="line">            _puts(<span class="string">&quot;task1 receive\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">2</span>)&#123;</span><br><span class="line">            _puts(<span class="string">&quot;task2 receive\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vTaskCreate</span> <span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    xTaskCreate(task1,<span class="string">&quot;task1&quot;</span>,<span class="number">1024</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(task2,<span class="string">&quot;task2&quot;</span>,<span class="number">1024</span>,<span class="literal">NULL</span>,<span class="number">4</span>,<span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(task3,<span class="string">&quot;task2&quot;</span>,<span class="number">1024</span>,<span class="literal">NULL</span>,<span class="number">5</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">_puts( <span class="string">&quot;Hello FreeRTOS!\n&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * str = <span class="string">&quot;taskn\n&quot;</span>;</span><br><span class="line">    xMyQueueHandle = xQueueCreate(<span class="number">20</span>,<span class="keyword">sizeof</span>(<span class="type">int32_t</span>));</span><br><span class="line"></span><br><span class="line">    vTaskCreate();</span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-编译和链接"><a href="#4-2-编译和链接" class="headerlink" title="4.2 编译和链接"></a>4.2 编译和链接</h3><p>首先来看<code>Makefile</code>，<code>Makefile</code>会将<code>trusted_domain</code>下的源文件编译生成一个固件，会对<code>FreeRTOS</code>内核的代码以及我们自己编写的源文件进行编译：<code>main.c</code> ，<code>startup.S</code>，<code>riscv/**</code>，<code>FreeRTOS-Kernel/**</code>，<code>driver/**</code>，编译后生成的固件会放在<code>build</code>目录下</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">##########################################################################################################################</span></span><br><span class="line"><span class="comment"># trusted_domain GCC compiler Makefile</span></span><br><span class="line"><span class="comment">##########################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="comment"># Generic Makefile (based on gcc)</span></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># target</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line">TARGET = trusted_fw</span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># building variables</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># debug build?</span></span><br><span class="line">DEBUG = 1</span><br><span class="line"><span class="comment"># optimization</span></span><br><span class="line">OPT = -Og</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PROJECTBASE = <span class="variable">$(PWD)</span></span><br><span class="line"><span class="keyword">override</span> PROJECTBASE    := <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(PROJECTBASE)</span>)</span></span><br><span class="line">TOP_DIR = <span class="variable">$(PROJECTBASE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># binaries</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">CROSS_COMPILE = riscv64-unknown-elf-</span><br><span class="line">CC        = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">AS        = <span class="variable">$(CROSS_COMPILE)</span>gcc -x assembler-with-cpp</span><br><span class="line">OBJCOPY   = <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP   = <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line">AR        = <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">SZ        = <span class="variable">$(CROSS_COMPILE)</span>size</span><br><span class="line">LD        = <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">HEX       = <span class="variable">$(OBJCOPY)</span> -O ihex</span><br><span class="line">BIN       = <span class="variable">$(OBJCOPY)</span> -O binary -S</span><br><span class="line">GDB       = <span class="variable">$(CROSS_COMPILE)</span>gdb</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># paths</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># firmware library path</span></span><br><span class="line">PERIFLIB_PATH =</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build path</span></span><br><span class="line">BUILD_DIR = build</span><br><span class="line">OBJ_DIR = <span class="variable">$(BUILD_DIR)</span>/obj</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># source</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># C sources</span></span><br><span class="line">C_SOURCES =  \</span><br><span class="line">$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/*.c&#125; \</span><br><span class="line">$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/portable/GCC/RISC-V/*.c&#125; \</span><br><span class="line">$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/portable/MemMang/heap_4.c&#125; \</span><br><span class="line">$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/driver/*.c&#125; \</span><br><span class="line">$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/riscv/*.c&#125; \</span><br><span class="line">$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/*.c&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ASM sources</span></span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/*.S&#125; \</span><br><span class="line">$&#123;wildcard <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/portable/GCC/RISC-V/*.S&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># firmware library</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line">PERIFLIB_SOURCES =</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># CFLAGS</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">MCU = -march=rv64imad -mcmodel=medany -msmall-data-limit=8 -fmessage-length=0 -fsigned-char</span><br><span class="line"></span><br><span class="line"><span class="comment"># macros for gcc</span></span><br><span class="line"><span class="comment"># AS defines</span></span><br><span class="line">AS_DEFS = </span><br><span class="line"></span><br><span class="line"><span class="comment"># C defines</span></span><br><span class="line">C_DEFS = </span><br><span class="line"></span><br><span class="line"><span class="comment"># AS includes</span></span><br><span class="line">AS_INCLUDES = \</span><br><span class="line">-I <span class="variable">$(TOP_DIR)</span>/riscv \</span><br><span class="line">-I <span class="variable">$(TOP_DIR)</span>/driver</span><br><span class="line"></span><br><span class="line"><span class="comment"># C includes</span></span><br><span class="line">C_INCLUDES = \</span><br><span class="line">-I <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/<span class="keyword">include</span> \</span><br><span class="line">-I <span class="variable">$(TOP_DIR)</span>/FreeRTOS-Kernel/portable/GCC/RISC-V \</span><br><span class="line">-I <span class="variable">$(TOP_DIR)</span>/riscv \</span><br><span class="line">-I <span class="variable">$(TOP_DIR)</span>/driver \</span><br><span class="line">-I <span class="variable">$(TOP_DIR)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># compile gcc flags</span></span><br><span class="line">ASFLAGS = <span class="variable">$(MCU)</span> <span class="variable">$(AS_DEFS)</span> <span class="variable">$(AS_INCLUDES)</span> <span class="variable">$(OPT)</span> -Wall -fdata-sections -ffunction-sections</span><br><span class="line"></span><br><span class="line">CFLAGS = <span class="variable">$(MCU)</span> <span class="variable">$(C_DEFS)</span> <span class="variable">$(C_INCLUDES)</span> <span class="variable">$(OPT)</span> -Wall -fdata-sections -ffunction-sections</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>, 1)</span><br><span class="line">CFLAGS += -g -gdwarf-2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate dependency information</span></span><br><span class="line">CFLAGS += -MMD -MP -MF<span class="string">&quot;$(@:%.o=%.d)&quot;</span> -MT<span class="string">&quot;$(@:%.o=%.d)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># LDFLAGS</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># link script</span></span><br><span class="line">LD_FILE = link.lds</span><br><span class="line">LDSCRIPT = <span class="variable">$(PROJECTBASE)</span>/<span class="variable">$(LD_FILE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libraries</span></span><br><span class="line">LIBS = -lm </span><br><span class="line">LIBDIR =</span><br><span class="line">LDFLAGS = <span class="variable">$(MCU)</span> -nostartfiles -T<span class="variable">$(LDSCRIPT)</span> <span class="variable">$(LIBDIR)</span> <span class="variable">$(LIBS)</span> -Wl,-Map=<span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.map -Wl,--gc-sections</span><br><span class="line"></span><br><span class="line"><span class="comment"># default action: build all</span></span><br><span class="line"><span class="section">all: <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.elf <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.hex <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.bin <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.lst</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># build the application</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># list of objects</span></span><br><span class="line">OBJECTS = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OBJ_DIR)</span>/,$(<span class="built_in">notdir</span> $(C_SOURCES:.c=.o)</span>))</span><br><span class="line"><span class="keyword">vpath</span> %.c <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(C_SOURCES)</span>)</span>)</span><br><span class="line"><span class="comment"># list of ASM program objects</span></span><br><span class="line">OBJECTS += <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OBJ_DIR)</span>/,$(<span class="built_in">notdir</span> $(ASM_SOURCES:.S=.o)</span>))</span><br><span class="line"><span class="keyword">vpath</span> %.S <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(ASM_SOURCES)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>/%.o: %.c Makefile | <span class="variable">$(OBJ_DIR)</span></span><br><span class="line">@echo CC <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">@<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> -Wa,-a,-ad,-alms=<span class="variable">$(OBJ_DIR)</span>/<span class="variable">$(<span class="built_in">notdir</span> $(&lt;:.c=.lst)</span>) <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>/%.o: %.S Makefile | <span class="variable">$(OBJ_DIR)</span></span><br><span class="line">@echo AS <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">@<span class="variable">$(AS)</span> -c <span class="variable">$(ASFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.elf: <span class="variable">$(OBJECTS)</span> <span class="variable">$(LDSCRIPT)</span> Makefile </span><br><span class="line">@echo LD <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">@<span class="variable">$(CC)</span> <span class="variable">$(OBJECTS)</span> <span class="variable">$(LDFLAGS)</span> -Wl,-Map=freertos.map -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.hex: <span class="variable">$(BUILD_DIR)</span>/%.elf | <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">@echo OBJCOPY <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">@<span class="variable">$(HEX)</span> <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.bin: <span class="variable">$(BUILD_DIR)</span>/%.elf | <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">@echo OBJCOPY <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">@<span class="variable">$(BIN)</span> <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.lst: <span class="variable">$(BUILD_DIR)</span>/%.elf | <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">@echo OBJDUMP <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$@</span>)</span></span><br><span class="line">@<span class="variable">$(OBJDUMP)</span> --source --demangle --disassemble --reloc --wide <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br><span class="line">@<span class="variable">$(SZ)</span> --format=berkeley <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>:</span><br><span class="line">mkdir <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(OBJ_DIR)</span>, <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(OBJ_DIR)</span>)</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>:<span class="variable">$(BUILD_DIR)</span></span><br><span class="line">mkdir <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># clean up</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -fR <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># use gdb debug</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line"><span class="variable">$(GDB)</span> <span class="variable">$(BUILD_DIR)</span>/trusted_fw.elf -x  ./gdbinit</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># dependencies</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment">#-include $(shell mkdir .dep 2&gt;/dev/null) $(wildcard .dep/*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** EOF ***</span></span><br></pre></td></tr></table></figure><p>链接脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line"></span><br><span class="line">ENTRY( _start )</span><br><span class="line"></span><br><span class="line">__stack_size = 0x4000;</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123; </span><br><span class="line">/* Fake ROM area */</span><br><span class="line">rom (rxa) : ORIGIN = 0xBF800000, LENGTH = 1M</span><br><span class="line">ram (wxa) : ORIGIN = 0xBF900000, LENGTH = 6M</span><br><span class="line">&#125;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .init :</span><br><span class="line">&#123;</span><br><span class="line">_text = .;</span><br><span class="line">KEEP (*(SORT_NONE(.init)))</span><br><span class="line">&#125; &gt;rom AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .text :</span><br><span class="line">&#123;</span><br><span class="line">*(.text.unlikely .text.unlikely.*)</span><br><span class="line">*(.text.startup .text.startup.*)</span><br><span class="line">*(.text .text.*)</span><br><span class="line">*(.gnu.linkonce.t.*)</span><br><span class="line">&#125; &gt;rom AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .fini :</span><br><span class="line">&#123;</span><br><span class="line">KEEP (*(SORT_NONE(.fini)))</span><br><span class="line">_etext = .;</span><br><span class="line">&#125; &gt;rom AT&gt;rom</span><br><span class="line">  /* 四字节对齐 */</span><br><span class="line">.rodata.align :</span><br><span class="line">&#123;</span><br><span class="line">. = ALIGN(4);</span><br><span class="line">_rodata = .;</span><br><span class="line">&#125; &gt;rom AT&gt;rom</span><br><span class="line"></span><br><span class="line">  /*  标记 rodata的链接地址*/</span><br><span class="line">.rodata.start :</span><br><span class="line">&#123;</span><br><span class="line">_rodata_lma = LOADADDR(.rodata.start);</span><br><span class="line">&#125; &gt;rom AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .data.align :</span><br><span class="line">&#123;</span><br><span class="line">. = ALIGN(4);</span><br><span class="line">_data = .;</span><br><span class="line">&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .data.start :</span><br><span class="line">&#123;</span><br><span class="line">_data_lma = LOADADDR(.data.start);</span><br><span class="line">&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .data :</span><br><span class="line">&#123;</span><br><span class="line">*(.data .data.*)</span><br><span class="line">*(.gnu.linkonce.d.*)</span><br><span class="line">. = ALIGN(8);</span><br><span class="line">PROVIDE( __global_pointer$ = . + 0x800 );</span><br><span class="line">*(.sdata .sdata.*)</span><br><span class="line">*(.sdata2 .sdata2.*)</span><br><span class="line">*(.gnu.linkonce.s.*)</span><br><span class="line">. = ALIGN(8);</span><br><span class="line">*(.srodata.cst16)</span><br><span class="line">*(.srodata.cst8)</span><br><span class="line">*(.srodata.cst4)</span><br><span class="line">*(.srodata.cst2)</span><br><span class="line">*(.srodata .srodata.*)</span><br><span class="line"></span><br><span class="line">. = ALIGN(4);</span><br><span class="line">_edata = .;</span><br><span class="line">&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line">.bss.align :</span><br><span class="line">&#123;</span><br><span class="line">. = ALIGN(4);</span><br><span class="line">_bss = .;</span><br><span class="line">&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .bss.start :</span><br><span class="line">&#123;</span><br><span class="line">_bss_lma = LOADADDR(.bss.start);</span><br><span class="line">&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line">  .bss :</span><br><span class="line">&#123;</span><br><span class="line">*(.sbss*)</span><br><span class="line">*(.gnu.linkonce.sb.*)</span><br><span class="line">*(.bss .bss.*)</span><br><span class="line">*(.gnu.linkonce.b.*)</span><br><span class="line">*(COMMON)</span><br><span class="line"></span><br><span class="line">. = ALIGN(4);</span><br><span class="line">_ebss = .;</span><br><span class="line">&#125; &gt;ram AT&gt;rom</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">. = ALIGN(8);</span><br><span class="line">_end = .;</span><br><span class="line"></span><br><span class="line">  .stack :</span><br><span class="line">&#123;</span><br><span class="line">. = ALIGN(16);</span><br><span class="line">. += __stack_size;</span><br><span class="line">_stack_top = .;</span><br><span class="line">&#125; &gt;ram AT&gt;ram</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>指定了程序入口地址为<code>_start</code>为<code>start.S</code>中的代码</p></li><li><p>写入的内存区域有两部分：</p><ul><li><code>rom (rxa) : ORIGIN = 0xBF800000, LENGTH = 1M</code>：可读可执行，起始地址为<code>0xBF800000</code>，大小为1M</li><li><code>ram (wxa) : ORIGIN = 0xBF900000, LENGTH = 6M</code>：可写可执行，起始地址为<code>0xBF900000</code>，大小为6M</li></ul></li><li><p>链接脚本中<code>AT</code>的是用来定义各个节应该在哪里被加载（LMA），而节的位置（放置位置，VMA）则是通过 <code>&gt;</code> 指定的，例如</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> .data.start :</span><br><span class="line">&#123;</span><br><span class="line">_data_lma = LOADADDR(.data.start);</span><br><span class="line">&#125; &gt;ram AT&gt;rom</span><br></pre></td></tr></table></figure><ul><li><code>.data</code> 节包含了初始化的全局变量，它在运行时应位于 RAM（通过 <code>&gt;ram</code> 指定）。</li><li>然而，在程序加载时，这些数据的初始值存储在 ROM 中（通过 <code>AT&gt;rom</code> 指定）。</li><li>简单来说就是数据段的数据是放在<code>rom</code>中的，代码段的程序在运行时需要去<code>rom</code>中拿到数据后加载到<code>ram</code>处执行，<code>.data</code>段和<code>.bss</code>段都是这样的特性</li></ul></li><li><p>在链接脚本最后定义了内核程序使用的主栈栈顶起始地址<code>_stack_top</code>，栈大小为<code>__stack_size = 0x4000</code></p></li></ul><h3 id="4-3-启动代码"><a href="#4-3-启动代码" class="headerlink" title="4.3 启动代码"></a>4.3 启动代码</h3><p><code>startup.S</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;riscv_encoding.h&quot;</span><br><span class="line">#include &quot;quard_star.h&quot;</span><br><span class="line">#include &quot;riscv_reg.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .init</span><br><span class="line">.globl _start</span><br><span class="line">.type _start,@function</span><br><span class="line">_start:  #程序入口地址</span><br><span class="line">.cfi_startproc</span><br><span class="line">.cfi_undefined ra</span><br><span class="line">.option push</span><br><span class="line">.option norelax  #取消汇编器的&quot;relaxation&quot;优化</span><br><span class="line">la  gp, __global_pointer$   #设置全局指针</span><br><span class="line">.option pop</span><br><span class="line">// Continue primary hart</span><br><span class="line">li   a1, PRIM_HART     #将核心号加载到a1寄存器中</span><br><span class="line">bne  a0, a1, secondary #比较核心号是否相等，如果不等，跳转到secondary处执行</span><br><span class="line"></span><br><span class="line">  csrw sie, 0        #sie寄存器用于控制中断，禁用所有中断</span><br><span class="line">  csrw sip, 0            #sip用于标识中断中断标志位，清楚所有的中断的标志位</span><br><span class="line">/* set to disable FPU */</span><br><span class="line">li t0, SSTATUS_FS</span><br><span class="line">csrc sstatus, t0</span><br><span class="line">li t0, SSTATUS_SUM // SUM in sstatus</span><br><span class="line">csrs sstatus, t0</span><br><span class="line"></span><br><span class="line">// Primary hart  设置主栈指针</span><br><span class="line">la sp, _stack_top</span><br><span class="line">csrw sscratch, sp  //将栈指针写入sscratch寄存器</span><br><span class="line"></span><br><span class="line">// Load data section</span><br><span class="line">la a0, _data_lma    //data数据在物理内存中的地址</span><br><span class="line">la a1, _data        //数据段起始地址</span><br><span class="line">la a2, _edata       //数据段结束地址</span><br><span class="line">bgeu a1, a2, 2f     //</span><br><span class="line">1:   //将数据段的数据从物理内存复制到dram</span><br><span class="line">LOAD t0, (a0)</span><br><span class="line">STOR t0, (a1)</span><br><span class="line">addi a0, a0, REGSIZE</span><br><span class="line">addi a1, a1, REGSIZE</span><br><span class="line">bltu a1, a2, 1b       //b代表向上寻找最近的同名标签</span><br><span class="line"></span><br><span class="line">2:</span><br><span class="line">// Clear bss section</span><br><span class="line">la a0, _bss</span><br><span class="line">la a1, _ebss</span><br><span class="line">bgeu a0, a1, 2f      //f代表向下寻找最近的同名标签</span><br><span class="line">1:  //清空bss段</span><br><span class="line">STOR zero, (a0)</span><br><span class="line">addi a0, a0, REGSIZE</span><br><span class="line">bltu a0, a1, 1b    </span><br><span class="line">2:</span><br><span class="line"></span><br><span class="line">// argc, argv, envp is 0</span><br><span class="line">li  a0, 0</span><br><span class="line">li  a1, 0</span><br><span class="line">li  a2, 0</span><br><span class="line">jal main</span><br><span class="line">1:</span><br><span class="line">wfi</span><br><span class="line">j 1b</span><br><span class="line"></span><br><span class="line">ecall_err:</span><br><span class="line">wfi</span><br><span class="line">j ecall_err</span><br><span class="line"></span><br><span class="line">secondary:</span><br><span class="line">// TODO: Multicore is not supported</span><br><span class="line">wfi</span><br><span class="line">j secondary</span><br><span class="line">.cfi_endproc</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>启动代码主要做一些初始化工作：首先禁用所有中断，然后设置主栈指针，加载<code>rom</code>上的数据段到<code>ram</code>里，将<code>bss</code>段清零。<code>bss</code>段通常放的都是未初始化的全局变量，因此os手动清零</li><li>跳转到<code>main</code>函数开始执行：<code>jal main</code></li></ul><h3 id="4-4-FreeRTOS任务启动"><a href="#4-4-FreeRTOS任务启动" class="headerlink" title="4.4 FreeRTOS任务启动"></a>4.4 FreeRTOS任务启动</h3><p>在<code>main</code>函数中可以看见当创建完成任务后，会调用<code>vTaskStartScheduler()</code>函数来开启任务调度：</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421215337861.png" alt="image-20240421215337861"></p><p>我们进入<code>vTaskStartScheduler()</code>内部，可以看见首先创建了一个<code>IDLE</code>任务，即空闲任务，如果我们用户没用手动创建任务，那么<code>IDLE</code>任务会一直运行，此任务被设置为最低优先级0</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421215700843.png" alt="image-20240421215700843"></p><p>然后就会开启时钟中断，然后启动第一个任务：</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421220103518.png" alt="image-20240421220103518"></p><ul><li><p>先调用<code>portDISABLE_INTERRUPTS()</code>这个宏来关闭中断，然后在<code>xPortStartScheduler()</code>函数中构建好第一个任务执行的上下文后，会打开中断，这两个和cpu架构有关的宏或者函数就是定义在之前<code>portable</code>文件夹下的</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421220331304.png" alt="image-20240421220331304"></p></li></ul><p><code>xPortStartScheduler()</code>定义在<code>port.c</code>中，在此函数中会恢复第一个要执行任务的任务上下文，开启时钟中断，开始执行调度。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">BaseType_t <span class="title function_">xPortStartScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">xPortStartFirstTask</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configASSERT_DEFINED == 1 )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> stvec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the least significant two bits of mtvec are 00 - indicating</span></span><br><span class="line"><span class="comment">single vector mode. */</span></span><br><span class="line">__asm <span class="title function_">volatile</span><span class="params">( <span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span>( stvec ) )</span>;</span><br><span class="line"><span class="comment">//检查 stvec 设置的是直接访问还是向量访问</span></span><br><span class="line">configASSERT( ( stvec &amp; <span class="number">0x03</span>UL ) == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check alignment of the interrupt stack - which is the same as the</span></span><br><span class="line"><span class="comment">stack that was being used by main() prior to the scheduler being</span></span><br><span class="line"><span class="comment">started. */</span></span><br><span class="line"><span class="comment">//检查栈顶的地址是否是对齐了</span></span><br><span class="line">configASSERT( ( xISRStackTop &amp; portBYTE_ALIGNMENT_MASK ) == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈中的数据为 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> configISR_STACK_SIZE_WORDS</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>( ( <span class="type">void</span> * ) xISRStack, portISR_STACK_FILL_BYTE, <span class="keyword">sizeof</span>( xISRStack ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configISR_STACK_SIZE_WORDS */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configASSERT_DEFINED */</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 通过sbi设置Timer为滴答时钟 */</span></span><br><span class="line">vPortSetupTimerInterrupt();</span><br><span class="line">   <span class="comment">/* 使能SIE中S模式Timer中断和Soft中断，注意此处使能并不会立即响应</span></span><br><span class="line"><span class="comment">xPortStartFirstTask中将打开全局使能 */</span></span><br><span class="line">    csr_set(CSR_SIE, SIP_STIP);</span><br><span class="line">    csr_set(CSR_SIE, SIP_SSIP);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动第一个任务</span></span><br><span class="line">xPortStartFirstTask();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Should not get here as after calling xPortStartFirstTask() only tasks</span></span><br><span class="line"><span class="comment">should be executing. */</span></span><br><span class="line"><span class="keyword">return</span> pdFAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>vPortSetupTimerInterrupt();</code>设置下次时钟中断的计数值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> uxTimerIncrementsForOneTick = ( <span class="type">size_t</span> ) ( ( configCPU_CLOCK_HZ ) / ( configTICK_RATE_HZ ) ); <span class="comment">/* Assumes increment won&#x27;t go over 32-bits. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortSetupTimerInterrupt</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 通过sbi设置下次tick中断 */</span></span><br><span class="line">sbi_set_timer(get_ticks() + uxTimerIncrementsForOneTick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uxTimerIncrementsForOneTick</code>为下次时钟中断到来时的计数值，通过时钟频率和在<code>FreeRTOSConfig.h</code>中定义的时钟中断频率来计算</p></li><li><p>使能SIE中S模式Timer中断和Soft中断，此时用于没有开启S态的全局中断，所以不会立即响应，会在<code>xPortStartFirstTask();</code>函数中恢复第一个任务的上下文后才开启</p></li></ul><p><code>xPortStartFirstTask()</code>定义在<code>portASM.S</code>中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">xPortStartFirstTask:</span><br><span class="line"></span><br><span class="line">la t0, freertos_risc_v_trap_handler    //设置异常处理地址</span><br><span class="line">csrw stvec, t0</span><br><span class="line"></span><br><span class="line">//加载任务的TCB指针</span><br><span class="line">load_x  sp, pxCurrentTCB/* Load pxCurrentTCB. */</span><br><span class="line">//加载此任务的栈地址</span><br><span class="line">load_x  sp, 0( sp ) /* Read sp from first TCB member. */</span><br><span class="line"></span><br><span class="line">load_x  x1, 0( sp ) /* Note for starting the scheduler the exception return address is used as the function return address. */</span><br><span class="line"></span><br><span class="line">load_x  x6, 3 * portWORD_SIZE( sp )/* t1 */</span><br><span class="line">load_x  x7, 4 * portWORD_SIZE( sp )/* t2 */</span><br><span class="line">load_x  x8, 5 * portWORD_SIZE( sp )/* s0/fp */</span><br><span class="line">load_x  x9, 6 * portWORD_SIZE( sp )/* s1 */</span><br><span class="line">load_x  x10, 7 * portWORD_SIZE( sp )/* a0 */</span><br><span class="line">load_x  x11, 8 * portWORD_SIZE( sp )/* a1 */</span><br><span class="line">load_x  x12, 9 * portWORD_SIZE( sp )/* a2 */</span><br><span class="line">load_x  x13, 10 * portWORD_SIZE( sp )/* a3 */</span><br><span class="line">load_x  x14, 11 * portWORD_SIZE( sp )/* a4 */</span><br><span class="line">load_x  x15, 12 * portWORD_SIZE( sp )/* a5 */</span><br><span class="line">load_x  x16, 13 * portWORD_SIZE( sp )/* a6 */</span><br><span class="line">load_x  x17, 14 * portWORD_SIZE( sp )/* a7 */</span><br><span class="line">load_x  x18, 15 * portWORD_SIZE( sp )/* s2 */</span><br><span class="line">load_x  x19, 16 * portWORD_SIZE( sp )/* s3 */</span><br><span class="line">load_x  x20, 17 * portWORD_SIZE( sp )/* s4 */</span><br><span class="line">load_x  x21, 18 * portWORD_SIZE( sp )/* s5 */</span><br><span class="line">load_x  x22, 19 * portWORD_SIZE( sp )/* s6 */</span><br><span class="line">load_x  x23, 20 * portWORD_SIZE( sp )/* s7 */</span><br><span class="line">load_x  x24, 21 * portWORD_SIZE( sp )/* s8 */</span><br><span class="line">load_x  x25, 22 * portWORD_SIZE( sp )/* s9 */</span><br><span class="line">load_x  x26, 23 * portWORD_SIZE( sp )/* s10 */</span><br><span class="line">load_x  x27, 24 * portWORD_SIZE( sp )/* s11 */</span><br><span class="line">load_x  x28, 25 * portWORD_SIZE( sp )/* t3 */</span><br><span class="line">load_x  x29, 26 * portWORD_SIZE( sp )/* t4 */</span><br><span class="line">load_x  x30, 27 * portWORD_SIZE( sp )/* t5 */</span><br><span class="line">load_x  x31, 28 * portWORD_SIZE( sp )/* t6 */</span><br><span class="line"></span><br><span class="line">load_x  x5, 29 * portWORD_SIZE( sp )/* Initial mstatus into x5 (t0) */</span><br><span class="line">ori x5, x5, 0x2    /* Set SIE bit so the first task starts with interrupts enabled - required as returns with ret not eret. */</span><br><span class="line">csrrw  x0, sstatus, x5/* Interrupts enabled from here! */</span><br><span class="line">load_x  x5, 2 * portWORD_SIZE( sp )/* Initial x5 (t0) value. */</span><br><span class="line"></span><br><span class="line">addisp, sp, portCONTEXT_SIZE</span><br><span class="line">ret</span><br><span class="line">.endfunc</span><br></pre></td></tr></table></figure><ul><li><p>首先设置异常处理地址，即设置<code>stvec</code>寄存器的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">la t0, freertos_risc_v_trap_handler    //设置异常处理地址</span><br><span class="line">csrw stvec, t0</span><br></pre></td></tr></table></figure><p>下一次<code>trap</code>来临时就会进入<code>freertos_risc_v_trap_handler </code>这个地址去进行处理，和我们<code>TimerOS</code>实现类似，在<code>freertos_risc_v_trap_handler</code>函数内部会判断是什么类型的异常，比如时钟中断、外部中断、异常等等，如果是时钟中断，则会去执行任务切换</p></li><li><p>然后是根据当前任务的<code>TCB</code>的指针，拿到此任务的栈地址，根据任务<code>TCB</code>的定义发现栈指针是放在<code>TCB</code>最开始的位置</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421223228120.png" alt="image-20240421223228120"></p></li><li><p>所以先取出<code>TCB</code>的指针，再从<code>TCB</code>的第一个地址取出任务栈，从此任务的栈中恢复任务上下文，<code>pxCurrentTCB</code>是<code>FreeRTOS</code>中定义的一个全局指针，用来指向当前正在执行的任务的<code>TCB</code>，由于我们最后创建的任务是<code>IDLE</code>任务，所以此时<code>pxCurrentTCB</code>肯定是指向<code>IDLE</code>任务的<code>TCB</code>的，<code>xTaskCreate</code>内部会去调用<code>prvAddNewTaskToReadyList</code>来初始化设置<code>pxCurrentTCB</code>的值</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421222608370.png" alt="image-20240421222608370"></p></li><li><p>此时你可能有一个疑问，既然要从栈中恢复任务上下文，是不是在创建任务的时候需要先为每个任务初始化任务上下文，那就对了，<code>xTaskCreate</code>内部会去调用<code>prvInitialiseNewTask</code>函数，而中<code>prvInitialiseNewTask</code>会去调用<code>pxPortInitialiseStack</code>函数来初始化任务栈</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240421222924490.png" alt="image-20240421222924490"></p></li></ul><p><code>pxPortInitialiseStack</code>此函数用于初始化一个任务的任务栈，定义在<code>portASM.S</code>中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">pxPortInitialiseStack:                  // 函数参数应该为栈的地址放入 a0 寄存器</span><br><span class="line">csrr t0, sstatus/* t0 = sstatus 保存当前sstatus寄存器的值到t0寄存器中 */</span><br><span class="line">andi t0, t0, ~0x2/* Ensure interrupts are disabled when the stack is restored within an ISR.  Required when a task is created after the schedulre has been started, otherwise interrupts would be disabled anyway. */</span><br><span class="line">addi t1, x0, 0x120/* Generate the value 0x120, which are the SPIE and SPP bits to set in sstatus. */</span><br><span class="line">or t0, t0, t1/* Set SPIE and SPP bits in sstatus value. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addi a0, a0, -portWORD_SIZE</span><br><span class="line">store_x t0, 0(a0)/* sstatus onto the stack. */</span><br><span class="line">addi a0, a0, -(22 * portWORD_SIZE)/* Space for registers x11-x31. */</span><br><span class="line">store_x a2, 0(a0)/* Task parameters (pvParameters parameter) goes into register X10/a0 on the stack. */</span><br><span class="line">addi a0, a0, -(6 * portWORD_SIZE)/* Space for registers x5-x9. */</span><br><span class="line">la t0, prvTaskExitError             /* 加载prvTaskExitError函数的地址到 t0 */</span><br><span class="line">store_x t0, 0(a0)/* Return address onto the stack, could be portTASK_RETURN_ADDRESS */</span><br><span class="line"></span><br><span class="line">addi a0, a0, -portWORD_SIZE</span><br><span class="line">store_x a1, 0(a0)/* sret value (pxCode parameter) onto the stack. */</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.endfunc</span><br></pre></td></tr></table></figure><ul><li><p>首先来看调用此函数的调用时传入的参数和返回值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );</span><br></pre></td></tr></table></figure><ul><li><p><code>pxTopOfStack</code>：任务栈的栈顶地址，<code>portSTACK_GROWTH</code>这个宏用于判断栈的增长方向，此宏在<code>portmacro.h</code>中被定义成了<code>-1</code>，因此往地址增长，<code>pxTopOfStack</code>指向了栈顶地址，</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422120342433.png" alt="image-20240422120342433"></p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422121813632.png" alt="image-20240422121813632" style="zoom:50%;"><p>注意：<code>pxTopOfStack</code>是个临时变量，指向此时栈的最低地址，不是<code>TCB</code>结构体顶部的那个<code>pxTopOfStack</code></p></li><li><p><code>pxTopOfStack</code>会被放入<code>a0</code>寄存器中，<code>pxTaskCode</code>放入<code>a1</code>寄存器中，<code>pvParameters</code>放入<code>a2</code>寄存器中</p></li></ul></li><li><p><code>pxPortInitialiseStack</code>函数内部会依次压栈初始化任务上下文，栈中的数据如下：</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422130449205.png" alt="image-20240422130449205"></p></li><li><p>此时再来回看<code>xPortStartFirstTask</code>中的恢复第一个任务的上下文就很清晰了，上面提到<code>xPortStartFirstTask</code>函数内部会在恢复上下文后开启全局中断，这一步就发生在<code>csrrw  x0, sstatus, x5/* Interrupts enabled from here! */</code>，我们在初始化任务上下文时会构造一个<code>sstatus</code>的初始值，会去设置相应的bit位来开启S态的全局中断，这样将<code>ssatus</code>的值从栈中恢复时就会开启全局中断了，从而开启基于RTC中断的任务调度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csrr t0, sstatus/* t0 = sstatus 保存当前sstatus寄存器的值到t0寄存器中 */</span><br><span class="line">andi t0, t0, ~0x2/* Ensure interrupts are disabled when the stack is restored within an ISR.  Required when a task is created after the schedulre has been started, otherwise interrupts would be disabled anyway. */</span><br><span class="line">addi t1, x0, 0x120/* Generate the value 0x120, which are the SPIE and SPP bits to set in sstatus. */</span><br><span class="line">or t0, t0, t1/* Set SPIE and SPP bits in sstatus value. */</span><br></pre></td></tr></table></figure></li></ul><p>回顾一下整个启动流程：</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422145110158.png" alt="image-20240422145110158"></p><h3 id="4-5-内核启动后的任务切换"><a href="#4-5-内核启动后的任务切换" class="headerlink" title="4.5 内核启动后的任务切换"></a>4.5 内核启动后的任务切换</h3><p>​在调用<code>xPortStartFirstTask()</code>之后，此时会启动<code>IDLE</code>任务，同时开启了时钟中断，那么在下一次时钟中断到来时，我们需要去进行处理，在<code>xPortStartFirstTask()</code>函数的开头我们设置了<code>stvec</code>的值，当产生<code>trap</code>时会跳转到<code>stvec</code>寄存器指向的地址处执行，这个地址是<code>freertos_risc_v_trap_handler</code>，这个函数定义在<code>portASM</code>的开头：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.align 8</span><br><span class="line">.func</span><br><span class="line">freertos_risc_v_trap_handler:</span><br><span class="line">    // x2 为sp ，不需要保存</span><br><span class="line">// x3 为gp，全局指针，基本不变也不需要保存</span><br><span class="line">// x4 为tp，线程指针，不需要保存</span><br><span class="line">addi sp, sp, -portCONTEXT_SIZE</span><br><span class="line">store_x x1, 1 * portWORD_SIZE( sp )</span><br><span class="line">store_x x5, 2 * portWORD_SIZE( sp )</span><br><span class="line">store_x x6, 3 * portWORD_SIZE( sp )</span><br><span class="line">store_x x7, 4 * portWORD_SIZE( sp )</span><br><span class="line">store_x x8, 5 * portWORD_SIZE( sp )</span><br><span class="line">store_x x9, 6 * portWORD_SIZE( sp )</span><br><span class="line">store_x x10, 7 * portWORD_SIZE( sp )</span><br><span class="line">store_x x11, 8 * portWORD_SIZE( sp )</span><br><span class="line">store_x x12, 9 * portWORD_SIZE( sp )</span><br><span class="line">store_x x13, 10 * portWORD_SIZE( sp )</span><br><span class="line">store_x x14, 11 * portWORD_SIZE( sp )</span><br><span class="line">store_x x15, 12 * portWORD_SIZE( sp )</span><br><span class="line">store_x x16, 13 * portWORD_SIZE( sp )</span><br><span class="line">store_x x17, 14 * portWORD_SIZE( sp )</span><br><span class="line">store_x x18, 15 * portWORD_SIZE( sp )</span><br><span class="line">store_x x19, 16 * portWORD_SIZE( sp )</span><br><span class="line">store_x x20, 17 * portWORD_SIZE( sp )</span><br><span class="line">store_x x21, 18 * portWORD_SIZE( sp )</span><br><span class="line">store_x x22, 19 * portWORD_SIZE( sp )</span><br><span class="line">store_x x23, 20 * portWORD_SIZE( sp )</span><br><span class="line">store_x x24, 21 * portWORD_SIZE( sp )</span><br><span class="line">store_x x25, 22 * portWORD_SIZE( sp )</span><br><span class="line">store_x x26, 23 * portWORD_SIZE( sp )</span><br><span class="line">store_x x27, 24 * portWORD_SIZE( sp )</span><br><span class="line">store_x x28, 25 * portWORD_SIZE( sp )</span><br><span class="line">store_x x29, 26 * portWORD_SIZE( sp )</span><br><span class="line">store_x x30, 27 * portWORD_SIZE( sp )</span><br><span class="line">store_x x31, 28 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">csrr t0, sstatus/* Required for SPIE bit. */</span><br><span class="line">store_x t0, 29 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">csrr t0, sepc  //sepc 存储了中断返回地址</span><br><span class="line">store_x t0, 0 * portWORD_SIZE( sp )</span><br><span class="line"></span><br><span class="line">load_x  t0, pxCurrentTCB/*  加载当前任务的任务控制块（TCB）地址到t0寄存器。 */</span><br><span class="line">store_x  sp, 0( t0 )/*  将当前的堆栈指针sp的值保存到TCB的第一个成员变量中. */</span><br><span class="line"></span><br><span class="line">csrr a0, scause</span><br><span class="line">csrr a1, sepc</span><br><span class="line"></span><br><span class="line">//判断是中断还是异常</span><br><span class="line">test_if_asynchronous:     //参数为 scause的值，存放在a0寄存器中</span><br><span class="line">srli a2, a0, __riscv_xlen - 1/* MSB of mcause is 1 if handing an asynchronous interrupt - shift to LSB to clear other bits. */</span><br><span class="line">beq a2, x0, handle_synchronous/* Branch past interrupt handing if not asynchronous. */</span><br><span class="line">store_x a1, 0( sp )/* Asynch so save unmodified exception return address. */</span><br><span class="line"></span><br><span class="line">//异常</span><br><span class="line">handle_asynchronous:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_if_ipi: //参数为 scause的值，存放在a0寄存器中</span><br><span class="line">addi t0, x0, 1</span><br><span class="line"></span><br><span class="line">slli t0, t0, __riscv_xlen - 1   /* LSB is already set, shift into MSB.  Shift 31 on 32-bit or 63 on 64-bit cores. */</span><br><span class="line">addi t1, t0, 1/* 0x8000[]0001 == Supervisor ipi interrupt. */</span><br><span class="line">bne a0, t1, test_if_mtimer      // 如果不是软件中断则跳转到 test_if_mtimer 处执行</span><br><span class="line"></span><br><span class="line">load_x sp, xISRStackTop/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">jal vPortClearIpiInterrupt</span><br><span class="line">jal vTaskSwitchContext          // </span><br><span class="line">j processed_source</span><br><span class="line"></span><br><span class="line">test_if_mtimer:/* If there is a CLINT then the mtimer is used to generate the tick interrupt. */</span><br><span class="line">addi t1, t1, 4/* 0x80000001 + 4 = 0x80000005 == Supervisor timer interrupt. */</span><br><span class="line">bne a0, t1, test_if_external_interrupt  </span><br><span class="line">/* 处理时钟中断 */</span><br><span class="line">load_x sp, xISRStackTop/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">jal vPortSetupTimerInterrupt    /* 设置定时器中断计数 */</span><br><span class="line">jal xTaskIncrementTick</span><br><span class="line">beqz a0, processed_source/* Don&#x27;t switch context if incrementing tick didn&#x27;t unblock a task. */</span><br><span class="line">jal vTaskSwitchContext</span><br><span class="line">j processed_source</span><br><span class="line"></span><br><span class="line">/* 外部中断处理函数 */</span><br><span class="line">test_if_external_interrupt:/* If there is a CLINT and the mtimer interrupt is not pending then check to see if an external interrupt is pending. */</span><br><span class="line">addi t1, t1, 4/* 0x80000005 + 4 = 0x80000009 == Supervisor external interrupt. */</span><br><span class="line">bne a0, t1, processed_trap   /* Something as yet unhandled. */</span><br><span class="line">//处理外部中断</span><br><span class="line">load_x sp, xISRStackTop/* Switch to ISR stack before function call. */</span><br><span class="line">jal handle_interrupt        /* Jump to the interrupt handler if there is no CLINT or if there is a CLINT and it has been determined that an external interrupt is pending. */</span><br><span class="line">j processed_source</span><br><span class="line"></span><br><span class="line">handle_synchronous:</span><br><span class="line">addi a1, a1, 4/* Synchronous so updated exception return address to the instruction after the instruction that generated the exeption. */</span><br><span class="line">store_x a1, 0( sp )/* Save updated exception return address. */</span><br><span class="line"></span><br><span class="line">//其他中断</span><br><span class="line">processed_trap:</span><br><span class="line">csrr a0, scause</span><br><span class="line">csrr a1, sepc</span><br><span class="line">csrr a2, stval</span><br><span class="line">mv   a4, sp</span><br><span class="line">load_x sp, xISRStackTop/* Switch to ISR stack before function call. */</span><br><span class="line">jal handle_trap                /* Jump to the interrupt handler if there is no CLINT or if there is a CLINT and it has been determined that an external interrupt is pending. */</span><br><span class="line">j processed_source</span><br><span class="line"></span><br><span class="line">//任务恢复</span><br><span class="line">processed_source:</span><br><span class="line">load_x  t1, pxCurrentTCB/* Load pxCurrentTCB. */</span><br><span class="line">load_x  sp, 0( t1 )/* Read sp from first TCB member. */</span><br><span class="line"></span><br><span class="line">/* Load sret with the address of the next instruction in the task to run next. */</span><br><span class="line">load_x t0,  0( sp )</span><br><span class="line">csrw sepc, t0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Load mstatus with the interrupt enable bits used by the task. */</span><br><span class="line">load_x  t0, 29 * portWORD_SIZE( sp )   //读取保存在栈中的sstatus寄存器的值</span><br><span class="line">csrw sstatus, t0/* Required for SPIE bit. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//从栈中恢复上下文寄存器</span><br><span class="line">load_x  x1, 1 * portWORD_SIZE( sp )</span><br><span class="line">load_x  x5, 2 * portWORD_SIZE( sp )/* t0 */</span><br><span class="line">load_x  x6, 3 * portWORD_SIZE( sp )/* t1 */</span><br><span class="line">load_x  x7, 4 * portWORD_SIZE( sp )/* t2 */</span><br><span class="line">load_x  x8, 5 * portWORD_SIZE( sp )/* s0/fp */</span><br><span class="line">load_x  x9, 6 * portWORD_SIZE( sp )/* s1 */</span><br><span class="line">load_x  x10, 7 * portWORD_SIZE( sp )/* a0 */</span><br><span class="line">load_x  x11, 8 * portWORD_SIZE( sp )/* a1 */</span><br><span class="line">load_x  x12, 9 * portWORD_SIZE( sp )/* a2 */</span><br><span class="line">load_x  x13, 10 * portWORD_SIZE( sp )/* a3 */</span><br><span class="line">load_x  x14, 11 * portWORD_SIZE( sp )/* a4 */</span><br><span class="line">load_x  x15, 12 * portWORD_SIZE( sp )/* a5 */</span><br><span class="line">load_x  x16, 13 * portWORD_SIZE( sp )/* a6 */</span><br><span class="line">load_x  x17, 14 * portWORD_SIZE( sp )/* a7 */</span><br><span class="line">load_x  x18, 15 * portWORD_SIZE( sp )/* s2 */</span><br><span class="line">load_x  x19, 16 * portWORD_SIZE( sp )/* s3 */</span><br><span class="line">load_x  x20, 17 * portWORD_SIZE( sp )/* s4 */</span><br><span class="line">load_x  x21, 18 * portWORD_SIZE( sp )/* s5 */</span><br><span class="line">load_x  x22, 19 * portWORD_SIZE( sp )/* s6 */</span><br><span class="line">load_x  x23, 20 * portWORD_SIZE( sp )/* s7 */</span><br><span class="line">load_x  x24, 21 * portWORD_SIZE( sp )/* s8 */</span><br><span class="line">load_x  x25, 22 * portWORD_SIZE( sp )/* s9 */</span><br><span class="line">load_x  x26, 23 * portWORD_SIZE( sp )/* s10 */</span><br><span class="line">load_x  x27, 24 * portWORD_SIZE( sp )/* s11 */</span><br><span class="line">load_x  x28, 25 * portWORD_SIZE( sp )/* t3 */</span><br><span class="line">load_x  x29, 26 * portWORD_SIZE( sp )/* t4 */</span><br><span class="line">load_x  x30, 27 * portWORD_SIZE( sp )/* t5 */</span><br><span class="line">load_x  x31, 28 * portWORD_SIZE( sp )/* t6 */</span><br><span class="line">addi sp, sp, portCONTEXT_SIZE</span><br><span class="line"></span><br><span class="line">sret</span><br><span class="line">.endfunc</span><br></pre></td></tr></table></figure><ul><li><p>我当前有一个任务正在暂用<code>cpu</code>运行，此时时钟中断来临，会打断当前任务的执行，然后执行任务切换，因此在中断处理函数中，需要先保存当前任务的上下文，<code>x2、x3、x4</code>不需要保存，保存任务上下文时先增加<code>sp</code>的值，增加的大小为<code>portCONTEXT_SIZE</code>，使用<code>store_x</code>依次保存寄存器后，将此时任务的栈顶地址保存到<code>pxNewTCB-&gt;pxTopOfStack</code>中，用于在任务恢复时找到栈顶</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portCONTEXT_SIZE ( 30 * portWORD_SIZE )   <span class="comment">//任务上下文占用内存大小</span></span></span><br></pre></td></tr></table></figure></li><li><p>保存完毕任务上下文后，将<code>scause</code>写入了<code>a0</code>寄存器，<code>sepc</code>寄存器写入了<code>a1</code>寄存器，用于后续针对不同类型的异常进行处理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断是中断还是异常</span><br><span class="line">test_if_asynchronous:     //参数为 scause的值，存放在a0寄存器中</span><br><span class="line">srli a2, a0, __riscv_xlen - 1/* MSB of mcause is 1 if handing an asynchronous interrupt - shift to LSB to clear other bits. */</span><br><span class="line">beq a2, x0, handle_synchronous/* Branch past interrupt handing if not asynchronous. */</span><br><span class="line">store_x a1, 0( sp )</span><br></pre></td></tr></table></figure><ul><li><code>srli</code>是右移位指令，<code>scause</code>的最高位表明了此次<code>trap</code>是中断还是异常，因此将<code>a0</code>寄存器右移<code>__riscv_xlen - 1</code>位后保存到<code>a2</code>寄存器中，此时<code>a2</code>寄存器中就保存了<code>scause</code>的最高位</li><li>如果<code>a2 == 0</code>则表示是异常，跳转到<code>handle_synchronous</code>处执行可以看见为空，否则为中断，将<code>sepc</code>寄存器的值写入到栈顶位置</li></ul></li><li><p>如果为中断则会继续向下执行<code>test_if_ipi</code>标签处的代码，这里会根据<code>scause</code>的最后一位判断是软件中断还是其他中断，如果是软件中断则会执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load_x sp, xISRStackTop/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">jal vPortClearIpiInterrupt</span><br><span class="line">jal vTaskSwitchContext          // </span><br><span class="line">j processed_source</span><br></pre></td></tr></table></figure><ul><li><p>如果是软件中断会切换到<code>ISR</code>专用的栈：<code>xISRStackTop</code>，这是在<code>port.c</code>中定义的一片内存的最高地址。</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422152624416.png" alt="image-20240422152624416"></p></li><li><p>然后跳转到<code>vPortClearIpiInterrupt</code>函数处执行，此函数也是定义在<code>port.c</code>中</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422152807737.png" alt="image-20240422152807737"></p></li><li><p>上面提到过任务可以通过调用<code>portYIELD()</code>来手动触发软中断，从而实现任务切换，此时就是这样的情况，在清楚软中断的标志位后，就会去执行任务切换，调用<code>vTaskSwitchContext</code>，这是<code>FreeRTOS</code>内部定义的选择下一个可执行任务上下文的函数，去看源码就发发现此函数从就绪链表中挑选出最高优先级的任务，然后将全局任务指针<code>pxCurrentTCB</code>指向此任务的<code>TCB</code>，然后就可以从此要执行任务的栈中恢复上下文了，然后跳转执行，恢复任务上下文的函数是<code>processed_source</code></p></li></ul></li><li><p>如果不是主动触发的软中断，则就跳转到<code>test_if_mtimer</code>处执行，此时会判断是时钟中断还是其他外部中断，如果是时钟中断，此时也要进行任务切换，同样切换ISR专用栈，不过需要设置下一次时钟中断到来的计数值，通过调用<code>vPortSetupTimerInterrupt</code>函数实现，然后调用<code>FreeRTOS</code>内部定义的<code>xTaskIncrementTick</code>函数，此函数用于告知系统增加了依次时钟计数，其内部机制我们暂不剖析，主要是用于延时和任务调度相关的。然后调用<code>vTaskSwitchContext</code>选择下一个就绪任务，恢复任务上下文，跳转执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test_if_mtimer:/* If there is a CLINT then the mtimer is used to generate the tick interrupt. */</span><br><span class="line">addi t1, t1, 4/* 0x80000001 + 4 = 0x80000005 == Supervisor timer interrupt. */</span><br><span class="line">bne a0, t1, test_if_external_interrupt  </span><br><span class="line">/* 处理时钟中断 */</span><br><span class="line">load_x sp, xISRStackTop/* 切换到ISR（中断服务例程）专用的堆栈。 */</span><br><span class="line">jal vPortSetupTimerInterrupt    /* 设置定时器中断计数 */</span><br><span class="line">jal xTaskIncrementTick</span><br><span class="line">beqz a0, processed_source/* Don&#x27;t switch context if incrementing tick didn&#x27;t unblock a task. */</span><br><span class="line">jal vTaskSwitchContext</span><br><span class="line">j processed_source</span><br></pre></td></tr></table></figure></li><li><p>如果是外部中断的话，会跳转到<code>handle_interrupt</code>进行处理，如果是其他中断会跳转到<code>processed_trap</code>处理</p></li><li><p>我们重点来看任务恢复函数<code>processed_source</code>，通过执行<code>vTaskSwitchContext</code>，将<code>pxCurrentTCB</code>指向了下一个要执行任务的<code>TCB</code>，通过<code>pxCurrentTCB</code>指针就可以访问到要执行任务的任务上下文的栈空间，因此恢复任务上下文，通过<code>sret</code>指令会跳转到<code>sepc</code>寄存器的地址执行，<code>sepc</code>寄存器在任务被中断后会自动设置，保存了中断返回后指令地址，在<code>freertos_risc_v_trap_handler</code>函数中进行了压栈，因此从栈中恢复后，<code>sret</code>指令就能跳转到正确的地址执行了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processed_source:</span><br><span class="line">load_x  t1, pxCurrentTCB/* Load pxCurrentTCB. */</span><br><span class="line">load_x  sp, 0( t1 )/* Read sp from first TCB member. */</span><br><span class="line"></span><br><span class="line">/* Load sret with the address of the next instruction in the task to run next. */</span><br><span class="line">load_x t0,  0( sp )</span><br><span class="line">csrw sepc, t0</span><br><span class="line"></span><br><span class="line">/* Load mstatus with the interrupt enable bits used by the task. */</span><br><span class="line">load_x  t0, 29 * portWORD_SIZE( sp )   //读取保存在栈中的sstatus寄存器的值</span><br><span class="line">csrw sstatus, t0/* Required for SPIE bit. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//从栈中恢复上下文寄存器</span><br><span class="line">load_x  x1, 1 * portWORD_SIZE( sp )</span><br><span class="line">load_x  x5, 2 * portWORD_SIZE( sp )/* t0 */</span><br><span class="line">load_x  x6, 3 * portWORD_SIZE( sp )/* t1 */</span><br><span class="line">load_x  x7, 4 * portWORD_SIZE( sp )/* t2 */</span><br><span class="line">load_x  x8, 5 * portWORD_SIZE( sp )/* s0/fp */</span><br><span class="line">load_x  x9, 6 * portWORD_SIZE( sp )/* s1 */</span><br><span class="line">load_x  x10, 7 * portWORD_SIZE( sp )/* a0 */</span><br><span class="line">load_x  x11, 8 * portWORD_SIZE( sp )/* a1 */</span><br><span class="line">load_x  x12, 9 * portWORD_SIZE( sp )/* a2 */</span><br><span class="line">load_x  x13, 10 * portWORD_SIZE( sp )/* a3 */</span><br><span class="line">load_x  x14, 11 * portWORD_SIZE( sp )/* a4 */</span><br><span class="line">load_x  x15, 12 * portWORD_SIZE( sp )/* a5 */</span><br><span class="line">load_x  x16, 13 * portWORD_SIZE( sp )/* a6 */</span><br><span class="line">load_x  x17, 14 * portWORD_SIZE( sp )/* a7 */</span><br><span class="line">load_x  x18, 15 * portWORD_SIZE( sp )/* s2 */</span><br><span class="line">load_x  x19, 16 * portWORD_SIZE( sp )/* s3 */</span><br><span class="line">load_x  x20, 17 * portWORD_SIZE( sp )/* s4 */</span><br><span class="line">load_x  x21, 18 * portWORD_SIZE( sp )/* s5 */</span><br><span class="line">load_x  x22, 19 * portWORD_SIZE( sp )/* s6 */</span><br><span class="line">load_x  x23, 20 * portWORD_SIZE( sp )/* s7 */</span><br><span class="line">load_x  x24, 21 * portWORD_SIZE( sp )/* s8 */</span><br><span class="line">load_x  x25, 22 * portWORD_SIZE( sp )/* s9 */</span><br><span class="line">load_x  x26, 23 * portWORD_SIZE( sp )/* s10 */</span><br><span class="line">load_x  x27, 24 * portWORD_SIZE( sp )/* s11 */</span><br><span class="line">load_x  x28, 25 * portWORD_SIZE( sp )/* t3 */</span><br><span class="line">load_x  x29, 26 * portWORD_SIZE( sp )/* t4 */</span><br><span class="line">load_x  x30, 27 * portWORD_SIZE( sp )/* t5 */</span><br><span class="line">load_x  x31, 28 * portWORD_SIZE( sp )/* t6 */</span><br><span class="line">addi sp, sp, portCONTEXT_SIZE</span><br><span class="line"></span><br><span class="line">sret</span><br><span class="line">.endfunc</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-编译运行测试"><a href="#5-编译运行测试" class="headerlink" title="5. 编译运行测试"></a>5. 编译运行测试</h2><p>在<code>build.sh</code>中需要将执行编译<code>trusted_domain</code>，并将生成的固件打包，主要修改的地方为：</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/image-20240422155222221.png" alt="image-20240422155222221"></p><p>固件打包的地方不用修改，还是写入到原本的地址</p><p>运行测试：如下三个任务，两个任务写队列，一个任务接收队列消息，运行成功</p><p><img src="/2024/04/17/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS-%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/GIF%202024-4-22%2015-55-01.gif" alt="GIF 2024-4-22 15-55-01"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://quard-star-tutorial.readthedocs.io/zh-cn/latest/ch21.html">基于qemu-riscv从0开始构建嵌入式linux系统ch21. 实时操作系统FreeRTOS移植RISCV-S模式 — 主页 (quard-star-tutorial.readthedocs.io)</a></li><li><a href="https://rvoslab.github.io/step_by_step_doc/interrupt/plic.html">PLIC · Code an OS Handbook (rvoslab.github.io)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Quard-star移植FreeRTOS-FreeRTOS内部机制剖析</title>
      <link href="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/"/>
      <url>/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客很久没更新了，忙着写简历、刷题、找实习去了，实习offer倒是拿到几个，但是导师不让我出去实习，哎…….. 苦逼牛马研究生的无奈</p></blockquote><h1 id="FreeRTOS内部机制剖析"><a href="#FreeRTOS内部机制剖析" class="headerlink" title="FreeRTOS内部机制剖析"></a>FreeRTOS内部机制剖析</h1><p><code>FreeRTOS</code>是一个嵌入式实时系统，内核设计十分精简，核心代码也比较少，是一个运行在单核cpu的系统 ，支持多种架构比如<code>ARM</code>、<code>RISCV</code>等</p><h2 id="1-FreeRTOS编译运行"><a href="#1-FreeRTOS编译运行" class="headerlink" title="1.FreeRTOS编译运行"></a>1.FreeRTOS编译运行</h2><p>移植此系统之前我们先来看一下如何编译运行，我们还是在<code>qemu</code>上运行。首先去下载源码：</p><ul><li>官网：<a href="https://www.freertos.org/">https://www.freertos.org/</a></li><li>Github：<a href="https://github.com/FreeRTOS/FreeRTOS/tree/main">FreeRTOS&#x2F;FreeRTOS: ‘Classic’ FreeRTOS distribution. Started as Git clone of FreeRTOS SourceForge SVN repo. Submodules the kernel. (github.com)</a></li></ul><p>我下载的是<code>GIthub</code>的<a href="https://github.com/FreeRTOS/FreeRTOS/releases/tag/202107.00">FreeRTOSv202107.00</a>版本，<code>FreeRTOS</code>源码文件夹主要组成如下：</p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/image-20240414144234864.png" alt="image-20240414144234864"></p><ul><li><code>source</code>为<code>FreeRTOS</code>源代码，包含不同平台移植相关的源码和<code>FreeRTOS</code>内核本身的代码</li><li><code>Demo</code>为不同平台下运行的示例</li></ul><p>我们直接来到<code>FreeRTOS/Demo/RISC-V-Qemu-virt_GCC</code>文件夹下，这个<code>demo</code>工程就是官方为<code>Qemu-virt</code>平台适配的，在此目录下直接<code>make</code>编译，大概率是会直接报错的，错误大概有如下几项：</p><ul><li><p><code>target emulation elf32-littleriscv&#39; does not match elf64-littleriscv</code></p><p>这个错误是编译工具链的选择问题，在<code>Makefile</code>第一行中，官方将默认编译器设置成了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CROSS   = riscv64-unknown-elf-</span><br></pre></td></tr></table></figure><p>修改成32位的编译器即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CROSS   = riscv32-unknown-elf-</span><br></pre></td></tr></table></figure></li><li><p><code> Error: unrecognized opcode csrc mstatus,8, extension zicsr required</code></p><p>这个错误是在编译时需要去读取控制寄存器但是却没有启用控制寄存器相关的拓展，在编译选项后加入<code>_zicsr</code>的拓展即可</p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/image-20240414151147506.png" alt="image-20240414151147506"></p></li><li><p><code> can&#39;t link double-float modules with soft-float modules</code></p><p>”这个错误编译环境中存在浮点数支持配置的不一致性。具体来说，项目中有些模块是用硬浮点（double-float）编译的，而有些则是用软浮点（soft-float）编译的。通过统一浮点支持配置来解决，加上<code>d</code>拓展就可以了</p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/image-20240414151415134.png" alt="image-20240414151415134"></p></li></ul><p>解决上述问题后再编译应该就不会报错了，接下来是使用<code>qemu</code>运行，在<code>demo</code>工程下官方有一个<code>readme</code>来说明了如何运行：</p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/image-20240414151546548.png" alt="image-20240414151546548"></p><blockquote><p><code>qemu-system-riscv32</code>可以直接<code>apt</code>下载</p></blockquote><p>运行试试看，出现下面的打印就说明运行成功了</p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/image-20240414152043708.png" alt="image-20240414152043708"></p><h2 id="2-FreeRTOS常用API"><a href="#2-FreeRTOS常用API" class="headerlink" title="2.FreeRTOS常用API"></a>2.FreeRTOS常用API</h2><p><strong>任务创建</strong></p><ul><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00125.html">xTaskCreate</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xTaskCreateStatic.html">xTaskCreateStatic</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00126.html">vTaskDelete</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xTaskGetStaticBuffers.html">xTaskGetStaticBuffers</a></li></ul><p><strong>任务控制</strong></p><ul><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00127.html">vTaskDelay</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/vtaskdelayuntil.html">vTaskDelayUntil</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xtaskdelayuntiltask-control.html">xTaskDelayUntil</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00128.html">uxTaskPriorityGet</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/uxtaskprioritygetfromisr.html">uxTaskPriorityGetFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/uxtaskbasepriorityget.html">uxTaskBasePriorityGet</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/uxtaskbaseprioritygetfromisr.html">uxTaskBasePriorityGetFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00129.html">vTaskPrioritySet</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00130.html">vTaskSuspend</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00131.html">vTaskResume</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/taskresumefromisr.html">xTaskResumeFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xTaskAbortDelay.html">xTaskAbortDelay</a></li></ul><p><strong>RTOS内核控制</strong></p><ul><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00020.html#taskYIELD">taskYIELD</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/taskENTER_CRITICAL_taskEXIT_CRITICAL.html">taskENTER_CRITICAL</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/taskENTER_CRITICAL_taskEXIT_CRITICAL.html">taskEXIT_CRITICAL</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/taskENTER_CRITICAL_FROM_ISR_taskEXIT_CRITICAL_FROM_ISR.html">taskENTER_CRITICAL_FROM_ISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/taskENTER_CRITICAL_FROM_ISR_taskEXIT_CRITICAL_FROM_ISR.html">taskEXIT_CRITICAL_FROM_ISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00020.html#taskDISABLE_INTERRUPTS">taskDISABLE_INTERRUPTS</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00020.html#taskENABLE_INTERRUPTS">taskENABLE_INTERRUPTS</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00132.html">vTaskStartScheduler</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00133.html">vTaskEndScheduler</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00134.html">vTaskSuspendAll</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00135.html">xTaskResumeAll</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/vTaskStepTick.html">vTaskStepTick</a></li></ul><p><strong>队列</strong></p><ul><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00116.html">xQueueCreate</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xQueueCreateStatic.html">xQueueCreateStatic</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00018.html#vQueueDelete">vQueueDelete</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00117.html">xQueueSend</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00119.html">xQueueSendFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xQueueSendToBack.html">xQueueSendToBack</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xQueueSendToBackFromISR.html">xQueueSendToBackFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xQueueSendToFront.html">xQueueSendToFront</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xQueueSendToFrontFromISR.html">xQueueSendToFrontFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00118.html">xQueueReceive</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00120.html">xQueueReceiveFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00018.html#ucQueueMessagesWaiting">uxQueueMessagesWaiting</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00018.html#ucQueueMessagesWaitingFromISR">uxQueueMessagesWaitingFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00018.html#uxQueueSpacesAvailable">uxQueueSpacesAvailable</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00018.html#xQueueReset">xQueueReset</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xQueuePeek.html">xQueuePeek</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xQueuePeekFromISR.html">xQueuePeekFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/vQueueAddToRegistry.html">vQueueAddToRegistry</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/pcQueueGetName.html">pcQueueGetName</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/vQueueUnregisterQueue.html">vQueueUnregisterQueue</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00018.html#xQueueIsQueueEmptyFromISR">xQueueIsQueueEmptyFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00018.html#xQueueIsQueueFullFromISR">xQueueIsQueueFullFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xQueueOverwrite.html">xQueueOverwrite</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xQueueOverwriteFromISR.html">xQueueOverwriteFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xQueueGetStaticBuffers.html">xQueueGetStaticBuffers</a></li></ul><p><strong>信号量&#x2F;互斥锁</strong></p><ul><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreCreateBinary.html">xSemaphoreCreateBinary</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreCreateBinaryStatic.html">xSemaphoreCreateBinaryStatic</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00121.html">vSemaphoreCreateBinary</a> [使用 <a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreCreateBinary.html">xSemaphoreCreateBinary()</a> 进行新设计]</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/CreateCounting.html">xSemaphoreCreateCounting</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreCreateCountingStatic.html">xSemaphoreCreateCountingStatic</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/CreateMutex.html">xSemaphoreCreateMutex</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreCreateMutexStatic.html">xSemaphoreCreateMutexStatic</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreCreateRecursiveMutex.html">xSemaphoreCreateRecursiveMutex</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreCreateRecursiveMutexStatic.html">xSemaphoreCreateRecursiveMutexStatic</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00113.html#vSemaphoreDelete">vSemaphoreDelete</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreGetMutexHolder.html">xSemaphoreGetMutexHolder</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00122.html">xSemaphoreTake</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreTakeFromISR.html">xSemaphoreTakeFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreTakeRecursive.html">xSemaphoreTakeRecursive</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00123.html">xSemaphoreGive</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreGiveRecursive.html">xSemaphoreGiveRecursive</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00124.html">xSemaphoreGiveFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/uxSemaphoreGetCount.html">uxSemaphoreGetCount</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xSemaphoreGetStaticBuffer.html">xSemaphoreGetStaticBuffer</a></li></ul><p><strong>软件定时器</strong></p><ul><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerCreate.html">xTimerCreate</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xTimerCreateStatic.html">xTimerCreateStatic</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerIsTimerActive.html">xTimerIsTimerActive</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-pvTimerGetTimerID.html">pvTimerGetTimerID</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-Software-Timer-API-Functions.html#pcTimerGetName">pcTimerGetName</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-Timers-vTimerSetReloadMode.html">vTimerSetReloadMode</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerStart.html">xTimerStart</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerStop.html">xTimerStop</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerChangePeriod.html">xTimerChangePeriod</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerDelete.html">xTimerDelete</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerReset.html">xTimerReset</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerStartFromISR.html">xTimerStartFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerStopFromISR.html">xTimerStopFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerChangePeriodFromISR.html">xTimerChangePeriodFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerResetFromISR.html">xTimerResetFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-pvTimerGetTimerID.html">pvTimerGetTimerID</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-vTimerSetTimerID.html">vTimerSetTimerID</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-Software-Timer-API-Functions.html#xTimerGetTimerDaemonTaskHandle">xTimerGetTimerDaemonTaskHandle</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xTimerPendFunctionCall.html">xTimerPendFunctionCall</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xTimerPendFunctionCallFromISR.html">xTimerPendFunctionCallFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-pcTimerGetName.html">pcTimerGetName</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerGetPeriod.html">xTimerGetPeriod</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-timers-xTimerGetExpiryTime.html">xTimerGetExpiryTime</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xTimerGetReloadMode.html">xTimerGetReloadMode</a></li></ul><p><strong>事件组</strong></p><ul><li><a href="https://www.freertos.org/zh-cn-cmn-s/vEventGroupDelete.html">vEventGroupDelete</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupClearBits.html">xEventGroupClearBits</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupClearBitsFromISR.html">xEventGroupClearBitsFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupCreate.html">xEventGroupCreate</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupCreateStatic.html">xEventGroupCreateStatic</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupGetBits.html">xEventGroupGetBits</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupGetBitsFromISR.html">xEventGroupGetBitsFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupGetStaticBuffer.html">xEventGroupGetStaticBuffer</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupSetBits.html">xEventGroupSetBits</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupSetBitsFromISR.html">xEventGroupSetBitsFromISR</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupSync.html">xEventGroupSync</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/xEventGroupWaitBits.html">xEventGroupWaitBits</a></li></ul><h2 id="3-任务管理与调度"><a href="#3-任务管理与调度" class="headerlink" title="3. 任务管理与调度"></a>3. 任务管理与调度</h2><h3 id="3-1-FreeRTOS的TCB"><a href="#3-1-FreeRTOS的TCB" class="headerlink" title="3.1 FreeRTOS的TCB"></a>3.1 FreeRTOS的TCB</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span>             </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">// 这里栈顶指针必须位于TCB第一项是为了便于上下文切换操作，详见xPortPendSVHandler中任务切换的操作。</span></span><br><span class="line">        <span class="keyword">volatile</span> StackType_t    *pxTopOfStack;    </span><br><span class="line"></span><br><span class="line">        <span class="comment">// MPU相关暂时不讨论</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line">            xMPU_SETTINGS    xMPUSettings;        </span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示任务状态，不同的状态会挂接在不同的状态链表下，这是链表的节点，可以用于挂载到链表上</span></span><br><span class="line">        ListItem_t            xStateListItem;    </span><br><span class="line">        <span class="comment">// 事件链表项，会挂接到不同事件链表下</span></span><br><span class="line">        ListItem_t            xEventListItem;        </span><br><span class="line">        <span class="comment">// 任务优先级，数值越大优先级越高</span></span><br><span class="line">        UBaseType_t            uxPriority;            </span><br><span class="line">        <span class="comment">// 指向堆栈起始位置，这只是单纯的一个分配空间的地址，可以用来检测堆栈是否溢出</span></span><br><span class="line">        StackType_t            *pxStack;            </span><br><span class="line">        <span class="comment">// 任务名</span></span><br><span class="line">        <span class="type">char</span>                pcTaskName[ configMAX_TASK_NAME_LEN ];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向栈尾，可以用来检测堆栈是否溢出</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</span></span><br><span class="line">            StackType_t        *pxEndOfStack;        </span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录临界段的嵌套层数</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span></span><br><span class="line">            UBaseType_t        uxCriticalNesting;    </span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跟踪调试用的变量</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">            UBaseType_t        uxTCBNumber;        </span><br><span class="line">            UBaseType_t        uxTaskNumber;        </span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务优先级被临时提高时，保存任务原本的优先级</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line">            UBaseType_t        uxBasePriority;        </span><br><span class="line">            UBaseType_t        uxMutexesHeld;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务的一个标签值，可以由用户自定义它的意义，例如可以传入一个函数指针可以用来做Hook    函数调用</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span></span><br><span class="line">            TaskHookFunction_t pxTaskTag;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务的线程本地存储指针，可以理解为这个任务私有的存储空间</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span>( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span></span><br><span class="line">            <span class="type">void</span>            *pvThreadLocalStoragePointers[     configNUM_THREAD_LOCAL_STORAGE_POINTERS ];</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行时间变量</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span>( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">            <span class="type">uint32_t</span>        ulRunTimeCounter;    </span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 支持NEWLIB的一个变量</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>    _<span class="title">reent</span> <span class="title">xNewLib_reent</span>;</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务通知功能需要用到的变量</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span>( configUSE_TASK_NOTIFICATIONS == 1 )</span></span><br><span class="line">            <span class="comment">// 任务通知的值 </span></span><br><span class="line">            <span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue;</span><br><span class="line">            <span class="comment">// 任务通知的状态</span></span><br><span class="line">            <span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来标记这个任务的栈是不是静态分配的</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span>( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span></span><br><span class="line">            <span class="type">uint8_t</span>    ucStaticallyAllocated;         </span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延时是否被打断</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">            <span class="type">uint8_t</span> ucDelayAborted;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 错误标识</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span>( configUSE_POSIX_ERRNO == 1 )</span></span><br><span class="line">            <span class="type">int</span> iTaskErrno;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125; tskTCB;</span><br><span class="line">    <span class="keyword">typedef</span> tskTCB TCB_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-任务创建"><a href="#3-2-任务创建" class="headerlink" title="3.2 任务创建"></a>3.2 任务创建</h3><p>xTaskCreate</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     </span><br><span class="line">TCB_t * pxNewTCB;</span><br><span class="line">BaseType_t xReturn;         </span><br><span class="line">   StackType_t * pxStack;     </span><br><span class="line">   pxStack = pvPortMalloc( ( ( ( <span class="type">size_t</span> ) usStackDepth ) * <span class="keyword">sizeof</span>( StackType_t ) ) );  <span class="comment">//分配任务栈内存</span></span><br><span class="line">   <span class="keyword">if</span>( pxStack != <span class="literal">NULL</span> )</span><br><span class="line">          &#123;</span><br><span class="line">              pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="keyword">sizeof</span>( TCB_t ) );  <span class="comment">//分配TCB内存</span></span><br><span class="line">                   <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">                   &#123;</span><br><span class="line">                       pxNewTCB-&gt;pxStack = pxStack; <span class="comment">//栈指针赋值</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                       vPortFree( pxStack );</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="meta">#<span class="keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span></span><br><span class="line">               &#123;</span><br><span class="line">                   pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">//初始化任务</span></span><br><span class="line">           prvInitialiseNewTask( pxTaskCode, pcName, ( <span class="type">uint32_t</span> ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, <span class="literal">NULL</span> );</span><br><span class="line">           <span class="comment">//将此任务挂载到ready链表中</span></span><br><span class="line">           prvAddNewTaskToReadyList( pxNewTCB );</span><br><span class="line">           xReturn = pdPASS;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> xReturn;</span><br></pre></td></tr></table></figure><ul><li>首先是创建一个<code>TCB</code>，分配一片内存</li><li>然后是为创建的任务分配栈空间</li><li>调用<code>prvInitialiseNewTask</code>初始化任务，会做如下操作：<ul><li>此函数内部会去调用<code>pxPortInitialiseStack</code>来初始化任务的栈，任务栈中存储的是任务的执行状态的寄存器的值，<code>pxPortInitialiseStack</code>会构建一份初始化的值将这个任务切换上下文对应寄存器的值全部设置为0</li><li>填充任务的名字</li><li>初始化任务优先级</li><li>设置栈溢出地址</li></ul></li><li>将此任务挂载到对应优先级的<code>ready</code>链表中</li></ul><h3 id="3-3-多优先级链式TCB连接"><a href="#3-3-多优先级链式TCB连接" class="headerlink" title="3.3 多优先级链式TCB连接"></a>3.3 多优先级链式TCB连接</h3><p>在<code>FreeRTOS</code>中任务有多种状态和多种优先级</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Task states returned by eTaskGetState. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    eRunning = <span class="number">0</span>,     <span class="comment">// 运行态</span></span><br><span class="line">    eReady,           <span class="comment">// 初始化准备运行态</span></span><br><span class="line">    eBlocked,         <span class="comment">// 阻塞态</span></span><br><span class="line">    eSuspended,       <span class="comment">// 挂起态</span></span><br><span class="line">    eDeleted,         <span class="comment">// 任务被删除</span></span><br><span class="line">    eInvalid          <span class="comment">// 任务为空</span></span><br><span class="line">&#125; eTaskState;</span><br></pre></td></tr></table></figure><p>任务切换的逻辑如下：</p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/20181211190823136.png" alt="20181211190823136"></p><ul><li><strong>就绪态</strong>：任务在创建完成时是<code>ready</code>状态，就绪态的任务等待调度器调度</li><li><strong>运行态</strong>：任务独占<code>cpu</code>正在运行</li><li><strong>阻塞态</strong>：等待某个事件的到来，定时或者同步</li><li><strong>挂起态</strong>：退出调度系统，调度器不可见，只能使用vTaskSuspend()挂起和vTaskResume()唤醒后进入就绪态</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PRIVILEGED_DATA TCB_t * <span class="keyword">volatile</span> pxCurrentTCB = <span class="literal">NULL</span>;  <span class="comment">//指向当前运行任务的全局指针</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; <span class="comment">//就绪任务链表数组</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xDelayedTaskList1;  <span class="comment">//存储被延时挂起的任务                        </span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xDelayedTaskList2;  <span class="comment">//存储被延时挂起的任务                    </span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t * <span class="keyword">volatile</span> pxDelayedTaskList;              </span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t * <span class="keyword">volatile</span> pxOverflowDelayedTaskList;    </span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xPendingReadyList;  <span class="comment">//挂起任务链表</span></span><br></pre></td></tr></table></figure><ul><li><p><code>pxCurrentTCB</code>是一个<code>TCB_t</code>类型的全局指针，用于指向当前运行任务的地址</p></li><li><p><code>pxReadyTasksLists[ configMAX_PRIORITIES ];</code>是一个数组，数组下标表示优先级，其每一个数组元素都是一个链表根节点数据结构。如下图所示。在<code>FreeRTOS</code>中，优先级数值越大，优先级越高。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表相关数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span></span></span><br><span class="line"><span class="class">&#123;</span>       </span><br><span class="line">    <span class="keyword">volatile</span> UBaseType_t uxNumberOfItems;</span><br><span class="line">    ListItem_t * configLIST_VOLATILE pxIndex;    </span><br><span class="line">    MiniListItem_t xListEnd;                      </span><br><span class="line">    listSECOND_LIST_INTEGRITY_CHECK_VALUE        </span><br><span class="line">&#125; List_t;</span><br><span class="line"><span class="comment">//MiniListItem_t 是一个双向循环链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    configLIST_VOLATILE TickType_t xItemValue;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span> <span class="title">MiniListItem_t</span>;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span>            </span><br><span class="line">    configLIST_VOLATILE TickType_t xItemValue;            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span>        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span>     </span><br><span class="line">    <span class="type">void</span> * pvOwner;                                         </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxContainer</span>;</span>                   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> <span class="title">ListItem_t</span>;</span>                      </span><br></pre></td></tr></table></figure><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/e05eeeaea6e1992dbaf23dcdcbdd56cb.png" alt="e05eeeaea6e1992dbaf23dcdcbdd56cb"></p></li><li><p>对于数组中的每个优先级的任务链表，构成如下：</p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/27f0786016fb060fa35ec45fbc630c28.png" alt="27f0786016fb060fa35ec45fbc630c28"></p><p>在<code>TCB</code>的定义中：定义了两个<code>ListItem_t </code>类型的变量，因此任务挂载到任务链表上实际上就是通过第一个<code>xStateListItem</code>来实现的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示任务状态，不同的状态会挂接在不同的状态链表下，这是链表的节点，可以用于挂载到链表上</span></span><br><span class="line">ListItem_t            xStateListItem;    </span><br><span class="line"><span class="comment">// 事件链表项，会挂接到不同事件链表下</span></span><br><span class="line"> ListItem_t            xEventListItem;  </span><br></pre></td></tr></table></figure><p>任务链表：xLIST即根节点，可以是就绪链表、阻塞链表、挂起链表等。</p><p>链表中的节点：每个红框为一个节点，通过<code>pvOwner</code>与任务控制块联系到一起，通过<code>pvContainer</code>挂载到就绪、阻塞、挂起链表上。</p></li><li><p><strong>就绪列表（数组）</strong>、<strong>任务控制块（TCB）</strong> 的拓扑结构如下：</p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATW9uc3RlciB4bg==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATW9uc3RlciB4bg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p></li><li><p>就绪列表是含有多个链表的数组集合，数组的索引代表优先级。<br>任务可以通过<code>TCB</code>中的<code>xLIST_ITEM</code>挂在任意一个优先级上的链表中。如上图就表示一个有256个优先级的就绪列表。其中优先级为254的链表上有两个节点，这两个节点分别属于两个任务的TCB。因此这两个TCB的任务优先级就是254，而且目前处于就绪态。假设此时有一个优先级为0的任务从其他状态转换到就绪态。则该任务插入就绪列表的过程如下：该 任务的<code>TCB</code>中的<code>xLIST_ITEM</code> 会链接(link)到 就绪列表数组的0号元素根节点<code>xList</code>中的<code>MiniListItem_t</code> 上。·</p></li></ul><h3 id="3-4-任务调度方式"><a href="#3-4-任务调度方式" class="headerlink" title="3.4 任务调度方式"></a>3.4 任务调度方式</h3><p><strong>抢占式调度</strong></p><ul><li><p>在可抢占式调度中，任务可以被更高优先级的任务抢占。当一个高优先级任务变得可用时，它可以打断当前正在执行的低优先级任务，从而使系统立即切换到高优先级任务执行。</p></li><li><p>在<code>FreeRTOS</code>中，任务调度是基于任务优先级的。当一个任务抢占另一个任务时，它会立即执行，无论被抢占的任务是否已经执行完其时间片。这种方式确保了高优先级任务能够及时响应，并在需要时立即执行，不受低优先级任务的阻碍。</p></li><li><p>在<code>FreeRTOS</code>中通过配置<code>configUSE_PREEMPTION</code>来决定是否启动抢占。</p></li><li><p>如果高优先级不让出cpu，那么低优先级的任务将一直得不到执行</p></li></ul><p><strong>时间片轮转调度</strong></p><ul><li><p>时间片轮转是指操作系统为每个任务分配一个时间片，即预定义的时间量。在时间片轮转调度方式下，每个任务可以执行一个时间片，然后系统将控制权移交给下一个就绪的任务。如果一个任务在其时间片结束前没有完成，系统会暂停该任务，将控制权交给下一个就绪的任务。</p></li><li><p><code>FreeRTOS</code>允许你在配置系统时启用或禁用时间片轮转。时间片的大小可以根据应用程序的需要进行调整。这种调度方式有助于确保任务之间的公平性，避免某些任务长时间占用处理器，同时允许多个任务分享处理时间。</p></li><li><p>在<code>FreeRTOS</code>中通过配置<code>configUSE_TIME_SLICING</code>来决定是否启动时间片轮转</p></li><li><p>对于同优先级的任务才会启用时间片轮转</p></li></ul><p><strong>如何让出CPU</strong></p><ul><li>任务主动让出：任务可以调用<code>vTaskDelay()</code>函数或者<code>vTaskDelayUntil()</code>函数，将自己挂起一段时间，以便其他任务能够运行。这种方式是任务主动放弃CPU的一种方式</li><li>阻塞等待事件：任务可以调用<code>FreeRTOS</code>提供的阻塞函数，如<code>xQueueReceive()、xSemaphoreTake()</code>等，来等待特定事件的发生。当任务在等待某个事件时，它会被置于阻塞状态，从而释放CPU，直到事件发生后才会被唤醒。</li><li>任务进入阻塞状态：任务在执行过程中，如果发生某些阻塞事件，如等待一个队列满足条件、等待互斥信号量等，会自动进入阻塞状态，这时会释放CPU。一旦阻塞条件得到满足，任务将被重新置于就绪状态。</li></ul><h2 id="4-消息队列和信号量"><a href="#4-消息队列和信号量" class="headerlink" title="4.消息队列和信号量"></a>4.消息队列和信号量</h2><p>消息队列是用于进程间通讯的，且可以实现互斥的访问，避免多进程间由于任务切换导致的竞态问题</p><ul><li><code>xQueueCreate</code>创建一个队列</li><li><code>xQueueSend</code>写队列</li><li><code>xQueueReceive</code>读队列</li></ul><h3 id="4-1-队列创建和初始化"><a href="#4-1-队列创建和初始化" class="headerlink" title="4.1 队列创建和初始化"></a>4.1 队列创建和初始化</h3><p>首先我们来看一下队列在<code>FreeRTOS</code>中的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QueuePointers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int8_t</span> * pcTail;    </span><br><span class="line">    <span class="type">int8_t</span> * pcReadFrom; </span><br><span class="line">&#125; QueuePointers_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QueueDefinition</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int8_t</span> * pcHead;       <span class="comment">/*&lt; 指向队列存储的起始位置。*/</span>    </span><br><span class="line">    <span class="type">int8_t</span> * pcWriteTo;    <span class="comment">/*&lt; 数据存储区下一个可以写入数据的位置。 */</span>   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        QueuePointers_t xQueue;     <span class="comment">/*&lt; 当结构体作为一个队列时使用,包含两个指针 */</span></span><br><span class="line">        SemaphoreData_t xSemaphore; <span class="comment">/*&lt; 当队列作为信号量时使用. */</span></span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    List_t xTasksWaitingToSend;   <span class="comment">/*&lt; 阻塞等待向队列中放入元素的任务链表。按照优先级顺序存储。 */</span>   </span><br><span class="line">    List_t xTasksWaitingToReceive;  <span class="comment">/*&lt; 阻塞等待从队列中读取元素的任务链表，按照优先级顺序存储。 */</span>        </span><br><span class="line">    <span class="keyword">volatile</span> UBaseType_t uxMessagesWaiting; <span class="comment">/*&lt;当前队列中的元素个数. */</span></span><br><span class="line">    UBaseType_t uxLength;          <span class="comment">/*&lt; 队列能够存储的元素个数。 */</span>         </span><br><span class="line">    UBaseType_t uxItemSize;        <span class="comment">/*&lt; 每一个元素的大小，如果这个值为0表示Mutex*/</span>        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int8_t</span> cRxLock;   <span class="comment">//队列上锁后，储存从队列收到的列表项数目            </span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int8_t</span> cTxLock;   <span class="comment">//队列上锁后，储存发送到队列的列表项数目            </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span></span><br><span class="line">        <span class="type">uint8_t</span> ucStaticallyAllocated; </span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">QueueDefinition</span> * pxQueueSetContainer; <span class="comment">//队列集</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">        UBaseType_t uxQueueNumber;</span><br><span class="line">        <span class="type">uint8_t</span> ucQueueType;    <span class="comment">//队列类型</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; xQUEUE;</span><br></pre></td></tr></table></figure><p>队列是通过<code>xQueueCreate</code>这个宏来创建的，这个宏内部会去调用<code>xQueueGenericCreate</code>函数来创建一个队列，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">QueueHandle_t xMyQueueHandle;</span><br><span class="line">xMyQueueHandle = xQueueCreate(<span class="number">20</span>,<span class="keyword">sizeof</span>(<span class="type">int32_t</span>));</span><br></pre></td></tr></table></figure><p>创建了一个长度为20个元素、每个元素为<code>int32_t</code>类型的队列：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueGenericCreate</span><span class="params">( <span class="type">const</span> UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                                       <span class="type">const</span> UBaseType_t uxItemSize,</span></span><br><span class="line"><span class="params">                                       <span class="type">const</span> <span class="type">uint8_t</span> ucQueueType )</span></span><br><span class="line">    &#123;</span><br><span class="line">        Queue_t * pxNewQueue;      <span class="comment">/* 消息队列控制块，一个结构体指针*/</span></span><br><span class="line">        <span class="type">size_t</span> xQueueSizeInBytes;  <span class="comment">/* 需要分配的内存大小，Bytes为单位 */</span></span><br><span class="line">        <span class="type">uint8_t</span> * pucQueueStorage; <span class="comment">/* 实际存放消息的地址，即消息队列控制块的后面 */</span></span><br><span class="line"></span><br><span class="line">        configASSERT( uxQueueLength &gt; ( UBaseType_t ) <span class="number">0</span> ); <span class="comment">/*判断要创建的消息队列的长度是否大于0*/</span></span><br><span class="line"><span class="comment">//计算需要分配的内存大小/字节  元素个数*单个元素大小</span></span><br><span class="line">        xQueueSizeInBytes = ( <span class="type">size_t</span> ) ( uxQueueLength * uxItemSize ); </span><br><span class="line">     </span><br><span class="line">        configASSERT( ( uxItemSize == <span class="number">0</span> ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        configASSERT( ( <span class="keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ) &gt;  xQueueSizeInBytes );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//分配内存，队列头+实际的元素占用的大小</span></span><br><span class="line">        pxNewQueue = ( Queue_t * ) pvPortMalloc( <span class="keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pxNewQueue != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line"> <span class="comment">//计算存放元素的内存开始地址</span></span><br><span class="line">            pucQueueStorage = ( <span class="type">uint8_t</span> * ) pxNewQueue;</span><br><span class="line">            pucQueueStorage += <span class="keyword">sizeof</span>( Queue_t ); </span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line">                &#123;</span><br><span class="line">              </span><br><span class="line">                    pxNewQueue-&gt;ucStaticallyAllocated = pdFALSE;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*初始化一个队列*/</span></span><br><span class="line">            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            traceQUEUE_CREATE_FAILED( ucQueueType );</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pxNewQueue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对列在创建完毕分配内存后会进行初始化，调用<code>prvInitialiseNewQueue</code>函数，此函数内部会调用<code>xQueueGenericReset</code>去做一些初始化操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseNewQueue</span><span class="params">( <span class="type">const</span> UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> UBaseType_t uxItemSize,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint8_t</span> * pucQueueStorage,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">uint8_t</span> ucQueueType,</span></span><br><span class="line"><span class="params">                                   Queue_t * pxNewQueue )</span></span><br><span class="line">&#123;</span><br><span class="line">    ( <span class="type">void</span> ) ucQueueType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( uxItemSize == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        pxNewQueue-&gt;pcHead = ( <span class="type">int8_t</span> * ) pxNewQueue; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxNewQueue-&gt;pcHead = ( <span class="type">int8_t</span> * ) pucQueueStorage;<span class="comment">//初始化头</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pxNewQueue-&gt;uxLength = uxQueueLength;</span><br><span class="line">    pxNewQueue-&gt;uxItemSize = uxItemSize;</span><br><span class="line">    ( <span class="type">void</span> ) xQueueGenericReset( pxNewQueue, pdTRUE );</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxNewQueue-&gt;ucQueueType = ucQueueType;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_TRACE_FACILITY */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxNewQueue-&gt;pxQueueSetContainer = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_QUEUE_SETS */</span></span></span><br><span class="line"></span><br><span class="line">    traceQUEUE_CREATE( pxNewQueue );</span><br><span class="line">&#125;</span><br><span class="line">BaseType_t <span class="title function_">xQueueGenericReset</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                               BaseType_t xNewQueue )</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line"></span><br><span class="line">    taskENTER_CRITICAL(); <span class="comment">//关中断</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxQueue-&gt;u.xQueue.pcTail = pxQueue-&gt;pcHead + ( pxQueue-&gt;uxLength * pxQueue-&gt;uxItemSize ); </span><br><span class="line">        pxQueue-&gt;uxMessagesWaiting = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line">        pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;</span><br><span class="line">        pxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead + ( ( pxQueue-&gt;uxLength - <span class="number">1U</span> ) * pxQueue-&gt;uxItemSize ); </span><br><span class="line">        pxQueue-&gt;cRxLock = queueUNLOCKED;</span><br><span class="line">        pxQueue-&gt;cTxLock = queueUNLOCKED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( xNewQueue == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//初始化阻塞任务链表</span></span><br><span class="line">            vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToSend ) );</span><br><span class="line">            vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL(); <span class="comment">//开中断</span></span><br><span class="line">    <span class="keyword">return</span> pdPASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列在初始化完成后内存分布如下：</p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/image-20240417161447063.png" alt="image-20240417161447063"></p><p><code>pcHead</code>和<code>pcTail</code>这两个指针用来记录队列的起始地址和结束地址，这两个值始终不变。数据的写入和读取分别使用<code>pvWriteTo</code>和<code>pcReadFrom</code>两个指针，<code>pcReadFrom</code>始终指向<code>pvWriteTo</code>指向元素的前一个元素的地址。</p><h3 id="4-2-写队列"><a href="#4-2-写队列" class="headerlink" title="4.2 写队列"></a>4.2 写队列</h3><p><code>xQueueSend</code>会去调用<code>xQueueGenericSend</code>写队列</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueGenericSend</span><span class="params">( QueueHandle_t xQueue, <span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> pvItemToQueue, TickType_t xTicksToWait, <span class="type">const</span> BaseType_t xCopyPosition )</span></span><br><span class="line">&#123;</span><br><span class="line">BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired; <span class="comment">/* 超时时间是否已设置 */</span></span><br><span class="line">TimeOut_t xTimeOut; <span class="comment">/* 阻塞等待的超时时间结构体*/</span></span><br><span class="line">Queue_t * <span class="type">const</span> pxQueue = ( Queue_t * ) xQueue; <span class="comment">/* 消息队列控制块*/</span></span><br><span class="line"></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line">    configASSERT( !( ( pvItemToQueue == <span class="literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line">    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != <span class="number">1</span> ) ) );</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span></span><br><span class="line">    &#123;</span><br><span class="line">        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="number">0</span> ) ) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这个函数放松了编码标准，允许在函数本身中使用返回语句。这样做是为了提高执行时间效率 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*当前消息队列的个数未满或设置了可以覆盖写入 */</span></span><br><span class="line">            <span class="keyword">if</span>( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )</span><br><span class="line">            &#123;</span><br><span class="line">                traceQUEUE_SEND( pxQueue );</span><br><span class="line">                <span class="comment">/* 复制数据到队列中 */</span></span><br><span class="line">                xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );</span><br><span class="line"></span><br><span class="line">                <span class="meta">#<span class="keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 队列所属队列集不为空 */</span></span><br><span class="line">                    <span class="keyword">if</span>( pxQueue-&gt;pxQueueSetContainer != <span class="literal">NULL</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 向队列集发送通知消息 */</span></span><br><span class="line">                        <span class="keyword">if</span>( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/* 该队列是队列集的成员，向队列集发送消息会导致一个优先级更高的任务解除阻塞，需要上下文切换 */</span></span><br><span class="line">                            queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 队列所属队列集为空 */</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 如果有任务等待数据到达队列，那么现在解除阻塞 */</span></span><br><span class="line">                        <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">/* 未阻塞的任务的优先级比我们自己的要高，所以要立即执行。</span></span><br><span class="line"><span class="comment">                                是的，在临界区内这样做是没问题的——内核会负责这一点。 */</span></span><br><span class="line">                                queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>( xYieldRequired != pdFALSE )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/* 此路径是一种特殊情况，只有在任务持有多个互斥锁并且这些互斥锁返回的顺序与获取它们的顺序不同时才会执行 */</span></span><br><span class="line">                            queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">#<span class="keyword">else</span> <span class="comment">/* configUSE_QUEUE_SETS */</span></span></span><br><span class="line">                <span class="comment">//...省略部分</span></span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_QUEUE_SETS */</span></span></span><br><span class="line"></span><br><span class="line">                taskEXIT_CRITICAL();</span><br><span class="line">                <span class="keyword">return</span> pdPASS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/* 队列已满，无法写入时 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="number">0</span> ) <span class="comment">/* 若设置的阻塞等待时间为0 */</span></span><br><span class="line">                &#123;   <span class="comment">/* 那就不写了，直接退出临界区 */</span></span><br><span class="line">                    taskEXIT_CRITICAL();</span><br><span class="line">                    <span class="comment">/* 退出函数之前返回原始权限级别 */</span></span><br><span class="line">                    traceQUEUE_SEND_FAILED( pxQueue );</span><br><span class="line">                    <span class="comment">/* 返回“队列满”的提示 */</span></span><br><span class="line">                    <span class="keyword">return</span> errQUEUE_FULL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( xEntryTimeSet == pdFALSE )  <span class="comment">/* 若设置的阻塞等待时间不为0，且进入时间还未设置 */</span></span><br><span class="line">                &#123;   <span class="comment">/* 队列已满，并且指定了一个块时间，因此配置超时结构体 */</span></span><br><span class="line">                    vTaskSetTimeOutState( &amp;xTimeOut );</span><br><span class="line">                    xEntryTimeSet = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 现在临界区已经退出，中断和其他任务可以向队列发送和从队列接收 */</span></span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        prvLockQueue( pxQueue );</span><br><span class="line">        <span class="comment">/* 更新超时状态，看看它是否已经过期 */</span></span><br><span class="line">        <span class="keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE ) <span class="comment">/*未超时*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueFull( pxQueue ) != pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                traceBLOCKING_ON_QUEUE_SEND( pxQueue );</span><br><span class="line">                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ), xTicksToWait );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 解除队列锁定意味着队列事件可以影响事件列表。现在发生的中断可能会再次将该任务从事件列表中删除</span></span><br><span class="line"><span class="comment">                ——但由于调度器被挂起，该任务将进入挂起的最后一个准备列表，而不是实际的准备列表。 */</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*恢复任务调度器将从等待就绪列表进入就绪列表,所以它是可行的,这个任务已经就绪列表之前产量</span></span><br><span class="line"><span class="comment">                ——在这种情况下,不会导致上下文切换,除非也在等待一个更高优先级的任务就绪列表 */</span></span><br><span class="line">                <span class="keyword">if</span>( xTaskResumeAll() == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    portYIELD_WITHIN_API();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;   <span class="comment">/* 再试一次 */</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line">                ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* 已经超时 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            prvUnlockQueue( pxQueue );</span><br><span class="line">            ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">            traceQUEUE_SEND_FAILED( pxQueue );</span><br><span class="line">            <span class="keyword">return</span> errQUEUE_FULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/v2-46bd62027d6c3c2de4ab8e0ce763d53a_r.jpg" alt="img"></p><ul><li>当前进程去写队列时，如果发现队列满了，则会将自己挂起，然后将自己挂到队列的等待写任务链表中，然后执行任务切换</li><li>如果队列未满，即当前队列可写，则会调用<code>prvCopyDataToQueue</code>函数去写队列，写完数据后会从队列的<code>delay</code>任务链表中取出一个想要读数据的任务，将此任务添加到就绪链表，然后执行任务切换</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> BaseType_t <span class="title function_">prvCopyDataToQueue</span><span class="params">( Queue_t * <span class="type">const</span> pxQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> BaseType_t xPosition )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdFALSE;</span><br><span class="line">    UBaseType_t uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">    uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pxQueue-&gt;uxItemSize == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX )</span><br><span class="line">                &#123;</span><br><span class="line">        </span><br><span class="line">                    xReturn = xTaskPriorityDisinherit( pxQueue-&gt;u.xSemaphore.xMutexHolder );</span><br><span class="line">                    pxQueue-&gt;u.xSemaphore.xMutexHolder = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_MUTEXES */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( xPosition == queueSEND_TO_BACK )</span><br><span class="line">    &#123;</span><br><span class="line">        ( <span class="type">void</span> ) <span class="built_in">memcpy</span>( ( <span class="type">void</span> * ) pxQueue-&gt;pcWriteTo, pvItemToQueue, ( <span class="type">size_t</span> ) pxQueue-&gt;uxItemSize ); </span><br><span class="line">        pxQueue-&gt;pcWriteTo += pxQueue-&gt;uxItemSize;                                                       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pxQueue-&gt;pcWriteTo &gt;= pxQueue-&gt;u.xQueue.pcTail )                                         </span><br><span class="line">        &#123;</span><br><span class="line">            pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ( <span class="type">void</span> ) <span class="built_in">memcpy</span>( ( <span class="type">void</span> * ) pxQueue-&gt;u.xQueue.pcReadFrom, pvItemToQueue, ( <span class="type">size_t</span> ) pxQueue-&gt;uxItemSize ); </span><br><span class="line">        pxQueue-&gt;u.xQueue.pcReadFrom -= pxQueue-&gt;uxItemSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pxQueue-&gt;u.xQueue.pcReadFrom &lt; pxQueue-&gt;pcHead ) </span><br><span class="line">        &#123;</span><br><span class="line">            pxQueue-&gt;u.xQueue.pcReadFrom = ( pxQueue-&gt;u.xQueue.pcTail - pxQueue-&gt;uxItemSize );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( xPosition == queueOVERWRITE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                --uxMessagesWaiting;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看见<code>prvCopyDataToQueue</code>内部根据<code>xPosition</code>来判断如何写入，总共有三种方式：队尾、队头、覆盖</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> queueSEND_TO_BACK       ( ( BaseType_t ) 0 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queueSEND_TO_FRONT      ( ( BaseType_t ) 1 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queueOVERWRITE          ( ( BaseType_t ) 2 )</span></span><br></pre></td></tr></table></figure></li><li><p><code>xQueueSend</code>默认是发送到队尾：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-读队列"><a href="#4-3-读队列" class="headerlink" title="4.3 读队列"></a>4.3 读队列</h3><p><code>xQueueReceive()</code>函数实际是使用<code>xQueueGenericReceive()</code>这个函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )</span></span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueueGenericReceive</span><span class="params">( QueueHandle_t xQueue, <span class="type">void</span> * <span class="type">const</span> pvBuffer, TickType_t xTicksToWait, <span class="type">const</span> BaseType_t xJustPeeking )</span></span><br><span class="line">&#123;</span><br><span class="line">BaseType_t xEntryTimeSet = pdFALSE;</span><br><span class="line">TimeOut_t xTimeOut;</span><br><span class="line"><span class="type">int8_t</span> *pcOriginalReadPosition;</span><br><span class="line">Queue_t * <span class="type">const</span> pxQueue = ( Queue_t * ) xQueue;</span><br><span class="line"></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line">    configASSERT( !( ( pvBuffer == <span class="literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span></span><br><span class="line">    &#123;</span><br><span class="line">        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="number">0</span> ) ) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这个函数放松了编码标准，允许在函数本身中使用返回语句。这样做是为了提高执行时间效率 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line">            <span class="comment">/* 现在队列中是否有数据?要运行调用任务，必须是希望访问队列的优先级最高的任务 */</span></span><br><span class="line">            <span class="keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="number">0</span> ) <span class="comment">/*消息队列中有数据*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                pcOriginalReadPosition = pxQueue-&gt;u.pcReadFrom;<span class="comment">/* 记住读取位置，以防队列被读取 */</span></span><br><span class="line">                prvCopyDataFromQueue( pxQueue, pvBuffer );<span class="comment">/* 从队列中复制数据 */</span></span><br><span class="line">                <span class="keyword">if</span>( xJustPeeking == pdFALSE ) <span class="comment">/*不是Peeking模式读取消息*/</span></span><br><span class="line">                &#123;</span><br><span class="line">                    traceQUEUE_RECEIVE( pxQueue );</span><br><span class="line">                    pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - <span class="number">1</span>;<span class="comment">/* 实际上删除数据，而不仅仅是读取 */</span></span><br><span class="line">                    <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX )</span><br><span class="line">                        &#123;   <span class="comment">/* 如果有必要，记录实现优先级继承所需的信息 */</span></span><br><span class="line">                            pxQueue-&gt;pxMutexHolder = ( <span class="type">int8_t</span> * ) pvTaskIncrementMutexHeldCount();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_MUTEXES */</span></span></span><br><span class="line">                    <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )</span><br><span class="line">                        &#123; queueYIELD_IF_USING_PREEMPTION(); &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">/*是Peeking模式读取消息（只读取，不删除）*/</span></span><br><span class="line">                &#123;</span><br><span class="line">                    traceQUEUE_PEEK( pxQueue ); <span class="comment">/*执行PEEK*/</span></span><br><span class="line">                    pxQueue-&gt;u.pcReadFrom = pcOriginalReadPosition;<span class="comment">/* 数据没有被移除，所以重置读指针 */</span></span><br><span class="line">                    <span class="comment">/* 数据被留在队列中，因此请查看是否有其他任务在等待该数据 */</span></span><br><span class="line">                    <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )</span><br><span class="line">                        &#123;  <span class="comment">/* 等待的任务具有比该任务更高的优先级 */</span></span><br><span class="line">                            queueYIELD_IF_USING_PREEMPTION(); <span class="comment">/*进行任务切换*/</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                taskEXIT_CRITICAL();</span><br><span class="line">                <span class="keyword">return</span> pdPASS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/*消息队列中没有数据*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="number">0</span> )</span><br><span class="line">                &#123;   <span class="comment">/* 队列是空的，没有指定块时间(或者块时间已经过期)，所以现在离开 */</span></span><br><span class="line">                    taskEXIT_CRITICAL();</span><br><span class="line">                    traceQUEUE_RECEIVE_FAILED( pxQueue ); </span><br><span class="line">                    <span class="keyword">return</span> errQUEUE_EMPTY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( xEntryTimeSet == pdFALSE )</span><br><span class="line">                &#123;   <span class="comment">/* 对列是空的，并且指定了块时间，因此配置超时结构 */</span></span><br><span class="line">                    vTaskSetTimeOutState( &amp;xTimeOut );</span><br><span class="line">                    xEntryTimeSet = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 临界区已经退出，中断和其他任务可以向队列发送或从队列接收消息 */</span></span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        prvLockQueue( pxQueue );</span><br><span class="line">        <span class="comment">/* 更新超时状态，查看它是否已经过期 */</span></span><br><span class="line">        <span class="keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )<span class="comment">//阻塞等待未超时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )<span class="comment">//消息队列为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX )</span><br><span class="line">                    &#123;</span><br><span class="line">                        taskENTER_CRITICAL();</span><br><span class="line">                        &#123; vTaskPriorityInherit( ( <span class="type">void</span> * ) pxQueue-&gt;pxMutexHolder ); &#125;</span><br><span class="line">                        taskEXIT_CRITICAL();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );<span class="comment">/*添加任务到阻塞列表*/</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line">                <span class="keyword">if</span>( xTaskResumeAll() == pdFALSE )</span><br><span class="line">                &#123; portYIELD_WITHIN_API(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//消息队列为空</span></span><br><span class="line">            &#123;   <span class="comment">/* 再试一次 */</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line">                ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//阻塞等待已超时</span></span><br><span class="line">        &#123;</span><br><span class="line">            prvUnlockQueue( pxQueue );</span><br><span class="line">            ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )<span class="comment">//消息队列为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                traceQUEUE_RECEIVE_FAILED( pxQueue );</span><br><span class="line">                <span class="keyword">return</span> errQUEUE_EMPTY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/v2-e6dc7526ceaf8924f4fe87b406282e7e_r.jpg" alt="img"></p><ul><li>当前任务去读队列时，如果队列中没有数据，则会将自己挂起，添加到队列的等待读的任务链表中，其他任务向队列中写入数据后会去队列的等待读链表中唤醒任务</li><li>如果队列中有数据，则会去调用<code>prvCopyDataFromQueue</code>函数从队列中取出一个元素</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvCopyDataFromQueue</span><span class="params">( Queue_t * <span class="type">const</span> pxQueue,</span></span><br><span class="line"><span class="params">                                  <span class="type">void</span> * <span class="type">const</span> pvBuffer )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        pxQueue-&gt;u.xQueue.pcReadFrom += pxQueue-&gt;uxItemSize;           </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pxQueue-&gt;u.xQueue.pcReadFrom &gt;= pxQueue-&gt;u.xQueue.pcTail ) </span><br><span class="line">        &#123;</span><br><span class="line">            pxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        ( <span class="type">void</span> ) <span class="built_in">memcpy</span>( ( <span class="type">void</span> * ) pvBuffer, ( <span class="type">void</span> * ) pxQueue-&gt;u.xQueue.pcReadFrom, ( <span class="type">size_t</span> ) pxQueue-&gt;uxItemSize ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-信号量和互斥量"><a href="#4-4-信号量和互斥量" class="headerlink" title="4.4 信号量和互斥量"></a>4.4 信号量和互斥量</h3><p>信号量和互斥量都是特殊的队列，都是通过队列来实现的，相当于队列中只放了一个元素供所有进程共享，信号量用于计数，互斥量只有<code>0 , 1</code>值，用于进程互斥</p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/01_mutex_example.png" alt="01_mutex_example"></p><p><img src="/2024/04/14/%E4%B8%BAQuard-star%E7%A7%BB%E6%A4%8DFreeRTOS/01_semaphore_usage.png" alt="01_semaphore_usage"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00106.html">FreeRTOS API categories</a></li><li><a href="https://blog.csdn.net/Nrush/article/details/102771404">FreeRTOS解析：TCB_t结构体及重要变量说明（Task-1）_rtos tcb-CSDN博客</a></li><li><a href="https://blog.csdn.net/Hxj_CSDN/article/details/84960220">FreeRTOS笔记（五）任务状态_freertos四种状态可以在什么和什么之间转换-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_45636061/article/details/121460778">【FreeRTOS】1. 任务链表的实现_freertos的就绪列表-CSDN博客</a></li><li><a href="https://blog.csdn.net/m0_49476241/article/details/133973941">FreeRTOS深入教程（任务创建的深入和任务调度机制分析）_freertos教程-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_39270987/article/details/114372975">FreeRtos源码分析之消息队列工作原理（九）_freertos消息队列等待原理-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/341506772">FreeRTOS源码探析之——消息队列 - 知乎 (zhihu.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用原始套接字剖析TCP</title>
      <link href="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/"/>
      <url>/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络分层"><a href="#1-网络分层" class="headerlink" title="1. 网络分层"></a>1. 网络分层</h2><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/ARP%E5%8D%8F%E8%AE%AE.png" alt="ARP协议"></p><ul><li><p>按照OSI分层的话从上到下分为7层：物理层、链路层、网络层、传输层、会话层、表示层、应用层</p></li><li><p>一般来说会话层、表示层、应用层 统一称为 应用层</p></li><li><p>每张网卡都有一个唯一确定的地址，被称为<code>MAC</code>地址，通过这个全球唯一的<code>MAC</code>地址，就能标识不同的网络设备，<code>MAC</code>地址是一个<code>48bit</code>的值</p></li></ul><h2 id="2-Ethernet-封包格式"><a href="#2-Ethernet-封包格式" class="headerlink" title="2. Ethernet 封包格式"></a>2. Ethernet 封包格式</h2><h3 id="2-1-以太网封包格式"><a href="#2-1-以太网封包格式" class="headerlink" title="2.1 以太网封包格式"></a>2.1 以太网封包格式</h3><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/v2-d69f6122a8ec686cbf573d96d66b078c_r.jpg" alt="img" style="zoom:150%;"><table><thead><tr><th>字段</th><th>字段长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>前导码（preamble）</td><td>7</td><td>0和1交替变换的码流</td></tr><tr><td>帧开始符（SFD）</td><td>1</td><td>帧起始符</td></tr><tr><td>目的地址（DA）</td><td>6</td><td>目的设备的MAC物理地址</td></tr><tr><td>源地址（SA）</td><td>6</td><td>发送设备的MAC物理地址</td></tr><tr><td>长度&#x2F;类型（Length&#x2F;Type）</td><td>2</td><td>帧数据字段长度&#x2F;帧协议类型</td></tr><tr><td>数据及填充（data and pad）</td><td>46~1500</td><td>帧数据字段</td></tr><tr><td>帧校验序列（FCS）</td><td>4</td><td>数据校验字段</td></tr></tbody></table><ul><li><p>以太网帧大小必须在64-1518字节（不包含前导码和定界符），即包括目的地址（6B）、源地址（6B）、类型（2B）、数据、FCS（4B）在内，其中数据段大小在46~1500字节之间。</p></li><li><p>以太网的前导码是一串交替的0和1，用于在网络流中区分一帧帧数据，前导码的最后一个字节是帧开始定界符</p></li></ul><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221170858451.png" alt="image-20240221170858451" style="zoom: 67%;"><h3 id="2-2-IP协议封包格式"><a href="#2-2-IP协议封包格式" class="headerlink" title="2.2 IP协议封包格式"></a>2.2 IP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/IP.png" alt="IP"></p><h3 id="2-2-ARP协议封包格式"><a href="#2-2-ARP协议封包格式" class="headerlink" title="2.2 ARP协议封包格式"></a>2.2 ARP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/ARP.png" alt="ARP"></p><h3 id="2-3-TCP协议封包格式"><a href="#2-3-TCP协议封包格式" class="headerlink" title="2.3 TCP协议封包格式"></a>2.3 TCP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/tcp-170852003743213.png" alt="tcp"></p><p>在Tcp协议中，比较重要的字段有：</p><ul><li><p>源端口：表示发送端端口号，字段长 16 位，2个字节</p></li><li><p>目的端口：表示接收端端口号，字段长 16 位，2个字节</p></li><li><p>序列号（sequence number）：字段长 32 位，占4个字节，序列号的范围为 [0，4284967296]。</p><ul><li>由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号</li><li>首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号，这是随机生成的。</li><li>序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0</li></ul></li><li><p>确认序号（acknowledgement number）：占32位（4字节），表示收到的下一个报文段的第一个数据字节的序号，如果确认序号为N，序号为S，则表明到序号N-S为止的所有数据字节都已经被正确地接收到了。</p></li><li><p>8个标志位（Flag）:</p><ul><li>CWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</li><li>ECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1.；</li><li>URG：该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</li><li>ACK：该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</li><li>PSH：该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</li><li>SYN：用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</li><li>FIN：该位设为 1，表示今后不再有数据发送，希望断开连接。</li></ul></li><li><p>窗口尺寸：该字段长 16 位，表示从确认序号所指位置开始能够接收的数据大小，TCP 不允许发送超过该窗口大小的数据。</p></li></ul><h3 id="2-4-UDP协议封包格式"><a href="#2-4-UDP协议封包格式" class="headerlink" title="2.4 UDP协议封包格式"></a>2.4 UDP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/udp-170852008999615.png" alt="udp"></p><h2 id="2-套接字通信"><a href="#2-套接字通信" class="headerlink" title="2.套接字通信"></a>2.套接字通信</h2><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/%E5%9B%BE%E7%89%87.png" alt="图片" style="zoom: 80%;"><ul><li>在Linux的套接字编程中分为标准套接字和原始套接字，而标准套接字又分为流式套接字和数据报套接字<ul><li>流式套接字：TCP</li><li>数据报套接字：UDP</li></ul></li></ul><h3 id="2-1-UDP编程"><a href="#2-1-UDP编程" class="headerlink" title="2.1 UDP编程"></a>2.1 UDP编程</h3><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/udp.png" alt="udp" style="zoom:80%;"><ul><li><code>sendto</code>函数是非阻塞的，<code>recvfrom</code>函数是阻塞的</li></ul><p><strong>udp客户端的实现:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//udp客户端的实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons inet_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;ip&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd; <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span> <span class="comment">//服务器网络信息结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：创建套接字</span></span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端自己指定自己的ip地址和端口号，一般不需要，系统会自动分配</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    clientaddr.sin_addr.s_addr = inet_addr(argv[<span class="number">3</span>]); <span class="comment">//客户端的ip地址</span></span><br><span class="line">    clientaddr.sin_port = htons(atoi(argv[<span class="number">4</span>])); <span class="comment">//客户端的端口号</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：填充服务器网络信息结构体</span></span><br><span class="line">    <span class="comment">//inet_addr：将点分十进制字符串ip地址转化为整形数据</span></span><br><span class="line">    <span class="comment">//htons：将主机字节序转化为网络字节序</span></span><br><span class="line">    <span class="comment">//atoi：将数字型字符串转化为整形数据</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：进行通信</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sendto(sockfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to sendto&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> text[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, text, <span class="keyword">sizeof</span>(text), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;from server: %s\n&quot;</span>, text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第四步：关闭文件描述符</span></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>udp服务器的实现:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//udp服务器的实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons inet_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;ip&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd; <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span> <span class="comment">//服务器网络信息结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：创建套接字</span></span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：填充服务器网络信息结构体</span></span><br><span class="line">    <span class="comment">//inet_addr：将点分十进制字符串ip地址转化为整形数据</span></span><br><span class="line">    <span class="comment">//htons：将主机字节序转化为网络字节序</span></span><br><span class="line">    <span class="comment">//atoi：将数字型字符串转化为整形数据</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：将套接字与服务器网络信息结构体绑定</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第四步：进行通信</span></span><br><span class="line">        <span class="type">char</span> text[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, text, <span class="keyword">sizeof</span>(text), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s - %d]: %s\n&quot;</span>, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port), text);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">strcat</span>(text, <span class="string">&quot; *_*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sendto(sockfd, text, <span class="keyword">sizeof</span>(text), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to sendto&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：关闭文件描述符</span></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-TCP编程"><a href="#2-2-TCP编程" class="headerlink" title="2.2 TCP编程"></a>2.2 TCP编程</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/tcp.png" alt="tcp"></p><h2 id="3-ARP协议分析"><a href="#3-ARP协议分析" class="headerlink" title="3. ARP协议分析"></a>3. ARP协议分析</h2><p><code>ARP</code>协议是链路层的协议，用于拿到目标<code>IP</code>主机的<code>MAC</code>地址，例如假设我现在主机<code>A(192.168.1.1)</code> 向 <code>B(192.168.1.2)</code> 发送一个数据包，那么<code>A</code>必须知道<code>B</code>主机的<code>ip</code>，<code>port</code>，使用的协议(<code>TCP/UDP</code>，此外还需要<code>MAC</code>地址，在第一次发送时<code>A</code>并不知道<code>B</code>的<code>MAC</code>地址，因此需要先拿到<code>B</code>的<code>MAC</code>地址，这就需要使用到<code>ARP</code>协议</p><p>ARP（Address Resolution Protocol，地址解析协议）</p><ul><li><p>1、是 TCP&#x2F;IP 协议族中的一个</p></li><li><p>2、主要用于查询指定 ip 所对应的的 MAC</p></li><li><p>3、请求方使用广播来发送请求</p></li><li><p>4、应答方使用单播来回送数据</p></li><li><p>5、为了在发送数据的时候提高效率在计算中会有一个 ARP 缓存表，用来暂时存放 ip 所对应的 MAC，在 linux中使用 ARP 即可查看,在 xp 中使用 ARP -a</p></li></ul><p>考虑如下的局域网通信流程，各个主机通过交换机相连接</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221151031897.png" alt="image-20240221151031897"></p><p>先说一下交换机的功能：</p><ul><li>交换机中有一个缓存表，这个表中保存了每一端口相连设备的MAC地址，将端口和MAC地址相互对应好保存在这个缓存表中</li><li>当一个设备向另外一个设备发送数据时，发送的数据先到达交换机，交换机会根据发送数据包中的目标主机的MAC地址去缓存表中索引目标设备的端口，然后将数据转发给此端口</li><li>交换机一般工作在数据链路层</li></ul><p>ARP获取目标MAC的流程：</p><ul><li><p>主机A不知道B的MAC地址，那么主机A会先发送一个ARP广播，交换机第一次收到ARP广播时，会把ARP广播数据包转发给所有连接上的端口（除来源端口）；此时也会根据A发送的ARP数据去拿到A的MAC地址，将A插入的端口何其MAC地址对应起来保存到交换机自己的缓存表中</p></li><li><p>这样所有的主机拿到这个ARP广播后，会比对IP地址，判断A主机是否想要自己的MAC地址，此时B主机比对后发现是，就会将自己的MAC地址写入到回复的ARP数据包中，并以单播的形式先发送给交换机，然后交换机再转发给对应的主机。</p></li><li><p>为了避免下次A主机向B主机发送数据时还要再次去发送ARP数据包去向B主机获取它的MAC地址，因此在第一次获取到B的MAC地址后会将它放在一张表中存起来，这张表用来暂时存放 ip 所对应的 MAC，在 linux中使用 ARP 即可查看,在 xp 中使用 ARP -a</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221152640111.png" alt="image-20240221152640111"></p></li></ul><p>现在假设各主机之间通过路由器相连：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221161712911.png" alt="image-20240221161712911"></p><p>先说一下路由器的功能：</p><ul><li><p>交换机用于实现同网段之间设备的通信，路由器用于不同网段之间的设备的通信，路由器工作在网络层</p></li><li><p>路由器中存在两个网卡，一个用于内部局域网通信，一个用于和另外一个路由器建立连接</p></li><li><p>假设A主机想要向D主机发送数据，由于此时不在同一网段中，因此A主机会将数据包先发送给路由器，由路由器进行转发。而A主机是如何知道谁是路由器呢，这就到了默认网关出场了，每台主机在配置网络的时候需要将默认网关配置成连接的路由器的IP地址，比如A主机的默认网关地址就是<code>192.168.1.1</code>，D主机的默认网关地址就是<code>192.168.3.1</code></p></li><li><p>现在A发送的数据包到达了路由器，A想要向<code>192.168.3.0</code>这个网段发送数据，此时路由器会进行判断说将这个数据包转发到和他连接的哪一个路由器，因此需要去查表，这个表就叫做路由表，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Network: 192.168.3.0</span><br><span class="line">Mask: 255.255.255.0</span><br><span class="line">Next Hop: 192.168.2.3</span><br></pre></td></tr></table></figure><p>对于路由器1来说，路由表就如上，意味着如果路由器1要向<code>192.168.3.0</code>这个网段发送数据，那么它的下一跳的路由器的地址为<code>192.168.2.3</code>，可以看见<code>192.168.2.3</code>就代表了路由器2，而通过路由器2就能访问到D主机了</p></li></ul><h2 id="4-使用原始套接字进行网络数据分析"><a href="#4-使用原始套接字进行网络数据分析" class="headerlink" title="4. 使用原始套接字进行网络数据分析"></a>4. 使用原始套接字进行网络数据分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ether.h&gt;</span> <span class="comment">//ETH_P_ALL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERRLOG(errmsg) do&#123;\</span></span><br><span class="line"><span class="meta">                            perror(errmsg);\</span></span><br><span class="line"><span class="meta">                            exit(1);\</span></span><br><span class="line"><span class="meta">                        &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建原始套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;sockfd = %d\n&quot;, sockfd);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收数据并分析</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> msg[<span class="number">1600</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//recvfrom recv read 都可以使用</span></span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, msg, <span class="keyword">sizeof</span>(msg), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析接收到的数据包</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> type;</span><br><span class="line">        <span class="built_in">sprintf</span>(dst_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">0</span>], msg[<span class="number">1</span>], msg[<span class="number">2</span>], msg[<span class="number">3</span>], msg[<span class="number">4</span>], msg[<span class="number">5</span>]);</span><br><span class="line">        <span class="built_in">sprintf</span>(src_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">6</span>], msg[<span class="number">7</span>], msg[<span class="number">8</span>], msg[<span class="number">9</span>], msg[<span class="number">10</span>], msg[<span class="number">11</span>]);</span><br><span class="line">        type = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">12</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;源mac：%s --&gt; 目的mac：%s\n&quot;</span>, src_mac, dst_mac);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;type = %#x\n&quot;</span>, type);</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0x0800</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip数据报\n&quot;</span>);</span><br><span class="line">            <span class="comment">//头部长度、总长度</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_head_len;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> ip_len;</span><br><span class="line">            ((*(<span class="type">unsigned</span> <span class="type">char</span> *)(msg + <span class="number">14</span>)) &amp; <span class="number">0x0f</span>) * <span class="number">4</span>;</span><br><span class="line">            ip_len = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">16</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip头部：%d, ip数据报总长度: %d\n&quot;</span>, ip_head_len, ip_len);</span><br><span class="line">            <span class="comment">//目的ip地址、源IP地址</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> dst_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> src_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(src_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">26</span>], msg[<span class="number">27</span>], msg[<span class="number">28</span>], msg[<span class="number">29</span>]);</span><br><span class="line">            <span class="built_in">sprintf</span>(dst_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">30</span>], msg[<span class="number">31</span>], msg[<span class="number">32</span>], msg[<span class="number">33</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;源ip地址：%s --&gt; 目的ip地址：%s\n&quot;</span>, src_ip, dst_ip);</span><br><span class="line">            <span class="comment">//协议类型</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_type;</span><br><span class="line">            ip_type = *(msg + <span class="number">23</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip_type = %d\n&quot;</span>, ip_type);</span><br><span class="line">            <span class="comment">//icmp、igmp、tcp、udp</span></span><br><span class="line">            <span class="keyword">if</span>(ip_type == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;icmp报文\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;igmp报文\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;tcp报文\n&quot;</span>);</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> src_port;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> dst_port;</span><br><span class="line">                src_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">34</span>));</span><br><span class="line">                dst_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">36</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;源端口号：%d --&gt; 目的端口号: %d\n&quot;</span>, src_port, dst_port);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">17</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;udp报文\n&quot;</span>);</span><br><span class="line">                <span class="comment">//目的端口号、源端口号</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> src_port;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> dst_port;</span><br><span class="line">                src_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">34</span>));</span><br><span class="line">                dst_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">36</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;源端口号：%d --&gt; 目的端口号: %d\n&quot;</span>, src_port, dst_port);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">0x0806</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;arp数据报\n&quot;</span>);</span><br><span class="line">            <span class="comment">//源ip地址</span></span><br><span class="line">            <span class="comment">//目的ip地址</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> dst_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> src_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(src_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">28</span>], msg[<span class="number">29</span>], msg[<span class="number">30</span>], msg[<span class="number">31</span>]);</span><br><span class="line">            <span class="built_in">sprintf</span>(dst_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">38</span>], msg[<span class="number">39</span>], msg[<span class="number">40</span>], msg[<span class="number">41</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;源ip地址：%s --&gt; 目的ip地址：%s\n&quot;</span>, src_ip, dst_ip);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">0x8035</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rarp数据报\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码运行结果如下，在<code>root</code>模式下运行：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221210039770.png" alt="image-20240221210039770"></p><h2 id="5-使用原始套接字剖析TCP协议"><a href="#5-使用原始套接字剖析TCP协议" class="headerlink" title="5. 使用原始套接字剖析TCP协议"></a>5. 使用原始套接字剖析TCP协议</h2><p>为了更好的理解TCP协议中的三次握手与四次挥手，我们使用原始套接字来抓取一下TCP数据报，逐步分析每次握手和挥手之间的TCP数据报的变化：</p><p>我现在有两台主机，主机之间通过路由器连接：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240222155851459.png" alt="image-20240222155851459"></p><ul><li>A作为客户端，IP为：192.168.3.9，端口为系统默认分配，我们将会在A主机上运行一个客户端程序使用TCP去连接B主机</li><li>B作为服务器，IP为：192.168.3.31，端口设置为<code>10000</code>，我们会在B主机上运行一个服务器程序使用TCP去监听TCP连接</li><li>额外在A主机上运行一个网络抓包程序，用来抓取A主机发送给B主机和B主机发送给A主机的TCP数据报</li></ul><p><strong>服务器代码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [ip] [port]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：创建套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：将套接字与服务器网络信息结构体绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line">    <span class="comment">//配置本地服务器的Ip和端口号</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, addrlen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：将套接字设置为被动监听状态</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd, <span class="number">10</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：阻塞等待客户端的链接请求</span></span><br><span class="line">    <span class="type">int</span> acceptfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>((acceptfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;addrlen)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印连接的客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip:%s, port:%d\n&quot;</span>, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：进行通信</span></span><br><span class="line">    <span class="comment">//tcp服务器与客户端通信时，需要使用accept函数的返回值</span></span><br><span class="line">    <span class="type">char</span> buf[N] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(recv(acceptfd, buf, N, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to recv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;from client: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(buf, <span class="string">&quot; *_*&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(send(acceptfd, buf, N, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to send&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字文件描述符</span></span><br><span class="line">    close(acceptfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [ip] [port]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;FAIL to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen =<span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line"></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr ,addrlen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[N] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    fgets(buf , N ,<span class="built_in">stdin</span>);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sockfd , buf , N , <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;faild to send&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> text[N] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(recv(sockfd , text, N , <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to recv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;from server: %s\n&quot;</span>, text);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>网络抓包代码</strong>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ether.h&gt;</span> <span class="comment">//ETH_P_ALL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERRLOG(errmsg) do&#123;\</span></span><br><span class="line"><span class="meta">                            perror(errmsg);\</span></span><br><span class="line"><span class="meta">                            exit(1);\</span></span><br><span class="line"><span class="meta">                        &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建原始套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收数据并分析</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> msg[<span class="number">1600</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//recvfrom recv read 都可以使用</span></span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, msg, <span class="keyword">sizeof</span>(msg), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析接收到的数据包</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> type;</span><br><span class="line">        <span class="built_in">sprintf</span>(dst_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">0</span>], msg[<span class="number">1</span>], msg[<span class="number">2</span>], msg[<span class="number">3</span>], msg[<span class="number">4</span>], msg[<span class="number">5</span>]);</span><br><span class="line">        <span class="built_in">sprintf</span>(src_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">6</span>], msg[<span class="number">7</span>], msg[<span class="number">8</span>], msg[<span class="number">9</span>], msg[<span class="number">10</span>], msg[<span class="number">11</span>]);</span><br><span class="line">        type = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">12</span>));</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0x0800</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//头部长度、总长度</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_head_len;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> ip_len;</span><br><span class="line">            ((*(<span class="type">unsigned</span> <span class="type">char</span> *)(msg + <span class="number">14</span>)) &amp; <span class="number">0x0f</span>) * <span class="number">4</span>;</span><br><span class="line">            ip_len = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">16</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//目的ip地址、源IP地址</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> dst_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> src_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(src_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">26</span>], msg[<span class="number">27</span>], msg[<span class="number">28</span>], msg[<span class="number">29</span>]);</span><br><span class="line">            <span class="built_in">sprintf</span>(dst_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">30</span>], msg[<span class="number">31</span>], msg[<span class="number">32</span>], msg[<span class="number">33</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//协议类型</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_type;</span><br><span class="line">            ip_type = *(msg + <span class="number">23</span>);</span><br><span class="line">            <span class="keyword">if</span>(ip_type == <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> src_port;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> dst_port;</span><br><span class="line">                src_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">34</span>));</span><br><span class="line">                dst_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">36</span>));</span><br><span class="line">                <span class="keyword">if</span>(dst_port == <span class="number">10000</span> || src_port==<span class="number">10000</span>)&#123;</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">char</span> flag = msg[<span class="number">47</span>] &amp; <span class="number">0x3f</span>;</span><br><span class="line">                    <span class="type">int</span> ACK = flag &gt;&gt; <span class="number">4</span> &amp; <span class="number">0x1</span>; </span><br><span class="line">                    <span class="type">int</span> SYN = flag &gt;&gt; <span class="number">1</span> &amp; <span class="number">0x1</span>;</span><br><span class="line">                    <span class="type">int</span> FIN = flag &amp; <span class="number">0x1</span>;</span><br><span class="line">                    <span class="type">uint32_t</span> seq = ntohl(*(<span class="type">uint32_t</span> *)(msg + <span class="number">38</span>));</span><br><span class="line">                    <span class="type">uint32_t</span> actual_seq = ntohl(*(<span class="type">uint32_t</span> *)(msg + <span class="number">42</span>));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;----------------tcp报文----------------\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;源端口号：%d --&gt; 目的端口号: %d\n&quot;</span>, src_port, dst_port);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;源ip地址：%s --&gt; 目的ip地址：%s\n&quot;</span>, src_ip, dst_ip);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ip头部：%d, ip数据报总长度: %d\n&quot;</span>, ip_head_len, ip_len);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ACK: %d SYN: %d SEQ: %u ASEQ: %u FIN: %d\n &quot;</span>,ACK,SYN,seq ,actual_seq,FIN);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于A主机来说，我们抓取目标为目标端口为<code>10000</code>或者发送端口为<code>10000</code>的TCP数据报，其他的全部舍弃，目标端口为<code>10000</code>的TCP数据报是A发送给B的，发送端口为<code>10000</code>的是B主机发送给A的</p><p>先启动服务器程序，再启动客户端程序，三次握手的结果如下，</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240222195612633.png" alt="image-20240222195612633"></p><p>很清晰的说明了三次握手的过程：上图中的<code>ASEQ</code>就是<code>ack</code>确认序号</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240222195914907.png" alt="image-20240222195914907"></p><ul><li><p>在理解三次握手，四次挥手之前，我们先理解两个很重要的概念：</p><p>在下面这张图中代表了一帧TCP数据包</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/tcp-170852003743213.png" alt="tcp"></p><ul><li><code>seq,序列号</code>：代表了发送的数据字节数，在一帧TCP数据包中发送的每一个字节都会计数；这里的数据指的是上图中给哪个进程中的数据，不包含TCP头中的字节，在我们进行握手或者挥手时，发送的字节数据数为0，因此<code>seq</code>理论上是不会增加的，但是由于我们在握手和挥手的过程中<code>FIN</code>、<code>SYN</code>状态码是会发生改变的，因此TCP协议规定这两个状态码发生改变时就当多了一字节的数据，因此<code>seq+1</code>;<code>seq</code>代表的本机发送的字节数，<code>seq</code>的增加与否只与本机发送的数据有关，和接收到的数据无关</li><li><code>ack，确认序列号</code>：这个<code>ack</code>和状态码中全部大写的<code>ACK</code>不一样，这里代表确认号，确认号只与接收到的数据的字节数有关，如果对方发送的TCP数据包中有数据，则这个<code>ack</code>的值等于上次<code>ack</code>的值加上收到的数据的字节数，同样如果接收到的数据包的<code>FIN</code>、<code>SYN</code>状态码发生了改变<code>ack</code>会相应的加一，</li></ul></li><li><p>第一次握手：</p><ul><li>客户端请求建立连接，将<code>SYN</code>置为<code>1</code>，<code>ACK</code>为<code>0</code>，然后随机生成一个<code>seq=1490486468</code>，<code>ack=0</code></li></ul></li><li><p>第二次握手：服务器给客户端回复数据</p><ul><li>服务器在收到客户端发送的第一次握手信息后，会先检查<code>SYN</code>是否为<code>1</code>，如果为<code>1</code>，将<code>ACK=1</code>，向客户端请求建立连接，因此<code>SYN=1</code>，然后随机生成一个<code>seq=4013990024</code>，将收到的<code>seq+1</code>放在<code>ack</code>中，此时<code>ack=1490486469</code>，然后打包发给客户端</li><li>客户端检测服务器发送来的请求信息，先判断<code>ACK</code>和<code>SYN</code>是否等于1，<code>ACK=1</code>代表服务器同意了客户端的连接请求，<code>SYN=1</code>代表服务器想要同客户端建立连接。此时对于客户端来说由于上次的<code>seq=1490486468</code>，然后上次发送了<code>SYN</code>，上面提到<code>SYN</code>代表发送了一个字节，因此下次发送的序列号为<code>seq = 1490486468 + 1 = 1490486469</code>，</li></ul></li><li><p>第三次握手：客户端发送数据给服务器</p><ul><li>客户端将<code>ACK</code>标志位置为1，代表同意了服务器的连接请求，服务器发送过来的数据的<code>seq = 4013990024</code>，同样由于服务器改变了<code>SYN</code>状态码，代表发送了一个字节过来，因此客户端发送给服务器的确认码为<code>ack 4013990024+1=4013990025</code></li><li>服务器端查看ACK对应的标志位是否为1, 如果是1代表, 客户端同意了服务器的连接请求，然后校验确认序号是否等于生成的随意序号+1，然后拿到客户端的发送序号</li></ul></li></ul><p>三次握手完成之后，客户端和服务器都变成了同一种状态，这种状态叫：ESTABLISHED，表示双向连接已经建立， 可以通信了。在通过过程中，正常的通信状态就是 ESTABLISHED。在我们的程序中，客户端会先向服务器写入数据，服务器拿到数据后会回复客户端确认收到数据，然后再向客户端发送数据，发送完毕后，就直接关闭连接</p><p>观察数据发送和四次挥手我们使用<code>Wireshark</code>抓包来看一下：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223111923750.png" alt="image-20240223111923750"></p><ul><li>前三帧数据就是三次握手的过程，然后客户端向服务器发送了数据，看第四帧的数据，发送的数据的长度为<code>128</code>，此时客户端的<code>seq = 1 ， ack = 1</code>，然后服务器接收到了数据，此时服务器接收到了发送来的<code>128</code>字节数据，</li><li><code>TCP</code>协议规定接收方在接收到数据后，需要应答发送方，发送发如果一直没收到接收方的应答，则代表此次发送数据出现了丢包，那发送方会重发数据，因此在第四帧客户端向无服务发送数据后，需要应答客户端，即第五帧数据，回复的确认号<code>ack = 128 + 1 =129</code>，发送方根据这个确认号就知道接收方成功接收到数据了</li></ul><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223115646850.png" alt="image-20240223115646850"></p><ul><li>然后第六帧数据，服务器向客户端发送数据，数据长度为128，发送给客户端后理论上客户端应该回复一帧说我已经收到了的数据包，但是由于服务器在发送完毕这128字节数据后立马执行了<code>close</code>操作去断开连接，导致了一些很奇怪的操作，因此好像看着并没有回复此帧</li></ul><p>接下来看四次挥手的过程：</p><ul><li><p>服务器和客户端都可以主动发起断开连接，在我们的代码中是服务器发起的断开连接</p></li><li><p>第一次挥手：服务器会将<code>FIN</code>置为1，然后发送给客户端去告诉客户端我想要断开连接了  </p></li><li><p>第二次挥手：客户端发现了服务器此次请求，因此<code>FIN</code>的改变占用一个字节因此回复的<code>ack = 129 + 1 = 130</code>，然后发送给服务器，服务器得到此数据包检查确认序号知道客户端同意了断开连接，进入等待</p></li><li><p>第三次挥手：客户端将<code>FIN</code>置为1去发送给服务器告诉服务器它想要断开连接</p></li><li><p>第四次挥手：服务器检查客户端发送的<code>FIN</code>的值，然后同意客户端断开连接，此时是服务器第二次发送数据因此<code>seq = 129 + 1 =130</code>，客户端的发送序号为<code>129</code>，然后客户端将<code>FIN</code>置为了1，因此此时<code>ack = 129 + 1 =130</code></p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223121923843.png" alt="image-20240223121923843"></p></li><li><p>根据<code>Wireshark</code>的抓包结果显示，最后四帧明显是四次挥手的过程，但实际上不然，我们看见似乎是少了一帧数据，三次握手三帧，客户端发送 + 服务器应答 2帧，服务器发送+客户端应答 2 帧，四次挥手四帧，总共应该是11帧，但实际上只有10帧</p></li><li><p>理论上第8帧中客户端执行第2次挥手时回复的<code>ack</code>应该是130才对，但是确回复的<code>ack</code>是<code>129 = 128 +1</code>，因此我们可以猜测第九帧实际上是用于回复上次服务器发送来的<code>128</code>自己的数据，而不是四次挥手中的第二次挥手，而客户端将第二次挥手和第三次挥手合并成了一帧数据发送，即第9帧。</p></li><li><p>这是由什么原因引起的，问题在于服务器在第6帧向客户端发送数据后，立刻执行了<code>close</code>操作，去发起断开连接，即第7帧，客户端先收到了这两帧数据，因此客户端先回复服务器收到了数据，然后再去应答断开连接的请求</p></li><li><p>我们修改一下服务器的代码，在<code>close</code>之前添加一个延时操作，再使用<code>Wireshark</code>，抓包</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223120541936.png" alt="image-20240223120541936"></p></li></ul><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223123938843.png" alt="image-20240223123938843"></p><ul><li>可以看见此时就有11帧数据了，此时是由客户端先发起的断开连接请求，因此服务器再向客户端发送数据后没有立即执行断开连接操作，因此客户端有时间去先执行应答，然后去向服务器申请断开连接</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/UDP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-对象池</title>
      <link href="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-FOR-EACH-宏实现"><a href="#1-FOR-EACH-宏实现" class="headerlink" title="1. FOR_EACH 宏实现"></a>1. FOR_EACH 宏实现</h2><p>代码目录：<code>cyber/base/for_each.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasLess, <span class="keyword">operator</span>&lt;)  <span class="comment">// NOLINT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">End</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;HasLess&lt;Value&gt;::value &amp;&amp; HasLess&lt;End&gt;::value,</span><br><span class="line">                        <span class="type">bool</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">LessThan</span><span class="params">(<span class="type">const</span> Value&amp; val, <span class="type">const</span> End&amp; end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &lt; end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">End</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasLess&lt;Value&gt;::value || !HasLess&lt;End&gt;::value,</span><br><span class="line">                        <span class="type">bool</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">LessThan</span><span class="params">(<span class="type">const</span> Value&amp; val, <span class="type">const</span> End&amp; end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val != end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR_EACH(i, begin, end)           \</span></span><br><span class="line"><span class="meta">  for (auto i = (true ? (begin) : (end)); \</span></span><br><span class="line"><span class="meta">       apollo::cyber::base::LessThan(i, (end)); ++i)</span></span><br></pre></td></tr></table></figure><p>我们先看看这个宏的用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, <span class="number">100</span>) &#123; vec.<span class="built_in">push_back</span>(i); &#125;</span><br><span class="line"><span class="built_in">FOR_EACH</span>(it, vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()) &#123; std::cout&lt;&lt;*it&lt;&lt;std::endl; &#125;</span><br></pre></td></tr></table></figure><p>简单来说就是用于对不同类型的数据进行遍历操作：</p><p><code>DEFINE_TYPE_TRAIT(HasLess, operator&lt;) </code>这个<code>trait</code>操作是保证传进来的<code>begin</code>和<code>end</code>类型重载了<code>&lt;</code>，</p><p><code>for</code>循环里会去调用<code>LessThan</code>函数，<code>LessThan</code>函数的两个模板参数就是<code>begin</code>所代表的类型和<code>End</code>所代表的类型。</p><p>当<code>HasLess&lt;Value&gt;::value &amp;&amp; HasLess&lt;End&gt;::value</code>满足时，才会走第一个模板函数，将会对<code>val</code>和<code>end</code>的值进行比较，函数返回值为<code>bool</code>类型，</p><p>当<code>Value</code>或者<code>End</code>其中任意一个类型不具有<code>&lt;</code>的重载则会走第二个模板函数，函数内部会对这两个值进行判断是否是相等</p><p>如果用户在使用时提供的类型既不支持 <code>&lt;</code> 运算符，也不支持 <code>!=</code> 运算符，那么在编译时将会导致错误。</p><h2 id="2-对象池的实现"><a href="#2-对象池的实现" class="headerlink" title="2. 对象池的实现"></a>2. 对象池的实现</h2><p>源码目录：<code>cyber/base/object_pool.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPool</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;ObjectPool&lt;T&gt;&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> InitFunc = std::function&lt;<span class="built_in">void</span>(T *)&gt;;</span><br><span class="line">  <span class="keyword">using</span> ObjectPoolPtr = std::shared_ptr&lt;ObjectPool&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ObjectPool</span><span class="params">(<span class="type">uint32_t</span> num_objects, Args &amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ObjectPool</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 拿到一个对象*/</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">GetObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T object;</span><br><span class="line">    Node *next;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/*禁用拷贝构造*/</span></span><br><span class="line">  <span class="built_in">ObjectPool</span>(ObjectPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ObjectPool &amp;<span class="keyword">operator</span>=(ObjectPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReleaseObject</span><span class="params">(T *)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> num_objects_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> *object_arena_ = <span class="literal">nullptr</span>;</span><br><span class="line">  Node *free_head_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">f</span>(obj);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::~<span class="built_in">ObjectPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">    <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object_arena_ + i * size)-&gt;object.~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(object_arena_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ObjectPool&lt;T&gt;::<span class="built_in">ReleaseObject</span>(T *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(object == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object)-&gt;next = free_head_;</span><br><span class="line">  free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ObjectPool&lt;T&gt;::<span class="built_in">GetObject</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(free_head_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> self = <span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">auto</span> obj =</span><br><span class="line">      std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="built_in">reinterpret_cast</span>&lt;T *&gt;(free_head_),</span><br><span class="line">                         [self](T *object) &#123; self-&gt;<span class="built_in">ReleaseObject</span>(object); &#125;);</span><br><span class="line">  free_head_ = free_head_-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">f</span>(obj);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::~<span class="built_in">ObjectPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">    <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object_arena_ + i * size)-&gt;object.~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(object_arena_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ObjectPool&lt;T&gt;::<span class="built_in">ReleaseObject</span>(T *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(object == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object)-&gt;next = free_head_;</span><br><span class="line">  free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ObjectPool&lt;T&gt;::<span class="built_in">GetObject</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(free_head_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> self = <span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">auto</span> obj =</span><br><span class="line">      std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="built_in">reinterpret_cast</span>&lt;T *&gt;(free_head_),</span><br><span class="line">                         [self](T *object) &#123; self-&gt;<span class="built_in">ReleaseObject</span>(object); &#125;);</span><br><span class="line">  free_head_ = free_head_-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向对象池中传递目标的类型和构建目标的参数，用<code>T</code>和<code> ... Args</code>来进行传递，在构造函数内部首先计算了一个<code>Node</code>的大小，然后分配<code>num_objects</code>个<code>node</code>大小的内存作为目标池来管理，根据这个<code>node</code>的定义我们可以知道对象池管理对象时是以链表的方式将各个链表链接起来的，再分配完毕内存后，通过<code>FOR_EACH</code>来在指定的地址处创建对象，然后让创建的这个对象的指针指向<code>free_head_</code></p><p>还有另外一个构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">f</span>(obj);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造和上一个的区别在于多了一个参数<code>InitFunc f</code>，允许在构造对象池的时候提供一个操作对象的函数，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> InitFunc = std::function&lt;<span class="built_in">void</span>(T *)&gt;;</span><br></pre></td></tr></table></figure><p><code>InitFunc</code>是一个可调用对象，此对象的返回值是<code>void</code>，需要的参数是<code>T *</code>类型，所以在构造对象池的时候使用<code>f(obj);</code>来操作了对象</p><p><img src="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/image-20231202110144511.png" alt="image-20231202110144511"></p><p>接着来看看释放一个对象的操作，释放对象就是将一个对象重新放入对象池中：然后更新<code>free_head</code>的值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ObjectPool&lt;T&gt;::<span class="built_in">ReleaseObject</span>(T *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(object == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object)-&gt;next = free_head_;</span><br><span class="line">  free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/image-20231202111140335.png" alt="image-20231202111140335"></p><p>最后是拿到一个对象的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ObjectPool&lt;T&gt;::<span class="built_in">GetObject</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(free_head_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> self = <span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">auto</span> obj =</span><br><span class="line">      std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="built_in">reinterpret_cast</span>&lt;T *&gt;(free_head_),</span><br><span class="line">                         [self](T *object) &#123; self-&gt;<span class="built_in">ReleaseObject</span>(object); &#125;);</span><br><span class="line">  free_head_ = free_head_-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过<code>std::shared_ptr&lt;T&gt; ptr(pointer, deleter);</code>来得到这个<code>obj</code>，第二个参数即是智能指针管理的这个对象的引用计数归零时将要执行的操作，这里就是说当<code>obj</code>的引用计数归零时，让此对象重新返回对象池，所以传入的可调用对象的形式是一个lamada函数：<code> [self](T *object) &#123; self-&gt;ReleaseObject(object); &#125;</code>，然后更新<code>free_head_</code></p><p>所以从对象池中拿对象从<code>arena</code>的高地址处<code>free_head_</code>开始拿，释放也是如此，将一个对象插入到<code>free_head_</code>之后，然后更新<code>free_head_</code></p><p>最后是析构函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::~<span class="built_in">ObjectPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">    <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object_arena_ + i * size)-&gt;object.~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(object_arena_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历调用对象的自己析构函数，然后释放<code>arena</code>这块内存</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/sinat_31608641/article/details/120692775">__builtin_expect函数-CSDN博客</a></li><li><a href="https://www.cnblogs.com/-citywall123/p/12726552.html">C++对象池的实现和原理 - 知道了呀~ - 博客园 (cnblogs.com)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 对象池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-无锁哈希表</title>
      <link href="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h2><p>源码目录：<code>cyber/base/atomic_hash_map.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief A implementation of lock-free fixed size hash map</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @tparam K Type of key, must be integral</span></span><br><span class="line"><span class="comment"> * @tparam V Type of value</span></span><br><span class="line"><span class="comment"> * @tparam 128 Size of hash table</span></span><br><span class="line"><span class="comment"> * @tparam 0 Type traits, use for checking types of key &amp; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, std::<span class="type">size_t</span> TableSize = <span class="number">128</span>,</span><br><span class="line">          <span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;K&gt;::value &amp;&amp;</span><br><span class="line">                                      (TableSize &amp; (TableSize - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                                  <span class="type">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> AtomicHashMap &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>() : <span class="built_in">capacity_</span>(TableSize), <span class="built_in">mode_num_</span>(capacity_ - <span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  AtomicHashMap &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Has</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Get</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V *value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    V *val = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">bool</span> res = table_[index].<span class="built_in">Get</span>(key, &amp;val);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      *value = *val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, V &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, std::forward&lt;V&gt;(value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="built_in">Entry</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entry</span><span class="params">(K key)</span> : key(key) &#123;</span></span><br><span class="line">      value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(), std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entry</span>(K key, <span class="type">const</span> V &amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">      value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(value), std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entry</span>(K key, V &amp;&amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">      value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(std::forward&lt;V&gt;(value)), std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entry</span>() &#123; <span class="keyword">delete</span> value_ptr.<span class="built_in">load</span>(std::memory_order_acquire); &#125;</span><br><span class="line"></span><br><span class="line">    K key = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;V *&gt; value_ptr = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    std::atomic&lt;Entry *&gt; next = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Bucket</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bucket</span>() : <span class="built_in">head_</span>(<span class="keyword">new</span> <span class="built_in">Entry</span>()) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Bucket</span>() &#123;</span><br><span class="line">      Entry *ite = head_;</span><br><span class="line">      <span class="keyword">while</span> (ite) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = ite-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">delete</span> ite;</span><br><span class="line">        ite = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">      Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;key &lt; key) &#123;</span><br><span class="line">          m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> target-&gt;key == key;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(K key, Entry **prev_ptr, Entry **target_ptr)</span> </span>&#123;</span><br><span class="line">      Entry *prev = head_;</span><br><span class="line">      Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;key == key) &#123;</span><br><span class="line">          *prev_ptr = prev;</span><br><span class="line">          *target_ptr = target;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;key &gt; key) &#123;</span><br><span class="line">          *prev_ptr = prev;</span><br><span class="line">          *target_ptr = target;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prev = target;</span><br><span class="line">          m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      *prev_ptr = prev;</span><br><span class="line">      *target_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">      V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">          <span class="comment">// key exists, update value</span></span><br><span class="line">          <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">            new_value = <span class="keyword">new</span> <span class="built_in">V</span>(value);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                  old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">                  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">            <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_entry;</span><br><span class="line">              new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">            new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key, value);</span><br><span class="line">          &#125;</span><br><span class="line">          new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">          <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                                 std::memory_order_acq_rel,</span><br><span class="line">                                                 std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// Insert success</span></span><br><span class="line">            <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_value;</span><br><span class="line">              new_value = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key, V &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">      V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">          <span class="comment">// key exists, update value</span></span><br><span class="line">          <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">            new_value = <span class="keyword">new</span> <span class="built_in">V</span>(std::forward&lt;V&gt;(value));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                  old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">                  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">            <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_entry;</span><br><span class="line">              new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">            new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key, value);</span><br><span class="line">          &#125;</span><br><span class="line">          new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">          <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                                 std::memory_order_acq_rel,</span><br><span class="line">                                                 std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// Insert success</span></span><br><span class="line">            <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_value;</span><br><span class="line">              new_value = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">      V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">          <span class="comment">// key exists, update value</span></span><br><span class="line">          <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">            new_value = <span class="keyword">new</span> <span class="built_in">V</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                  old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">                  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">            <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_entry;</span><br><span class="line">              new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">            new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key);</span><br><span class="line">          &#125;</span><br><span class="line">          new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">          <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                                 std::memory_order_acq_rel,</span><br><span class="line">                                                 std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// Insert success</span></span><br><span class="line">            <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_value;</span><br><span class="line">              new_value = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">        *value = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry *head_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Bucket table_[TableSize];</span><br><span class="line">  <span class="type">uint64_t</span> capacity_;</span><br><span class="line">  <span class="type">uint64_t</span> mode_num_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-无锁哈希表的实现"><a href="#2-无锁哈希表的实现" class="headerlink" title="2. 无锁哈希表的实现"></a>2. 无锁哈希表的实现</h2><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在存储器存储位置的数据结构。 也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。 这个映射函数称做散列函数，存放记录的数组称做散列表。</p><p>给定一个键值<code>K</code>，通过一个函数计算出了这个<code>K</code>在内存中对应值的存储位置，那个这个函数就被称为哈希函数：</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/20210517094111543.png" alt="关键字和存储地址之间的对应关系"></p><p>这里举个例子：</p><p>假如我们一共有 50 人参加学校的数学竞赛，然后我们为每个学生分配一个编号，依次是 1 到 50.</p><p>如果我们想要快速知道编号对应学生的信息，我们就可以用一个数组来存放学生的信息，编号为 1 的放到数组下标为 1 的位置，编号为 2 的放到数组下标为 2 的位置，依次类推。</p><p>现在如果我们想知道编号为 20 的学生的信息，我们只需要把数组下标为 20 的元素取出来就可以了，时间复杂度为 O(1)，是不是效率非常高呢。</p><p>但是这些学生肯定来自不同的年级和班级，为了包含更详细的信息，我们在原来编号前边加上年级和班级的信息，比如 030211 ，03 表示年级，02 表示班级，11 原来的编号，这样我们该怎么存储学生的信息，才能够像原来一样使用下标快速查找学生的信息呢？</p><p>思路还是和原来一样，我们通过编号作为下标来储存，但是现在编号多出了年级和班级的信息怎么办呢，我们只需要截取编号的后两位作为数组下标来储存就可以了。</p><p>这个过程就是典型的散列思想。其中，参赛学生的编号我们称之为键(key)，我们用它来标识一个学生。然后我们通过一个方法（比如上边的截取编号最后两位数字）把编号转变为数组下标，这个方法叫做散列函数（哈希函数），通过散列函数得到的值叫做散列值（哈希值）</p><p>我们自己在设计散列函数的函数时应该遵循什么规则呢？</p><ol><li>得到的散列值是一个非负整数</li><li>两个相同的键，通过散列函数计算出的散列值也相同</li><li>两个不同的键，计算出的散列值不同</li></ol><p>虽然我们在设计的时候要求满足以上三条要求，但对于第三点很难保证所有不同的建都被计算出不同的散列值。有可能不同的建会计算出相同的值，这叫做哈希冲突。为了解决这个冲突，可以将散列函数计算得到相同值得<code>key</code>放到同一个链表中，这也是<code>CyberRt</code>中散列表的做法：</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130123005161.png" alt="image-20231130123005161"></p><p>因此散列表就是一个数组，只不过数组中的每个元素都是一个链表，这个链表我们称为一个<code>Bucket</code>，就是一个篮子。<code>Bucket</code>中链表的节点我们用<code>Entry</code>来进行描述。</p><p>我们先来看<code>Entry</code>的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">  <span class="built_in">Entry</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Entry</span><span class="params">(K key)</span> : key(key) &#123;</span></span><br><span class="line">    value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(), std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Entry</span>(K key, <span class="type">const</span> V &amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">    value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(value), std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Entry</span>(K key, V &amp;&amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">    value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(std::forward&lt;V&gt;(value)), std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Entry</span>() &#123; <span class="keyword">delete</span> value_ptr.<span class="built_in">load</span>(std::memory_order_acquire); &#125;</span><br><span class="line"></span><br><span class="line">  K key = <span class="number">0</span>;</span><br><span class="line">  std::atomic&lt;V *&gt; value_ptr = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  std::atomic&lt;Entry *&gt; next = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个<code>Entry</code>存储了一个数据指针和指向下一个<code>Entry</code>的指针，他们都是原子变量，在这份源码中，定义说这个键的类型必须为整形，因此<code>K key = 0</code>，里面提供了四个构造函数。</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130125814591.png" alt="image-20231130125814591"></p><p>然后是<code>Bucket</code>的定义：<code>Bucket</code>是一个链表，对链表中的每一个节点的操作都是原子的。</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130135128856.png" alt="image-20231130135128856"></p><p>在散列表中放入键值后，散列表就长下面这样子了：哈希值相同的键放在同一个<code>Bucket</code>里，同一个<code>Bucket</code>中键的排列依次往下接就行</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130140811197.png" alt="image-20231130140811197"></p><ul><li><p>在<code>Bucket</code>中查找<code>key</code>：根据<code>key</code>挨个对<code>Entry</code>中的<code>key</code>值进行比较，如果找到了就返回<code>true</code>，没找到就返回<code>false</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">  Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;key &lt; key) &#123;</span><br><span class="line">      m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target-&gt;key == key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Bucket</code>中查找<code>key</code>对应的那个<code>Entry</code>：从头节点开始遍历，只要<code>m_target</code>不是<code>null_ptr</code>，循环就会继续执行，如果有对应的<code>key</code>值，将通过<code>prev_ptr</code>和<code>target_ptr</code>参数返回查找结果。<code>prev_ptr</code>和<code>target_ptr</code>都是二级指针，都指向了一个<code>Entry*</code>。如果<code>target</code>指向的那个<code>Entry</code>中的<code>key</code>值大于传入的这个<code>key</code>值，同时又不相等，说明这个<code>key</code>值的大小位于<code>prev</code>和<code>target</code>之间，从这里我们可以猜测，拥有相同哈希值的<code>key</code>在同一个<code>Bucket</code>中的排列是按照从小到大的顺序排的</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130144538014.png" alt="image-20231130144538014"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(K key, Entry **prev_ptr, Entry **target_ptr)</span> </span>&#123;</span><br><span class="line">  Entry *prev = head_;</span><br><span class="line">  Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;key == key) &#123;</span><br><span class="line">      *prev_ptr = prev;</span><br><span class="line">      *target_ptr = target;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;key &gt; key) &#123;</span><br><span class="line">      *prev_ptr = prev;</span><br><span class="line">      *target_ptr = target;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev = target;</span><br><span class="line">      m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *prev_ptr = prev;</span><br><span class="line">  *target_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Bucket</code>中根据键值插入对应的<code>value</code>:首先调用上面的<code>find</code>函数去查找<code>Bucket</code>中是否存在<code>key</code>，如果存在则新建一个<code>value</code>，然后通过cas操作去修改此<code>Entry</code>中的<code>value</code>值。如果在<code>Bucket</code>中没有找到这个<code>key</code>，说明需要新建一个<code>Entry</code>，需要将这个<code>new_entry</code>插入到<code>prev</code>和<code>target</code>之间，这里也是原子操作。其余两个插入函数同理，只是入参不一样。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">  Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">  Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">  Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">  V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">      <span class="comment">// key exists, update value</span></span><br><span class="line">      <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">        new_value = <span class="keyword">new</span> <span class="built_in">V</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">              old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">              std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">        <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">          <span class="keyword">delete</span> new_entry;</span><br><span class="line">          new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">        new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">      new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">      <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                             std::memory_order_acq_rel,</span><br><span class="line">                                             std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">// Insert success</span></span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">          <span class="keyword">delete</span> new_value;</span><br><span class="line">          new_value = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后是根据<code>key</code>值拿到<code>value</code>的函数，也是通过<code>Find</code>函数去找，如果找到了则赋值，没找到就返回<code>false</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">  Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">  Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">    *value = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>有了<code>Entry</code>和<code>Bucket</code>之后我们来看一下<code>AtomicHashMap</code>的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, std::<span class="type">size_t</span> TableSize = <span class="number">128</span>,</span><br><span class="line">          <span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;K&gt;::value &amp;&amp;</span><br><span class="line">                                      (TableSize &amp; (TableSize - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                                  <span class="type">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> AtomicHashMap &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>() : <span class="built_in">capacity_</span>(TableSize), <span class="built_in">mode_num_</span>(capacity_ - <span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  AtomicHashMap &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Has</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Get</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V *value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    V *val = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">bool</span> res = table_[index].<span class="built_in">Get</span>(key, &amp;val);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      *value = *val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, V &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, std::forward&lt;V&gt;(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  Bucket table_[TableSize];</span><br><span class="line">  <span class="type">uint64_t</span> capacity_;</span><br><span class="line">  <span class="type">uint64_t</span> mode_num_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先模板操作就很有意思:</p><ul><li><code>&lt;typename K, typename V, std::size_t TableSize = 128, ...&gt;</code>: 定义模板的参数列表。<code>K</code> 和 <code>V</code> 是模板的键和值类型，<code>TableSize</code> 是哈希表的大小，默认为 128。</li><li><code>typename std::enable_if&lt;...&gt;::type = 0</code>: 使用 <code>std::enable_if</code> 实现模板的部分特化。这里检查是否 <code>K</code> 是整数类型（<code>std::is_integral&lt;K&gt;::value</code>）并且 <code>TableSize</code> 是 2 的幂（<code>(TableSize &amp; (TableSize - 1)) == 0</code>）。如果条件为真，则模板参数 <code>int</code> 被设置为 0，否则，此模板不可用。</li><li>这里也是用到了c++的<code>SFINAE</code>特性</li></ul><blockquote><p><code>TableSize &amp; (TableSize - 1)</code> 是一个位运算操作，用于检查一个数是否是2的幂。</p><ul><li>如果一个数是2的幂，那么它的二进制表示中只有一个位是1，其余位都是0。</li><li>如果减去1，所有的1都变成0，而低位的0都变成1。</li></ul><p>通过使用按位与（<code>&amp;</code>）操作，只有在两个相应的位都是1时结果才是1。因此，如果 <code>TableSize</code> 是2的幂，那么 <code>TableSize &amp; (TableSize - 1)</code> 将等于0。</p><p>这个检查在哈希表的实现中经常用来确保哈希表的大小是2的幂，这有助于提高散列函数的效果，使得键在哈希表中更均匀地分布。</p></blockquote><p><code>AtomicHashMap</code>类的内部定义了一个<code>Bucket table_[TableSize]</code>的数组，哈希函数其实就是线性的取余，里面对哈希表的操作也比较简单，就是先去根据键的值取余去拿到对应的<code>Bucket</code>，然后再去<code>Buket</code>中操作</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/Peealy/article/details/116895964">一文看懂哈希表并学会使用C++ STL 中的哈希表_哈希表end函数-CSDN博客</a></li><li><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp16.html">实现线程安全的查找表 · 恋恋风辰的编程笔记 (llfc.club)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-线程池</title>
      <link href="/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h2><p>在<code>cyber/base/thread_pool.h</code>中实现了一个线程池的类，写得很高级，我们来分析一下，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(std::<span class="type">size_t</span> thread_num, std::<span class="type">size_t</span> max_task_num = <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">      -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">  BoundedQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; task_queue_;</span><br><span class="line">  std::atomic_bool stop_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数入参为 线程数量和最大任务数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(std::<span class="type">size_t</span> threads, std::<span class="type">size_t</span> max_task_num)</span></span></span><br><span class="line"><span class="function">    : stop_(false) &#123;</span></span><br><span class="line">  <span class="comment">/*创建一个BoundedQueue，采用的等待策略是阻塞策略*/</span></span><br><span class="line">  <span class="keyword">if</span> (!task_queue_.<span class="built_in">Init</span>(max_task_num, <span class="keyword">new</span> <span class="built_in">BlockWaitStrategy</span>())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue init failed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化线程池 创建空的任务，每个任务的逻辑就是 */</span></span><br><span class="line">  workers_.<span class="built_in">reserve</span>(threads);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">    workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">while</span> (!stop_) &#123;</span><br><span class="line">        <span class="comment">/*返回值为空的可调用对象*/</span></span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">if</span> (task_queue_.<span class="built_in">WaitDequeue</span>(&amp;task)) &#123;</span><br><span class="line">          <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before using the return value, you should check value.valid()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::Enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">      std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">  std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">  <span class="keyword">if</span> (stop_) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">future</span>&lt;return_type&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">Enqueue</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="comment">/* 唤醒线程池里所有线程，然后等待所有子线程执行完毕，释放资源*/</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (stop_.<span class="built_in">exchange</span>(<span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">BreakAllWait</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::thread&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-线程池的实现"><a href="#2-线程池的实现" class="headerlink" title="2. 线程池的实现"></a>2. 线程池的实现</h2><p>线程池是一种多线程处理形式，它处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。</p><p> 首先先来看一下线程池的模型：</p><p><img src="/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20231129165547298.png" alt="image-20231129165547298"></p><p>线程池中有两个队列，一个工作队列，这就是线程池维护的线程队列，另一个是任务队列，工作队列中的线程去任务队列中领取任务从而执行，空闲的线程呢则等待直到任务队列有任务可获取。</p><p>基于此我们来看<code>ThreadPool</code>类中定义的成员变量：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">BoundedQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; task_queue_;</span><br><span class="line">std::atomic_bool stop_;</span><br></pre></td></tr></table></figure><ul><li>工作队列的数据结构是<code>vector</code>类型，就是一个数组，数组中的每一个元素都是一个<code>std::thread</code></li><li>任务队列的数据结构是前面实现的<code> BoundedQueue</code>，<code> BoundedQueue</code>中的每一个元素都是c++中的一个可调用对象：<code>std::function&lt;void()&gt;</code>，是一个返回值为空，参数列表也为空的可调用对象</li><li>还有一个原子变量用于判断线程池是否还在工作</li></ul><p>然后来看线程池的构造函数：传入的参数为线程的数量和所能创建的最大的线程数量，将<code>stop_</code>标志位置为<code>false</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(std::<span class="type">size_t</span> threads, std::<span class="type">size_t</span> max_task_num)</span></span></span><br><span class="line"><span class="function">    : stop_(false) &#123;</span></span><br><span class="line">  <span class="comment">/*创建一个BoundedQueue，采用的等待策略是阻塞策略*/</span></span><br><span class="line">  <span class="keyword">if</span> (!task_queue_.<span class="built_in">Init</span>(max_task_num, <span class="keyword">new</span> <span class="built_in">BlockWaitStrategy</span>())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue init failed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化线程池 创建空的任务，每个任务都是一个while循环 */</span></span><br><span class="line">  workers_.<span class="built_in">reserve</span>(threads);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">    workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">while</span> (!stop_) &#123;</span><br><span class="line">        <span class="comment">/*返回值为空的可调用对象*/</span></span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">if</span> (task_queue_.<span class="built_in">WaitDequeue</span>(&amp;task)) &#123;</span><br><span class="line">          <span class="comment">/*如果出队成功，说明领取到了任务，则就去执行此任务*/</span></span><br><span class="line">          <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先是初始化任务队列<code>task_queue_</code>，并且采用<code>BlockWaitStrategy</code>的线程同步方式，在这种方式下，当队列中没有数据的时候，去队列取数据的线程会被阻塞，直到有线程向队列中添加元素，此时就会通过信号量机制通知阻塞的线程可以继续执行了</p></li><li><p>然后是初始化工作队列，由于<code>workers_</code>数组中的每一个元素都是一个<code>std::function&lt;void()&gt;</code>，所以在初始化的时候是通过<code>lamda</code>表达式来创建的，使用 <code>[this]</code> 捕获列表是为了能够在<code> lambda</code> 函数中访问当前类的成员变量 <code>stop_</code> 和任务队列 <code>task_queue_</code>。如果没有使用 <code>[this]</code>，那么在 <code>lambda</code> 函数中就不能直接访问当前类的成员，因为<code> lambda</code> 默认是不捕获任何外部变量的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">     <span class="keyword">while</span> (!stop_) &#123;</span><br><span class="line">       <span class="comment">/*返回值为空的可调用对象*/</span></span><br><span class="line">       std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">       <span class="keyword">if</span> (task_queue_.<span class="built_in">WaitDequeue</span>(&amp;task)) &#123;</span><br><span class="line">         <span class="comment">/*如果出队成功，说明领取到了任务，则就去执行此任务*/</span></span><br><span class="line">         <span class="built_in">task</span>();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当执行<code>emplace_back</code>操作时此时就会创建线程，然后线程一旦创建就会开始执行，执行的操作就是上面这个<code>while</code>循环里代码，此时每个线程都会去执行这一步<code>task_queue_.WaitDequeue(&amp;task)</code>操作，但是由于任务队列中还未放入任务，所以此时创建的所有线程都会被阻塞。</p></li></ul><p>然后来看关键的向任务队列中添加任务的函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before using the return value, you should check value.valid()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::Enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">      std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">  std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">  <span class="keyword">if</span> (stop_) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">future</span>&lt;return_type&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">Enqueue</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数有两个模板参数，第一个模板函数代表一个可调用对象，这个可调用对象就可以理解成我们一个任务，我们在这个函数里会将这个可调用对象封装然后进行入队，第二个模板参数是模板参数包，用于给这个可调用对象传参。这两个模板参数都是以<code>&amp;&amp;</code>万能引用的方式传入的</p><p>函数的返回值类型是<code>std::future&lt;T&gt;</code>类型的，而这个<code>T</code>是什么类型呢：<code>std::result_of&lt;F(Args...)&gt;::type</code></p><p>通过c++11提供的<code>std::result_of</code>推导出了调用<code>F(Args)</code>后的返回值类型。</p><p>拿到这个<code>return_type</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure><p>然后是对这个传入的可调用对象的封装，通过封装使得任务队列中的每个元素都是统一类型，这样工作队列去面对的就是统一的任务类型了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">    std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br></pre></td></tr></table></figure><ul><li><p>首先<code>task</code>是一个智能指针，通过<code>std::make_shared</code>创建</p></li><li><p>指针的模板类型是<code>std::packaged_task&lt;return_type()&gt;</code>，<code>std::packaged_task</code>可以用来封装任何可以调用的目标，从而用于实现异步的调用。<code>return_type()</code>是<code>std::packaged_task</code>的模板参数，代表封装的是一个<code>return_type()</code>类型的可调用对象，这不就是我们传入的这个<code>F(Args)</code>吗，区别在于没有参数而已，这时候就轮到<code>std::bind</code>出场了</p></li><li><p>假设不用智能指针封装，那么代码该这么写：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">return_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...))</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>std::bind</code>起到的作用就是将函数和参数打包生成一个可调用对象，这个可调用对象不用传参了，c++去调用的时候函数的参数已经被打包到<code>bind</code>内部，这不就刚好满足我们上面的需求吗，经过上面一系列操作，我们的任务队列中存储的就是一个个指向具体任务的指针了。注意这里使用<code>std::forward</code>是为了对传进来的模板参数进行完美转发</p></li></ul><p>接着创建了一个<code>future</code>对象：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure><p>这个<code>future</code>对象的模板参数是<code>return_type</code>，用于和上面创建的任务队列里的<code>std::packaged_task&lt;return_type()&gt;</code>可调用对象的返回值相绑定，后续当任务执行完毕我们就可以通过<code>res.get()</code>来异步的获取任务执行后的返回值</p><p>后面就是入队操作了：再次利用<code>std::function</code>，将<code>task</code>指向的<code>std::packaged_task</code>对象取出并包装为void函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">task_queue_.<span class="built_in">Enqueue</span>([task]() &#123; (*task)(); &#125;);</span><br></pre></td></tr></table></figure><p>传入的是一个<code>lamda</code>表达式，捕获<code>task</code>，表达式内部就是去执行这个可调用对象，通过<code>(*task)()</code></p><p>在任务入队之后，还记得在之前实现<code>BoundedQueue</code>时会去执行<code>NotifyOne</code>操作，这样就会唤醒阻塞在队列上的一个工作者线程去拿到传入的这个<code>std::function&lt;void()&gt;</code>去执行。</p><p><img src="/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20231129210355863.png" alt="image-20231129210355863"></p><p>最后来看析构函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (stop_.<span class="built_in">exchange</span>(<span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">BreakAllWait</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::thread&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将<code>stop_</code>标志位设置为<code>true</code></li><li>调用<code> task_queue_.BreakAllWait();</code>来唤醒所有的线程，等待所有线程执行完毕后销毁资源</li></ul><p>这个线程池的设计涉及到c++11很多知识点：</p><ul><li><p>左值与右值引用</p></li><li><p>引用折叠与完美转发</p></li><li><p><code>std::thread</code></p></li><li><p><code>std::future</code></p></li><li><p><code>std::bind</code></p></li><li><p><code>std::function</code></p></li><li><p><code>std::packaged_task</code></p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>[<a href="https://zhuanlan.zhihu.com/p/469607144">C++特性]对std::move和std::forward的理解 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现线程池 - 知乎 (zhihu.com)</a></li><li><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp07.html">C++ 并发三剑客future, promise和async · 恋恋风辰的编程笔记 (llfc.club)</a></li><li><a href="https://www.bilibili.com/video/BV18w411i74T/?spm_id_from=333.337.search-card.all.click&vd_source=1325a6af2d360c06e8e0c5e177802b1b">C++ 并发编程(7) 并发三剑客async,promise和future_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-原子读写锁</title>
      <link href="/2023/11/25/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8E%9F%E5%AD%90%E8%AF%BB%E5%86%99%E9%94%81/"/>
      <url>/2023/11/25/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8E%9F%E5%AD%90%E8%AF%BB%E5%86%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h2><p>在<code>cyber/base/atomic_rw_lock.h</code>中实现了一个读写锁，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicRWLock</span> &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ReadLockGuard</span>&lt;AtomicRWLock&gt;;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteLockGuard</span>&lt;AtomicRWLock&gt;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> RW_LOCK_FREE = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> WRITE_EXCLUSIVE = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> MAX_RETRY_TIMES = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">AtomicRWLock</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AtomicRWLock</span><span class="params">(<span class="type">bool</span> write_first)</span> : write_first_(write_first) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// all these function only can used by ReadLockGuard/WriteLockGuard;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReadLock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">WriteLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReadUnlock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">WriteUnlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AtomicRWLock</span>(<span class="type">const</span> AtomicRWLock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  AtomicRWLock&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AtomicRWLock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  std::atomic&lt;<span class="type">uint32_t</span>&gt; write_lock_wait_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  std::atomic&lt;<span class="type">int32_t</span>&gt; lock_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">bool</span> write_first_ = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int32_t</span> lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">  <span class="keyword">if</span> (write_first_) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE || write_lock_wait_num_.<span class="built_in">load</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int32_t</span> rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(rw_lock_free, WRITE_EXCLUSIVE,</span><br><span class="line">                                          std::memory_order_acq_rel,</span><br><span class="line">                                          std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="comment">// rw_lock_free will change after CAS fail, so init agin</span></span><br><span class="line">    rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">    <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">      <span class="comment">// saving cpu</span></span><br><span class="line">      std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">      retry_times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="2-原子读写锁的实现"><a href="#2-原子读写锁的实现" class="headerlink" title="2.原子读写锁的实现"></a>2.原子读写锁的实现</h2><p>读写锁的特性：</p><ul><li>当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会<strong>阻塞</strong>（不是失败）。</li><li>当读写锁被加了读锁时，其他线程对该锁加写锁会<strong>阻塞</strong>，加读锁会成功。</li></ul><p>简单说就是运行多个线程同时读，但是同时只能允许一个线程去写，非常适合读多少写的场景</p><p>首先<code>AtomicRWLock </code>中声明了两个友元类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ReadLockGuard</span>&lt;AtomicRWLock&gt;;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteLockGuard</span>&lt;AtomicRWLock&gt;;</span><br></pre></td></tr></table></figure><p>这两个友元类定义在<code>cyber/base/rw_lock_guard.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RWLock&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadLockGuard</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReadLockGuard</span><span class="params">(RWLock&amp; lock)</span> : rw_lock_(lock) &#123;</span> rw_lock_.<span class="built_in">ReadLock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReadLockGuard</span>() &#123; rw_lock_.<span class="built_in">ReadUnlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">ReadLockGuard</span>(<span class="type">const</span> ReadLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  ReadLockGuard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ReadLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  RWLock&amp; rw_lock_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RWLock&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriteLockGuard</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">WriteLockGuard</span><span class="params">(RWLock&amp; lock)</span> : rw_lock_(lock) &#123;</span></span><br><span class="line">    rw_lock_.<span class="built_in">WriteLock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">WriteLockGuard</span>() &#123; rw_lock_.<span class="built_in">WriteUnlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">WriteLockGuard</span>(<span class="type">const</span> WriteLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  WriteLockGuard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WriteLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  RWLock&amp; rw_lock_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看见这两个类在创建的时候构造函数会去调用读写锁的读或者写操作去持有锁，在析构的时候会去解锁，这就是利用c++的RAII机制实现对加锁和开锁的封装，这样就不用用户手动去加锁和释放锁了，和c++提供的<code>std::lock_guard</code>用法类似</p><p>读写锁的操作是靠几个变量来控制的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">uint32_t</span>&gt; write_lock_wait_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int32_t</span>&gt; lock_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> write_first_ = <span class="literal">true</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> RW_LOCK_FREE = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> WRITE_EXCLUSIVE = <span class="number">-1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> MAX_RETRY_TIMES = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li><code>write_lock_wait_num_</code> 代表了有多少个线程等着写就是多少个线程等着持有读锁</li><li><code>lock_num_</code>代表持有锁的线程的数量，由于读锁是允许多个线程同时读的，所以</li><li><code>RW_LOCK_FREE</code>：标志位，代表此时没有线程持有锁，可读可写</li><li><code>WRITE_EXCLUSIVE</code>：标志位，代表此时锁被一个写的线程暂用</li><li><code>MAX_RETRY_TIMES</code>：尝试获取锁的时候连续尝试次数，就像自旋锁那样，连续失败MAX_RETRY_TIMES次则会让出线程的执行权</li><li><code>write_first_</code>：默认写的操作优先</li></ul><p>我们先来看读写锁的写锁：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int32_t</span> rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(rw_lock_free, WRITE_EXCLUSIVE,</span><br><span class="line">                                          std::memory_order_acq_rel,</span><br><span class="line">                                          std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="comment">// rw_lock_free will change after CAS fail, so init agin</span></span><br><span class="line">    rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">    <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">      <span class="comment">// saving cpu</span></span><br><span class="line">      std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">      retry_times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>write_lock_wait_num_</code>记录了想要持有读锁的线程的数量，因此每次<code>WriteLock()</code>操作需要+1</li><li>接着循环会去比较<code>lock_num_</code>和<code>rw_lock_free</code>的值，会出现以下两种情况：<ul><li>1.：<code>lock_num_</code> &#x3D;  <code>rw_lock_free</code>&#x3D;&#x3D; <code>0</code>，代表此时没人用锁，则将<code>lock_num_</code>的值置为<code>WRITE_EXCLUSIVE=-1</code>,直接跳出循环，此时假设另外一个线程也来写，而<code>lock_num_=-1</code>，所以必须等待前一个持有写锁的人解锁才行，所以解锁操作也显而易见了，就是将<code>lock_num_+1</code>恢复到<code>RW_LOCK_FREE</code></li><li>2：<code>lock_num_&gt;=1</code>代表其他线程持有了读锁，或<code>lock_num_&gt;=WRITE_EXCLUSIVE</code>这种情况就是上面提到的另外一个线程持有了读锁，但是还没解锁，那么此时该线程就会去执行<code>while</code>循环里的操作，在while循环里会重置<code>rw_lock_free</code>的值，然后循环判断几次如果还在等待就执行<code>yield()</code>操作让当前线程释放cpu所有权。</li></ul></li></ul><p>再来看读写锁的读锁：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int32_t</span> lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">  <span class="keyword">if</span> (write_first_) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE || write_lock_wait_num_.<span class="built_in">load</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于默认写优先就是说我在写的时候是不允许读的，先进入一个分支执行<code>do</code>操作：然后去进行判断是否有线程在执行写操作，即<code>lock_num &lt; RW_LOCK_FREE || write_lock_wait_num_.load() &gt; 0</code>，则想要读的这个线程就让出cpu等着写的线程写完先，如果写完了重新加载一下<code>lock_num</code>的值，然后去执行<code>lock_num_.compare_exchange_weak</code>这个操作，这里有两种情况：</p><ul><li>1.<code>lock_num_==lock_num</code>(即大于等于0)，可能你会说这不是肯定的吗？这个还真不一定，虽然刚执行过<code>lock_num = lock_num_.load()</code>;但是<code>lock_num</code>是个多线程控制的值，随时在变。然后将<code>lock_num_</code>的值加一</li><li>2.<code>lock_num_!=lock_num  lock_num</code>赋值为<code>lock_num_</code>（无用） 重新循环 简单点来讲就是：刚刚的判断好好的，正当我要办事的时候，突然有线程偷偷改变了值，一切判断作废，重新来过</li></ul><p>最后是解锁操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><p>读锁解锁就是将大于0的<code>lock_num_</code>做减1操作，写锁的解锁就是将-1转到0</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://liujiayu.blog.csdn.net/article/details/124732353">百度自动驾驶apollo源码解读1：std::atomic实现读写锁_阿波罗自动驾驶代码-CSDN博客</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/569073042">原子读写锁的实现 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://subingwen.cn/linux/thread-sync/">线程同步 | 爱编程的大丙 (subingwen.cn)</a></p></li><li><p><a href="https://blog.csdn.net/kenjianqi1647/article/details/117998175">C++11锁的用法( 多线程，并发，错误使用、std::ref用法、RAII)_c++11智能锁-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 原子读写锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-有界无锁队列</title>
      <link href="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
      <url>/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h2><p>在<code>cyber/base/bounded_queue.h</code>中实现了一个有界无锁队列的模板类，通过c++提供的原子操作来确保线程安全，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedQueue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BoundedQueue</span>() &#123;&#125;</span><br><span class="line">  BoundedQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> BoundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">BoundedQueue</span>(<span class="type">const</span> BoundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  ~<span class="built_in">BoundedQueue</span>();</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">uint64_t</span> size)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">uint64_t</span> size, WaitStrategy* strategy)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(T&amp;&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WaitEnqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WaitEnqueue</span><span class="params">(T&amp;&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T* element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WaitDequeue</span><span class="params">(T* element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Size</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetWaitStrategy</span><span class="params">(WaitStrategy* WaitStrategy)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head_.<span class="built_in">load</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> tail_.<span class="built_in">load</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Commit</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> commit_.<span class="built_in">load</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">GetIndex</span><span class="params">(<span class="type">uint64_t</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; head_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; tail_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; commit_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="comment">// alignas(CACHELINE_SIZE) std::atomic&lt;uint64_t&gt; size_ = &#123;0&#125;;</span></span><br><span class="line">  <span class="type">uint64_t</span> pool_size_ = <span class="number">0</span>;</span><br><span class="line">  T* pool_ = <span class="literal">nullptr</span>;</span><br><span class="line">  std::unique_ptr&lt;WaitStrategy&gt; wait_strategy_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">bool</span> break_all_wait_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BoundedQueue&lt;T&gt;::~<span class="built_in">BoundedQueue</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (wait_strategy_) &#123;</span><br><span class="line">    <span class="built_in">BreakAllWait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pool_) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">      pool_[i].~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(pool_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Init</span>(<span class="type">uint64_t</span> size) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Init</span>(size, <span class="keyword">new</span> <span class="built_in">SleepWaitStrategy</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Init</span>(<span class="type">uint64_t</span> size, WaitStrategy* strategy) &#123;</span><br><span class="line">  <span class="comment">// Head and tail each occupy a space</span></span><br><span class="line">  pool_size_ = size + <span class="number">2</span>;</span><br><span class="line">  pool_ = <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(std::<span class="built_in">calloc</span>(pool_size_, <span class="built_in">sizeof</span>(T)));</span><br><span class="line">  <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    <span class="keyword">new</span> (&amp;(pool_[i])) <span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  wait_strategy_.<span class="built_in">reset</span>(strategy);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Enqueue</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_commit = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_tail = tail_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_tail = old_tail + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetIndex</span>(new_tail) == <span class="built_in">GetIndex</span>(head_.<span class="built_in">load</span>(std::memory_order_acquire))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!tail_.<span class="built_in">compare_exchange_weak</span>(old_tail, new_tail,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  pool_[<span class="built_in">GetIndex</span>(old_tail)] = element;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old_commit = old_tail;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">      old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">      std::memory_order_relaxed)));</span><br><span class="line">  <span class="comment">//唤醒一个等待的线程，告诉它队列中已经有新的元素可以被取出或处理了。</span></span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">NotifyOne</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Enqueue</span>(T&amp;&amp; element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_commit = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_tail = tail_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_tail = old_tail + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetIndex</span>(new_tail) == <span class="built_in">GetIndex</span>(head_.<span class="built_in">load</span>(std::memory_order_acquire))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!tail_.<span class="built_in">compare_exchange_weak</span>(old_tail, new_tail,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  pool_[<span class="built_in">GetIndex</span>(old_tail)] = std::<span class="built_in">move</span>(element);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old_commit = old_tail;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">      old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">      std::memory_order_relaxed)));</span><br><span class="line">  <span class="comment">//唤醒一个等待的线程，告诉它队列中已经有新的元素可以被取出或处理了。</span></span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">NotifyOne</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Dequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_head = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_head = head_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_head = old_head + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_head == commit_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *element = pool_[<span class="built_in">GetIndex</span>(new_head)];</span><br><span class="line">  &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_weak</span>(old_head, new_head,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitEnqueue</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Enqueue</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitEnqueue</span>(T&amp;&amp; element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Enqueue</span>(std::<span class="built_in">move</span>(element))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitDequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dequeue</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint64_t</span> BoundedQueue&lt;T&gt;::<span class="built_in">Size</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> tail_ - head_ - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Empty</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Size</span>() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint64_t</span> BoundedQueue&lt;T&gt;::<span class="built_in">GetIndex</span>(<span class="type">uint64_t</span> num) &#123;</span><br><span class="line">  <span class="keyword">return</span> num - (num / pool_size_) * pool_size_;  <span class="comment">// faster than %</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> BoundedQueue&lt;T&gt;::<span class="built_in">SetWaitStrategy</span>(WaitStrategy* strategy) &#123;</span><br><span class="line">  wait_strategy_.<span class="built_in">reset</span>(strategy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> BoundedQueue&lt;T&gt;::<span class="built_in">BreakAllWait</span>() &#123;</span><br><span class="line">  break_all_wait_ = <span class="literal">true</span>;</span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">BreakAllWait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-有界无锁队列的实现"><a href="#2-有界无锁队列的实现" class="headerlink" title="2.有界无锁队列的实现"></a>2.有界无锁队列的实现</h2><p>首先来看<code>BoundedQueue</code>这个模板类拥有的数据成员：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; head_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; tail_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; commit_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// alignas(CACHELINE_SIZE) std::atomic&lt;uint64_t&gt; size_ = &#123;0&#125;;</span></span><br><span class="line"><span class="type">uint64_t</span> pool_size_ = <span class="number">0</span>;</span><br><span class="line">T* pool_ = <span class="literal">nullptr</span>;</span><br><span class="line">std::unique_ptr&lt;WaitStrategy&gt; wait_strategy_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> break_all_wait_ = <span class="literal">false</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有界的无锁队列是采用顺序存储结构来实现的，可以理解为一个数组，所以头部和尾部的描述就不是使用的链式结构的指针来维护的，直接定义为<code>u64</code>格式的索引，<code>pool_size_</code>就是这个数组的大小，<code>wait_strategy_</code>是一个<code>unique_ptr</code>，因此<code>wait_strategy_</code>指向的内容不允许被其他指针共享，<code>T* pool</code>是指针，用来指向队列数组的头，在初始化时需要为此指针分配内存大小</p><p>还定义了一个私有函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 由于是无符号整数，所以返回的是索引，类似于取余*/</span></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint64_t</span> BoundedQueue&lt;T&gt;::GetIndex(<span class="type">uint64_t</span> num) &#123;</span><br><span class="line">  <span class="keyword">return</span> num - (num / pool_size_) * pool_size_;  <span class="comment">// faster than %</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明一下上面的操作相当于取余操作，因为无符号整型的数相除，得到的值也是一个无符号数，如果相除的值小于1，则得到的值是0，所以实现了类似取余的操作。</p><p>然后看<code>init</code>函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Init</span>(<span class="type">uint64_t</span> size, WaitStrategy* strategy) &#123;</span><br><span class="line">  <span class="comment">// Head and tail each occupy a space</span></span><br><span class="line">  pool_size_ = size + <span class="number">2</span>;</span><br><span class="line">  pool_ = <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(std::<span class="built_in">calloc</span>(pool_size_, <span class="built_in">sizeof</span>(T)));</span><br><span class="line">  <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    <span class="keyword">new</span> (&amp;(pool_[i])) <span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  wait_strategy_.<span class="built_in">reset</span>(strategy);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>std::calloc(pool_size_, sizeof(T))</code>: 这部分使用了 C 标准库函数 <code>calloc</code>，该函数用于分配指定数量的元素并将它们的内存初始化为零。在这里，它分配了 <code>pool_size_</code> 个元素，每个元素的大小为 <code>sizeof(T)</code> 字节。<code>calloc</code> 与 <code>malloc</code> 不同之处在于它会将分配的内存初始化为零。</p></li><li><p><code>reinterpret_cast&lt;T*&gt;(...)</code>: 这是 C++ 中的类型转换语法，用于将 <code>calloc</code> 返回的指针从 <code>void*</code> 类型转换为 <code>T*</code> 类型。<code>reinterpret_cast</code> 表示底层的二进制表示不发生改变，这种转换通常用于进行低级别的类型转换。</p></li><li><p><code>new (&amp;(pool_[i])) T();</code> 这个用法是在指定的内存地址上调用 T 类型的构造函数。这是一个称为 “placement new” 的 C++ 特性。它允许我们在给定的内存地址上构造对象，而不是在默认的堆上分配内存。这通常用于需要对内存进行更精细控制的场景。</p></li></ul><p>在调用<code>init</code>函数后，队列的内存模型如下：</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124152948409.png" alt="image-20231124152948409"></p><p>这里其实我没想明白为啥要<code>pool_size_ = size + 2;</code>看写的注释说是<code>head_</code>和<code>tail_</code>会占空间。</p><p>接着是向队列中添加元素：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Enqueue</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_commit = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_tail = tail_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_tail = old_tail + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetIndex</span>(new_tail) == <span class="built_in">GetIndex</span>(head_.<span class="built_in">load</span>(std::memory_order_acquire))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!tail_.<span class="built_in">compare_exchange_weak</span>(old_tail, new_tail,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  pool_[<span class="built_in">GetIndex</span>(old_tail)] = element;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old_commit = old_tail;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">      old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">      std::memory_order_relaxed)));</span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">NotifyOne</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是将<code>new_tail+1</code>，然后判断队列是否越界，然后调用<code>tail_.compare_exchange_weak</code>来原子的更新<code>tail</code>_的值。</p><blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  //tail_为原子变量，将当前的tail_的值和old_tail进行比较，如果相等，则tail_更新为new_tail</span><br><span class="line">  //返回true,!操作返回fasle，使得跳出循环，开始下面的入队操作</span><br><span class="line">  //否则，如果tail_的值和old_tail不相等（将old_tail更新为当前的tail_值），</span><br><span class="line">  //说明其他线程已经做了do里边的操作并且tail_值已经更新，已经抢先入队</span><br><span class="line">  //这时返回false,!操作返回true，继续下一次执行do里面的操作，等待入队的时机（或队列已满返回false）</span><br><span class="line">//在old_tail的位置入队，old_tail可能在上面的循环了进行了多次的累加</span><br><span class="line">//和程序入口的old_tail可能已经不同了</span><br></pre></td></tr></table></figure></blockquote><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124165704805.png" alt="image-20231124165704805"></p><p>上面的逻辑是当两个线程操作时，假设其中一个线程执行完毕<code>new_tail = old_tail + 1;</code>后，另外一个线程已经更新了<code>tail_</code>的值，此时就会出现第二张图的情况，<code>tail_</code>不等去当前线程获得的<code>old_tail_</code>，因此将当前线程的<code>old_tail</code>跟新为新的<code>tail_</code>，然后再返回while循环，将<code>new_tail_+1</code>，然后再进行比较发现此时的<code>tail_=old_tail_</code>了，然后再次更新<code>tail_</code>的值就成了第三幅图的样子。</p><p>然后将新加的值放入<code>pool_[GetIndex(old_tail)]</code>中</p><blockquote><p>这里使用了一个很有意思的宏<code>#define cyber_unlikely(x) (__builtin_expect((x), 0))</code></p><p>宏定义使用了 GCC 内建函数 <code>__builtin_expect</code>，它是 GCC 编译器提供的一个特殊内建函数，用于提供条件概率的提示，以帮助编译器进行更好的代码优化。</p><p>具体而言，这个宏的作用是提示编译器表达式 <code>(x)</code> 的结果是不太可能的。<code>__builtin_expect</code> 函数的参数是两个值，第一个是表达式，第二个是期望的结果。在这里，<code>0</code> 表示不太可能的分支。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  old_commit = old_tail;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">    old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">    std::memory_order_relaxed)));</span><br></pre></td></tr></table></figure><p>这里有点绕，假设只有一个线程执行入队操作，那么<code>old_commit</code>和<code>commit</code>的值是相等的，所以此时会将<code>commit_</code>的值更新到新的<code>tail_</code>的位置</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124163223274.png" alt="image-20231124163223274"></p><p>假设有两个线程操作了此队列：后修改<code>tail_</code>的那个线程就会出现如下的情况：<code>old_commit!=commit</code>，因此此线程的<code>old_commit</code>值会被更新成<code>commit</code>的值，然后在do里面<code>old_commit</code>又会被更新成<code>old_tail</code>的值，相当于它一直阻塞在这里了</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124170412439.png" alt="image-20231124170412439"></p><p>而对于先修改<code>tail_</code>的那个线程来说：<code>old_commit=commit</code>，因此会跳出do循环，同时将<code>commit_</code>的值更新成此线程的<code>new_tail</code>的值，即上面那个线程的<code>old_tail</code>的值。</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124170550072.png" alt="image-20231124170550072"></p><p>因此commit_的值是完全根据入队的顺序进行递增的，不同线程根据入队的循序依次跳出该循环,哪个线程先完成入队操作，哪个线程先跳出该while循环。</p><blockquote><p>但我感觉这个commit的值没啥屌用阿，md还很难理解</p></blockquote><p>然后是从队列中取出元素：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Dequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_head = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_head = head_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_head = old_head + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_head == commit_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *element = pool_[<span class="built_in">GetIndex</span>(new_head)];</span><br><span class="line">  &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_weak</span>(old_head, new_head,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当队列里有数据的时候，<code>head_</code>和<code>old_head</code>比较，如果相等，则更新为<code>new_head</code>并返回<code>true</code>，退出循环。如果不等，则说明其他线程已经取走了当前的<code>head</code>元素，将<code>old_head</code>更新为<code>head_</code>值并进入下一次do里面的操作，这里说明一下为什么去元素是从<code>new_head</code>处取，因为插入元素时，<code>head_</code>和<code>tail_</code>处是不会放元素的。</p><p>当队列里没数据的时候，第一次<code>do</code>的操作，会对<code>new_head</code>的值和<code>commit_</code>的值进行判断，如果这两个值相等，说明队列里没数据，则返回<code>false</code></p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124172803708.png" alt="image-20231124172803708"></p><p>然后是实现了等待策略的插入函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitEnqueue</span>(T&amp;&amp; element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Enqueue</span>(std::<span class="built_in">move</span>(element))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现了等待机制，如果队列未满，则立马插入返回，否则进入空等状态</p><p>实现了等待策略的取出函数：如果队列中没数据则空等</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitDequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dequeue</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的入队操作就是往尾部添加元素，然后移动尾部指针。出队操作就是从头部取出一个元素，然后移动头部指针，虽然移动了头部指针，但是之前申请的内存是还在的，并不会释放。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/569493127">有界队列及其无锁实现 - 知乎 (zhihu.com)</a></li><li><a href="https://liujiayu.blog.csdn.net/article/details/125657500">百度自动驾驶apollo源码解读9:无锁有界队列BoundedQueue_cyberrt boundedqueue-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 无界无锁队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-无界无锁队列</title>
      <link href="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
      <url>/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h2><p>在<code>cyber/base/unbounded_queue.h</code>中实现了一个无界无锁队列的模板类，通过c++提供的原子操作来确保线程安全，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnboundedQueue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UnboundedQueue</span>() &#123; <span class="built_in">Reset</span>(); &#125;</span><br><span class="line">  UnboundedQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UnboundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">UnboundedQueue</span>(<span class="type">const</span> UnboundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">UnboundedQueue</span>() &#123; <span class="built_in">Destroy</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Destroy</span>();</span><br><span class="line">    <span class="built_in">Reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Enqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    node-&gt;data = element;</span><br><span class="line">    Node* old_tail = tail_.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tail_.<span class="built_in">compare_exchange_strong</span>(old_tail, node)) &#123;</span><br><span class="line">        old_tail-&gt;next = node;</span><br><span class="line">        old_tail-&gt;<span class="built_in">release</span>();</span><br><span class="line">        size_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T* element)</span> </span>&#123;</span><br><span class="line">    Node* old_head = head_.<span class="built_in">load</span>();</span><br><span class="line">    Node* head_next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      head_next = old_head-&gt;next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (head_next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_strong</span>(old_head, head_next));</span><br><span class="line">    *element = head_next-&gt;data;</span><br><span class="line">    size_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">    old_head-&gt;<span class="built_in">release</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_.<span class="built_in">load</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_.<span class="built_in">load</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    std::atomic&lt;<span class="type">uint32_t</span>&gt; ref_count;</span><br><span class="line">    Node* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">Node</span>() &#123; ref_count.<span class="built_in">store</span>(<span class="number">2</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (ref_count.<span class="built_in">load</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    head_.<span class="built_in">store</span>(node);</span><br><span class="line">    tail_.<span class="built_in">store</span>(node);</span><br><span class="line">    size_.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ite = head_.<span class="built_in">load</span>();</span><br><span class="line">    Node* tmp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (ite != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      tmp = ite-&gt;next;</span><br><span class="line">      <span class="keyword">delete</span> ite;</span><br><span class="line">      ite = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;Node*&gt; head_;</span><br><span class="line">  std::atomic&lt;Node*&gt; tail_;</span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-无界无锁队列的实现"><a href="#2-无界无锁队列的实现" class="headerlink" title="2.无界无锁队列的实现"></a>2.无界无锁队列的实现</h2><p>队列（queue）是只允许在一端进行插入操作，在另一端进行删除操作的线性表，简称“队”。队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾（rear），允许删除的一端称为队头(front)。向队列中插入新的数据元素称为入队，新入队的元素就成为了队列的队尾元素。从队列中删除队头元素称为出队，其后继元素成为新的队头元素。</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/20200915111440959.png" alt="img"></p><blockquote><p>队列作为一种特殊的线性表，也同样存在两种存储结构：顺序存储结构和链式存储结构，可以分别用数组和链表来实现队列。</p></blockquote><p>在cyberrt中是采用链式结构来实现的，通过链表来进行维护，看上面的代码，先看<code>Node</code>的组成：</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124115312276.png" alt="image-20231124115312276"></p><p><code>Node</code>中的成员包含一个模板类的数据<code>data</code>,一个指向下一个节点的指针和一个用于引用计数的<code>count</code>值,<code>release</code>函数用于释放此节点。</p><p><code>UnboundedQueue</code>内部有三个成员，它的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UnboundedQueue</span>() &#123; <span class="built_in">Reset</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    head_.<span class="built_in">store</span>(node);</span><br><span class="line">    tail_.<span class="built_in">store</span>(node);</span><br><span class="line">    size_.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  std::atomic&lt;Node*&gt; head_;</span><br><span class="line">  std::atomic&lt;Node*&gt; tail_;</span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; size_;</span><br></pre></td></tr></table></figure><p><code>head_</code>即是队列的头节点指针，<code>tail_</code>是队列的尾节点指针，<code>size_</code>是节点的个数，这三个变量都是原子类型，保证了在多线程时操作这三个变量时都是线程安全的。</p><p>当<code>UnboundedQueue</code>创建时会去调用<code>Reset()</code>函数，<code>Reset()</code>函数会去<code>new</code>一个<code>Node</code>对象，在<code>Node</code>的构造函数中会将<code>ref_count</code>的值设置为2，因为在队列初始化时头指针和尾指针都指向了同一个节点，所以<code>ref_count=2</code></p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124120233507.png" alt="image-20231124120233507"></p><p>再来看像队列添加元素的函数<code>void Enqueue(const T&amp; element)</code>，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Enqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">  node-&gt;data = element;</span><br><span class="line">  Node* old_tail = tail_.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail_.<span class="built_in">compare_exchange_strong</span>(old_tail, node)) &#123;</span><br><span class="line">      old_tail-&gt;next = node;</span><br><span class="line">      old_tail-&gt;<span class="built_in">release</span>();</span><br><span class="line">      size_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先同样会新建一个<code>Node</code>，然后对新建的<code>Node</code>的<code>data</code>赋值，我们知道向队列插入元素是在尾部添加，这里使用了一个<code>compare_exchange_strong</code>函数来将<code>tail</code>与<code>old_tail</code>进行比较，如果是同一个则将tail的替换成新建的这个node，然后现在队列的尾部指针就是新建这个<code>node</code>了,这个<code>compare_exchange_strong</code>写的非常巧妙，如果没有发生多线程竞争的话，<code>compare_exchange_strong</code>返回true  ,意味着循环一次就结束，<code>tail_</code>的值被设为了<code>node</code>。因为<code>compare_exchange_strong</code>是线程安全的。</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124121117146.png" alt="image-20231124121117146"></p><p>可以看见当尾插一个新的节点后上一个节点的引用计数就变成了1，因为调用了<code>release()</code>函数，<code>release()</code>中会对节点引用计数减一，同时如果此节点的引用计数变成了0则销毁此节点释放内存</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (ref_count.<span class="built_in">load</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的整体结构如下：尾部节点的引用计数始终是2，链表里面所有成员的引用计数都是1。</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124122433323.png" alt="image-20231124122433323"></p><p>然后来看从队列中取出数据的函数，取出数据时就是从头部取了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T* element)</span> </span>&#123;</span><br><span class="line">  Node* old_head = head_.<span class="built_in">load</span>();</span><br><span class="line">  Node* head_next = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    head_next = old_head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head_next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_strong</span>(old_head, head_next));</span><br><span class="line">  *element = head_next-&gt;data;</span><br><span class="line">  size_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">  old_head-&gt;<span class="built_in">release</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单，就是将之前的头指针指向第二个节点，同样使用了<code>compare_exchange_strong</code>来保证线程安全，取出数据后之前的头节点就没用了因此调用<code>release()</code>函数去删除这个节点。</p><p>然后最后是队列的销毁函数，这个函数就比较简单了：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ite = head_.<span class="built_in">load</span>();</span><br><span class="line">  Node* tmp = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (ite != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    tmp = ite-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> ite;</span><br><span class="line">    ite = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从头节点开始遍历，依次删除节点，直到遍历到最后一个节点，因为最后一个节点的<code>next</code>指针指向了<code>nullptr</code>，所以到此停止。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://liujiayu.blog.csdn.net/article/details/129615374">百度自动驾驶apollo源码解读13:无锁无界队列UnboundedQueue_H-KING的博客-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/599202353">C++原子变量atomic详解 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/Jacky_Feng/article/details/108595654">【数据结构】队列(顺序队列、循环队列、链队列）-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 无界无锁队列 </tag>
            
            <tag> 原子操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-线程等待策略</title>
      <link href="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/"/>
      <url>/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程等待策略"><a href="#1-线程等待策略" class="headerlink" title="1.线程等待策略"></a>1.线程等待策略</h2><p>在<code>base/wait_strategy.h</code>这个头文件中定义了线程切换的策略类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitStrategy</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NotifyOne</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">WaitStrategy</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BlockWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyOne</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_one</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    cv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_all</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex mutex_;</span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SleepWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SleepWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepWaitStrategy</span><span class="params">(<span class="type">uint64_t</span> sleep_time_us)</span></span></span><br><span class="line"><span class="function">      : sleep_time_us_(sleep_time_us) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(sleep_time_us_));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetSleepTimeMicroSeconds</span><span class="params">(<span class="type">uint64_t</span> sleep_time_us)</span> </span>&#123;</span><br><span class="line">    sleep_time_us_ = sleep_time_us;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint64_t</span> sleep_time_us_ = <span class="number">10000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YieldWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">YieldWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BusySpinWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BusySpinWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeoutBlockWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TimeoutBlockWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TimeoutBlockWaitStrategy</span><span class="params">(<span class="type">uint64_t</span> timeout)</span></span></span><br><span class="line"><span class="function">      : time_out_(std::chrono::milliseconds(timeout)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyOne</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_one</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (cv_.<span class="built_in">wait_for</span>(lock, time_out_) == std::cv_status::timeout) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_all</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetTimeout</span><span class="params">(<span class="type">uint64_t</span> timeout)</span> </span>&#123;</span><br><span class="line">    time_out_ = std::chrono::<span class="built_in">milliseconds</span>(timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex mutex_;</span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line">  std::chrono::milliseconds time_out_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>WaitStrategy基类：</strong><ul><li><code>WaitStrategy</code> 是一个虚基类，定义了等待策略的基本接口。</li><li>其中包括 <code>NotifyOne()</code> 、 <code>BreakAllWait()</code> 和 <code>EmptyWait()</code> 纯虚函数。</li></ul></li><li><strong>BlockWaitStrategy类：</strong><ul><li><code>BlockWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了阻塞式等待策略。</li><li>它使用了互斥锁和条件变量，通过 <code>cv_.wait(lock)</code> 进行线程等待，通过 <code>cv_.notify_one()</code> 唤醒一个等待的线程，通过 <code>cv_.notify_all()</code> 唤醒所有等待的线程。</li><li>线程会一直阻塞在此直到另外一个线程来唤醒，当线程被唤醒后才会返回<code>true</code></li></ul></li><li><strong>SleepWaitStrategy类：</strong><ul><li><code>SleepWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了休眠式等待策略。</li><li>在 <code>EmptyWait()</code> 中，通过 <code>std::this_thread::sleep_for()</code> 函数使当前线程休眠一段时间。</li><li>线程会休眠一段时间，不会进行阻塞，睡眠时间结束后返回<code>true</code></li></ul></li><li><strong>YieldWaitStrategy类：</strong><ul><li><code>YieldWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了让出CPU时间片的等待策略。</li><li>在 <code>EmptyWait()</code> 中，通过 <code>std::this_thread::yield()</code> 函数让当前线程放弃其时间片。</li><li>线程时间片切换，返回<code>true</code></li></ul></li><li><strong>BusySpinWaitStrategy类：</strong><ul><li><code>BusySpinWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了忙等待策略。</li><li>在 <code>EmptyWait()</code> 中，直接返回 <code>true</code>，表示一直忙等。</li><li>始终返回<code>true</code>，一直等待</li></ul></li><li><strong>TimeoutBlockWaitStrategy类：</strong><ul><li><code>TimeoutBlockWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了带有超时的阻塞等待策略。</li><li>它在 <code>EmptyWait()</code> 中，使用 <code>cv_.wait_for(lock, time_out_)</code>，允许线程等待一段时间，如果超时则返回 <code>false</code>，否则返回 <code>true</code>。</li><li>线程在超时时间内没有被唤醒，此时 <code>EmptyWait</code> 方法将返回 <code>false</code>，反映了等待过程中的超时情况。如果被唤醒，返回 <code>true</code>。线程在确定时间内为阻塞状态</li></ul></li></ol><p>uml类图如下：</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/uml.png" alt="uml"></p><h2 id="2-参考连接"><a href="#2-参考连接" class="headerlink" title="2.参考连接"></a>2.参考连接</h2><ul><li><p><a href="https://cloud.tencent.com/developer/article/2339238">C++ std::condition_variable 条件变量用法-腾讯云开发者社区-腾讯云 (tencent.com)</a></p></li><li><p><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp03.html">C++ 互斥和死锁 · 恋恋风辰的编程笔记 (llfc.club)</a></p></li><li><p><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp04.html">unique_lock，读写锁以及递归锁 · 恋恋风辰的编程笔记 (llfc.club)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/499085575">多线程不安全因素？线程安全问题分析总结 - 知乎 (zhihu.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> fastrtps </tag>
            
            <tag> 分布式通信中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-常用宏分析</title>
      <link href="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/"/>
      <url>/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从这篇blog开始，我们来分析百度CyberRt这个高性能的分布式通信中间件</p></blockquote><p>CyberRt的源码组成如下：</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/image-20231123135714615.png" alt="image-20231123135714615"></p><p><code>base</code>文件夹是Apollo开发的高性能基础库，我们先从这个文件夹里的代码看起:</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/image-20231123202400187.png" alt="image-20231123202400187"></p><p>从文件命名中可以看见实现了与线程相关的如线程池、锁、无锁队列、哈希表等等基础组件，我们就开始从零造轮子吧</p><h2 id="1-c-前置知识"><a href="#1-c-前置知识" class="headerlink" title="1.c++前置知识"></a>1.c++前置知识</h2><h3 id="std-nothrow"><a href="#std-nothrow" class="headerlink" title="std::nothrow"></a>std::nothrow</h3><p><code>(std::nothrow)</code> 是在C++中用于进行内存分配时的一种选项。通常，当你使用 <code>new</code> 运算符创建对象时，如果内存分配失败，<code>new</code> 会抛出 <code>std::bad_alloc</code> 异常。但是，当你希望在分配失败时不抛出异常，而是返回一个空指针，你可以使用 <code>(std::nothrow)</code> 作为参数传递给 <code>new</code>。</p><p>具体来说，使用 <code>(std::nothrow)</code> 会使得 <code>new</code> 在分配失败时返回一个空指针而不是抛出异常。这样，你可以在分配失败时通过检查返回的指针是否为空来处理错误，而不必使用异常处理机制。</p><p>以下是一个示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试分配一个非常大的数组，可能导致分配失败</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="literal">nullptr</span>;</span><br><span class="line">    arr = <span class="built_in">new</span>(std::nothrow) <span class="type">int</span>[<span class="number">1000000000000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory allocation failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory allocation successful.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] arr;  <span class="comment">// 记得释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们尝试分配一个非常大的整数数组。由于这个数组可能太大而无法成功分配，我们使用 <code>(std::nothrow)</code>，这样 <code>new</code> 在分配失败时会返回一个空指针。在分配失败的情况下，我们打印一条错误消息。这样，我们可以通过检查指针是否为空来处理内存分配失败的情况，而不必处理异常。</p><h3 id="std-once-flag-amp-amp-std-call-once"><a href="#std-once-flag-amp-amp-std-call-once" class="headerlink" title="std::once_flag &amp;&amp; std::call_once"></a>std::once_flag &amp;&amp; std::call_once</h3><p>在C++中，<code>std::once_flag</code> 是一个用于确保只执行一次代码的标记。它通常与 <code>std::call_once</code> 函数一起使用，以确保其中的代码只会在多线程环境下被执行一次。</p><p>多线程环境中，多个线程可能同时尝试执行某个特定的代码块，但有些代码块可能只需要执行一次。这时，就可以使用 <code>std::once_flag</code> 和 <code>std::call_once</code> 来确保代码块只会在第一次调用时执行，而后续调用会被忽略。</p><p>在C++中，<code>std::once_flag</code> 是一个用于确保只执行一次代码的标记。它通常与 <code>std::call_once</code> 函数一起使用，以确保其中的代码只会在多线程环境下被执行一次。</p><p>多线程环境中，多个线程可能同时尝试执行某个特定的代码块，但有些代码块可能只需要执行一次。这时，就可以使用 <code>std::once_flag</code> 和 <code>std::call_once</code> 来确保代码块只会在第一次调用时执行，而后续调用会被忽略。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(flag.mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双检锁，检查是否已经被执行过</span></span><br><span class="line">    <span class="keyword">if</span> (!flag.called) &#123;</span><br><span class="line">        <span class="comment">// 调用传入的函数</span></span><br><span class="line">        <span class="built_in">func</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置标志，表示函数已经执行过</span></span><br><span class="line">        flag.called = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个简化的示例中，<code>std::once_flag</code> 包含一个互斥锁（<code>mutex</code>）和一个布尔标志（<code>called</code>）。当第一个线程调用 <code>std::call_once</code> 时，它会获得互斥锁，检查标志。如果标志为假，表示函数还没有执行过，于是调用传入的函数，然后设置标志为真，释放互斥锁。如果标志为真，说明函数已经执行过，不再重复执行。</p><p>通过使用互斥锁和双检锁的技术，<code>std::call_once</code> 在多线程环境下能够保证传入的函数只执行一次，同时尽可能地减小了锁的开销。需要注意的是，尽管双检锁可以提高性能，但也需要小心处理一些细节，以防止出现竞态条件和内存可见性的问题。在实践中，使用现代C++标准库提供的 <code>std::call_once</code> 是比手动实现更为安全和简便的选择。</p><h3 id="std-enable-if"><a href="#std-enable-if" class="headerlink" title="std::enable_if"></a>std::enable_if</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::type</span><br></pre></td></tr></table></figure><p>这行代码使用了<code>std::enable_if</code>，它是一个模板元编程工具，用于在编译时根据条件启用或禁用模板的某个部分。</p><ul><li><code>std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;</code>：这是一个模板元编程的条件，它基于 <code>HasShutdown&lt;T&gt;::value</code> 的值。如果 <code>HasShutdown&lt;T&gt;::value</code> 为 <code>true</code>，那么这个表达式的结果是 <code>std::enable_if</code> 的一个特殊的内部类型，否则没有这个内部类型。</li><li><code>typename</code>：这是告诉编译器，后面的 <code>std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::type</code> 是一个类型名，而不是一个成员变量或函数。</li></ul><p>所以，整个表达式的意思是：如果 <code>HasShutdown&lt;T&gt;::value</code> 为 <code>true</code>，则这是一个有效的类型；否则，这个表达式没有有效的类型。</p><h2 id="2-宏分析"><a href="#2-宏分析" class="headerlink" title="2.宏分析"></a>2.宏分析</h2><h3 id="2-1-特征判断宏"><a href="#2-1-特征判断宏" class="headerlink" title="2.1 特征判断宏"></a>2.1 特征判断宏</h3><p><code>DEFINE_TYPE_TRAIT</code>定义在<code>base/macros.h</code>中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TYPE_TRAIT(name, func)                     \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                           \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename Class&gt;</span>                             \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(decltype(&amp;Class::func)*) &#123; \</span></span><br><span class="line"><span class="meta">      return true;                                        \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(...) &#123;                     \</span></span><br><span class="line"><span class="meta">      return false;                                       \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">    static constexpr bool value = Test<span class="string">&lt;T&gt;</span>(nullptr);       \</span></span><br><span class="line"><span class="meta">  &#125;;                                                      \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  constexpr bool name<span class="string">&lt;T&gt;</span>::value;</span></span><br></pre></td></tr></table></figure><ol><li><p><code>DEFINE_TYPE_TRAIT(name, func)</code> 定义了一个宏，该宏接受两个参数，<code>name</code> 是要定义的类型特征结构体的名称，<code>func</code> 是要检查的成员函数的名称。这个宏在内部定义了一个名为<code>name</code>的结构体，此结构体中提供了两个函数模板。</p></li><li><p><code>template &lt;typename T&gt; struct name &#123; ... &#125;;</code> 定义了一个模板结构体，该结构体接受一个类型参数 <code>T</code>。实际上这个宏就是用来检查传入的这个<code>T</code>是否包含有<code>func</code>这个函数，借助了<code>name</code>这个结构体来实现</p></li><li><p><code>name</code>结构体的内部有一个数据成员就是<code>value</code>，<code>value</code>的类型是<code>static constexpr bool</code>，是一个静态常量，这里使用<code>constexpr</code>来声明此变量是为了让编译器在编译的时候就把<code>value</code>的值计算出来，<code>value</code>的值就代表了传入的这个<code>T</code>是否有<code>func</code>这个函数，这个值的计算是通过调用<code>Test&lt;T&gt;</code>这个函数模板来实现的，传入的参数是<code>nullptr</code></p></li><li><p><code>Test&lt;T&gt;</code>这个函数模板有一个泛化的版本和一个特化的版本，首先来看特化的版本</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Class&gt;                             \</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="keyword">decltype</span>(&amp;Class::func)*)</span> </span>&#123; \</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;                                        \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过<code>decltype</code>去识别<code>&amp;Class::func</code>，如果说<code>&amp;Class::func</code>是存在的话，那么<code>decltype(&amp;Class::func)</code>推断出的类型就是一个指向成员函数函数的指针，这就说明了<code>class </code>存在一个名为<code>func</code>的函数，后面这个<code>*</code>号我没想明白为啥要加估计是为了告诉编译器传入的参数是一个指针类型吧，如果是这样的话代码可以改成下面这个样子更具有可读性：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Class&gt;                             \</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="keyword">decltype</span>(&amp;Class::func)* ptr)</span> </span>&#123; \</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;                                        \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样也就解释了为啥后面计算<code>value</code>值得时候传入了一个<code>nullptr</code>作为参数。回到最初，假设我现在传入的这个<code>T</code>这个类没有<code>func</code>这个成员，那么编译器就会去调用下面这个泛化的版本，并且上面那个特化的版本不会报错，这叫做c++的<code>SFINAE</code>特性</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;                                   \</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(...)</span> </span>&#123;                     \</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;                                       \</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ol><p>当你想要检查一个类型是否有某个成员函数时，你可以使用这个宏。下面是一个简单的例子，假设你想检查一个类型是否有 <code>size</code> 成员函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TYPE_TRAIT(name, func)                     \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                           \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename Class&gt;</span>                             \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(decltype(&amp;Class::func)*) &#123; \</span></span><br><span class="line"><span class="meta">      return true;                                        \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(...) &#123;                     \</span></span><br><span class="line"><span class="meta">      return false;                                       \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">    static constexpr bool value = Test<span class="string">&lt;T&gt;</span>(nullptr);       \</span></span><br><span class="line"><span class="meta">  &#125;;                                                      \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  constexpr bool name<span class="string">&lt;T&gt;</span>::value;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏定义类型特征结构体</span></span><br><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasSize, size)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个示例类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用类型特征检查类型是否有成员函数</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;HasSize for MyClass: &quot;</span> &lt;&lt; HasSize&lt;MyClass&gt;::value &lt;&lt; std::endl;  <span class="comment">// 输出 1 (true)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 另一个示例类，没有 size 成员函数</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AnotherClass</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;HasSize for AnotherClass: &quot;</span> &lt;&lt; HasSize&lt;AnotherClass&gt;::value &lt;&lt; std::endl;  <span class="comment">// 输出 0 (false)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DEFINE_TYPE_TRAIT(HasSize, size)</code> 定义了一个名为 <code>HasSize</code> 的类型特征结构体，用于检查类型是否有 <code>size</code> 成员函数。然后，通过 <code>HasSize&lt;MyClass&gt;::value</code> 和 <code>HasSize&lt;AnotherClass&gt;::value</code> 分别检查了 <code>MyClass</code> 和 <code>AnotherClass</code> 是否有 <code>size</code> 成员函数。根据定义，<code>MyClass</code> 有 <code>size</code> 成员函数，而 <code>AnotherClass</code> 没有，因此输出结果分别为 <code>1</code>（true）和 <code>0</code>（false）。</p><h3 id="2-2-单例宏"><a href="#2-2-单例宏" class="headerlink" title="2.2 单例宏"></a>2.2 单例宏</h3><p>代码在：<code>cyber/common/macros.h</code>中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasShutdown, Shutdown)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(T *instance)</span> </span>&#123;</span><br><span class="line">  instance-&gt;<span class="built_in">Shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    T *instance)</span> </span>&#123;</span><br><span class="line">  (<span class="type">void</span>)instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// There must be many copy-paste versions of these macros which are same</span></span><br><span class="line"><span class="comment">// things, undefine them to avoid conflict.</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> UNUSED</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DISALLOW_COPY_AND_ASSIGN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNUSED(param) (void)param</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line"><span class="meta">  classname(const classname &amp;) = delete;    \</span></span><br><span class="line"><span class="meta">  classname &amp;operator=(const classname &amp;) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_SINGLETON(classname)                                      \</span></span><br><span class="line"><span class="meta"> public:                                                                  \</span></span><br><span class="line"><span class="meta">  static classname *Instance(bool create_if_needed = true) &#123;              \</span></span><br><span class="line"><span class="meta">    static classname *instance = nullptr;                                 \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span></span><br><span class="line"><span class="meta">      static std::once_flag flag;                                         \</span></span><br><span class="line"><span class="meta">      std::call_once(flag,                                                \</span></span><br><span class="line"><span class="meta">                     [&amp;] &#123; instance = new (std::nothrow) classname(); &#125;); \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">    return instance;                                                      \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta">  static void CleanUp() &#123;                                                 \</span></span><br><span class="line"><span class="meta">    auto instance = Instance(false);                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (instance != nullptr) &#123;                                            \</span></span><br><span class="line"><span class="meta">      CallShutdown(instance);                                             \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta"> private:                                                                 \</span></span><br><span class="line"><span class="meta">  classname();                                                            \</span></span><br><span class="line"><span class="meta">  DISALLOW_COPY_AND_ASSIGN(classname)</span></span><br></pre></td></tr></table></figure><ol><li><p>首先定了两个很有意思的函数模板</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasShutdown, Shutdown)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(T *instance)</span> </span>&#123;</span><br><span class="line">  instance-&gt;<span class="built_in">Shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    T *instance)</span> </span>&#123;</span><br><span class="line">  (<span class="type">void</span>)instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DEFINE_TYPE_TRAIT(HasShutdown, Shutdown)</code>结合上面所讲的这个宏定义了一个名为<code>HasShutdown</code>的结构体用于判断传入的模板<code>T</code>这个类是否包含<code>Shutdown</code>这个成员函数，然后又使用了c++的<code>SFINAE</code>特性做了一个很有意思的操作</p><ul><li><p><code>typename</code>告诉了编译器后面<code>std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::type</code>这玩意儿是一个类型，上面这两个<code>CallShutdown</code>的函数模板入参都是一样的，唯一有区别的就是这个返回值的类型。</p></li><li><p>我们来看看<code>std::enable_if</code>的源码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Primary template.</span></span><br><span class="line"><span class="comment">/// Define a member typedef @c type only if a boolean constant is true.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span>, <span class="keyword">typename</span> _Tp = <span class="type">void</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> enable_if</span><br><span class="line">  &#123; &#125;;</span><br><span class="line">     </span><br><span class="line"><span class="comment">// Partial specialization for true.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">true</span>, _Tp&gt;</span><br><span class="line">  &#123; <span class="keyword">typedef</span> _Tp type; &#125;;</span><br></pre></td></tr></table></figure><p>可以看见c++官方对<code>std::enable_if</code>做了两种定义，一个泛化版本和一个特化版本</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::enable_if&lt;<span class="literal">true</span>, T&gt; <span class="comment">//用的是偏特化的版本</span></span><br><span class="line">std::enable_if&lt;<span class="literal">false</span>, T&gt; <span class="comment">// 用的是泛化的</span></span><br></pre></td></tr></table></figure><p>假设<code>HasShutdown&lt;T&gt;::value</code>的值为<code>true</code>，那么上面两个<code>CallShutdown</code>函数就变成了如下两种情况：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::enable_if&lt;<span class="literal">true</span>&gt;::type     </span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;<span class="literal">false</span>&gt;::type</span><br></pre></td></tr></table></figure><p>很明显<code>std::enable_if&lt;false&gt;::type</code>会走泛化版本，此时<code>std::enable_if</code>内部是没有<code>type</code>这个成员的，由于<code>SFINAE</code>特性的存在，此时并不会报错，所以编译器只会去走<code>std::enable_if&lt;true, T&gt; </code>，但是这里我很奇怪的一点是<code>typename std::enable_if&lt;true&gt;::type</code>这里没有传第二模板参数呀，按我的理解是不是应该&#96;&#96;typename std::enable_if&lt;true,T&gt;::type<code>这样子用，我不是很明白，我想了一下，我先姑且认为编译器会先去做泛化版本的判断，此时由于泛化版本中</code> template&lt;bool, typename _Tp &#x3D; void&gt;<code>，第二模板参数被默认成了</code>void<code>此时编译器发现前面这个bool值为</code>true<code>然后就去走下面这个特化版本，在特化版本中就会定义</code>type<code>的值，此时就是：</code>typedef void type&#96;了。</p><p>同理假设<code>HasShutdown&lt;T&gt;::value</code>的值为<code>fasle</code>，上面两个<code>CallShutdown</code>函数就反过来了，当去调用<code>CallShutdown</code>函数时就会走下面这个版本。</p></li></ul><p>综上所述，上面这两个函数模板就是用于检测类型 <code>T</code> 具有 <code>Shutdown</code> 成员函数，那么这个函数将被启用，否则将被禁用。在启用的情况下，它调用 <code>instance-&gt;Shutdown()</code>。类型 <code>T</code> 不具有 <code>Shutdown</code> 成员函数的情况。在这种情况下，这个函数什么都不做。</p></li><li><p><code>DISALLOW_COPY_AND_ASSIGN</code> 宏用于禁止拷贝和赋值操作。它通过将拷贝构造函数和拷贝赋值操作符声明为 <code>delete</code> 来阻止对象的拷贝和赋值。这通常用于单例模式等情况，以确保对象只能有一个实例。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line"><span class="meta">  classname(const classname &amp;) = delete;    \</span></span><br><span class="line"><span class="meta">  classname &amp;operator=(const classname &amp;) = delete;</span></span><br></pre></td></tr></table></figure></li><li><p><code>DECLARE_SINGLETON</code> 宏用于声明一个单例模式的类。具体来说，它包含以下功能：</p><ul><li><code>Instance(bool create_if_needed = true)</code> 函数用于获取单例对象的实例。如果单例对象尚未创建，它将使用 <code>std::call_once</code> 和 <code>new</code> 运算符创建一个实例。这确保在多线程环境下仅执行一次对象的创建操作。</li><li><code>CleanUp()</code> 函数用于清理单例对象。它调用 <code>CallShutdown</code> 函数来执行对象的清理操作。</li><li><code>classname()</code> 构造函数声明为 <code>private</code>，确保类的实例只能通过 <code>Instance</code> 函数创建。</li><li><code>DISALLOW_COPY_AND_ASSIGN(classname)</code> 用于禁止拷贝和赋值操作，将默认构造也声明成私有的，以确保类的唯一性。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_SINGLETON(classname)                                      \</span></span><br><span class="line"><span class="meta"> public:                                                                  \</span></span><br><span class="line"><span class="meta">  static classname *Instance(bool create_if_needed = true) &#123;              \</span></span><br><span class="line"><span class="meta">    static classname *instance = nullptr;                                 \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span></span><br><span class="line"><span class="meta">      static std::once_flag flag;                                         \</span></span><br><span class="line"><span class="meta">      std::call_once(flag,                                                \</span></span><br><span class="line"><span class="meta">                     [&amp;] &#123; instance = new (std::nothrow) classname(); &#125;); \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">    return instance;                                                      \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta">  static void CleanUp() &#123;                                                 \</span></span><br><span class="line"><span class="meta">    auto instance = Instance(false);                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (instance != nullptr) &#123;                                            \</span></span><br><span class="line"><span class="meta">      CallShutdown(instance);                                             \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta"> private:                                                                 \</span></span><br><span class="line"><span class="meta">  classname();                                                            \</span></span><br><span class="line"><span class="meta">  DISALLOW_COPY_AND_ASSIGN(classname)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3.参考链接"></a>3.参考链接</h2><ul><li><a href="https://liujiayu.blog.csdn.net/article/details/130346051">百度自动驾驶apollo源码解读14:接口存在判定宏DEFINE_TYPE_TRAIT_H-KING的博客-CSDN博客</a></li><li><a href="https://liujiayu.blog.csdn.net/article/details/130367869">百度自动驾驶apollo源码解读15:懒汉式单例宏DECLARE_SINGLETON-CSDN博客</a></li><li><a href="https://www.cnblogs.com/yb-blogs/p/13702717.html">C++ enable_if 探究 - BoBro - 博客园 (cnblogs.com)</a></li><li><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/enable-if-class?view=msvc-170">enable_if 类 | Microsoft Learn</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> fastrtps </tag>
            
            <tag> 分布式通信中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现user_shell</title>
      <link href="/2023/10/26/%E5%AE%9E%E7%8E%B0user-shell/"/>
      <url>/2023/10/26/%E5%AE%9E%E7%8E%B0user-shell/</url>
      
        <content type="html"><![CDATA[<h2 id="1-bug修复"><a href="#1-bug修复" class="headerlink" title="1.bug修复"></a>1.bug修复</h2><p>在实现<code>shell</code>应用程序时，我发现了许多<code>bug</code>，在完成<code>shell</code>这个应用程序之前先把之前代码的<code>bug</code>修复了</p><h3 id="1-1-sys-fork-错误修复"><a href="#1-1-sys-fork-错误修复" class="headerlink" title="1.1 sys_fork 错误修复"></a>1.1 sys_fork 错误修复</h3><p><img src="/2023/10/26/%E5%AE%9E%E7%8E%B0user-shell/image-20231026112455283.png" alt="image-20231026112455283"></p><ul><li><p>在之前的实现中，<code>trap</code>页中内核栈忘记覆盖了，因为<code>sys_fork</code>会去空闲任务数组中拿到一个，此时内核栈和父进程不一样，因此<code>trap</code>页中内核栈的地址需要重新赋值：<code> cx_ptr-&gt;kernel_sp = np-&gt;kstack;</code></p></li><li><p>初始化任务上下文，这里我只是用<code>tcx_init</code>这个函数来初始化了，之前是直接赋值，这里优化了一下</p></li></ul><h3 id="1-2-sys-exec-错误修复"><a href="#1-2-sys-exec-错误修复" class="headerlink" title="1.2 sys_exec 错误修复"></a>1.2 sys_exec 错误修复</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AppMetadata metadata = get_app_data_by_name(name);</span><br><span class="line">    <span class="keyword">if</span>(metadata.id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ELF 文件头</span></span><br><span class="line">    <span class="type">elf64_ehdr_t</span> *ehdr = metadata.start;</span><br><span class="line">    elf_check(ehdr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span>* <span class="title">proc</span> =</span> current_proc();</span><br><span class="line">    PageTable old_pagetable = proc-&gt;pagetable;</span><br><span class="line">    u64 oldsz = proc-&gt;base_size;</span><br><span class="line">    <span class="comment">//重新分配页表</span></span><br><span class="line">    proc_pagetable(proc);</span><br><span class="line">    <span class="comment">//加载程序段</span></span><br><span class="line">    load_segment(ehdr,proc);</span><br><span class="line">    <span class="comment">//映射应用程序用户栈开始地址</span></span><br><span class="line">    proc_ustack(proc);</span><br><span class="line"></span><br><span class="line">    TrapContext* cx_ptr = proc-&gt;trap_cx_ppn;</span><br><span class="line">    cx_ptr-&gt;sepc = (u64)ehdr-&gt;e_entry;</span><br><span class="line">    cx_ptr-&gt;sp = proc-&gt;ustack;</span><br><span class="line"></span><br><span class="line">    proc_freepagetable(&amp;old_pagetable,oldsz);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<code>exec</code>实现时，我们是没有重新分配<code>trap</code>页，我们只是根据传进来的<code>elf</code>文件对程序进行覆盖替换掉原来的，因此只是重新分配了根页表，然后对地址空间重新进行了映射。本质上<code>exec</code>前后都还是同一个进程，只是地址空间不同了，<code>trap</code>页中的某些数据不同了：1. 程序入口地址<code>e_entry</code> 2. 用户栈地址<code>u_stack</code>。因此<code>trap</code>页中需要替换的也就是这两个部分，其他是不需要修改的，比如内核栈、<code>trap_handler</code>地址什么的都是没变的，不需要覆盖。同时由于<code>trap</code>页没有被重新分配物理页，只是改变了映射的地址空间，因此此页不能被释放掉</li></ul><p><img src="/2023/10/26/%E5%AE%9E%E7%8E%B0user-shell/image-20231026113942302.png" alt="image-20231026113942302"></p><ul><li>在<code>proc_freepagetable</code>中，<code>trap</code>页物理内存是否释放的标志位修改为0，不能被释放掉</li></ul><h3 id="1-3-sys-read-问题修复"><a href="#1-3-sys-read-问题修复" class="headerlink" title="1.3 sys_read 问题修复"></a>1.3 sys_read 问题修复</h3><p><img src="/2023/10/26/%E5%AE%9E%E7%8E%B0user-shell/image-20231026114151361.png" alt="image-20231026114151361"></p><ul><li>之前的实现中，没有去调用<code>schedule</code>函数，这样造成的后果就是程序会阻塞在<code>sys_read</code>中出不去，加上调度后的逻辑就是<code>sys_read</code>在读取串口的字符，如果此时没读到就调度执行其他进程，重新调度回<code>sys_read</code>时再判断有没有读到字符，这样就不会阻塞在这里了。</li></ul><h2 id="2-user-shell-实现"><a href="#2-user-shell-实现" class="headerlink" title="2. user_shell 实现"></a>2. user_shell 实现</h2><p>内核在执行<code>user_shell</code>这个应用程序时，应该会有一个<code>initproc</code>的初始化进程，<code>user_shell</code>是由这个初始化进程<code>fork</code>来的，初始化进程负责拉起<code>user_shell</code>和回收结束执行的子进程的资源。初始化进程是内核默认加载执行的第一个应用程序。在这里我们直接<code>sys_exec</code>来执行<code>user_shell</code>，因为还没实现子进程的资源回收机制，因此<code>initproc</code>的程序如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">sys_exec(<span class="string">&quot;user_shell&quot;</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内核中手动拉起此初始化进程，：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载进程</span></span><br><span class="line">load_app(<span class="number">0</span>);</span><br><span class="line">app_init(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>接下来实现<code>user_shell</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LF 0x0a     </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR 0x0d   <span class="comment">//enter</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DL 0x7f   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BS 0x08   <span class="comment">// backspace</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Timer os user shell\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">    <span class="type">char</span> line[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> CR:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(line) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                line[<span class="built_in">strlen</span>(line)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> pid = sys_fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sys_exec(line);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BS:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(line) &gt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\b \b&quot;</span>);</span><br><span class="line">                line[<span class="built_in">strlen</span>(line) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,c);</span><br><span class="line">            <span class="built_in">strncat</span>(line,(<span class="type">char</span>*)&amp;c,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>user_shell</code>的逻辑就是从键盘获取输入，将读到的字符放进<code>line</code>这个字符数组中保存，如果这个字符是键盘上的<code>enter</code>键，则<code>fork</code>一个子进程，让子进程通过<code>sys_exec</code>来执行用户通过键盘输出的可执行程序；如果是键盘上的<code>backspace</code>键，意味着删除一个字符，在c语言中<code>\b</code>是退格字符，当它被打印时，它会导致光标向后移动一格，覆盖先前打印的字符。具体而言，<code>printf(&quot;\b \b&quot;);</code> 会打印一个退格字符，然后打印一个空格，最后再打印一个退格字符。这会导致光标向后移动一格，然后再向前移动一格，从而导致看起来好像什么都没有打印一样。</li><li>这里用到了一个函数<code>strncat</code>，这个函数的作用就是用于向一个字符串的末尾拼接字符，具体实现如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*dest) &#123;</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; *src) &#123;</span><br><span class="line">        *dest++ = *src++;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><p><img src="/2023/10/26/%E5%AE%9E%E7%8E%B0user-shell/GIF%202023-10-26%2015-04-48.gif" alt="GIF 2023-10-26 15-04-48"></p><p>在上面的测试中，可以看见<code>user_shell</code>由<code>initproc</code>拉起，然后我测试了一下字符输入与删除，接着输出<code>xec</code>然后按<code>enter</code>键，此时会去执行<code>xec</code>这个子进程，此进程会循环打印<code>exec!</code>，测试成功!</p><h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h2><ul><li><p><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter5/1process.html">进程概念及重要系统调用 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li><li><p><a href="https://blog.csdn.net/harryduanchina/article/details/90751355">C语言中的转义字符\b的含义_c语言\b-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sys_exec的实现</title>
      <link href="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-exec系统调用原型"><a href="#1-exec系统调用原型" class="headerlink" title="1.exec系统调用原型"></a>1.exec系统调用原型</h2><p>在<code>linux</code>系统下系统调用<code>exec</code>是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。在我们的内核中，如果仅有 <code>fork</code> 的话，那么所有的进程都只能和用户初始进程一样执行同样的代码段，这显然是远远不够的。于是我们还需要引入 <code>exec</code> 系统调用来执行不同的可执行文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execve 221</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_exec</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_execve,<span class="number">0</span>,name,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是定义在用户态的<code>app.c</code>中，<code>name</code>为传递给<code>sys_exec</code>函数的参数，代表了要加载的可执行文件的名字。实际上一般来说可执行文件都有参数，因此参数也需要通过<code>sys_exec</code>传递进去，这里先默认无参数。</p><p>用户在用户态调用此函数来加载执行一个可执行文件，内核通过系统调用分发，因此在内核的<code>sys_call.c</code>中做了如下修改：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> __sys_exec(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* app_name = translated_byte_buffer(name);</span><br><span class="line">    printk(<span class="string">&quot;exec app_name:%s\n&quot;</span>,app_name);</span><br><span class="line">    exec(app_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231020200131656.png" alt="image-20231020200131656"></p><p>和之前同理用户态传进来的字符串的参数由于地址空间的不同因此需要先去调用<code>translated_byte_buffer</code>转换一下，然后去调用<code>exec</code>函数，此函数会用来根据传入的<code>app</code>的名字进行加载执行</p><p>在实现<code>exec</code>函数之前，先来精简一下<code>loader.c</code>中的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">load_app</span><span class="params">(<span class="type">size_t</span> app_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加载ELF文件</span></span><br><span class="line">    AppMetadata metadata = get_app_data(app_id + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//ELF 文件头</span></span><br><span class="line">    <span class="type">elf64_ehdr_t</span> *ehdr = metadata.start;</span><br><span class="line">    <span class="comment">//检查elf 文件</span></span><br><span class="line">    elf_check(ehdr);</span><br><span class="line">    <span class="comment">//创建任务</span></span><br><span class="line">    TaskControlBlock* proc = task_create_pt(app_id);</span><br><span class="line">    <span class="comment">//加载程序段</span></span><br><span class="line">    load_segment(ehdr,proc);</span><br><span class="line">    <span class="comment">//赋值任务的 entry</span></span><br><span class="line">    proc-&gt;entry = (u64)ehdr-&gt;e_entry;</span><br><span class="line">    <span class="comment">// 映射应用程序用户栈开始地址</span></span><br><span class="line">    proc_ustack(proc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>load_app</code>此函数进行了简化，封装了三个函数，一个是<code>elf_check(elf64_ehdr_t *ehdr)</code>，用于检查传入的<code>elf</code>文件的魔数，另一个是<code>load_segment(elf64_ehdr_t *ehdr,struct TaskControlBlock* proc)</code>，用于加载应用程序的数据并映射，第三个是<code>proc_ustack(struct TaskControlBlock *p)</code>，用于映射应用程序的用户栈。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">elf_check</span><span class="params">(<span class="type">elf64_ehdr_t</span> *ehdr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断 elf 文件的魔数</span></span><br><span class="line">    assert(*(u32 *)ehdr==ELFMAG);</span><br><span class="line">    <span class="comment">//判断传入文件是否为 riscv64 的</span></span><br><span class="line">    <span class="keyword">if</span> (ehdr-&gt;e_machine != EM_RISCV || ehdr-&gt;e_ident[EI_CLASS] != ELFCLASS64)</span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;only riscv64 elf file is supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">load_segment</span><span class="params">(<span class="type">elf64_ehdr_t</span> *ehdr,<span class="keyword">struct</span> TaskControlBlock* proc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">elf64_phdr_t</span> *phdr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ehdr-&gt;e_phnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到每个Program Header的指针</span></span><br><span class="line">        phdr =(u64) (ehdr-&gt;e_phoff + ehdr-&gt;e_phentsize * i + (u64)ehdr);</span><br><span class="line">        <span class="keyword">if</span>(phdr-&gt;p_type == PT_LOAD)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取映射内存段开始位置</span></span><br><span class="line">            u64 start_va = phdr-&gt;p_vaddr;</span><br><span class="line">            <span class="comment">// 获取映射内存段结束位置</span></span><br><span class="line">            proc-&gt;ustack = start_va + phdr-&gt;p_memsz;</span><br><span class="line">            <span class="comment">//  转换elf的可读，可写，可执行的 flags</span></span><br><span class="line">            u8 map_perm = PTE_U | flags_to_mmap_prot(phdr-&gt;p_flags);</span><br><span class="line">            <span class="comment">// 获取映射内存大小,需要向上对齐</span></span><br><span class="line">            u64 map_size = PGROUNDUP(phdr-&gt;p_memsz);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; map_size; j+= PAGE_SIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 分配物理内存，加载程序段，然后映射</span></span><br><span class="line">                PhysPageNum ppn = kalloc();</span><br><span class="line">                    <span class="comment">//获取到分配的物理内存的地址</span></span><br><span class="line">                u64 paddr = phys_addr_from_phys_page_num(ppn).value;</span><br><span class="line">                <span class="built_in">memcpy</span>(paddr, (u64)ehdr + phdr-&gt;p_offset + j, PAGE_SIZE);</span><br><span class="line">                    <span class="comment">//内存逻辑段内存映射</span></span><br><span class="line">                PageTable_map(&amp;proc-&gt;pagetable,<span class="type">virt_addr_from_size_t</span>(start_va + j), \</span><br><span class="line">                                <span class="type">phys_addr_from_size_t</span>(paddr), PAGE_SIZE , map_perm);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;ustack =  <span class="number">2</span> * PAGE_SIZE + PGROUNDUP(proc-&gt;ustack);</span><br><span class="line">    proc-&gt;base_size=proc-&gt;ustack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc_ustack</span><span class="params">(<span class="keyword">struct</span> TaskControlBlock *p)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 映射应用程序用户栈开始地址</span></span><br><span class="line">    PhysPageNum ppn = kalloc();</span><br><span class="line">    u64 paddr = phys_addr_from_phys_page_num(ppn).value;</span><br><span class="line">    PageTable_map(&amp;p-&gt;pagetable,<span class="type">virt_addr_from_size_t</span>(p-&gt;ustack - PAGE_SIZE),<span class="type">phys_addr_from_size_t</span>(paddr), \</span><br><span class="line">                  PAGE_SIZE, PTE_R | PTE_W | PTE_U);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是修复一个<code>bug</code>:</p><p><img src="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231020200842704.png" alt="image-20231020200842704"></p><p>这个根据程序名获取应用程序的函数，这里应该是<code>get_app_data(i+1)</code>。</p><h2 id="2-解除映射与释放内存"><a href="#2-解除映射与释放内存" class="headerlink" title="2. 解除映射与释放内存"></a>2. 解除映射与释放内存</h2><p>一个进程通过<code>exec</code>系统调用来加载另外一个应用程序来进行执行，那么在这个新的应用程序开始执行的时候，原有进程的地址空间生命周期就可以结束了，里面包含的全部物理页帧都会被回收，新的应用程序需要为其分配新的页表，然后映射新的地址空间。首先同样回忆一下一个应用程序包含了哪些内存地址空间：</p><p><img src="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231020203225421.png" alt="image-20231020203225421"></p><p>每个应用程序依次映射了：跳板页，<code>trap</code>上下文页，用户栈页，应用程序页。销毁一个应用程序的地址空间首先就是要解除映射关系，然后将内核分配给此应用程序的物理内存释放掉。由于所有程序的跳板页都是映射到同一页物理地址，这一页是不能是不能释放物理内存的，只需要解除映射关系即可。</p><p>在<code>address.c</code>中定义了一个函数用于销毁一个应用程序的地址空间：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc_freepagetable</span><span class="params">(PageTable* pagetable, u64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, floor_virts(<span class="type">virt_addr_from_size_t</span>(TRAMPOLINE)), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, floor_virts(<span class="type">virt_addr_from_size_t</span>(TRAPFRAME)), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数的参数为应用程序的根页表和应用程序的大小<code>base_size</code>，此函数首先是</p><ul><li>调用<code>uvmunmap</code>函数将<code>TRAMPOLINE</code>页解除了映射关系，并未释放此页内存</li><li>调用<code>uvmunmap</code>函数将<code>TRAPFRAME</code>页解除了映射关系，并且释放了此页内存</li><li>调用<code>uvmfree</code>函数将应用程序从<code>0x10000</code>开始到<code>base_size</code>之间的内存页解除了映射关系，并且释放掉了对应的物理内存。释放掉了页表所占的三页内存</li></ul><p>首先来看<code>uvmunmap</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 取消映射 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmunmap</span><span class="params">(PageTable* pt, VirtPageNum vpn, u64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">    PageTableEntry* pte;</span><br><span class="line">    u64 a;</span><br><span class="line">    <span class="keyword">for</span> (a = vpn.value; a &lt; vpn.value + npages; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        pte = find_pte(pt,<span class="type">virt_page_num_from_size_t</span>(a));</span><br><span class="line">        <span class="keyword">if</span>(pte !=<span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(do_free)</span><br><span class="line">            &#123;</span><br><span class="line">                u64 phyaddr = PTE2PA(pte-&gt;bits);</span><br><span class="line">                PhysPageNum ppn = floor_phys(<span class="type">phys_addr_from_size_t</span>(phyaddr));</span><br><span class="line">                kfree(ppn);</span><br><span class="line">            &#125;</span><br><span class="line">            *pte = PageTableEntry_empty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入参数为应用程序的根页表，需要取消映射的虚拟地址的起始地址，需要取消映射的页数，是否释放内存的标志位</li><li>从<code>vpn</code>开始，通过<code>find_pte</code>函数去查看此页是否被映射，如果被映射了，则取消映射即将第三级的页表项赋值为空</li><li>如果<code>do_free</code>成立，则去释放掉对应的物理内存</li></ul><p><img src="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231020204733570.png" alt="image-20231020204733570"></p><p>然后来看<code>uvmfree</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uvmfree</span><span class="params">(PageTable* pt , u64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        uvmunmap(pt,floor_virts(<span class="type">virt_addr_from_size_t</span>(<span class="number">0</span>)),sz/PAGE_SIZE,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    freewalk(pt-&gt;root_ppn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先是调用<code>uvmunmap</code>函数，将应用程序虚拟地址从<code>0~base_sz</code>之间的的映射关系取消掉，同时释放掉对应的物理内存</li><li>然后是调用<code>freewalk</code>函数将此地址空间页表占用的物理空间全部释放掉</li></ul><p><img src="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231020210202183.png" alt="image-20231020210202183"></p><p>从根页表开始映射，一个应用程序的映射关系如上图所示，每个页表页有512个页表项，因此需要递归搜寻去释放内存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 解除页表映射关系，释放内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freewalk</span><span class="params">(PhysPageNum ppn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PageTableEntry* pte =  &amp;get_pte_array(ppn)[i];</span><br><span class="line">        <span class="keyword">if</span>((pte-&gt;bits &amp; PTE_V) &amp;&amp; (pte-&gt;bits &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            PhysPageNum child_ppn = PageTableEntry_ppn(pte);</span><br><span class="line">            freewalk(child_ppn);</span><br><span class="line">            *pte = PageTableEntry_empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pte-&gt;bits &amp; PTE_V)</span><br><span class="line">        &#123;</span><br><span class="line">            panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kfree(ppn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>freewalk</code>函数是在解除映射关系后才调用的，因此在上述的映射关系中，二级页表的所有页表项都是空的，<code>if((pte-&gt;bits &amp; PTE_V) &amp;&amp; (pte-&gt;bits &amp; (PTE_R|PTE_W|PTE_X)) == 0)</code>这个判断条件只在根页表和一级页表才成立，此时才会去向下搜寻下一级页表知道三级页表搜寻完毕。</p><h2 id="3-exec系统调用的实现"><a href="#3-exec系统调用的实现" class="headerlink" title="3.exec系统调用的实现"></a>3.exec系统调用的实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exec</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AppMetadata metadata = get_app_data_by_name(name);</span><br><span class="line">    <span class="comment">//ELF 文件头</span></span><br><span class="line">    <span class="type">elf64_ehdr_t</span> *ehdr = metadata.start;</span><br><span class="line">    elf_check(ehdr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span>* <span class="title">proc</span> =</span> current_proc();</span><br><span class="line">    <span class="comment">//保存旧的页表</span></span><br><span class="line">    PageTable old_pagetable = proc-&gt;pagetable;</span><br><span class="line">    <span class="comment">//拿到旧进程的数据大小</span></span><br><span class="line">    u64 oldsz = proc-&gt;base_size;</span><br><span class="line">    <span class="comment">//重新分配页表</span></span><br><span class="line">    proc_pagetable(proc);</span><br><span class="line">    <span class="comment">//加载程序段</span></span><br><span class="line">    load_segment(ehdr,proc);</span><br><span class="line">    <span class="comment">// 映射应用程序用户栈开始地址</span></span><br><span class="line">    proc_ustack(proc);</span><br><span class="line"></span><br><span class="line">    TrapContext* cx_ptr = proc-&gt;trap_cx_ppn;</span><br><span class="line">    cx_ptr-&gt;sepc = (u64)ehdr-&gt;e_entry;</span><br><span class="line">    cx_ptr-&gt;sp = proc-&gt;ustack;</span><br><span class="line">    <span class="type">reg_t</span> sstatus = r_sstatus();</span><br><span class="line">    <span class="comment">// 设置 sstatus 寄存器第8位即SPP位为0 表示为U模式</span></span><br><span class="line">    sstatus &amp;= (<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    w_sstatus(sstatus);</span><br><span class="line">    cx_ptr-&gt;sstatus = sstatus; </span><br><span class="line">    <span class="comment">// 设置内核页表token</span></span><br><span class="line">    cx_ptr-&gt;kernel_satp = kernel_satp;</span><br><span class="line">    <span class="comment">// 设置内核栈虚拟地址</span></span><br><span class="line">    cx_ptr-&gt;kernel_sp = proc-&gt;kstack;</span><br><span class="line">    <span class="comment">// 设置内核trap_handler的地址</span></span><br><span class="line">    cx_ptr-&gt;trap_handler = (u64)trap_handler;</span><br><span class="line"></span><br><span class="line">    proc_freepagetable(&amp;old_pagetable,oldsz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>根据传入的应用程序的名字拿到此程序的应用数据</p></li><li><p>调用<code>proc_pagetable</code>函数为新的应用程序创建一个空的用户的页表，映射跳板页，映射用户程序的<code>trap</code>页</p></li><li><p>为新的应用程序加载和映射程序段，映射用户栈</p></li><li><p>填充<code>trap</code>页</p></li><li><p>解除旧进程的映射和释放物理内存</p></li></ul><p>这里无需对任务上下文进行处理，因为这个进程本身已经在执行了，而只有被暂停的应用才需要在内核栈上保留一个任务上下文。</p><h2 id="4-系统调用后重新获取-Trap-上下文"><a href="#4-系统调用后重新获取-Trap-上下文" class="headerlink" title="4. 系统调用后重新获取 Trap 上下文"></a>4. 系统调用后重新获取 Trap 上下文</h2><p>过去的 <code>trap_handler</code> 实现是这样处理系统调用的：</p><p><img src="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231020211956964.png" alt="image-20231020211956964"></p><p>这里的 <code>cx</code> 是当前应用的 Trap 上下文的指针，我们需要通过查页表找到它具体被放在哪个物理页帧上，并构造相同的虚拟地址来在内核中访问它。对于系统调用 <code>sys_exec</code> 来说，一旦调用它之后，我们会发现 <code>trap_handler</code> 原来上下文中的 <code>cx</code> 失效了——因为它是用来访问之前地址空间中 Trap 上下文被保存在的那个物理页帧的，而现在它已经被回收掉了。因此，为了能够处理类似的这种情况，我们在 <code>syscall</code> 分发函数返回之后需要重新获取 <code>cx</code> ，目前的实现如下：</p><p><img src="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231020212105723.png" alt="image-20231020212105723"></p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h2><p>在<code>user</code>目录下新建一个应用程序<code>xec.c</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;exec!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们让<code>write.c</code>通过<code>sys_exec</code>系统调用来执行此程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sys_exec(<span class="string">&quot;xec&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我修改了一下<code>user</code>目录下的<code>Makefile</code>使得通过一个<code>make</code>命令就可编译所用的应用程序</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE = riscv64-unknown-elf-</span><br><span class="line">CFLAGS = -nostdlib -fno-builtin -mcmodel=medany</span><br><span class="line"></span><br><span class="line">CC = $&#123;CROSS_COMPILE&#125;gcc</span><br><span class="line">OBJCOPY = $&#123;CROSS_COMPILE&#125;objcopy</span><br><span class="line">OBJDUMP = $&#123;CROSS_COMPILE&#125;objdump</span><br><span class="line">INCLUDE:=-I../<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line">LIB = ../lib</span><br><span class="line"></span><br><span class="line"><span class="section">all: time write xec</span></span><br><span class="line"></span><br><span class="line"><span class="section">write: write.c <span class="variable">$(LIB)</span>/*.c</span></span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; <span class="variable">$(INCLUDE)</span> -T user.ld -Wl,-Map=write.map -o bin/write <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">time: time.c <span class="variable">$(LIB)</span>/*.c</span></span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; <span class="variable">$(INCLUDE)</span> -T user.ld -Wl,-Map=time.map -o bin/time <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">xec: xec.c <span class="variable">$(LIB)</span>/*.c</span></span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; <span class="variable">$(INCLUDE)</span> -T user.ld -o bin/xec <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">debug: objdump_time objdump_write objdump_xec</span></span><br><span class="line"></span><br><span class="line"><span class="section">objdump_time:</span></span><br><span class="line">$&#123;OBJDUMP&#125; -d bin/time &gt; time.txt</span><br><span class="line"><span class="section">objdump_write:</span></span><br><span class="line">$&#123;OBJDUMP&#125; -d bin/write &gt; write.txt</span><br><span class="line"><span class="section">objdump_xec:</span></span><br><span class="line">$&#123;OBJDUMP&#125; -d bin/xec &gt; xec.txt</span><br></pre></td></tr></table></figure><p>编译运行，现在<code>os/user</code>目录执行<code>make</code>命令生成应用程序，然后到<code>quard-star</code>目录编译运行，结果如下：</p><p><img src="/2023/10/20/sys-exec%E7%9A%84%E5%AE%9E%E7%8E%B0/GIF%202023-10-20%2021-30-08.gif" alt="GIF 2023-10-20 21-30-08"></p><p>可以看见<code>xec</code>被成功执行了！！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter5/3implement-process-mechanism.html">进程管理机制的设计实现 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sys_fork的实现</title>
      <link href="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-进程控制块"><a href="#1-进程控制块" class="headerlink" title="1. 进程控制块"></a>1. 进程控制块</h2><p>在之前我们没有提进程的概念，都是以任务的概念来说的，从这章开始正式进入进程，在内核中一个<code>TaskControlBlock</code>即代表了一个进程，系统中同一时间存在的每个进程都被一个不同的 <strong>进程标识符</strong> (PID, Process Identifier) 所标识。在内核初始化完毕之后会创建一个进程——即 <strong>用户初始进程</strong> (Initial Process) ，它是目前在内核中以硬编码方式创建的唯一一个进程。其他所有的进程都是通过一个名为 <code>fork</code> 的系统调用来创建的。</p><p>因此我们首先更新一下<code>TCB</code>的内容：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TaskState task_state;       <span class="comment">//任务状态</span></span><br><span class="line">    <span class="type">int</span> pid;                    <span class="comment">// Process ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span>* <span class="title">parent</span>;</span>  <span class="comment">//Parent process</span></span><br><span class="line">    TaskContext task_context;   <span class="comment">//任务上下文</span></span><br><span class="line">    u64  trap_cx_ppn;            <span class="comment">//Trap 上下文所在物理地址</span></span><br><span class="line">    u64  base_size;             <span class="comment">//应用数据大小</span></span><br><span class="line">    u64  kstack;                <span class="comment">//应用内核栈的虚拟地址</span></span><br><span class="line">    u64  ustack;                <span class="comment">//应用用户栈的虚拟地址</span></span><br><span class="line">    u64  entry;                 <span class="comment">//应用程序入口地址</span></span><br><span class="line">    PageTable pagetable;        <span class="comment">//应用页表所在物理页</span></span><br><span class="line">&#125;TaskControlBlock;</span><br></pre></td></tr></table></figure><p>新增了<code>pid</code>以及父进程的<code>TCB</code>指针，每个进程都需要为其分配一个<code>pid</code>的值，我将初始的第一个进程的<code>pid</code>值设置成了1，当有新的进程被创建时，相应的<code>pid</code>值加一就行，代码实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nextpid = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">allocpid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  pid = nextpid;</span><br><span class="line">  nextpid = nextpid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用<code>app_init</code>函数进行进程初始化的话就去调用此函数为进程分配一个<code>pid</code>号：</p><p><img src="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231008201309663.png" alt="image-20231008201309663"></p><p>顺便这里修复一个<code>bug</code>，在调用<code>tcx_init</code>函数初始化任务上下文时，传入的参数应该是该进程的内核栈的地址才对，用于更新<code>sp</code>之前传入错了。</p><h2 id="2-fork的实现"><a href="#2-fork的实现" class="headerlink" title="2. fork的实现"></a>2. fork的实现</h2><p><code>fork</code>函数的功能直观体现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在父进程中创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程fork()的返回值: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程执行的逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程执行的逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d, 我爹是: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// pid == -1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子进程失败了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不加判断, 父子进程都会执行这个循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父进程在调用<code>fork</code>函数后会生成一个新的子进程，此子进程和父进程的代码一样，执行逻辑是不一样的，当父进程<code>fork</code>成功后，<code>fork</code>返回的是子进程的<code>pid</code>号，而子进程中返回的是<code>0</code>代表子进程创建成功</p><p>在实现 fork 的时候，分为两个步骤：</p><ul><li>新建一个进程，为其分配页表，分配<code>trap</code>页，映射跳板页</li><li>拷贝父进程的数据和子进程的一致</li></ul><p>父进程和子进程的虚拟地址空间是完全相同的，但是由于页表不一样，所以映射到的实际物理内存是不一样的。</p><p>首先来实现第一步，为子进程创建页表，分配与映射<code>trap</code>页，映射跳板页：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TaskControlBlock* <span class="title function_">allocproc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span>* <span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">for</span>(p = tasks; p &lt; &amp;tasks[MAX_TASKS]; p++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;task_state == UnInit)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">      p-&gt;pid = allocpid();</span><br><span class="line">      p-&gt;task_state = Ready;</span><br><span class="line">      <span class="comment">// 为每个应用程序分配一页内存用与存放trap，同时初始化任务上下文</span></span><br><span class="line">      proc_trap(p);</span><br><span class="line">      <span class="comment">// 为用户程序创建页表，映射跳板页和trap上下文页</span></span><br><span class="line">      proc_pagetable(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>去进程数组里查找未初始化的进程，找到了则跳转到<code>found</code>处</p></li><li><p>为此进程分配<code>pid</code>，将其任务状态设置成<code>Ready</code>，这样就可以进入调度了</p></li><li><p>调用<code>proc_trap</code>函数，为应用程序分配一页内存用与存放<code>trap</code>，同时初始化任务上下文</p></li><li><p>调用<code>proc_pagetable</code>函数，为用户程序创建页表，映射跳板页和<code>trap</code>上下文页</p></li></ul><p>在此之前，实现了一个内核支持进程的初始化函数，将所有进程状态设置成了<code>UnInit</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">for</span>(p = tasks; p &lt; &amp;tasks[MAX_TASKS]; p++)</span><br><span class="line">  &#123;</span><br><span class="line">    p-&gt;task_state = UnInit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当创建新的进程时就去<code>tasks</code>数组里查找未初始化的。</p><p>然后来实现第二步，为子进程创建一个和父进程几乎完全相同的应用地址空间，定义了<code>uvmcopy</code>函数，此函数的入参为父进程的根页表和子进程的根页表和一个<code>sz</code>的参数，我们对父进程的页表进行索引，去查找父进程的虚拟地址空间中那些页是映射了的，如果此虚拟地址被映射了，则为子进程创建相同的映射，不同的是需要为子进程分配进行映射的物理地址页。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(PageTable* old, PageTable* new, u64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    PageTableEntry* pte;</span><br><span class="line">    u64 pa, i;</span><br><span class="line">    u8 flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i+=PAGE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        VirtPageNum vpn = floor_virts(<span class="type">virt_addr_from_size_t</span>(i));</span><br><span class="line">        pte = find_pte(old,vpn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pte != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将PTE 转换为物理地址*/</span></span><br><span class="line">            u64 phyaddr = PTE2PA(pte-&gt;bits);</span><br><span class="line">            <span class="comment">/* 得到PTE的映射 flags */</span></span><br><span class="line">            flags = PTE_FLAGS(pte-&gt;bits);</span><br><span class="line">            <span class="comment">/* 分配一页内存 */</span></span><br><span class="line">            PhysPageNum ppn = kalloc();</span><br><span class="line">            u64 paddr = phys_addr_from_phys_page_num(ppn).value;</span><br><span class="line">            <span class="comment">/* 拷贝内存 */</span></span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="type">void</span>*)paddr,(<span class="type">void</span>*)phyaddr,PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 映射内存 */</span></span><br><span class="line">            PageTable_map(new,<span class="type">virt_addr_from_size_t</span>(i), \</span><br><span class="line">                              <span class="type">phys_addr_from_size_t</span>(paddr),PAGE_SIZE,flags);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>sz</code>的值是父进程所占的虚拟地址空间的最大值，是在<code>load_app</code>函数中进行赋值的：</p><p><img src="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231008204403555.png" alt="image-20231008204403555"></p><p>如下图：</p><p><img src="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231008205605214.png" alt="image-20231008205605214"></p><p>我们从<code>0x0</code>开始依次遍历，通过<code>find_pte(old,vpn);</code>函数去一页一页遍历直到遍历到<code>base_size</code>大小，如果此页未被映射，则<code>find_pte(old,vpn);</code>会返回0，反之如果此页被映射了，则会返回映射的<code>pte</code>的值，我们此时就能对子进程进行映射了，同时根据父进程的<code>pte</code>找到存储父进程应用数据的物理页，拷贝数据到子进程的物理页中</p><p>这里<code>find_pte</code>函数有个小<code>bug</code>:</p><p><img src="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231008210055967.png" alt="image-20231008210055967"></p><p>将判断页表为空的这一步提到了返回<code>pte</code>的前面。</p><p>有了上面这两部我们再来看<code>__sys_fork()</code>的实现：</p><ul><li><p>父进程就是当前正在执行的进程，通过<code>current_proc()</code>函数拿到了当前进程的<code>PCB</code>指针</p></li><li><p>创建一个新的子进程</p></li><li><p>拷贝父进程的内存数据，创建一个和父进程相同的虚拟地址空间</p></li><li><p>拷贝父进程的<code>trap</code>页的数据</p></li><li><p>将子进程的<code>trap</code>返回值设置为0，然后复制父进程的<code>TCB</code>的信息</p></li><li><p>设置子进程的返回地址和内核栈</p></li><li><p>将<code>_top++</code></p></li><li><p><code>__sys_fork()</code>的返回值为子进程的<code>pid</code>号</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __sys_fork()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span>* <span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span>* <span class="title">p</span> =</span> current_proc();</span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝父进程的内存数据，根据页表查找物理页拷贝</span></span><br><span class="line">  uvmcopy(&amp;p-&gt;pagetable,&amp;np-&gt;pagetable,p-&gt;base_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝父进程的trap页数据</span></span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">void</span>*)np-&gt;trap_cx_ppn,(<span class="type">void</span>*)p-&gt;trap_cx_ppn,PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子进程返回值为0</span></span><br><span class="line">  TrapContext* cx_ptr = np-&gt;trap_cx_ppn;</span><br><span class="line">  cx_ptr-&gt;a0 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 复制TCB的信息</span></span><br><span class="line">  np-&gt;entry = p-&gt;entry;</span><br><span class="line">  np-&gt;base_size = p-&gt;base_size;</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  np-&gt;ustack = p-&gt;ustack;</span><br><span class="line">  <span class="comment">// 设置子进程返回地址和内核栈</span></span><br><span class="line">  np-&gt;task_context.ra = trap_return;</span><br><span class="line">  np-&gt;task_context.sp = np-&gt;kstack;</span><br><span class="line"></span><br><span class="line">  _top++;</span><br><span class="line">  <span class="keyword">return</span> np-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在子进程内核栈上压入一个初始化的任务上下文，使得内核一旦通过任务切换到该进程，就会跳转到 <code>trap_return</code> 来进入用户态。而在复制地址空间的时候，子进程的 Trap 上下文也是完全从父进程复制过来的，这可以保证子进程进入用户态和其父进程回到用户态的那一瞬间 CPU 的状态是完全相同的。而两个进程的应用数据由于地址空间复制的原因也是完全相同的，</p><p>我们再来看看从父进程trap进内核执行fork的过程：</p><ul><li>首先父进程执行<code>fork</code>函数进入内核的<code>trap_handler</code>函数进行分发，这里将<code>cx-&gt;sepc += 8;</code>向前移动到了<code>sys_call</code>的上一步，这也是一个小<code>bug</code>。因为在<code>__sys_fork()</code>内部会对父进程的<code>trap</code>页数据进行拷贝，为了保证子进程从内核返回后能正确返回到调用<code>fork</code>函数的下一指令开始执行，所以需要先修改<code>trap</code>页数据</li></ul><p><img src="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231008210725866.png" alt="image-20231008210725866"></p><ul><li>然后执行<code>__sys_fork()</code>函数，此函数执行完毕后，内核中就多了一个子进程，父进程就从<code>trap</code>返回了，此时返回到用户态的值就是<code>__sys_fork()</code>的返回值即子进程的<code>pid</code>值</li></ul><p><img src="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231008210912704.png" alt="image-20231008210912704"></p><ul><li>然后进行调度，当调度到子进程时会从内核态返回到用户态，由于在<code>__sys_fork()</code>函数中我们将子进程的<code>trap</code>页的<code>a0</code>寄存器的值设置成了0，所以用户态接收到的值就是0</li></ul><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><ul><li>首先修改一下<code>main</code>函数，初始化所有进程</li></ul><p><img src="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20231008211359077.png" alt="image-20231008211359077"></p><ul><li>然后修改应用程序，我直接修改<code>time.c</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在父进程中创建子进程</span></span><br><span class="line">    <span class="type">int</span> pid = sys_fork();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 父进程执行的逻辑</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;father\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 子进程执行的逻辑</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// pid == -1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建子进程失败了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<code>app.c</code>中新建一个系统调用函数，<code>#define __NR_clone 220</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_clone,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，先编译<code>time</code>应用程序，再编译内核：</p><p><img src="/2023/10/08/sys-fork%E7%9A%84%E5%AE%9E%E7%8E%B0/GIF%202023-10-8%2021-17-28.gif" alt="GIF 2023-10-8 21-17-28"></p><p>可以看见来回打印<code>father</code>和<code>child</code>，测试成功</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter5/3implement-process-mechanism.html">进程管理机制的设计实现 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/618481323">xv6 学习：进程管理B fork&amp;exec - 知乎 (zhihu.com)</a></p></li><li><p>[xv6 fork的实现 | Blurred code](<a href="https://www.blurredcode.com/2020/11/xv6fork%E7%9A%84%E5%AE%9E%E7%8E%B0/#:~:text=fork%E7%9A%84%E5%AE%9E%E7%8E%B0">https://www.blurredcode.com/2020/11/xv6fork的实现/#:~:text=fork的实现</a> 在xv6中的fork的实现是 int fork(void) { int child_pid %3D,0 for child_process fork () return child_pid%3B })</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符读入与应用名称读取</title>
      <link href="/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/"/>
      <url>/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-sys-read的实现"><a href="#1-sys-read的实现" class="headerlink" title="1.  sys_read的实现"></a>1.  sys_read的实现</h2><p> 在之前借助<code>Opensbi</code>可以向串口输出一个字符，这里同理，我们可以借助<code>Opensbi</code>读入从串口输入来的数据，在<code>sbi.c</code>中新增一个获取读入串口字符的函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_console_getchar() - Reads a byte from console device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the value read from console.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbi_console_getchar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">ret = sbi_ecall(SBI_EXT_0_1_CONSOLE_GETCHAR, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret.error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的字符存储在 <code>ret.error</code>中,读入字符的调用号是<code>SBI_EXT_0_1_CONSOLE_GETCHAR</code>。</p><p>借助此函数我们就能来实现<code>sys_read</code>了，应用程序在用户态调用<code>sys_read</code>来获取一个字符，内核在接收到这来自用户态的系统调用时会进行分发，然后去调用<code>sbi_console_getchar</code>函数将输出的字符返回给用户态，用户态的<code>sys_read</code>函数定义如下，<code>__NR_read</code>系统调用号的值为：63</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">size_t</span> fd ,<span class="type">const</span> <span class="type">char</span>* buf , <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_read,fd,buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数定义在<code>app.c</code>中，和<code>sys_write</code>系统调用类似，<code>buf</code>用来存储从串口输入的字符，对此函数封装一下,定义一个每次从串口获取一个字符的函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取一个字符 */</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">getchar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">1</span>];</span><br><span class="line">    sys_read(<span class="built_in">stdin</span>,data,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当内核的发现来自用户态的<code>__NR_read</code>系统调用时需要进行分发：</p><p><img src="/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/image-20230928154914856.png" alt="image-20230928154914856"></p><p>会去调用<code>__sys_read</code>函数进行处理：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __sys_read(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="built_in">stdin</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c ;</span><br><span class="line">        assert( len == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = sbi_console_getchar();</span><br><span class="line">            <span class="keyword">if</span>(c != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>* str = translated_byte_buffer(data , len);</span><br><span class="line">        str[<span class="number">0</span>]  = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数会循环读取串口的数据，直到读到一个字符，然后这里会去调用<code>translated_byte_buffer</code>找到从内核传进来的<code>buf</code>对应的实际物理地址，然后将串口读到的字符写入此物理地址。这里和<code>__sys_write</code>同理，应用地址空间和内核地址空间被隔离了，要进行数据传递需要找到实际的物理地址，因此<code>translated_byte_buffer</code>也做了一点小小的修改：</p><p><img src="/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/image-20230928155338315.png" alt="image-20230928155338315"></p><p>可以看见根据传入的用户态的地址转换后返回实际对应的物理地址。</p><p>来测试一下，首先修改一下应用程序，让<code>time</code>应用程序不打印东西，在<code>write</code>应用程序中来读取字符：</p><p><img src="/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/image-20230928155709010.png" alt="image-20230928155709010"></p><p>编译内核和执行：</p><p><img src="/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/GIF%202023-9-28%2016-00-18.gif" alt="GIF 2023-9-28 16-00-18"></p><p>可以看见我从键盘输出的字符都成功打印了出来。</p><h2 id="2-内核栈的修改"><a href="#2-内核栈的修改" class="headerlink" title="2. 内核栈的修改"></a>2. 内核栈的修改</h2><p>在<a href="https://yanglianoo.github.io/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/">内核和用户程序的映射逻辑 | TimerのBlog (yanglianoo.github.io)</a>我们对每个应用程序的内核栈进行了映射，当时映射后的内存分布长这样子：</p><p><img src="/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/image-20230921221056504.png" alt="image-20230921221056504"></p><p>这样不太好，我当时脑子抽了，实际上<code>trampoline</code>和<code>app0 kstack</code>之间应该存在一页<code>guard page</code>才对，修改后的内存分布长这样子：</p><p><img src="/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/image-20230928160653036.png" alt="image-20230928160653036"></p><p>映射内核栈的代码也要随之修改一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为每个应用程序映射内核栈,内核空间以及进行了映射 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_mapstacks</span><span class="params">(PageTable* kpgtbl)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(p = tasks; p &lt; &amp;tasks[MAX_TASKS]; p++) &#123;</span><br><span class="line">    <span class="type">char</span> *pa = (<span class="type">char</span>*)phys_addr_from_phys_page_num(kalloc()).value;</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">    u64 va = KSTACK((<span class="type">int</span>) (p - tasks));</span><br><span class="line">    PageTable_map(kpgtbl, <span class="type">virt_addr_from_size_t</span>(va ), <span class="type">phys_addr_from_size_t</span>((u64)pa), \</span><br><span class="line">                  PAGE_SIZE, PTE_R | PTE_W);</span><br><span class="line">    <span class="comment">// 给应用内核栈赋值 </span></span><br><span class="line">    p-&gt;kstack = va +  PAGE_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-读取应用程序的名称"><a href="#3-读取应用程序的名称" class="headerlink" title="3. 读取应用程序的名称"></a>3. 读取应用程序的名称</h2><p>在后续的开发中我们会使用进程的名字来对应用程序加载和执行，因此需要内核能得到应用的名称，在我们之前的<code>build.c</code>中加入几行代码：</p><p><img src="/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/image-20230928161110012.png" alt="image-20230928161110012"></p><p>加入这几行代码后，<code>link_app.S</code>也会随之改变，原因在于我们按照顺序将各个应用的名字通过 <code>.string</code> 伪指令放到数据段中，注意链接器会自动在每个字符串的结尾加入分隔符 <code>\0</code> ，它们的位置则由全局符号 <code>_app_names</code> 指出。</p><p><img src="/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/image-20230928161220189.png" alt="image-20230928161220189"></p><p>在<code>loader.c</code>中新建一个函数来读取应用的名字：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _app_names[];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* app_names[MAX_TASKS];</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_app_names</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> app_num = get_num_app();</span><br><span class="line">    printk(<span class="string">&quot;/**** APPS ****\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; app_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> len = <span class="built_in">strlen</span>(_app_names);</span><br><span class="line">            app_names[<span class="number">0</span>] = _app_names;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> len = <span class="built_in">strlen</span>(app_names[i<span class="number">-1</span>]);</span><br><span class="line">            app_names[i] = (<span class="type">char</span>*)((u64)_app_names + i * len + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printk(<span class="string">&quot;%s\n&quot;</span>,app_names[i]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;**************/&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于链接器会自动在每个字符串的结尾加入分隔符 <code>\0</code> ，因此根据<code>\0</code>将每个应用程序的名称存储到了<code>app_names</code>这个数组中。在main函数中调用此函数测试一下：</p><p><img src="/2023/09/28/%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%85%A5%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88%E8%B0%83%E6%95%B4/image-20230928161630834.png" alt="image-20230928161630834"></p><p>成功解析到程序的名称。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter5/2core-data-structures.html">进程管理的核心数据结构 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于地址空间的分时多任务</title>
      <link href="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/"/>
      <url>/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>这一节的目标是实现基于地址空间的分时多任务，内核和应用之间的地址空间是隔离的。</p><p>应用程序部分：</p><ul><li>解析ELF程序</li><li>为应用程序创建独立的三级页表</li><li>映射应用程序跳板页</li><li>映射<code>trap</code>上下文</li><li>映射应用程序逻辑段</li><li>映射用户栈</li></ul><p>任务创建部分：</p><ul><li>任务控制块属性新增</li><li>修改<code>task_create</code>函数</li><li>设置每个应用程序的<code>trap</code>上下文：<ul><li><code>sepc</code>： 应用程序入口地址</li><li>用户栈指针</li><li>内核栈栈顶虚拟地址</li><li><code>trap handler</code> 入口虚拟地址</li></ul></li></ul><h2 id="1-程序加载与映射"><a href="#1-程序加载与映射" class="headerlink" title="1. 程序加载与映射"></a>1. 程序加载与映射</h2><p>应用程序是以ELF格式组织的，我在这篇博客中：<a href="https://yanglianoo.github.io/2023/09/11/elf%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/">elf文件解析 | TimerのBlog (yanglianoo.github.io)</a>对ELF文件的构成做了详细的解析，我们现在就需要编码把应用程序的数据解析出来。</p><p>首先在<code>loader.h</code>中定义ELF文件解析相关的数据结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前16个字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT 16</span></span><br><span class="line"><span class="comment">//所有的ASCII码都可以用“\”加数字（一般是8进制数字）来表示。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFMAG 0x464C457FU   <span class="comment">// 0x464C457FU  &quot;\177ELF&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_RISCV 0xF3  <span class="comment">//risc-v 对应的 e_machine 的value值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_CLASS     4 <span class="comment">//EI_NIDENT 的 第四位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASSNONE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASS32   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASS64   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASSNUM  3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOAD 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ELF文件中段属性定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_X 0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_W 0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_R 0x4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  elf header 结构体定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u8 e_ident[EI_NIDENT];</span><br><span class="line">    u16 e_type;</span><br><span class="line">    u16 e_machine;</span><br><span class="line">    u32 e_version;</span><br><span class="line">    u64 e_entry;</span><br><span class="line">    u64 e_phoff;</span><br><span class="line">    u64 e_shoff;</span><br><span class="line">    u32 e_flags;</span><br><span class="line">    u16 e_ehsize;</span><br><span class="line">    u16 e_phentsize;</span><br><span class="line">    u16 e_phnum;</span><br><span class="line">    u16 e_shentsize;</span><br><span class="line">    u16 e_shnum;</span><br><span class="line">    u16 e_shstrndx;</span><br><span class="line">&#125; <span class="type">elf64_ehdr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  program header 结构体定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u32 p_type;</span><br><span class="line">    u32 p_flags;</span><br><span class="line">    u64 p_offset;</span><br><span class="line">    u64 p_vaddr;</span><br><span class="line">    u64 p_paddr;</span><br><span class="line">    u64 p_filesz;</span><br><span class="line">    u64 p_memsz;</span><br><span class="line">    u64 p_align;</span><br><span class="line">&#125; <span class="type">elf64_phdr_t</span>;</span><br></pre></td></tr></table></figure><p>然后再<code>loader.c</code>中新建一个<code>void load_app(size_t app_id)</code>的函数，这个函数做的事情就是上面提到的应用程序部分，我们直接先看代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">flags_to_mmap_prot</span><span class="params">(u8 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (flags &amp; PF_R ? PTE_R : <span class="number">0</span>) | </span><br><span class="line">           (flags &amp; PF_W ? PTE_W : <span class="number">0</span>) |</span><br><span class="line">           (flags &amp; PF_X ? PTE_X : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_app</span><span class="params">(<span class="type">size_t</span> app_id)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加载ELF文件</span></span><br><span class="line">    AppMetadata metadata = get_app_data(app_id + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ELF 文件头</span></span><br><span class="line">    <span class="type">elf64_ehdr_t</span> *ehdr = metadata.start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断 elf 文件的魔数</span></span><br><span class="line">    assert(*(u32 *)ehdr==ELFMAG);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断传入文件是否为 riscv64 的</span></span><br><span class="line">    <span class="keyword">if</span> (ehdr-&gt;e_machine != EM_RISCV || ehdr-&gt;e_ident[EI_CLASS] != ELFCLASS64)</span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;only riscv64 elf file is supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录APP程序的入口地址，为 main 函数地址</span></span><br><span class="line">    u64 entry = (u64)ehdr-&gt;e_entry;</span><br><span class="line">    <span class="comment">//创建任务</span></span><br><span class="line">    TaskControlBlock* proc = task_create_pt(app_id);</span><br><span class="line">    <span class="comment">//赋值任务的 entry</span></span><br><span class="line">    proc-&gt;entry = entry;</span><br><span class="line">    <span class="comment">// Program Header 解析</span></span><br><span class="line">    <span class="type">elf64_phdr_t</span> *phdr;</span><br><span class="line">    <span class="comment">//遍历每一个逻辑段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ehdr-&gt;e_phnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到每个Program Header的指针</span></span><br><span class="line">        phdr =(u64) (ehdr-&gt;e_phoff + ehdr-&gt;e_phentsize * i + metadata.start);</span><br><span class="line">        <span class="keyword">if</span>(phdr-&gt;p_type == PT_LOAD)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取映射内存段开始位置</span></span><br><span class="line">            u64 start_va = phdr-&gt;p_vaddr;</span><br><span class="line">            <span class="comment">// 获取映射内存段结束位置</span></span><br><span class="line">            proc-&gt;ustack = start_va + phdr-&gt;p_memsz;</span><br><span class="line">            <span class="comment">//  转换elf的可读，可写，可执行的 flags</span></span><br><span class="line">            u8 map_perm = PTE_U | flags_to_mmap_prot(phdr-&gt;p_flags);</span><br><span class="line">            <span class="comment">// 获取映射内存大小,需要向上对齐</span></span><br><span class="line">            u64 map_size = PGROUNDUP(phdr-&gt;p_memsz);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; map_size; j+= PAGE_SIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 分配物理内存，加载程序段，然后映射</span></span><br><span class="line">                PhysPageNum ppn = kalloc();</span><br><span class="line">                    <span class="comment">//获取到分配的物理内存的地址</span></span><br><span class="line">                u64 paddr = phys_addr_from_phys_page_num(ppn).value;</span><br><span class="line">                <span class="built_in">memcpy</span>(paddr, metadata.start + phdr-&gt;p_offset + j, PAGE_SIZE);</span><br><span class="line">                    <span class="comment">//内存逻辑段内存映射</span></span><br><span class="line">                PageTable_map(&amp;proc-&gt;pagetable,<span class="type">virt_addr_from_size_t</span>(start_va + j), \</span><br><span class="line">                                <span class="type">phys_addr_from_size_t</span>(paddr), PAGE_SIZE , map_perm);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射应用程序用户栈开始地址</span></span><br><span class="line">    proc-&gt;ustack =  <span class="number">2</span> * PAGE_SIZE + PGROUNDUP(proc-&gt;ustack);</span><br><span class="line">    PhysPageNum ppn = kalloc();</span><br><span class="line">    u64 paddr = phys_addr_from_phys_page_num(ppn).value;</span><br><span class="line">    PageTable_map(&amp;proc-&gt;pagetable,<span class="type">virt_addr_from_size_t</span>(proc-&gt;ustack - PAGE_SIZE),<span class="type">phys_addr_from_size_t</span>(paddr), \</span><br><span class="line">                  PAGE_SIZE, PTE_R | PTE_W | PTE_U);</span><br><span class="line">               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>通过<code>get_app_data</code>拿到了应用程序的数据，这里传入的参数<code>app_id + 1</code>是因为<code>_num_app</code>这个数组中第一位储存的是app的个数，所以比如<code>load_app(0)</code>，实际上取的就是<code>_num_app[1]</code>，这才对应上</p></li><li><p>取出ELF文件的文件头，判断魔数，判断传入文件是否是 riscv64的。</p></li><li><p>然后取出此应用程序的入口地址</p></li><li><p>接下来就是创建任务：<code>task_create_pt</code>这个函数干的事其实就是：为应用程序创建独立的三级页表、映射应用程序跳板页、映射<code>trap</code>上下文，然后返回代表该任务的任务控制块指针，将此任务的入口地址设置为ELF文件中解析出来的。这里我们暂时先不看，后面来解析，只要知道干完了上面三件事即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建任务</span></span><br><span class="line">TaskControlBlock* proc = task_create_pt(app_id);</span><br><span class="line"><span class="comment">//赋值任务的 entry</span></span><br><span class="line">proc-&gt;entry = entry;</span><br></pre></td></tr></table></figure></li><li><p>接下来就是解析<code>Program Header</code>，遍历每一个逻辑段，如果此逻辑段是可被加载的，则将此逻辑段进行映射，同时将此逻辑段加载到物理内存中，我们先来看一下应用程序的逻辑段组成，如下图可以看见有两个逻辑段是需要被加载的，01 段的属性是 <code>R E</code>、大小<code>0x1060</code>超过了一页大小，虚拟地址是<code>0x10000</code>，02 段的属性是<code>R W</code>、大小是<code>0x3eb8</code>小于一页、起始虚拟地址是<code>0x12000</code>。</p><p>对这两段进行映射时有几个需要注意的地方：</p><ul><li>对于大小超过一页的，需要向上对齐映射，就是要多映射一页，大小小于一页的就映射一页就对了； </li><li>需要分配新的物理页来储存逻辑段的数据，分配内存是通过<code>kalloc</code>函数的，然后直接通过<code>memcpy</code>将数据拷贝到分配的物理内存处；</li><li>在映射时ELF的可读可写可执行标志位和riscv的页表项不是相对应的，需要先转换一下，所以定义了一个<code>flags_to_mmap_prot</code>来用于转换标志位，同时这些段都是U模式下可访问的，因此映射的标志位需要或上<code>PTE_U</code></li><li>在调用<code>PageTable_map</code>函数开始映射时，映射的虚拟地址是<code>start_va + j</code>，就是因为如果这一段需要映射的内存大于一页，就需要一页一页内存</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">flags_to_mmap_prot</span><span class="params">(u8 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (flags &amp; PF_R ? PTE_R : <span class="number">0</span>) | </span><br><span class="line">           (flags &amp; PF_W ? PTE_W : <span class="number">0</span>) |</span><br><span class="line">           (flags &amp; PF_X ? PTE_X : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20230921223535279.png" alt="image-20230921223535279"></p></li><li><p>在完成逻辑段映射后就需要映射用户程序的内核栈了,如下图内核栈栈顶的虚拟地址位于应用程序上面的两页，我通过<code>proc-&gt;ustack</code>来记录了应用程序结束的位置，然后<code>proc-&gt;ustack =  2 * PAGE_SIZE + PGROUNDUP(proc-&gt;ustack);</code>对这个结束位置向上对齐然后再加两页内存就得到了用户栈的栈顶的虚拟地址，然后进行映射，这里映射用户栈和映射内核栈同理，虚拟地址起始地址应该为<code>guard page</code>的顶部位置</p></li></ol><p><img src="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20230923105021519.png" alt="image-20230923105021519"></p><p>至此通过<code>load_app</code>这个函数我们就完成了对应用程序数据的加载以及内存的映射。</p><h2 id="2-任务控制段修改"><a href="#2-任务控制段修改" class="headerlink" title="2. 任务控制段修改"></a>2. 任务控制段修改</h2><p>在上面<code>load_app</code>函数中，我们创建了一个<code>TaskControlBlock* proc</code>用来管理一个任务的具体信息，比如对任务的入口地址赋值，对任务的用户栈栈顶虚拟地址赋值：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值任务的 entry</span></span><br><span class="line">proc-&gt;entry = entry;</span><br><span class="line"><span class="comment">// 映射应用程序用户栈开始地址</span></span><br><span class="line">proc-&gt;ustack =  <span class="number">2</span> * PAGE_SIZE + PGROUNDUP(proc-&gt;ustack);</span><br></pre></td></tr></table></figure><p>相比于之前现在<code>TaskControlBlock</code>中多了一些信息：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TaskState task_state;       <span class="comment">//任务状态</span></span><br><span class="line">    TaskContext task_context;   <span class="comment">//任务上下文</span></span><br><span class="line">    u64 trap_cx_ppn;            <span class="comment">//Trap 上下文所在物理地址</span></span><br><span class="line">    u64  base_size;             <span class="comment">//应用数据大小</span></span><br><span class="line">    u64  kstack;                <span class="comment">//应用内核栈的虚拟地址</span></span><br><span class="line">    u64  ustack;                <span class="comment">//应用用户栈的虚拟地址</span></span><br><span class="line">    u64  entry;                 <span class="comment">//应用程序入口地址</span></span><br><span class="line">    PageTable pagetable;        <span class="comment">//应用页表所在物理页</span></span><br><span class="line">&#125;TaskControlBlock;</span><br></pre></td></tr></table></figure><p>增加了：Trap 上下文所在物理地址 、应用数据大小、应用内核栈的虚拟地址、应用用户栈的虚拟地址、应用程序入口地址、应用页表所在物理页 。在加载程序以及进行映射时需要对这些属性赋值，这样我们就可以通过<code>TaskControlBlock</code>这个数据结构来管理和具体代表一个应用程序了。</p><p>其中<code>kstack</code>的赋值是在映射内核栈时搞定的：</p><p><img src="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20230923110253668.png" alt="image-20230923110253668"></p><h2 id="3-创建页表映射跳板页和trap上下文"><a href="#3-创建页表映射跳板页和trap上下文" class="headerlink" title="3. 创建页表映射跳板页和trap上下文"></a>3. 创建页表映射跳板页和trap上下文</h2><p>在<code>load_app</code>函数中，我们调用了一个名为<code>task_create_pt</code>的函数，这个函数会完成应用程序页表的建立，同时映射跳板页和trap上下文页，然后返回一个代表一个应用程序的任务控制块，这个函数定义在<code>task.c</code>中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskControlBlock* <span class="title function_">task_create_pt</span><span class="params">(<span class="type">size_t</span> app_id)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(_top &lt; MAX_TASKS)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为应用程序分配一页内存用与存放trap</span></span><br><span class="line">    proc_trap(&amp;tasks[app_id]);</span><br><span class="line">    <span class="comment">//为用户程序创建页表，映射跳板页和trap上下文页</span></span><br><span class="line">    proc_pagetable(&amp;tasks[app_id]); </span><br><span class="line">    _top++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &amp;tasks[app_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数传入的参数为<code>app_id</code>，然后争对此应用程序首先分配了一页内存用于存放<code>trap</code>页，然后为用户程序创建页表，映射跳板页和<code>trap</code>上下文页。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为每个应用程序分配一页内存用与存放trap，同时初始化任务上下文 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_trap</span><span class="params">(<span class="keyword">struct</span> TaskControlBlock *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 为每个程序分配一页trap物理内存</span></span><br><span class="line">  p-&gt;trap_cx_ppn = phys_addr_from_phys_page_num(kalloc()).value;</span><br><span class="line">  printk(<span class="string">&quot;trap value : %p\n&quot;</span>,p-&gt;trap_cx_ppn);</span><br><span class="line">  <span class="comment">// 初始化任务上下文全部为0</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;task_context, <span class="number">0</span> ,<span class="keyword">sizeof</span>(p-&gt;task_context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个应用程序都需要一个<code>trap</code>页来存储自己的<code>trap</code>上下文，因此需要事先分配一页内存，然后对<code>p-&gt;trap_cx_ppn</code>赋值，分配完毕后将任务上下文全部清零。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> trampoline[];</span><br><span class="line"><span class="comment">/* 为用户程序创建页表，映射跳板页和trap上下文页*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> TaskControlBlock *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 创建一个空的用户的页表，分配一页内存</span></span><br><span class="line">  PageTable pagetable;</span><br><span class="line">  pagetable.root_ppn = kalloc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//映射跳板页</span></span><br><span class="line">  PageTable_map(&amp;pagetable,<span class="type">virt_addr_from_size_t</span>(TRAMPOLINE),<span class="type">phys_addr_from_size_t</span>((u64)trampoline),\</span><br><span class="line">                PAGE_SIZE , PTE_R | PTE_X);</span><br><span class="line">  printk(<span class="string">&quot;finish user TRAMPOLINE map!\n&quot;</span>);</span><br><span class="line">  <span class="comment">//映射用户程序的trap页</span></span><br><span class="line">  PageTable_map(&amp;pagetable,<span class="type">virt_addr_from_size_t</span>(TRAPFRAME),<span class="type">phys_addr_from_size_t</span>(p-&gt;trap_cx_ppn), \</span><br><span class="line">                PAGE_SIZE, PTE_R | PTE_W );</span><br><span class="line">  printk(<span class="string">&quot;finish user TRAPFRAME map!\n&quot;</span>);</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  printk(<span class="string">&quot;p-&gt;pagetable:%p\n&quot;</span>,p-&gt;pagetable.root_ppn.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是创建页表，和之前对内核地址映射的操作同理，分配一页内存来存放根页表，然后依次映射跳板页和<code>trap</code>页，这里需要注意的是在上一篇博客中提到所有的应用程序都是共享同一个跳板页的，所以是映射到同一个物理地址，然后呢各自有自己的<code>trap</code>页，因此需要分配一个物理内存来映射。跳板页的虚拟地址位于应用地址空间最顶端的地址，<code>trap</code>页位于其下一页。</p><p><img src="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20230923111438809.png" alt="image-20230923111438809"></p><p>映射完成后对<code>p-&gt;pagetable</code>赋值。</p><h2 id="4-改进Trap处理的实现"><a href="#4-改进Trap处理的实现" class="headerlink" title="4. 改进Trap处理的实现"></a>4. 改进Trap处理的实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trap_from_kernel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">panic(<span class="string">&quot;a trap from kernel!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_kernel_trap_entry</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">w_stvec((<span class="type">reg_t</span>)trap_from_kernel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_user_trap_entry</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">w_stvec((<span class="type">reg_t</span>)TRAMPOLINE);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trap_handler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">set_kernel_trap_entry();</span><br><span class="line">TrapContext* cx = get_current_trap_cx();</span><br><span class="line"></span><br><span class="line">    <span class="type">reg_t</span> scause = r_scause();</span><br><span class="line"><span class="type">reg_t</span> cause_code = scause &amp; <span class="number">0xfff</span>;</span><br><span class="line"><span class="keyword">if</span>(scause &amp; <span class="number">0x8000000000000000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (cause_code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* rtc 中断*/</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">set_next_trigger();</span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">printk(<span class="string">&quot;undfined interrrupt scause:%x\n&quot;</span>,scause);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (cause_code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* U模式下的syscall */</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">cx-&gt;a0 = __SYSCALL(cx-&gt;a7,cx-&gt;a0,cx-&gt;a1,cx-&gt;a2);</span><br><span class="line">cx-&gt;sepc += <span class="number">8</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">printk(<span class="string">&quot;undfined exception scause:%x\n&quot;</span>,scause);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trap_return();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于应用的 Trap 上下文不在内核地址空间，因此我们调用 <code>current_trap_cx</code> 来获取当前应用的 Trap 上下文，这个函数定义在<code>task.c</code>中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回当前执行的应用程序的trap上下文的地址 */</span></span><br><span class="line">u64 <span class="title function_">get_current_trap_cx</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tasks[_current].trap_cx_ppn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，在 <code>trap_handler</code> 的开头还调用 <code>set_kernel_trap_entry</code> 将 <code>stvec</code> 修改为同模块下另一个函数 <code>trap_from_kernel</code> 的地址。这就是说，一旦进入内核后再次触发到 S态 Trap，则硬件在设置一些 CSR 寄存器之后，会跳过对通用寄存器的保存过程，直接跳转到 <code>trap_from_kernel</code> 函数，在这里直接 <code>panic</code> 退出。这是因为内核和应用的地址空间分离之后，U态 –&gt; S态 与 S态 –&gt; S态 的 Trap 上下文保存与恢复实现方式&#x2F;Trap 处理逻辑有很大差别。这里为了简单起见，弱化了 S态 –&gt; S态的 Trap 处理过程：直接 <code>panic</code></p><blockquote><p>在这里我之前有个误区：在改进 Trap 处理的实现时，通过set_kernel_trap_entry函数将S态的异常处理地址设置成了trap_from_kernel函数，那时钟中断也会进入这个函数来处理吧，按照之前分时多任务的处理逻辑，当检测到是时钟中断时会进入_alltraps函数然后跳转到trap_handler来分发，从而进行调度。而在这里修改后，调度的过程是怎么发生的，我没想明白。</p><p>这个问题下面来解释</p></blockquote><p>在 <code>trap_handler</code> 完成 Trap 处理之后，我们需要调用 <code>trap_return</code> 返回用户态：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap_return</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">/* 把 stvec 设置为内核和应用地址空间共享的跳板页面的起始地址 */</span>  </span><br><span class="line">    set_user_trap_entry();</span><br><span class="line">    <span class="comment">/* Trap 上下文在应用地址空间中的虚拟地址 */</span>  </span><br><span class="line">    u64 trap_cx_ptr = TRAPFRAME;  </span><br><span class="line">    <span class="comment">/* 要继续执行的应用地址空间的 token */</span>  </span><br><span class="line">    u64  user_satp = current_user_token();  </span><br><span class="line">  </span><br><span class="line">    u64  restore_va = (u64)__restore - (u64)__alltraps + TRAMPOLINE;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(    </span></span><br><span class="line"><span class="params"><span class="string">&quot;fence.i\n\t&quot;</span>    </span></span><br><span class="line"><span class="params"><span class="string">&quot;mv a0, %0\n\t&quot;</span>  <span class="comment">// 将trap_cx_ptr传递给a0寄存器  </span></span></span><br><span class="line"><span class="params"><span class="string">&quot;mv a1, %1\n\t&quot;</span>  <span class="comment">// 将user_satp传递给a1寄存器  </span></span></span><br><span class="line"><span class="params"><span class="string">&quot;jr %2\n\t&quot;</span>      <span class="comment">// 跳转到restore_va的位置执行代码  </span></span></span><br><span class="line"><span class="params">:    </span></span><br><span class="line"><span class="params">: <span class="string">&quot;r&quot;</span> (trap_cx_ptr),    </span></span><br><span class="line"><span class="params"><span class="string">&quot;r&quot;</span> (user_satp),</span></span><br><span class="line"><span class="params"><span class="string">&quot;r&quot;</span> (restore_va)</span></span><br><span class="line"><span class="params">: <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在 <code>trap_return</code> 的开始处就调用 <code>set_user_trap_entry</code> ，来让应用 Trap 到 S 的时候可以跳转到 <code>__alltraps</code> 。注：我们把 <code>stvec</code> 设置为内核和应用地址空间共享的跳板页面的起始地址<code>TRAMPOLINE</code> 而不是编译器在链接时看到的 <code>__alltraps</code> 的地址。这是因为启用分页模式之后，内核只能通过跳板页面上的虚拟地址来实际取得 <code>__alltraps</code> 和 <code>__restore</code> 的汇编代码。</p><blockquote><p>这里就能回答我上面那个问题，当应用程序在执行时，此时产生了时钟中断，由于此时<code>stvec</code>寄存器的值我们在 <code>trap_return</code>时设置成了<code>TRAMPOLINE</code>，所以此时会进入<code>__alltraps</code> 函数执行，然后跳转到<code>trap_handler</code>进行处理来调用调度函数进行函数切换</p></blockquote></li><li><p>准备好 <code>__restore</code> 需要两个参数：分别是 Trap 上下文在应用地址空间中的虚拟地址和要继续执行的应用地址空间的 token 。最后我们需要跳转到 <code>__restore</code> ，以执行：切换到应用地址空间、从 Trap 上下文中恢复通用寄存器、 <code>sret</code> 继续执行应用。它的关键在于如何找到 <code>__restore</code> 在内核&#x2F;应用地址空间中共同的虚拟地址。</p></li><li><p>由于 <code>__alltraps</code> 是对齐到地址空间跳板页面的起始地址 <code>TRAMPOLINE</code> 上的， 则 <code>__restore</code> 的虚拟地址只需在 <code>TRAMPOLINE</code> 基础上加上 <code>__restore</code> 相对于 <code>__alltraps</code> 的偏移量即可。这里 <code>__alltraps</code> 和 <code>__restore</code> 都是指编译器在链接时看到的内核内存布局中的地址。</p></li><li><p>使用 <code>fence.i</code> 指令清空指令缓存 i-cache 。这是因为，在内核中进行的一些操作可能导致一些原先存放某个应用代码的物理页帧如今用来存放数据或者是其他应用的代码，i-cache 中可能还保存着该物理页帧的错误快照。因此我们直接将整个 i-cache 清空避免错误。接着使用 <code>jr</code> 指令完成了跳转到 <code>__restore</code> 的任务。</p></li></ul><h2 id="5-初始化任务"><a href="#5-初始化任务" class="headerlink" title="5. 初始化任务"></a>5. 初始化任务</h2><p>完成上面的步骤后，接下来就万事具备只欠东风了，回想之前我们要从内核态跳转到用户态执行应用程序之前需要填充此应用程序的<code>trap</code>上下文和任务上下文，之前是在<code>task_create</code>函数中完成的，现在对其就行了修改：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> u64 kernel_satp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_init</span><span class="params">(<span class="type">size_t</span> app_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    TrapContext* cx_ptr = tasks[app_id].trap_cx_ppn;</span><br><span class="line">    <span class="type">reg_t</span> sstatus = r_sstatus();</span><br><span class="line">    <span class="comment">// 设置 sstatus 寄存器第8位即SPP位为0 表示为U模式</span></span><br><span class="line">    sstatus &amp;= (<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    w_sstatus(sstatus);</span><br><span class="line">    <span class="comment">// 设置程序入口地址</span></span><br><span class="line">    cx_ptr-&gt;sepc = tasks[app_id].entry;</span><br><span class="line">    printk(<span class="string">&quot;cx_ptr-&gt;sepc:%p\n&quot;</span>,cx_ptr-&gt;sepc);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    cx_ptr-&gt;sstatus = sstatus; </span><br><span class="line">    <span class="comment">// 设置用户栈虚拟地址</span></span><br><span class="line">    cx_ptr-&gt;sp = tasks[app_id].ustack;</span><br><span class="line">    printk(<span class="string">&quot;cx_ptr-&gt;sp:%p\n&quot;</span>,cx_ptr-&gt;sp);</span><br><span class="line">    <span class="comment">// 设置内核页表token</span></span><br><span class="line">    cx_ptr-&gt;kernel_satp = kernel_satp;</span><br><span class="line">    <span class="comment">// 设置内核栈虚拟地址</span></span><br><span class="line">    cx_ptr-&gt;kernel_sp = tasks[app_id].kstack;</span><br><span class="line">    printk(<span class="string">&quot;cx_ptr-&gt;kernel_sp:%p\n&quot;</span>,cx_ptr-&gt;kernel_sp);</span><br><span class="line">    <span class="comment">// 设置内核trap_handler的地址</span></span><br><span class="line">    cx_ptr-&gt;trap_handler = (u64)trap_handler;</span><br><span class="line">    printk(<span class="string">&quot;cx_ptr-&gt;trap_handler:%p\n&quot;</span>,cx_ptr-&gt;trap_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造每个任务任务控制块中的任务上下文，设置 ra 寄存器为 trap_return 的入口地址*/</span></span><br><span class="line">    tasks[app_id].task_context = tcx_init((<span class="type">reg_t</span>)cx_ptr);</span><br><span class="line">    <span class="comment">// 初始化 TaskStatus 字段为 Ready</span></span><br><span class="line">    tasks[app_id].task_state = Ready;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当每个应用第一次获得 CPU 使用权即将进入用户态执行的时候，它的内核栈顶放置着我们在内核加载应用的时候 构造的一个任务上下文;在 <code>__switch</code> 切换到该应用的任务上下文的时候，内核将会跳转到 <code>trap_return</code> 并返回用户态开始该应用的启动执行。</p><p>在开启地址空间后，无论是从内核切换到应用程序还是从应用程序切换到内核都需要对<code>satp</code>的值进行切换，因此需要在任务上下文中保存内核的<code>satp</code>的值，在内核中需要知道当前执行的应用程序的<code>satp</code>的值。</p><p>综上所述，我们需要在应用trap上下文中保存：程序入口地址、用户栈虚拟地址、内核页表token、内核栈虚拟地址、内核<code>trap_handler</code>的地址。需要在任务上下文中：将trap上下文的地址放到任务上下文的<code>sp</code>寄存器中，将任务上下文的返回地址设置为<code>trap_return</code></p><p><img src="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20230923114013752.png" alt="image-20230923114013752"></p><h2 id="6-改进sys-write"><a href="#6-改进sys-write" class="headerlink" title="6. 改进sys_write"></a>6. 改进sys_write</h2><p>这里为啥需要对<code>sys_write</code>进行改写呢，那是因为假设一个应用程序在应用地址空间调用了<code>sys_write</code>函数，其中有个参数是：<code>char * buf</code>，这里代表了字符串储存的地址，但是这是应用地址空间的地址，进入内核态后切换到内核地址空间<code>char * buf</code>所代表的字符串的地址我们不能直接在内核地址空间下访问，需要转换成实际的物理地址去访问，需要我们手动查页表去访问，因此在<code>sys_call.c</code>中定义了一个辅助函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">translated_byte_buffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data , <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拿到当前应用程序的 satp</span></span><br><span class="line">    u64  user_satp = current_user_token();  </span><br><span class="line">    PageTable  pt ;</span><br><span class="line">    <span class="comment">//根据 satp 找到应用的根页表</span></span><br><span class="line">    pt.root_ppn.value = MAKE_PAGETABLE(user_satp);</span><br><span class="line"><span class="comment">//定义字符串起始地址和结束地址</span></span><br><span class="line">    u64 start_va = data;</span><br><span class="line">    u64 end_va = start_va + len;</span><br><span class="line">    VirtPageNum vpn = floor_virts(<span class="type">virt_addr_from_size_t</span>(start_va));</span><br><span class="line">    <span class="comment">//根据虚拟页号查找页表</span></span><br><span class="line">    PageTableEntry* pte = find_pte(&amp;pt , vpn);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拿到物理页地址</span></span><br><span class="line">    <span class="type">int</span> mask = ~( (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) <span class="number">-1</span> );</span><br><span class="line">    u64 phyaddr = ( pte-&gt;bits &amp; mask) &lt;&lt; <span class="number">2</span> ;</span><br><span class="line">    <span class="comment">//拿到偏移地址</span></span><br><span class="line">    u64 page_offset = start_va &amp; <span class="number">0xFFF</span>;</span><br><span class="line"><span class="comment">//打印字符串</span></span><br><span class="line">    u64 data_d = phyaddr + page_offset;</span><br><span class="line">    <span class="type">char</span> *data_p = (<span class="type">char</span>*) data_d;</span><br><span class="line">    printk(<span class="string">&quot;%s&quot;</span>,data_p); </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个函数就可以拿到实际的物理页上的字符串的数据，并将其打印出来</p><p><img src="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20230923204757141.png" alt="image-20230923204757141"></p><h2 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. 测试</h2><p>修改应用程序：</p><ul><li>time.c</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> current_timer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        current_timer = sys_gettime();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;current_timer:%x\n&quot;</span>,current_timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>write.c</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task write is running!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Makefile</li></ul><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE = riscv64-unknown-elf-</span><br><span class="line">CFLAGS = -nostdlib -fno-builtin -mcmodel=medany</span><br><span class="line"></span><br><span class="line">CC = $&#123;CROSS_COMPILE&#125;gcc</span><br><span class="line">OBJCOPY = $&#123;CROSS_COMPILE&#125;objcopy</span><br><span class="line">OBJDUMP = $&#123;CROSS_COMPILE&#125;objdump</span><br><span class="line">INCLUDE:=-I../<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line">LIB = ../lib</span><br><span class="line"></span><br><span class="line"><span class="section">write: write.c <span class="variable">$(LIB)</span>/*.c</span></span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; <span class="variable">$(INCLUDE)</span> -T user.ld -Wl,-Map=write.map -o bin/write <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">time: time.c <span class="variable">$(LIB)</span>/*.c</span></span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; <span class="variable">$(INCLUDE)</span> -T user.ld -Wl,-Map=time.map -o bin/time <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">objdump_time:</span></span><br><span class="line">$&#123;OBJDUMP&#125; -d bin/time &gt; time.txt</span><br><span class="line"><span class="section">objdump_write:</span></span><br><span class="line">$&#123;OBJDUMP&#125; -d bin/write &gt; write.txt</span><br></pre></td></tr></table></figure><p>上面这两个程序都会用到<code>lib</code>目录下的函数，因此将<code>lib</code>目录下的源文件页加入编译，同时我把<code>app.c</code>修改了一下放到了<code>lib</code>目录下,<code>write.c</code>和<code>time.c</code>都是调用了<code>app.c</code>的函数来执行系统调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/os.h&gt;</span></span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a0 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a0&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg1);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a1 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a1&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg2);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a2 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a2&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg3);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a7 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a7&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ecall&quot;</span></span></span><br><span class="line"><span class="params">      : <span class="string">&quot;+r&quot;</span> (a0)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;r&quot;</span> (a1), <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a7)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> a0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_write,fd,buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">sys_yield</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_sched_yield,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">sys_gettime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_gettimeofday,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先编译应用程序：</p><p><img src="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20230923120309144.png" alt="image-20230923120309144"></p><p>修改main函数：将两个程序加载和初始化，设置内核的trap的stvec的地址，然后开启时钟，开始执行</p><p><img src="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20230923120721233.png" alt="image-20230923120721233"></p><p>编译内核和执行：</p><p><img src="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/GIF%202023-9-23%2012-05-02.gif" alt="GIF 2023-9-23 12-05-02"></p><p>🆗，验证成功。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/6multitasking-based-on-as.html">基于地址空间的分时多任务 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></li></ul><p>最后说一下这一节的代码涉及到很多细节，需要很耐心的调试，我是用<code>GDB</code>用<code>si</code>指令一步一步跟进汇编然后看地址，看寄存器的值来调试最后才跑通的，可以看见在生成应用程序时我是用<code>objdump</code>生成了汇编代码，这也是我当时调试的产物，这里说几个调试相关的问题：</p><p><img src="/2023/09/13/%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20230923121725011.png" alt="image-20230923121725011"></p><p>在上图中我用n指令去调试，当函数从trap_return跳转到_restore函数时，就会出现<code>Cannot find bounds of current function</code>的问题，此时就得用<code>si</code>单步汇编调试了。</p><p>第二个是好像现在开启中断后我是没法调试的，不知道咋解决……….</p><blockquote><p>好多小bug调试累死我了……</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核和用户程序的映射逻辑</title>
      <link href="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/"/>
      <url>/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="1-内核映射补充"><a href="#1-内核映射补充" class="headerlink" title="1. 内核映射补充"></a>1. 内核映射补充</h2><p>在说应用程序的内核栈映射之前先说我之前陷入的一个误区，我之前想当然的认为在进行内核映射时我们不是把从<code>etext ~ PHYSTOP</code>所在的内存都映射了吗，每一页内存的映射需要根据虚拟地址三级映射去查表，如果根据页表项的索引发现页表项为空则去分配一页内存，我就以为这后面所有的内存都被使用了，我岂不是没有空闲的物理内存页可用了，但实际不是。一页内存可以存放512个页表项，以内核的两页为例子，我们的页表使用了三页内存，虚拟地址的前两个索引都是一样的，所以在二级页表中一次往下排，依次类推<code>0x80202000</code>会放在二级页表的三号框内，<code>0x80203000</code>会放在二级页表的4号框内，所以虽然从<code>etext ~ PHYSTOP</code>的内存都被映射了，但实际占用的物理内存页并不多。我们来打印看一下:</p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/image-20230912162657834.png" alt="image-20230912162657834"></p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/image-20230912162442822.png" alt="image-20230912162442822"></p><p>在内存分配函数中加一个使用物理页的打印。</p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/image-20230912162810260.png" alt="image-20230912162810260"></p><p>可以看见映射128M的内存占用的实际的物理内存并不多，映射只是为了告诉MMU真的要去访问一个虚拟地址时如何去查表，并不代表真的占用了，当然最后你想要去访问这128M的虚拟地址最终对应的还是128M的物理地址。</p><h2 id="2-xv6-的应用程序内核栈映射"><a href="#2-xv6-的应用程序内核栈映射" class="headerlink" title="2. xv6 的应用程序内核栈映射"></a>2. xv6 的应用程序内核栈映射</h2><p>在<code>timer os</code>的设计中，之前是使用一个二维数组来作为应用程序的内核栈，我们在<code>trap</code>时会将应用的<code>trap</code>上下文保存到内核栈中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> KernelStack[MAX_TASKS][KERNEL_STACK_SIZE];</span><br></pre></td></tr></table></figure><p>在<code>xv6-riscv</code>中是单独为每个应用映射了一个内核栈：</p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/image-20230912163758732.png" alt="image-20230912163758732"></p><p>我们来看看这个函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a page for each process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_mapstacks</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="type">char</span> *pa = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中比较重要的一点是<code>KSTACK</code>这个宏：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span></span><br></pre></td></tr></table></figure><p>遍历所有的应用程序，为每个应用程序映射一个内核栈，可以看见是两页两页的跳着映射，只映射一页，另外一页用来用作栈保护，由于两页中有一页没有映射所以如果应用程序的用户栈超过了一页的大小就会触发缺页异常。并且应用程序的内核栈不是直接映射的，是映射到存放完毕页表之后的可用内存页的。</p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/kernel-as-high.png" alt="../_images/kernel-as-high.png"></p><p>这里在虚拟地址空间的最顶端有一页叫做：<code>TRAMPOLINE</code>，这一页是跳板页，我们后面来分析。</p><p>这时候再来看<code>xv6</code>的内存映射图就很清楚了：</p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/v2-9c287c7d7384525eae9a37022322fd78_720w.png" alt="img"></p><h2 id="3-应用地址空间"><a href="#3-应用地址空间" class="headerlink" title="3. 应用地址空间"></a>3. 应用地址空间</h2><p>应用地址空间的内存布局如下图所示:</p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/app-as-full.png" alt="../_images/app-as-full.png"></p><p>左侧链接脚本中指明了应用连接到<code>0x10000</code>，从 <code>0x10000 </code>开始向高地址放置应用内存布局中的各个逻辑段，最后放置带有一个保护页面的用户栈。</p><p>右侧则给出了最高的 256GiB ，可以看出它只是和内核地址空间一样将跳板放置在最高页，还将 Trap 上下文放置在次高页中。为啥要在应用空间的最高出映射这两页，我们后续再来分析。</p><p>由此为每个应用程序的映射逻辑就清晰了：</p><ul><li>解析每个应用程序的<code>ELF</code>文件，从中解析出各逻辑段的信息</li><li>依次映射各逻辑段</li><li>映射应用程序用户栈</li></ul><h2 id="4-跳板机制的实现"><a href="#4-跳板机制的实现" class="headerlink" title="4. 跳板机制的实现"></a>4. 跳板机制的实现</h2><h3 id="4-1-为什么需要跳板机制"><a href="#4-1-为什么需要跳板机制" class="headerlink" title="4.1 为什么需要跳板机制"></a>4.1 为什么需要跳板机制</h3><p>为啥需要跳板机制，rCore中是下面这样解释的</p><blockquote><p>在上面的内核地址空间和应用程序地址空间中我们看到无论是内核还是应用的地址空间，最高的虚拟页面都是一个跳板。同时应用地址空间的次高虚拟页面还被设置为用来存放应用的<code> Trap</code> 上下文。那么跳板究竟起什么作用呢？为何不直接把 <code>Trap</code> 上下文仍放到应用的内核栈中呢？</p><p>在之前的设计中，当一个应用 Trap 到内核时，<code>sscratch</code> 已指向该应用的内核栈栈顶，我们用一条指令即可从用户栈切换到内核栈，然后直接将 <code>Trap</code> 上下文压入内核栈栈顶。当<code> Trap</code> 处理完毕返回用户态的时候，将 <code>Trap</code> 上下文中的内容恢复到寄存器上，最后将保存着应用用户栈顶的 <code>sscratch</code> 与 <code>sp</code> 进行交换，也就从内核栈切换回了用户栈。在这个过程中， <code>sscratch</code> 起到了非常关键的作用，它使得我们可以在不破坏任何通用寄存器的情况下，完成用户栈与内核栈的切换，以及位于内核栈顶的 <code>Trap</code> 上下文的保存与恢复。</p><p>然而，一旦使能了分页机制，一切就并没有这么简单了，我们必须在这个过程中同时完成地址空间的切换。具体来说，当 <code>__alltraps</code> 保存 Trap 上下文的时候，我们必须通过修改<code> satp</code> 从应用地址空间切换到内核地址空间，因为<code> trap handler</code> 只有在内核地址空间中才能访问；同理，在 <code>__restore</code> 恢复 Trap 上下文的时候，我们也必须从内核地址空间切换回应用地址空间，因为应用的代码和数据只能在它自己的地址空间中才能访问，应用是看不到内核地址空间的。这样就要求地址空间的切换不能影响指令的连续执行，即要求应用和内核地址空间在切换地址空间指令附近是平滑的。</p><p>我们为何将应用的 Trap 上下文放到应用地址空间的次高页面而不是内核地址空间中的内核栈中呢？原因在于，在保存 Trap 上下文到内核栈中之前，我们必须完成两项工作：1）必须先切换到内核地址空间，这就需要将内核地址空间的 token 写入 satp 寄存器；2）之后还需要保存应用的内核栈栈顶的位置，这样才能以它为基址保存 Trap 上下文。这两步需要用寄存器作为临时周转，然而我们无法在不破坏任何一个通用寄存器的情况下做到这一点。因为事实上我们需要用到内核的两条信息：内核地址空间的 token ，以及应用的内核栈栈顶的位置，RISC-V却只提供一个 <code>sscratch</code> 寄存器可用来进行周转。所以，我们不得不将 Trap 上下文保存在应用地址空间的一个虚拟页面中，而不是切换到内核地址空间去保存。</p></blockquote><p>总结一下就是要是想要在内核栈中保存trap上下文，则需要先切换到内核的页表，需要一个寄存器去存内核地址空间<code>satp</code>的值，在进行地址空间切换后，才能将trap上下文压入内核栈中，之前是通过<code>sscratch</code> 来保存应用的内核栈的，现在由于开启了分页机制，导致需要多一个寄存器来实现。但是无法在不破坏任何一个通用寄存器的情况来做到这一点，因此将Trap上下文保存到应用地址空间的一页中。</p><p>这里我有个问题，刚产生<code>trap</code>时，此时已经进入了S模式，需要在S模式下执行<code>__alltraps</code>函数，但此时执行代码和访问数据还是在应用程序所处的用户态虚拟地址空间中，而不是我们通常理解的内核虚拟地址空间。从内核态的<code>trap</code>返回时，会去执行<code>__restore</code>函数，此时也是在S态，但是需要去应用地址空间拿到<code>trap</code>上下文来恢复。</p><p>rCore的解释是：无论是内核还是应用的地址空间，跳板的虚拟页均位于同样位置，且它们也将会映射到同一个实际存放这段汇编代码的物理页帧。也就是说，在执行 <code>__alltraps</code> 或 <code>__restore</code> 函数进行地址空间切换的时候，应用的用户态虚拟地址空间和操作系统内核的内核态虚拟地址空间对切换地址空间的指令所在页的映射方式均是相同的，这就说明了这段切换地址空间的指令控制流仍是可以连续执行的。</p><p>简单点说就是，所用应用程序的跳板页都映射到同一物理内存页上，同时内核的也需要映射一个跳板页到这同一个物理页上，这样无论内核态去访问还是用户态去访问，访问的都是同一页物理内存，这一页物理内存上放的就是之前的<code>__alltraps</code> 函数和<code>__restore</code> ，这样就能理解了。</p><h3 id="4-2-trap修改"><a href="#4-2-trap修改" class="headerlink" title="4.2 trap修改"></a>4.2 trap修改</h3><p>根据上面的分析，<code>__alltraps</code> 函数需要实现在保存完毕<code>trap</code>上下文后从应用地址空间切换到内核地址空间，而<code>__restore</code>函数需要先切换到应用地址空间去恢复<code>trap</code>上下文，然后返回用户态。</p><p>先对<code>trap</code>上下文进行拓展：多了三项</p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/image-20230912173119079.png" alt="image-20230912173119079"></p><p>在多出的三个字段中：</p><ul><li><code>kernel_satp</code> 表示内核地址空间的 token ，即内核页表的起始物理地址；</li><li><code>kernel_sp</code> 表示当前应用在内核地址空间中的内核栈栈顶的虚拟地址；</li><li><code>trap_handler</code> 表示内核中<code>trap handler</code>入口点的虚拟地址。</li></ul><p>然后是切换地址空间：修改<code>kerneltrap.S</code>，在<code>kerneltrap.S</code>文件的开头我们声明此代码段为一个名为<code>trampoline</code>的节，这样<code>trampoline</code>就指向了此段代码的起始地址，用于后面链接和映射</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text.trampoline</span><br><span class="line">.globl __alltraps</span><br><span class="line">.align 3</span><br><span class="line">__alltraps:</span><br><span class="line">    # 从sscratch获取S模式下的SP，把U模式下的SP保存到sscratch寄存器中</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    # allocate a TrapContext on kernel stack</span><br><span class="line">    # save general-purpose registers</span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    # skip sp(x2), we will save it later</span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    # skip tp(x4), application does not use it</span><br><span class="line">    # save x5~x31</span><br><span class="line">    sd x4, 4*8(sp)</span><br><span class="line">    sd x5, 5*8(sp)</span><br><span class="line">    sd x6, 6*8(sp)</span><br><span class="line">    sd x7, 7*8(sp)</span><br><span class="line">    sd x8, 8*8(sp)</span><br><span class="line">    sd x9, 9*8(sp)</span><br><span class="line">    sd x10,10*8(sp)</span><br><span class="line">    sd x11, 11*8(sp)</span><br><span class="line">    sd x12, 12*8(sp)</span><br><span class="line">    sd x13, 13*8(sp)</span><br><span class="line">    sd x14, 14*8(sp)</span><br><span class="line">    sd x15, 15*8(sp)</span><br><span class="line">    sd x16, 16*8(sp)</span><br><span class="line">    sd x17, 17*8(sp)</span><br><span class="line">    sd x18, 18*8(sp)</span><br><span class="line">    sd x19, 19*8(sp)</span><br><span class="line">    sd x20, 20*8(sp)</span><br><span class="line">    sd x21, 21*8(sp)</span><br><span class="line">    sd x22, 22*8(sp)</span><br><span class="line">    sd x23, 23*8(sp)</span><br><span class="line">    sd x24, 24*8(sp)</span><br><span class="line">    sd x25, 25*8(sp)</span><br><span class="line">    sd x26, 26*8(sp)</span><br><span class="line">    sd x27, 27*8(sp)</span><br><span class="line">    sd x28, 28*8(sp)</span><br><span class="line">    sd x29, 29*8(sp)</span><br><span class="line">    sd x30, 30*8(sp)</span><br><span class="line">    sd x31, 31*8(sp)</span><br><span class="line"></span><br><span class="line">    # we can use t0/t1/t2 freely, because they were saved on kernel stack</span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    # read user stack from sscratch and save it on the kernel stack</span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    # load kernel_satp into t0</span><br><span class="line">    ld t0, 34*8(sp)</span><br><span class="line">    # load trap_handler into t1</span><br><span class="line">    ld t1, 36*8(sp)</span><br><span class="line">    # move to kernel_sp</span><br><span class="line">    ld sp, 35*8(sp)</span><br><span class="line">    # switch to kernel space</span><br><span class="line">    csrw satp, t0</span><br><span class="line">    sfence.vma</span><br><span class="line">    # jump to trap_handler</span><br><span class="line">    jr t1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.globl __restore</span><br><span class="line">.align 3</span><br><span class="line">__restore:</span><br><span class="line">    # a0: *TrapContext in user space(Constant); a1: user space token</span><br><span class="line">    # switch to user space</span><br><span class="line">    csrw satp, a1</span><br><span class="line">    sfence.vma</span><br><span class="line">    csrw sscratch, a0</span><br><span class="line">    mv sp, a0</span><br><span class="line">    # now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack</span><br><span class="line">    # restore sstatus/sepc</span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    # restore general-purpuse registers except sp/tp</span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    ld x4, 4*8(sp)</span><br><span class="line">    ld x5, 5*8(sp)</span><br><span class="line">    ld x6, 6*8(sp)</span><br><span class="line">    ld x7, 7*8(sp)</span><br><span class="line">    ld x8, 8*8(sp)</span><br><span class="line">    ld x9, 9*8(sp)</span><br><span class="line">    ld x10,10*8(sp)</span><br><span class="line">    ld x11, 11*8(sp)</span><br><span class="line">    ld x12, 12*8(sp)</span><br><span class="line">    ld x13, 13*8(sp)</span><br><span class="line">    ld x14, 14*8(sp)</span><br><span class="line">    ld x15, 15*8(sp)</span><br><span class="line">    ld x16, 16*8(sp)</span><br><span class="line">    ld x17, 17*8(sp)</span><br><span class="line">    ld x18, 18*8(sp)</span><br><span class="line">    ld x19, 19*8(sp)</span><br><span class="line">    ld x20, 20*8(sp)</span><br><span class="line">    ld x21, 21*8(sp)</span><br><span class="line">    ld x22, 22*8(sp)</span><br><span class="line">    ld x23, 23*8(sp)</span><br><span class="line">    ld x24, 24*8(sp)</span><br><span class="line">    ld x25, 25*8(sp)</span><br><span class="line">    ld x26, 26*8(sp)</span><br><span class="line">    ld x27, 27*8(sp)</span><br><span class="line">    ld x28, 28*8(sp)</span><br><span class="line">    ld x29, 29*8(sp)</span><br><span class="line">    ld x30, 30*8(sp)</span><br><span class="line">    ld x31, 31*8(sp)</span><br><span class="line"></span><br><span class="line">    # back to user stack</span><br><span class="line">    ld sp, 2*8(sp)</span><br><span class="line"></span><br><span class="line">    sret</span><br></pre></td></tr></table></figure><ul><li><p>当应用 Trap 进入内核的时候，硬件会设置一些 CSR 并在 S 特权级下跳转到 <code>__alltraps</code> 保存 Trap 上下文。此时 sp 寄存器仍指向用户栈，但 <code>sscratch</code> 则被设置为指向应用地址空间中存放 Trap 上下文的位置（实际在次高页面）。随后，就像之前一样，我们 <code>csrrw</code> 交换 sp 和 <code>sscratch</code> ，并基于指向 Trap 上下文位置的 sp 开始保存通用寄存器和一些 CSR ，这个过程在第 28 行结束。到这里，我们就全程在应用地址空间中完成了保存 Trap 上下文的工作。</p></li><li><p>接下来该考虑切换到内核地址空间并跳转到 trap handler 了。</p><ul><li>第 53 行将内核地址空间的 <code>token </code>载入到<code> t0</code> 寄存器中；</li><li>第 55 行将 <code>trap handler</code> 入口点的虚拟地址载入到<code> t1</code> 寄存器中；</li><li>第 57 行直接将 <code>sp</code> 修改为应用内核栈顶的地址；</li><li>第 59~60 行将 satp 修改为内核地址空间的 token 并使用 <code>sfence.vma</code> 刷新快表，这就切换到了内核地址空间；</li><li>第 62 行 最后通过 <code>jr</code> 指令跳转到 <code>t1</code> 寄存器所保存的<code>trap handler</code> 入口点的地址。</li></ul></li><li><p>当内核将 Trap 处理完毕准备返回用户态的时候会 <em>调用</em> <code>__restore</code> （符合RISC-V函数调用规范），它有两个参数：第一个是 Trap 上下文在应用地址空间中的位置，这个对于所有的应用来说都是相同的，在 a0 寄存器中传递；第二个则是即将回到的应用的地址空间的 token ，在 a1 寄存器中传递。</p><ul><li>第 70~71 行先切换回应用地址空间（注：Trap 上下文是保存在应用地址空间中）；</li><li>第 72 行将传入的 Trap 上下文位置保存在 <code>sscratch</code> 寄存器中，这样 <code>__alltraps</code> 中才能基于它将 Trap 上下文保存到正确的位置；</li><li>第 73 行将 sp 修改为 Trap 上下文的位置，后面基于它恢复各通用寄存器和 CSR；</li><li>第 115 行最后通过 <code>sret</code> 指令返回用户态。</li></ul></li></ul><h3 id="4-3-链接文件修改"><a href="#4-3-链接文件修改" class="headerlink" title="4.3 链接文件修改"></a>4.3 链接文件修改</h3><p>将 <code>kerneltrap.S</code> 中的整段汇编代码放置在 <code>.text.trampoline</code> 段，并在调整内存布局的时候将它对齐到代码段的一个页面中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skernel = .;   /* 定义内核起始内存地址 */</span><br><span class="line">.text : &#123;</span><br><span class="line">       *(.text.entry)</span><br><span class="line">       . = ALIGN(4K);</span><br><span class="line">       trampoline = .;</span><br><span class="line">       *(.text.trampoline);</span><br><span class="line">       . = ALIGN(4K);</span><br><span class="line">_strampoline = .;</span><br><span class="line">*(.text .text.*)</span><br><span class="line">. = ALIGN(4K);</span><br><span class="line">PROVIDE(etext = .);</span><br><span class="line">&#125; &gt;ram</span><br></pre></td></tr></table></figure><p>这样，这段汇编代码放在一个物理页帧中，且 <code>__alltraps</code> 恰好位于这个物理页帧的开头，其物理地址被外部符号 <code>strampoline</code> 标记。在开启分页模式之后，内核和应用代码都只能看到各自的虚拟地址空间，而在它们的视角中，这段汇编代码都被放在它们各自地址空间的最高虚拟页面上，由于这段汇编代码在执行的时候涉及到地址空间切换，故而被称为跳板页面。</p><h3 id="4-4-映射跳板页"><a href="#4-4-映射跳板页" class="headerlink" title="4.4 映射跳板页"></a>4.4 映射跳板页</h3><p>在<code>kvmmake</code>中将跳板页进行映射，大小为一页，属性为可读可执行</p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/image-20230912195136081.png" alt="image-20230912195136081"></p><h2 id="5-为timer-os映射应用程序内核栈"><a href="#5-为timer-os映射应用程序内核栈" class="headerlink" title="5. 为timer os映射应用程序内核栈"></a>5. 为timer os映射应用程序内核栈</h2><p>无论是rCore还是xv6的内存方式都是一样的，我们内核的应用程序内核栈和xv6一样映射，首先在<code>address</code>中新建一个<code>kalloc</code>函数：此函数直接返回分配的物理页帧号。我们现在<code>address</code>的部分是十分臃肿的，是因为我最开始为了模仿rCore把那些<code>PhysPageNum PageTable VirtPageNum VirtPageNum  PhysAddr</code>之类的定义全部搞成了结构体类型的，所以操作这些数据结构的方式全部使用了函数。其实应该定义成一个u64的类型就可以了，然后定义一些宏来操作。后面再来优化吧。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PhysPageNum <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PhysPageNum frame =  StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>task.c</code>中新建一个函数，来进行应用程序内核栈的映射：就是把xv6中的那个函数抄了过来，然后修改了一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为每个应用程序映射内核栈,内核空间以及进行了映射 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_mapstacks</span><span class="params">(PageTable* kpgtbl)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(p = tasks; p &lt; &amp;tasks[MAX_TASKS]; p++) &#123;</span><br><span class="line">    <span class="type">char</span> *pa = (<span class="type">char</span>*)phys_addr_from_phys_page_num(kalloc()).value;</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">    u64 va = KSTACK((<span class="type">int</span>) (p - tasks));</span><br><span class="line">    PageTable_map(kpgtbl, <span class="type">virt_addr_from_size_t</span>(va + PAGE_SIZE), <span class="type">phys_addr_from_size_t</span>((u64)pa), \</span><br><span class="line">                  PAGE_SIZE, PTE_R | PTE_W);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明一下<code>u64 va = KSTACK((int) (p - tasks));</code>得到的<code>va</code>实际上是<code>guard page</code>的最低地址，因此实际开始映射的地址是：<code>va + PAGE_SIZE</code>，如下图：</p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/image-20230921221056504.png" alt="image-20230921221056504"></p><p>然后在<code>kvmmake</code>中来调用此函数：</p><p><img src="/2023/09/12/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%98%A0%E5%B0%84%E9%80%BB%E8%BE%91/image-20230913143448035.png" alt="image-20230913143448035"></p><p>至此我们完成了内核的映射、跳板页的映射、应用程序内核栈的映射，下一步就是读取应用程序的elf文件，完成对应用程序的各逻辑段的映射、跳板页的映射、用户栈的映射、<code>trap</code>上下文的映射，然后在<code>task_create</code>函数中设置每个任务的<code>trap</code>上下文，包括应用程序入口地址、用户栈指针、内核空间的<code>satp</code>值、内核栈顶的虚拟地址、内核中<code>trap handler </code>入口的虚拟地址。然后就可以实现开启虚拟地址的多任务了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/351646541">Chapter 3: Page Tables - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf">xv6: a simple, Unix-like teaching operating system (mit.edu)</a></p></li><li><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/6multitasking-based-on-as.html#id8">基于地址空间的分时多任务 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li><li><p><a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c3/s2.html">3.2 内核地址空间 · 6.S081 All-In-One (dgs.zone)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elf文件解析</title>
      <link href="/2023/09/11/elf%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/09/11/elf%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ELF文件解析"><a href="#ELF文件解析" class="headerlink" title="ELF文件解析"></a>ELF文件解析</h1><h2 id="1-ELF文件概述"><a href="#1-ELF文件概述" class="headerlink" title="1. ELF文件概述"></a>1. ELF文件概述</h2><p>ELF（Executable and Linkable Format）是一种可执行文件和可链接库的标准格式，通常在Linux和其他类Unix操作系统中使用。ELF文件包含了程序的代码、数据、符号表、调试信息等。</p><p>ELF文件包含三个主要部分：头部、节区和程序头表。头部描述了ELF文件的基本信息，包括文件类型、机器类型、入口地址、节区表偏移等。节区包含了程序的代码、数据、符号表等信息。程序头表则描述了如何将ELF文件加载到内存中，包括需要加载的节区、地址、内存对齐方式等信息</p><p>ELF文件有两种用途，一种用于<strong>程序链接</strong>，一种用于<strong>程序执行</strong>，下图为官方文档中ELF文件两种组件视图:</p><p><img src="/2023/09/11/elf%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/image-20230419155229377.png" alt="image-20230419155229377"></p><p>对于可执行程序，<code>Program Header</code>是必须的，描述了不同的段即<code>Segment</code>,<code>Section Header</code>是可选的 </p><p>对于链接程序，<code>Program Header</code>是可选的，<code>Section Header</code>是必须的，描述了不同的<code>section</code></p><p>我们来看一下编译生成的<code>app</code>，在<code>user\bin</code>目录下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">readelf -a write</span><br></pre></td></tr></table></figure><p><img src="/2023/09/11/elf%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/image-20230911191055242.png" alt="image-20230911191055242"></p><h2 id="2-数据结构定义"><a href="#2-数据结构定义" class="headerlink" title="2. 数据结构定义"></a>2. 数据结构定义</h2><p><code>elf</code>文件支持具有8位、32位架构和64位架构的各种处理器。下表列出了32位数据类型和64位数据类型。</p><p><code>elf</code>文件使用机器无关格式表示一些控制数据。该格式提供了对目标文件的通用识别和解释。<code>elf</code>文件中的其余数据使用目标处理器的编码，而不管创建文件的机器是什么</p><ul><li>32位数据格式定义</li></ul><table><thead><tr><th align="left">Name</th><th align="left">Size</th><th align="left">Alignment</th><th align="left">Purpose</th></tr></thead><tbody><tr><td align="left"><code>Elf32_Addr</code></td><td align="left"><code>4</code></td><td align="left"><code>4</code></td><td align="left">Unsigned program address</td></tr><tr><td align="left"><code>Elf32_Half</code></td><td align="left"><code>2</code></td><td align="left"><code>2</code></td><td align="left">Unsigned medium integer</td></tr><tr><td align="left"><code>Elf32_Off</code></td><td align="left"><code>4</code></td><td align="left"><code>4</code></td><td align="left">Unsigned file offset</td></tr><tr><td align="left"><code>Elf32_Sword</code></td><td align="left"><code>4</code></td><td align="left"><code>4</code></td><td align="left">Signed integer</td></tr><tr><td align="left"><code>Elf32_Word</code></td><td align="left"><code>4</code></td><td align="left"><code>4</code></td><td align="left">Unsigned integer</td></tr><tr><td align="left"><code>unsigned char</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td align="left">Unsigned small integer</td></tr></tbody></table><ul><li>64位数据数据格式定义</li></ul><table><thead><tr><th align="left">Name</th><th align="left">Size</th><th align="left">Alignment</th><th align="left">Purpose</th></tr></thead><tbody><tr><td align="left"><code>Elf64_Addr</code></td><td align="left"><code>8</code></td><td align="left"><code>8</code></td><td align="left">Unsigned program address</td></tr><tr><td align="left"><code>Elf64_Half</code></td><td align="left"><code>2</code></td><td align="left"><code>2</code></td><td align="left">Unsigned medium integer</td></tr><tr><td align="left"><code>Elf64_Off</code></td><td align="left"><code>8</code></td><td align="left"><code>8</code></td><td align="left">Unsigned file offset</td></tr><tr><td align="left"><code>Elf64_Sword</code></td><td align="left"><code>4</code></td><td align="left"><code>4</code></td><td align="left">Signed integer</td></tr><tr><td align="left"><code>Elf64_Word</code></td><td align="left"><code>4</code></td><td align="left"><code>4</code></td><td align="left">Unsigned integer</td></tr><tr><td align="left"><code>Elf64_Xword</code></td><td align="left"><code>8</code></td><td align="left"><code>8</code></td><td align="left">Unsigned long integer</td></tr><tr><td align="left"><code>Elf64_Sxword</code></td><td align="left"><code>8</code></td><td align="left"><code>8</code></td><td align="left">Signed long integer</td></tr><tr><td align="left"><code>unsigned char</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td align="left">Unsigned small integer</td></tr></tbody></table><p><code>elf</code>文件格式定义的所有数据结构都遵循相关类别的自然大小和对齐准则。数据结构可以包含显式填充以确保4字节对齐，强制结构大小为4的倍数等等。数据也具有从文件开头开始的适当对齐方式。因此，例如，包含Elf32_Addr成员的结构在文件中是以4字节边界对齐的。类似地，包含Elf64_Addr成员的结构在8字节边界上对齐。</p><h2 id="3-ELF文件的文件头（ELF-Header"><a href="#3-ELF文件的文件头（ELF-Header" class="headerlink" title="3. ELF文件的文件头（ELF Header)"></a>3. ELF文件的文件头（ELF Header)</h2><p>ELF头文件描述了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>   e_ident[EI_NIDENT]; </span><br><span class="line">        Elf32_Half      e_type;</span><br><span class="line">        Elf32_Half      e_machine;</span><br><span class="line">        Elf32_Word      e_version;</span><br><span class="line">        Elf32_Addr      e_entry;</span><br><span class="line">        Elf32_Off       e_phoff;</span><br><span class="line">        Elf32_Off       e_shoff;</span><br><span class="line">        Elf32_Word      e_flags;</span><br><span class="line">        Elf32_Half      e_ehsize;</span><br><span class="line">        Elf32_Half      e_phentsize;</span><br><span class="line">        Elf32_Half      e_phnum;</span><br><span class="line">        Elf32_Half      e_shentsize;</span><br><span class="line">        Elf32_Half      e_shnum;</span><br><span class="line">        Elf32_Half      e_shstrndx;</span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>e_ident[EI_NIDENT]; <span class="comment">/* Magic number and other info */</span>   <span class="comment">// 1 byte * 16</span></span><br><span class="line">  Elf64_Halfe_type;    <span class="comment">/* Object file type */</span>                  <span class="comment">// 2 bytes</span></span><br><span class="line">  Elf64_Halfe_machine;    <span class="comment">/* Architecture */</span><span class="comment">// 2 bytes</span></span><br><span class="line">  Elf64_Worde_version;    <span class="comment">/* Object file version */</span>               <span class="comment">// 4 bytes</span></span><br><span class="line">  Elf64_Addre_entry;    <span class="comment">/* Entry point virtual address */</span>       <span class="comment">// 8 bytes</span></span><br><span class="line">  Elf64_Offe_phoff;    <span class="comment">/* Program header table file offset */</span>  <span class="comment">// 8 bytes</span></span><br><span class="line">  Elf64_Offe_shoff;    <span class="comment">/* Section header table file offset */</span>  <span class="comment">// 8 bytes   </span></span><br><span class="line">  Elf64_Worde_flags;    <span class="comment">/* Processor-specific flags */</span> <span class="comment">// 4 bytes   </span></span><br><span class="line">  Elf64_Halfe_ehsize;    <span class="comment">/* ELF header size in bytes */</span><span class="comment">// 2 bytes</span></span><br><span class="line">  Elf64_Halfe_phentsize;<span class="comment">/* Program header table entry size */</span><span class="comment">// 2 bytes</span></span><br><span class="line">  Elf64_Halfe_phnum;    <span class="comment">/* Program header table entry count */</span><span class="comment">// 2 bytes</span></span><br><span class="line">  Elf64_Halfe_shentsize;<span class="comment">/* Section header table entry size */</span><span class="comment">// 2 bytes</span></span><br><span class="line">  Elf64_Halfe_shnum;    <span class="comment">/* Section header table entry count */</span><span class="comment">// 2 bytes</span></span><br><span class="line">  Elf64_Halfe_shstrndx;    <span class="comment">/* Section header string table index */</span><span class="comment">// 2 bytes</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br><span class="line"><span class="comment">//64位的大小为64字节</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>e_ident</strong></p><p>最开始处的这 16 个字节含有 ELF 文件的识别标志，作为一个数组，它的各个索引位置的字节数据有固定的含义，提供一些用于解码和解析文件内容的数据，是不依赖于具体操作系统的。</p><table><thead><tr><th>数据成员名称</th><th>数组下标的索引</th><th>占用字节数</th><th>意义</th></tr></thead><tbody><tr><td>EI_MAG0</td><td>0</td><td>1</td><td>文件标识-魔数：0x7F</td></tr><tr><td>EI_MAG1</td><td>1</td><td>1</td><td>文件标识：45</td></tr><tr><td>EI_MAG2</td><td>2</td><td>1</td><td>文件标识：43</td></tr><tr><td>EI_MAG3</td><td>3</td><td>1</td><td>文件标识：46</td></tr><tr><td>EI_CLASS</td><td>4</td><td>1</td><td>文件类别：表示为32位还是64位</td></tr><tr><td>EI_DATA</td><td>5</td><td>1</td><td>编码格式：设置大端还是小端</td></tr><tr><td>EI_VERSION</td><td>6</td><td>1</td><td>文件版本：默认为1</td></tr><tr><td>EI_OSABI</td><td>7</td><td>1</td><td>OS ABI 识别标志</td></tr><tr><td>EI_ABIVERSION</td><td>8</td><td>1</td><td>ABI 版本</td></tr><tr><td>EI_PAD</td><td>9</td><td>7</td><td>补充字节开始的地址，目前未使用。应该用零填充，读取时忽略。</td></tr></tbody></table><ul><li><p><strong>EI_MAG0</strong> ~ <strong>EI_MAG3</strong>（<strong>E</strong>LF <strong>I</strong>dentification-<strong>Mag</strong>ic Number）：文件的最前面 4 字节 e_ident[EI_MAG0] ~ e_ident[EI_MAG3] 的内容被称为“魔数”，用于标识这是一个 ELF 文件。这 4 个字节存放的 16 进制数值是固定的，依次为<code>0x7f</code>，<code>0x45</code>，<code>0x4c</code>和<code>0x46</code>，后三个数值对应的 ASCII码 为 “E”，“L” 和 “F”。</p></li><li><p><strong>EI_CLASS</strong>（<strong>E</strong>LF <strong>I</strong>dentification-<strong>Class</strong>）：e_ident[EI_CLASS] 指明文件位数的标志，根据当前字节位置上的数值说明该文件是 32 位的还是 64 位的 ELF 文件。下面为可能的几个取值及其对应的含义。值为 1：32 位目标文件；值为 2：64 位目标文件。下方为源码中的定义、可取值及其对应的含义。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_CLASS4<span class="comment">/* File class byte index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASSNONE0<span class="comment">/* Invalid class */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASS321<span class="comment">/* 32-bit objects */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASS642<span class="comment">/* 64-bit objects */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASSNUM3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>EI_DATA</strong>（<strong>E</strong>LF <strong>I</strong>dentification-<strong>Data</strong>）：e_ident[EI_DATA] 指明了目标文件中的数据编码格式，指明是小端编码还是大端编码。值为 1：补码编码（2’s complement）且为小端编码（little endian）；值为 2：补码编码且为大端编码（big endian）。下方为源码中的定义、可取值及其对应的含义。</p></li></ul></li><li><p><strong>e_type</strong></p><p>标识目标文件类型，如下表所示，</p><table><thead><tr><th align="left">Name</th><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><code>ET_NONE</code></td><td align="left"><code>0x00</code></td><td align="left">No file type</td></tr><tr><td align="left"><code>ET_REL</code></td><td align="left"><code>0x01</code></td><td align="left">Relocatable file</td></tr><tr><td align="left"><code>ET_EXEC</code></td><td align="left"><code>0x02</code></td><td align="left">Executable file</td></tr><tr><td align="left"><code>ET_DYN</code></td><td align="left"><code>0x03</code></td><td align="left">Shared object file</td></tr><tr><td align="left"><code>ET_CORE</code></td><td align="left"><code>0x04</code></td><td align="left">Core file</td></tr><tr><td align="left"><code>ET_LOPROC</code></td><td align="left"><code>0xff00</code></td><td align="left">Processor-specific</td></tr><tr><td align="left"><code>ET_HIPROC</code></td><td align="left"><code>0xffff</code></td><td align="left">Processor-specific</td></tr></tbody></table></li><li><p><strong>e_machine</strong></p><p>指定单个文件所需的体系结构。相关架构如下表所示，列出了一些常用的架构,可在官方<code>wiki</code>上查表找到所有支持的架构</p><table><thead><tr><th align="left">Name</th><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><code>EM_NONE</code></td><td align="left"><code>0</code></td><td align="left">No machine</td></tr><tr><td align="left"><code>EM_SPARC</code></td><td align="left"><code>2</code></td><td align="left">SPARC</td></tr><tr><td align="left"><code>EM_386</code></td><td align="left"><code>3</code></td><td align="left">Intel 80386</td></tr><tr><td align="left"><code>EM_SPARC32PLUS</code></td><td align="left"><code>18</code></td><td align="left">Sun SPARC 32+</td></tr><tr><td align="left"><code>EM_SPARCV9</code></td><td align="left"><code>43</code></td><td align="left">SPARC V9</td></tr><tr><td align="left"><code>EM_AMD64</code></td><td align="left"><code>62</code></td><td align="left">AMD 64</td></tr><tr><td align="left"><code>EM_RISCV</code></td><td align="left"><code>0xF3</code></td><td align="left">RISC-V</td></tr></tbody></table></li><li><p><strong>e_version</strong></p><p>标识目标文件的版本，初始版本的ELF设置为1</p></li><li><p><strong>e_entry</strong></p><p>这是进程开始执行的入口点的内存地址。该字段长度为32位或64位，取决于前面定义的格式。如果文件没有关联的入口点，则该值为零。</p></li><li><p><strong>e_phoff</strong></p><p><code>Program Header</code>的文件起始地址偏移量，以字节为单位。如果文件没有程序头表，则该成员为零。</p></li><li><p><strong>e_shoff</strong></p><p>指明节头表（section header table）开始处在文件中的偏移量</p></li><li><p><strong>e_flags</strong></p><p>处理器特定的标志，一般为0。</p></li><li><p><strong>e_ehsize</strong></p><p>ELF头的大小(以字节为单位)。</p></li><li><p><strong>e_phentsize</strong></p><p><code>Program Header</code>中每个表项的大小，以字节为单位</p></li><li><p><strong>e_phnum</strong></p><p><code>Program Header</code>中总共有多少个表项，如果一个目标文件中没有程序头表，该值应设为 0</p></li><li><p><strong>e_shentsize</strong></p><p>一个段头表条目的大小。</p></li><li><p><strong>e_shnum</strong></p><p>包含段头表中条目的数量。</p></li><li><p><strong>e_shstrndx</strong></p><p>包含一个索引，指向段头表中包含段名称的段头条目。</p></li></ul><h2 id="4-Program-Header"><a href="#4-Program-Header" class="headerlink" title="4. Program Header"></a>4. Program Header</h2><p>程序头表告诉系统如何创建进程映像。它位于文件偏移量<code>e_phoff</code>处，由<code>e_phnum</code>项组成，每个项的大小<code>e_phentsize</code>。32位ELF与64位ELF的布局略有不同，因为出于对齐原因，<code>p_flags</code>位于不同的结构位置。</p><p>可用如下的命令来查看一个 ELF 文件的 <code>Program Header</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">readelf -l write</span><br></pre></td></tr></table></figure><p><img src="/2023/09/11/elf%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/image-20230911191959311.png" alt="image-20230911191959311"></p><p>可以看到该ELF文件的<code>Program Header</code>有三个表项</p><ul><li><code>Program Header</code>的定义如下</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf32_Word      p_type;</span><br><span class="line">        Elf32_Off       p_offset;</span><br><span class="line">        Elf32_Addr      p_vaddr;</span><br><span class="line">        Elf32_Addr      p_paddr;</span><br><span class="line">        Elf32_Word      p_filesz;</span><br><span class="line">        Elf32_Word      p_memsz;</span><br><span class="line">        Elf32_Word      p_flags;</span><br><span class="line">        Elf32_Word      p_align;</span><br><span class="line">&#125; Elf32_Phdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf64_Word      p_type;</span><br><span class="line">        Elf64_Word      p_flags;</span><br><span class="line">        Elf64_Off       p_offset;</span><br><span class="line">        Elf64_Addr      p_vaddr;</span><br><span class="line">        Elf64_Addr      p_paddr;</span><br><span class="line">        Elf64_Xword     p_filesz;</span><br><span class="line">        Elf64_Xword     p_memsz;</span><br><span class="line">        Elf64_Xword     p_align;</span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure><ul><li><p><code>p_type</code></p><p>定义了段的类型</p><table><thead><tr><th align="left">Name</th><th align="left">Value</th><th>Meaning</th></tr></thead><tbody><tr><td align="left"><code>PT_NULL</code></td><td align="left"><code>0</code></td><td>程序头表项未使用。</td></tr><tr><td align="left"><code>PT_LOAD</code></td><td align="left"><code>1</code></td><td>此类型表明本程序头指向一个可装载的段</td></tr><tr><td align="left"><code>PT_DYNAMIC</code></td><td align="left"><code>2</code></td><td>表明本段指明了动态连接的信息。</td></tr><tr><td align="left"><code>PT_INTERP</code></td><td align="left"><code>3</code></td><td></td></tr><tr><td align="left"><code>PT_NOTE</code></td><td align="left"><code>4</code></td><td></td></tr><tr><td align="left"><code>PT_SHLIB</code></td><td align="left"><code>5</code></td><td></td></tr><tr><td align="left"><code>PT_PHDR</code></td><td align="left"><code>6</code></td><td></td></tr><tr><td align="left"><code>PT_TLS</code></td><td align="left"><code>7</code></td><td></td></tr><tr><td align="left"><code>PT_LOOS</code></td><td align="left"><code>0x60000000</code></td><td></td></tr><tr><td align="left"><code>PT_SUNW_UNWIND</code></td><td align="left"><code>0x6464e550</code></td><td></td></tr><tr><td align="left"><code>PT_SUNW_EH_FRAME</code></td><td align="left"><code>0x6474e550</code></td><td></td></tr><tr><td align="left"><code>PT_LOSUNW</code></td><td align="left"><code>0x6ffffffa</code></td><td></td></tr><tr><td align="left"><code>PT_SUNWBSS</code></td><td align="left"><code>0x6ffffffa</code></td><td></td></tr><tr><td align="left"><code>PT_SUNWSTACK</code></td><td align="left"><code>0x6ffffffb</code></td><td></td></tr><tr><td align="left"><code>PT_SUNWDTRACE</code></td><td align="left"><code>0x6ffffffc</code></td><td></td></tr><tr><td align="left"><code>PT_SUNWCAP</code></td><td align="left"><code>0x6ffffffd</code></td><td></td></tr><tr><td align="left"><code>PT_HISUNW</code></td><td align="left"><code>0x6fffffff</code></td><td></td></tr><tr><td align="left"><code>PT_HIOS</code></td><td align="left"><code>0x6fffffff</code></td><td></td></tr><tr><td align="left"><code>PT_LOPROC</code></td><td align="left"><code>0x70000000</code></td><td></td></tr><tr><td align="left"><code>PT_HIPROC</code></td><td align="left"><code>0x7fffffff</code></td><td></td></tr></tbody></table></li><li><p><code>p_offset</code>（<strong>P</strong>rogram Header-File <strong>Offset</strong>）：此字段（8 字节）给出本段内容在文件中的位置，即段内容的开始位置相对于文件开头的偏移量。</p></li><li><p><code>p_vaddr</code>（<strong>P</strong>rogram Header-<strong>V</strong>irtual <strong>Addr</strong>ess）：此字段（8 字节）给出本段内容的开始位置在进程空间中的虚拟地址。</p></li><li><p><code>p_paddr</code>（<strong>P</strong>rogram Header-<strong>P</strong>hysical <strong>Addr</strong>ess）：此字段（8 字节）给出本段内容的开始位置在进程空间中的物理地址。对于目前大多数现代操作系统而言，应用程序中段的物理地址事先是不可知的，所以目前这个 成员多数情况下保留不用，或者被操作系统改作它用。</p></li><li><p><code>p_filesz</code>（<strong>P</strong>rogram Header-<strong>File</strong> <strong>S</strong>i<strong>z</strong>e）：此字段（8 字节）给出本段内容在文件中的大小，单位是字节，可以是 0。</p></li><li><p><code>p_memsz</code>（<strong>P</strong>rogram Header-<strong>Mem</strong>ory <strong>S</strong>i<strong>z</strong>e）：此字段（8 字节）给出本段内容在内容镜像中的大小，单位是字节，可以是 0。</p></li><li><p><code>p_align</code>（<strong>P</strong>rogram Header-<strong>Align</strong>ment ）：此字段（8 字节）指明本段内容如何在内存和文件中对齐。如果该值为 0 或 1，表明没有对齐要求；否则，p_align 应该是一个正整数，并且是 2 的幂次数。p_vaddr 和 p_offset 在对 p_align 取模后应该相等。注：对于可装载的段来说，其 p_vaddr 和 p_offset 的值至少要向内存页面大小对齐。</p></li><li><p><code>p_flags</code>（<strong>P</strong>rogram Header-<strong>Flags</strong>）：此字段（4 字节）给出本段内容的属性，指明了段的权限。虽然 ELF 文件格式中没有规定，但是一个可执行程序至少会有一个可加载的段。当为可加载段创建内存镜像时，系统会按照 p_flags 的指示给段赋予一定的权限。</p><table><thead><tr><th align="left">Name</th><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><code>PF_X</code></td><td align="left"><code>0x1</code></td><td align="left">Execute</td></tr><tr><td align="left"><code>PF_W</code></td><td align="left"><code>0x2</code></td><td align="left">Write</td></tr><tr><td align="left"><code>PF_R</code></td><td align="left"><code>0x4</code></td><td align="left">Read</td></tr><tr><td align="left"><code>PF_MASKPROC</code></td><td align="left"><code>0xf0000000</code></td><td align="left">Unspecified</td></tr></tbody></table></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">可执行和可链接格式 - 维基百科 (wikipedia.org)</a></p></li><li><p><a href="http://www.skyfree.org/linux/references/ELF_Format.pdf">ELF_Format.pdf (skyfree.org)</a></p></li><li><p><a href="https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-43405.html#scrolltoc">ELF Header - Linker and Libraries Guide (oracle.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/380908650">ELF 文件解析 1-前述+文件头分析 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-83432.html#scrolltoc">Program Header - Linker and Libraries Guide (oracle.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> riscv </tag>
            
            <tag> ELF </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用程序的装载</title>
      <link href="/2023/09/10/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E8%BD%BD/"/>
      <url>/2023/09/10/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="1-分离应用程序"><a href="#1-分离应用程序" class="headerlink" title="1. 分离应用程序"></a>1. 分离应用程序</h2><p>之前我们U模式下的应用程序是写在<code>app.c</code>中的，是和内核一起编译打包的，但是内核和应用程序都需要开启虚拟地址，而这两者的映射状态是不同的，类比于<code>linux windows</code>这种操作系统都是操作系统来将程序加载到内存来运行，因此我们需要将内核和应用程序隔离开来。</p><p>在<code>os</code>目录下新建<code>user</code>文件夹，在此文件夹下的文件组成如下：</p><p><img src="/2023/09/10/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E8%BD%BD/image-20230910191105860.png" alt="image-20230910191105860"></p><p><code>time.c</code>和<code>write.c</code>是两个应用该程序，<code>Makefile</code>用于编译，<code>user.ld</code>是链接脚本，在开启虚拟地址后，用户程序就可使用同一个链接文件了，因为即使被链接到同一个虚拟地址，也会映射到不同的物理地址。<code>bin</code>目录是编译生成的可执行文件，是<code>elf</code>格式的。</p><p>我把<code>lib</code>目录下的<code>stack.c</code>移动到了<code>src</code>目录下</p><ul><li><code>write.c</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/os.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/stdio.h&gt;</span></span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a0 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a0&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg1);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a1 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a1&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg2);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a2 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a2&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg3);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a7 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a7&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ecall&quot;</span></span></span><br><span class="line"><span class="params">      : <span class="string">&quot;+r&quot;</span> (a0)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;r&quot;</span> (a1), <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a7)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> a0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_write,fd,buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task1 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>time.c</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a0 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a0&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg1);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a1 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a1&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg2);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a2 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a2&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg3);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a7 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a7&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ecall&quot;</span></span></span><br><span class="line"><span class="params">      : <span class="string">&quot;+r&quot;</span> (a0)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;r&quot;</span> (a1), <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a7)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> a0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">sys_gettime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_gettimeofday,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> current_timer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       current_timer = sys_gettime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分离了两个应用程序</p><ul><li><code>Makefile</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE = riscv64-unknown-elf-</span><br><span class="line">CFLAGS = -nostdlib -fno-builtin </span><br><span class="line"></span><br><span class="line">CC = $&#123;CROSS_COMPILE&#125;gcc</span><br><span class="line">OBJCOPY = $&#123;CROSS_COMPILE&#125;objcopy</span><br><span class="line">OBJDUMP = $&#123;CROSS_COMPILE&#125;objdump</span><br><span class="line">INCLUDE:=-I../include</span><br><span class="line"></span><br><span class="line">LIB = ../lib</span><br><span class="line"></span><br><span class="line">write: write.c $(LIB)<span class="comment">/*.c</span></span><br><span class="line"><span class="comment">$&#123;CC&#125; $&#123;CFLAGS&#125; $(INCLUDE) -T user.ld -Wl,-Map=write.map -o bin/write $^</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">time: time.c </span></span><br><span class="line"><span class="comment">$&#123;CC&#125; $&#123;CFLAGS&#125; $(INCLUDE) -T user.ld -Wl,-Map=time.map -o bin/time $^</span></span><br></pre></td></tr></table></figure><ul><li><code>user.ld</code>：在链接脚本中将程序的入口地址指明为<code>main</code>函数，链接地址为<code>0x10000</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(main)</span><br><span class="line">BASE_ADDRESS = 0x10000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">    &#125;</span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">        *(.debug*)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-装载应用程序"><a href="#2-装载应用程序" class="headerlink" title="2. 装载应用程序"></a>2. 装载应用程序</h2><p>在<code>rCore</code>中，在编译os之前，它是使用了一个<code>build.rs</code>来生成了一段汇编代码，这段汇编代码会嵌入到内核中，用于指示APP的个数和夹杂APP的二进制文件到内存中。我将这个<code>build.rs</code>改成了c语言的实现，在os目录下新建一个<code>build.c</code></p><p>代码逻辑就是遍历<code>user/bin</code>目录下的文件个数，然后记录用户程序数量，生成<code>link_app.S</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TARGET_PATH <span class="string">&quot;../user/bin/&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare_strings</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(*(<span class="type">const</span> <span class="type">char</span>**)a, *(<span class="type">const</span> <span class="type">char</span>**)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_app_data</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    FILE* f = fopen(<span class="string">&quot;src/link_app.S&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* apps[<span class="number">100</span>]; <span class="comment">// Assuming a maximum of 100 apps</span></span><br><span class="line">    <span class="type">int</span> app_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the directory and collect app names</span></span><br><span class="line">    DIR* dir = opendir(<span class="string">&quot;./user/bin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open directory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">dir_entry</span>;</span></span><br><span class="line">    <span class="keyword">while</span> ((dir_entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* name_with_ext = dir_entry-&gt;d_name;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排除掉 . 和 .. 条目</span></span><br><span class="line">        <span class="keyword">if</span> (name_with_ext[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; (name_with_ext[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span> || (name_with_ext[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; name_with_ext[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span>))) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// Skip this entry</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(name_with_ext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove file extension by replacing the dot with a null terminator  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name_with_ext[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                name_with_ext[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// strdup 函数用于创建一个字符串的副本，并返回指向新字符串的指针。</span></span><br><span class="line">        apps[app_count] = strdup(name_with_ext);</span><br><span class="line">        app_count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;File name: %s, app_count: %d\n&quot;</span>, name_with_ext, app_count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    closedir(dir);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对 app name 排序</span></span><br><span class="line">    qsort(apps, app_count, <span class="keyword">sizeof</span>(<span class="type">char</span>*), compare_strings);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;\n.align 3\n.section .data\n.global _num_app\n_num_app:\n.quad %d&quot;</span>, app_count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; app_count; i++) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(f, <span class="string">&quot;\n.quad app_%d_start&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;\n.quad app_%d_end&quot;</span>, app_count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; app_count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;app_%d: %s\n&quot;</span>, i, apps[i]);</span><br><span class="line">        <span class="built_in">fprintf</span>(f, <span class="string">&quot;\n.section .data\n.global app_%d_start\n.global app_%d_end\n.align 3\napp_%d_start:\n.incbin \&quot;%s%s\&quot;\napp_%d_end:&quot;</span>, i, i, i, TARGET_PATH, apps[i], i);</span><br><span class="line">        <span class="built_in">free</span>(apps[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    insert_app_data();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在os的<code>Makefile</code>中添加对<code>build.c</code>的编译：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">build_app: build.c</span><br><span class="line">gcc $&lt; -o build.out</span><br></pre></td></tr></table></figure><p>然后在编译内核代码之前需要先编译此代码，然后执行生成<code>link_app.S</code>，<code>link_app.S</code>会被放在<code>src</code>目录下。</p><p>然后修改一下<code>build.sh</code>：先编译执行<code>build.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 编译os</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">&quot;$SHELL_FOLDER/output/os&quot;</span> ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/os</span><br><span class="line">fi</span><br><span class="line">cd $SHELL_FOLDER/os</span><br><span class="line"># 编译app加载模块</span><br><span class="line">make build_app</span><br><span class="line">./build.out</span><br><span class="line"># 编译os</span><br><span class="line">make</span><br><span class="line">cp $SHELL_FOLDER/os/os.bin $SHELL_FOLDER/output/os/os.bin</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>运行<code>build.sh</code>，就可以看见在<code>src</code>目录下生成了<code>link_app.S</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 2</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_1_end</span><br><span class="line">    </span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">    .align 3</span><br><span class="line">app_0_start:</span><br><span class="line">.incbin &quot;../user/bin/time&quot;</span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br><span class="line">    .align 3</span><br><span class="line">app_1_start:</span><br><span class="line">.incbin &quot;../user/bin/write&quot;</span><br><span class="line">app_1_end:</span><br></pre></td></tr></table></figure><p>可以看见总共有两个用户程序，用户程序开始的地方是两个标号：<code>app_0_start，app_1_start</code>，<code>.incbin</code>伪指令的功能是包含可执行文件、文字或其他任意数据。 文件的内容将按字节逐一添加到当前 ELF 节中，而不进行任何方式的解释。简单来说就是加载二进制数据到内存中，之后我们就可以去访问此段内存的数据了，并将其解析出来。<code>.quad</code>的功能是声明一个64位的数据。</p><p>接下里来读取这些信息，在<code>include</code>目录下新建一个<code>loader.h</code>的文件，<code>src</code>目录下新建<code>loader.c</code></p><ul><li><code>loader.h</code>：定义了一个描述app数据的结构体</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TOS_LOADER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOS_LOADER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这个结构用于存储应用程序元数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> start;</span><br><span class="line">    <span class="type">uint64_t</span> size;</span><br><span class="line">&#125; AppMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取加载的app数量</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_num_app</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取app的数据</span></span><br><span class="line">AppMetadata  <span class="title function_">get_app_data</span><span class="params">(<span class="type">size_t</span> app_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>loader.c</code>：<code>_num_app</code>由于在汇编中进行了声明，在c语言中可以将其看作一个数组，数组大小是4，<code>_num_app[0]</code>的值就是2。<code>app</code>数据的起始地址也放在了<code>_num_app</code>数组中，根据传入的 <code>app_id</code>进行索引，由于app的数据是挨着放置的，所以app数据的大小可用下一个app的起始地址减去当前app的起始地址。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/loader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u64 _num_app[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取加载的app数量</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_num_app</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _num_app[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AppMetadata  <span class="title function_">get_app_data</span><span class="params">(<span class="type">size_t</span> app_id)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AppMetadata metadata;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> num_app = get_num_app();</span><br><span class="line"></span><br><span class="line">    metadata.start = _num_app[app_id];  <span class="comment">// 获取app起始地址</span></span><br><span class="line">    metadata.size = _num_app[app_id+<span class="number">1</span>] - _num_app[app_id];    <span class="comment">// 获取app数据长度</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;app start:%x , app end: %x\n&quot;</span>,metadata.start,metadata.size);</span><br><span class="line">    </span><br><span class="line">    assert(app_id &lt;= num_app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>首先在<code>user</code>目录下编译生成用户程序：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make time</span><br><span class="line">make write</span><br></pre></td></tr></table></figure><p>在main函数中打印一下app的数量：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   printk(<span class="string">&quot;hello timer os!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 内存分配器初始化</span></span><br><span class="line">   frame_alloctor_init();</span><br><span class="line">   </span><br><span class="line">   printk(<span class="string">&quot;num app:%d\n&quot;</span>,get_num_app());</span><br><span class="line">   <span class="comment">//初始化内存</span></span><br><span class="line">   kvminit();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//映射内核</span></span><br><span class="line">   kvminithart();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//trap初始化</span></span><br><span class="line">   trap_init();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// task_init();</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// timer_init();</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// run_first_task();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/09/10/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E8%BD%BD/image-20230911110419592.png" alt="image-20230911110419592"></p><p>确保没问题，下一节就来解析用户程序的数据，用户程序都是<code>elf</code>格式的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/3batch-system.html">实现批处理操作系统 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启mmu实现虚实地址映射</title>
      <link href="/2023/09/06/%E5%BC%80%E5%90%AFmmu%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/"/>
      <url>/2023/09/06/%E5%BC%80%E5%90%AFmmu%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-内存映射代码修改"><a href="#1-内存映射代码修改" class="headerlink" title="1. 内存映射代码修改"></a>1. 内存映射代码修改</h2><p>在<a href="https://yanglianoo.github.io/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/">实现timeros的内存映射机制 | TimerのBlog (yanglianoo.github.io)</a>这篇博客中我们已经实现了虚拟地址到物理地址映射的函数，但是我在实际调试中发现了一些bug，这里做一些修改。</p><p>在<code>find_pte_create</code>函数中：有两处修改</p><p><img src="/2023/09/06/%E5%BC%80%E5%90%AFmmu%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/image-20230906112031781.png" alt="image-20230906112031781"></p><ul><li><p>首先是<code>size_t idx[3]</code>，这里<code>idx</code>应该定义成数组，之前定义的是一个指针是错误的，这是我的小失误</p></li><li><p>然后是不需要对<code>frame</code>的压栈操作，修改了<code>pte</code>的结构定义，不要栈来保存<code>frame</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义页表项 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> bits;</span><br><span class="line">&#125;PageTableEntry;</span><br></pre></td></tr></table></figure></li></ul><p>然后是<code>PageTable_map</code>函数的修改：新增了一个参数用于传递需要映射的内存长度，将从<code>va</code>开始的<code>size</code>大小的内存全部映射了，这里参考了<code>xv6-riscv</code>的映射实现。先计算需要映射多少页的内存，然后一页一页映射。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PageTable_map</span><span class="params">(PageTable* pt,VirtAddr va, PhysAddr pa, u64 size ,<span class="type">uint8_t</span> pteflgs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    PhysPageNum ppn = floor_phys(pa);</span><br><span class="line">    VirtPageNum vpn = floor_virts(va);</span><br><span class="line">    u64 last = (va.value + size - <span class="number">1</span>) / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        PageTableEntry* pte = find_pte_create(pt,vpn);</span><br><span class="line">        assert(!PageTableEntry_is_valid(pte));</span><br><span class="line">        *pte = PageTableEntry_new(ppn,PTE_V | pteflgs);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>( vpn.value == last )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一页一页映射</span></span><br><span class="line">        vpn.value+=<span class="number">1</span>;</span><br><span class="line">        ppn.value+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-内存初始化"><a href="#2-内存初始化" class="headerlink" title="2. 内存初始化"></a>2. 内存初始化</h2><p>在开启虚拟地址之前，我们先来看一下现在内核的地址结构：</p><p><img src="/2023/09/06/%E5%BC%80%E5%90%AFmmu%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).png" alt="未命名文件 (1)"></p><p>内核的起始地址是<code>KERNBASE</code>，内核的代码被编译器编译后是由代码段和数据段组成的，可以在<code>os.map</code>中看见各段的地址空间，代码段结束的地址设定为<code>etext</code>，数据段结束的地址设定为<code>kernelend</code>。然后指定从内核结束后向上128M的空间为空闲内存，可以给应用使用的。至于为什么<code>etext</code>和<code>kernelend</code>是上图那两个地址，我们来看一下<code>os.ld</code>文件，我做了一些修改：</p><p><img src="/2023/09/06/%E5%BC%80%E5%90%AFmmu%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/image-20230906121349431.png" alt="image-20230906121349431"></p><p>在链接脚本中，指定了代码段结束地址按页对齐，这是为了后续映射操作的方便性，因为我们映射的时候是按页进行映射的。</p><p>然后定义了两个符号：<code>PROVIDE(etext = .);</code>，<code>PROVIDE(kernelend = .);</code>，<code>etext</code>就代表了内核代码段结束的地址，<code>kernelend</code>就代表了内核结束的地址。这两个地址可以在<code>os.map</code>中找到，定义好符号后就可以用c语言去拿到值了</p><p><img src="/2023/09/06/%E5%BC%80%E5%90%AFmmu%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/image-20230906121710788.png" alt="image-20230906121710788"></p><p><img src="/2023/09/06/%E5%BC%80%E5%90%AFmmu%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/image-20230906121735482.png" alt="image-20230906121735482"></p><p>在了解完毕内存分布之后，我们就可以来初始化内存了，我们可用的内存是从<code>kernelend</code>开始到<code>PHYSTOP</code>结束之间的大小，内核占据的代码段和数据段是不允许的，在<code>address.c</code>中来初始化可用内存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">StackFrameAllocator FrameAllocatorImpl;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> kernelend[];</span><br><span class="line"><span class="type">void</span> <span class="title function_">frame_alloctor_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化时 kernelend 需向上取整</span></span><br><span class="line">    StackFrameAllocator_new(&amp;FrameAllocatorImpl);</span><br><span class="line">    StackFrameAllocator_init(&amp;FrameAllocatorImpl, \</span><br><span class="line">            ceil_phys(<span class="type">phys_addr_from_size_t</span>(kernelend)), \</span><br><span class="line">            ceil_phys(<span class="type">phys_addr_from_size_t</span>(PHYSTOP)));</span><br><span class="line">    printk(<span class="string">&quot;Memoery start:%p\n&quot;</span>,kernelend);</span><br><span class="line">    printk(<span class="string">&quot;Memoery end:%p\n&quot;</span>,PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<code>kernelend</code>需要向上取整来对齐到<code>0x80250000</code></p><h2 id="3-内存映射"><a href="#3-内存映射" class="headerlink" title="3. 内存映射"></a>3. 内存映射</h2><p>我们采用的内存映射方式为恒等映射，就是虚拟地址映射后的物理地址是相同的，这样在启用<code>mmu</code>后，原先的代码执行逻辑不变。在<code>address</code>中来进行恒等内存映射：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext[];</span><br><span class="line">PageTable <span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PageTable pt;</span><br><span class="line">    PhysPageNum root_ppn =  StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">    pt.root_ppn = root_ppn;</span><br><span class="line">    printk(<span class="string">&quot;root_ppn:%p\n&quot;</span>,phys_addr_from_phys_page_num(root_ppn));</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;etext:%p\n&quot;</span>,(u64)etext);</span><br><span class="line">    <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">    PageTable_map(&amp;pt,<span class="type">virt_addr_from_size_t</span>(KERNBASE),<span class="type">phys_addr_from_size_t</span>(KERNBASE), \</span><br><span class="line">                    (u64)etext-KERNBASE , PTE_R | PTE_X ) ;</span><br><span class="line">    printk(<span class="string">&quot;finish kernel text map!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of. </span></span><br><span class="line">    PageTable_map(&amp;pt,<span class="type">virt_addr_from_size_t</span>((u64)etext),<span class="type">phys_addr_from_size_t</span>((u64)etext ), \</span><br><span class="line">                    PHYSTOP - (u64)etext , PTE_R | PTE_W ) ;</span><br><span class="line">    printk(<span class="string">&quot;finish kernel data and physical RAM map!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line">PageTable kernel_pagetable;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先建立一个根页表，从空闲内存中拿出一页，然后映射内核代码段，再映射数据段，代码段的属性是可执行可读的，数据段的属性是可读可写的，且U模式不可访问。由于我们现在是将U模式的应用和内核代码一起打包了，所以肯定U模式下的代码肯定是执行不了的，需要后面实现一个读取应用的模块来加载app。</p><p>映射完成后的内存长这样子：</p><p><img src="/2023/09/06/%E5%BC%80%E5%90%AFmmu%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(2).png" alt="未命名文件 (2)"></p><p>然后是内核的映射表建立：内核的代码段只占两页内存： <code>0x80200000</code>,<code>0x80201000</code>，内核根页表放在<code>0x8025000</code>即空闲内存开始的第一页。虚拟地址<code>0x80200000</code>的三级页号的索引为 2 1 0，<code>0x80201000</code>的三级页号的索引为 2 1 1,通过下图的三次查表就对应上了具体的物理内存，要想彻底理解，还是自己手推一下映射关系。</p><p><img src="/2023/09/06/%E5%BC%80%E5%90%AFmmu%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(3).png" alt="未命名文件 (3)"></p><h2 id="4-开启Sv39分页模式"><a href="#4-开启Sv39分页模式" class="headerlink" title="4. 开启Sv39分页模式"></a>4. 开启Sv39分页模式</h2><p>要开启Sv39的分页模式，只需要去写<code>satp</code>的值就行了：设置为<code>Sv39</code>分页模式，然后将<code>root_ppn</code>的值写入。这里有一个刷新TLB的操作。</p><p><strong>快表</strong> (TLB, Translation Lookaside Buffer) ， 它维护了部分虚拟页号到页表项的键值对。当 MMU 进行地址转换的时候，首先会到快表中看看是否匹配，如果匹配的话直接取出页表项完成地址转换而无需访存；否则再去查页表并将键值对保存在快表中。一旦我们修改 satp 就会切换地址空间，快表中的键值对就会失效（因为快表保存着老地址空间的映射关系，切换到新地址空间后，老的映射关系就没用了）。为了确保 MMU 的地址转换能够及时与 satp 的修改同步，我们需要立即使用 <code>sfence.vma</code> 指令将快表清空，这样 MMU 就不会看到快表中已经过期的键值对了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_SV39 (8L &lt;&lt; 60)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((u64)pagetable)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable.root_ppn.value));</span><br><span class="line">  <span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">  <span class="type">reg_t</span> satp = r_satp();</span><br><span class="line">  printk(<span class="string">&quot;satp:%lx\n&quot;</span>,satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sfence_vma</code>和<code>w_satp</code>这两个函数定义在<code>riscv.h</code>中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// supervisor address translation and protection;</span></span><br><span class="line"><span class="comment">// holds the address of the page table.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_satp</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw satp, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_satp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, satp&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新 TLB.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sfence_vma</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// the zero, zero means flush all TLB entries.</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sfence.vma zero, zero&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果内存正确映射的话，我们就可以看见打印<code>satp</code>寄存器的值了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h2><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">frame_alloctor_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">kvminit</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">kvminithart</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   printk(<span class="string">&quot;hello timer os!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 内存分配器初始化</span></span><br><span class="line">   frame_alloctor_init();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//初始化内存</span></span><br><span class="line">   kvminit();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//映射内核</span></span><br><span class="line">   kvminithart();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//trap初始化</span></span><br><span class="line">   trap_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// task_init();</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// timer_init();</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// run_first_task();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行脚本测试：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./build.sh</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure><p><img src="/2023/09/06/%E5%BC%80%E5%90%AFmmu%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/image-20230906131256055.png" alt="image-20230906131256055"></p><p>可以看见成功开启分页模式！！！！！</p>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启调试功能</title>
      <link href="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="1-bug修改"><a href="#1-bug修改" class="headerlink" title="1. bug修改"></a>1. bug修改</h1><p> 之前的代码中留下了一个<code>bug</code>，在<code>app.c</code>中，通过<code>sys_gettime</code>的系统调用来获取时间，这里是有问题的，从内核返回的值不知道为啥不对，问题出在<code>syscall</code>函数上，以前的写法是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">uintptr_t</span> arg1, <span class="type">uintptr_t</span> arg2, <span class="type">uintptr_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// Move syscall id to a0 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// Move args[0] to a1 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// Move args[1] to a2 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// Move args[2] to a3 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// Perform syscall</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// Move return value to &#x27;ret&#x27; variable</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道为啥这样写就有问题，好像这个<code>ret</code>定义了就会导致返回的值不对，从内核返回的值是放在<code>a0</code>寄存器中，把上面的代码替换了一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a0 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a0&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg1);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a1 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a1&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg2);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a2 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a2&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg3);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a7 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a7&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ecall&quot;</span></span></span><br><span class="line"><span class="params">      : <span class="string">&quot;+r&quot;</span> (a0)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;r&quot;</span> (a1), <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a7)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样内核的返回值就没问题了，来测试一下<code>sys_gettime()</code>系统调用，在<code>task3</code>中调用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task3 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> current_timer = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> wait_for = current_timer + <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       current_timer = sys_gettime();</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;current_timer:%d\n&quot;</span>,current_timer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/GIFtime.gif" alt="GIFtime"></p><p>时间打印成功，由于定时中断的分频系数被修改成了500，所以这里是以2us为单位返回时间。</p><h1 id="2-开启调试功能"><a href="#2-开启调试功能" class="headerlink" title="2.开启调试功能"></a>2.开启调试功能</h1><p>之前在调试内核的时候，我一直没使用gdb去调试程序，因为代码不算困难，我用printf去打印调试也花费不了太多时间，最近在倒腾mmu，我觉得有必要用gdb去调试了，再vscode中调试是非常方便的，当然也可以直接在终端中调试。</p><h2 id="2-1-终端使用GDB调试"><a href="#2-1-终端使用GDB调试" class="headerlink" title="2.1 终端使用GDB调试"></a>2.1 终端使用GDB调试</h2><p>在os的makefile中添加调试选项：</p><ul><li>编译时需要生成调试信息，添加 <code>-g</code>的编译选项</li></ul><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = -nostdlib -fno-builtin -mcmodel=medany -g</span><br></pre></td></tr></table></figure><ul><li>指定调试器，这里的调试器需要使用riscv编译工具链中提供的<code>riscv64-unknown-elf-gdb</code>，当然还有一个<code>gdb-multiarch</code>也是可以的，但是联合vscode时不知道为啥不能检测寄存器的值</li></ul><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">GDB = riscv64-unknown-elf-gdb</span><br></pre></td></tr></table></figure><ul><li>配置调试选项，新建一个<code>gdbinit</code>文件，<code>gdb</code>调试qemu程序时，需要将端口映射到<code>1234</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> disassemble-next-line on</span><br><span class="line">b _start</span><br><span class="line">target remote : <span class="number">1234</span></span><br><span class="line">c</span><br></pre></td></tr></table></figure><ul><li>修改<code>run.sh</code>，添加如下选项就可启动调试了，此时<code>qemu</code>会作为<code>gdb</code>的服务端，端口号为<code>1234</code></li></ul><p><img src="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/image-20230904195304055.png" alt="image-20230904195304055"></p><ul><li>开启调试，这样make clean时不会删除<code>os.elf</code>文件，在启动qemu后就可通过<code>make debug</code>来开启调试了</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.PHONY : debug</span><br><span class="line">debug: </span><br><span class="line">@echo <span class="string">&quot;os debug start...&quot;</span></span><br><span class="line">@$&#123;GDB&#125; os.elf -q -x ./gdbinit</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean:</span><br><span class="line">rm -rf *.o *.bin </span><br></pre></td></tr></table></figure><p><img src="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/image-20230904195427526.png" alt="image-20230904195427526"></p><p>这样就可以在终端中调试了。</p><h2 id="2-2-GDB-Vscode调试"><a href="#2-2-GDB-Vscode调试" class="headerlink" title="2.2 GDB+Vscode调试"></a>2.2 GDB+Vscode调试</h2><p>新建<code>.vscode</code>文件夹，在此文件夹中新建两个文件</p><p><img src="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/image-20230904195603498.png" alt="image-20230904195603498"></p><ul><li><code>launch.json</code>，需要将调试器指定为<code>riscv64-unknown-elf-gdb</code>，需要指定为你自己电脑上的编译工具链的gdb的位置，然后调试的<code>program</code>指定为：<code>os.elf</code></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;timeros - Build and debug kernel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/os/os.elf&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/os/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build  timeros&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/timer/riscv/riscv64-elf/bin/riscv64-unknown-elf-gdb&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>task.json</code>就是用来运行<code>build.sh</code></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build  timeros&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build.sh &quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Task generated by Debugger.&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>launch.json</code>设置官方文档：<a href="https://code.visualstudio.com/docs/cpp/launch-json-reference">Configure launch.json for C&#x2F;C++ debugging in Visual Studio Code</a></p><p><code>tasks.json</code>设置官方文档：<a href="https://code.visualstudio.com/Docs/editor/tasks">Tasks in Visual Studio Code</a></p><blockquote><p><code>launch.json</code>文件是VSCode<strong>启动程序</strong>的配置文件，<code>task.json</code>就是用于定义前置任务。若在<code>launch.json</code>中指定了<code>preLaunchTask</code>参数，则会去执行<code>task.json</code>中指定的命令。</p><ul><li><code>$&#123;workspaceFolder&#125;</code>：项目文件夹在 VS Code 中打开的路径</li><li><code>$&#123;file&#125;</code>：当前开打开（激活）的文件</li><li><code>$&#123;relativeFile&#125;</code>：相对于 <code>&#123;workspaceFolder&#125;</code> 的文件路径</li><li><code>$&#123;fileBasename&#125;</code>：当前打开文件的名称</li><li><code>$&#123;fileBasenameNoExtension&#125;</code>：当前打开文件的名称，不带扩展名的</li><li><code>$&#123;fileExtname&#125;</code>：当前打开文件的扩展名</li><li><code>$&#123;fileDirname&#125;</code>：当前打开文件的文件夹名称</li></ul></blockquote><p><img src="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/image-20230904200407996.png" alt="image-20230904200407996"></p><p>这样就可以在<code>vscode</code>中调试内核了</p>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现timeros的内存映射机制</title>
      <link href="/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-页表操作"><a href="#1-页表操作" class="headerlink" title="1. 页表操作"></a>1. 页表操作</h1><h2 id="1-1-页表项定义"><a href="#1-1-页表项定义" class="headerlink" title="1.1 页表项定义"></a>1.1 页表项定义</h2><p>在上一篇博客中：<a href="https://yanglianoo.github.io/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">用户态printf以及物理内存管理 | TimerのBlog (yanglianoo.github.io)</a>已经展示了页表项的组成：</p><p><img src="/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/image-20230831125451059.png" alt="image-20230831125451059"></p><p><strong>页表项</strong> (PTE, Page Table Entry)是一个<code>64bit</code>的数据，其中低10位存储的是下级物理页的属性的标志位；<code>10~54</code>这44位存储的是下级页表的物理页号。</p><p>具体定义如下：在address.h中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义页表项 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> bits;</span><br><span class="line">&#125;PageTableEntry;</span><br></pre></td></tr></table></figure><p>然后定义标志位：定义在address.h中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义位掩码常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1 &lt;&lt; 0)   <span class="comment">//有效位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1 &lt;&lt; 1)   <span class="comment">//可读属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1 &lt;&lt; 2)   <span class="comment">//可写属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1 &lt;&lt; 3)   <span class="comment">//可执行属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1 &lt;&lt; 4)   <span class="comment">//用户访问模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_G (1 &lt;&lt; 5)   <span class="comment">//全局映射</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1 &lt;&lt; 6)   <span class="comment">//访问标志位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_D (1 &lt;&lt; 7)   <span class="comment">//脏位</span></span></span><br></pre></td></tr></table></figure><p>然后定义一些操作<code>PTE</code>的函数：在address.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 新建一个页表项 */</span></span><br><span class="line">PageTableEntry <span class="title function_">PageTableEntry_new</span><span class="params">(PhysPageNum ppn, <span class="type">uint8_t</span> PTEFlags)</span> &#123;</span><br><span class="line">    PageTableEntry entry;</span><br><span class="line">    entry.bits = (ppn.value &lt;&lt; <span class="number">10</span>) | PTEFlags;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断页表项是否为空 */</span></span><br><span class="line">PageTableEntry <span class="title function_">PageTableEntry_empty</span><span class="params">()</span> &#123;</span><br><span class="line">    PageTableEntry entry;</span><br><span class="line">    entry.bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取下级页表的物理页号 */</span></span><br><span class="line">PhysPageNum <span class="title function_">PageTableEntry_ppn</span><span class="params">(PageTableEntry *entry)</span> &#123;</span><br><span class="line">    PhysPageNum ppn;</span><br><span class="line">    ppn.value = (entry-&gt;bits &gt;&gt; <span class="number">10</span>) &amp; ((<span class="number">1ul</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ppn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取页表项的标志位 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">PageTableEntry_flags</span><span class="params">(PageTableEntry *entry)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> entry-&gt;bits &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断页表项是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PageTableEntry_is_valid</span><span class="params">(PageTableEntry *entry)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> entryFlags = PageTableEntry_flags(entry);</span><br><span class="line">    <span class="keyword">return</span> (entryFlags &amp; PTE_V) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-构造物理页帧的访问方法"><a href="#1-2-构造物理页帧的访问方法" class="headerlink" title="1.2 构造物理页帧的访问方法"></a>1.2 构造物理页帧的访问方法</h2><p>假设我现在已经根据PTE拿到了物理页号，我要去访问此物理页号对应的物理帧的内存数据，因此需要定义了两个个辅助函数：</p><ul><li>首先是以一个字节作为单位访问数据，拿到物理页号之后转换为对应的物理地址，得到的物理地址是此物理帧的开头，将其转换为一个<code>uint8_t*</code>类型的指针，这样根据此指针就可操作这一页的4096个字节了</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span>* <span class="title function_">get_bytes_array</span><span class="params">(PhysPageNum ppn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先从物理页号转换为物理地址</span></span><br><span class="line">    PhysAddr addr = phys_addr_from_phys_page_num(ppn);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>*) addr.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后假设物理页帧中存储的是一个个PTE，我现在需要去访问这一个个PTE。同样需要先拿到物理页号之后转换为对应的物理地址，然后将其转换为<code>PageTableEntry*</code>的指针就可以了</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PageTableEntry* <span class="title function_">get_pte_array</span><span class="params">(PhysPageNum ppn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先从物理页号转换为物理地址</span></span><br><span class="line">    PhysAddr addr = phys_addr_from_phys_page_num(ppn);</span><br><span class="line">    <span class="keyword">return</span> (PageTableEntry*) addr.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-虚实地址映射"><a href="#2-虚实地址映射" class="headerlink" title="2.虚实地址映射"></a>2.虚实地址映射</h1><h2 id="2-1-rCore的内存映射实现"><a href="#2-1-rCore的内存映射实现" class="headerlink" title="2.1 rCore的内存映射实现"></a>2.1 rCore的内存映射实现</h2><p><img src="/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/sv39-full.png" alt="../_images/sv39-full.png"></p><p>MMU在寻址时的流程如上图，先要拿到<code>Virtual address</code>的三级页号索引，定义如下的辅助函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 拿到虚拟页号的三级索引，按照从高到低的顺序返回 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">indexes</span><span class="params">(VirtPageNum vpn, <span class="type">size_t</span>* result)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> idx[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        idx[i] = vpn.value &amp; <span class="number">0x1ff</span>;   <span class="comment">// 1_1111_1111 = 0x1ff</span></span><br><span class="line">        vpn.value &gt;&gt;= <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        result[i] = idx[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要根据拿到的虚拟地址的三级页号索引来查找页表项，当然在最开始的时候多级页表的页表项里是没有数据的，这就需要我们去进行填充。</p><p>在这之前需要定义一个管理页表的结构体：每个应用的地址空间都对应一个不同的多级页表，这也就意味这不同页表的起始地址（即页表根节点的地址）是不一样的。因此 <code>PageTable</code> 要保存它根节点的物理页号 <code>root_ppn</code> 作为页表唯一的区分标志。此外，向量 <code>frames</code>保存了页表所有的节点（包括根节点）所在的物理页帧。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义页表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PhysPageNum root_ppn; <span class="comment">//根节点</span></span><br><span class="line">    Stack frames;         <span class="comment">//页帧</span></span><br><span class="line">&#125;PageTable;</span><br></pre></td></tr></table></figure><p>然后在来看查找页表项，填充页表项的操作：传入一个<code>PageTable</code>，根据此页表的根节点开始遍历，根节点的物理页号是保存在<code>satp</code>寄存器中的，从页表中根据虚拟地址的页表项索引来取出具体的页表项，如果此页表项为空，则分配一页内存，然后新建一个页表项进行填充。直到三级页表索引完毕，会返回虚拟地址最终对应的三级页表的页表项，此时三级页表的页表项是空的，在进行map时只需要对此页表项赋值就行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PageTableEntry* <span class="title function_">find_pte_create</span><span class="params">(PageTable* pt,VirtPageNum vpn)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到虚拟页号的三级索引，保存到idx数组中</span></span><br><span class="line">    <span class="type">size_t</span>* idx;</span><br><span class="line">    indexes(vpn, idx); </span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    PhysPageNum ppn = pt-&gt;root_ppn;</span><br><span class="line">    <span class="comment">//从根节点开始遍历，如果没有pte，就分配一页内存，然后创建一个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到具体的页表项</span></span><br><span class="line">        PageTableEntry* pte =  &amp;get_pte_array(ppn)[idx[i]];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> pte;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果此项页表为空</span></span><br><span class="line">            <span class="keyword">if</span> (!PageTableEntry_is_valid(pte)) &#123;</span><br><span class="line">                <span class="comment">//分配一页物理内存</span></span><br><span class="line">                PhysPageNum frame =  StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">               <span class="comment">//新建一个页表项</span></span><br><span class="line">               *pte =  PageTableEntry_new(frame,PTE_V);</span><br><span class="line">               <span class="comment">//压入栈中</span></span><br><span class="line">                push(&amp;pt-&gt;frames,frame.value);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//取出进入下级页表的物理页号</span></span><br><span class="line">        ppn = PageTableEntry_ppn(pte);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PageTableEntry* <span class="title function_">find_pte</span><span class="params">(PageTable* pt, VirtPageNum vpn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拿到虚拟页号的三级索引，保存到idx数组中</span></span><br><span class="line">    <span class="type">size_t</span>* idx;</span><br><span class="line">    indexes(vpn, idx); </span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    PhysPageNum ppn = pt-&gt;root_ppn;</span><br><span class="line">    <span class="comment">//从根节点开始遍历，如果没有pte，就分配一页内存，然后创建一个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到具体的页表项</span></span><br><span class="line">        PageTableEntry* pte =  &amp;get_pte_array(ppn)[idx[i]];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> pte;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果此项页表为空</span></span><br><span class="line">            <span class="keyword">if</span> (!PageTableEntry_is_valid(pte)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//取出进入下级页表的物理页号</span></span><br><span class="line">        ppn = PageTableEntry_ppn(pte);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>find_pte_create</code> 和<code>find_pte</code>基本一样，区别在于<code>find_pte</code>只会去查找页表项不会去创建。</p><p>有了上面这个函数，我们就可以建立虚实隐射关系了：只需要将你需要映射的物理页号与虚拟地址索引的三级页表中的页表项对应起来即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PageTable_map</span><span class="params">(PageTable* pt,VirtPageNum vpn, PhysPageNum ppn, <span class="type">uint8_t</span> pteflgs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PageTableEntry* pte = find_pte_create(pt,vpn);</span><br><span class="line">    assert(!PageTableEntry_is_valid(pte));</span><br><span class="line">    *pte = PageTableEntry_new(ppn,PTE_V | pteflgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后还需一个解除映射的函数：先查找页表项，如果找到了就将其设为空就行了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PageTable_unmap</span><span class="params">(PageTable* pt, VirtPageNum vpn)</span></span><br><span class="line">&#123;</span><br><span class="line">    PageTableEntry* pte = find_pte(pt,vpn);</span><br><span class="line">    assert(!PageTableEntry_is_valid(pte));</span><br><span class="line">    *pte = PageTableEntry_empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按逻辑上来说这里如果解除映射之后，应该需要释放掉对应的页内存才对</p></blockquote><p>上面用到了一个<code>assert</code>函数，这是断言的宏，具体的实现如下，新增了一个<code>assert.c</code>和<code>assert.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TOS_ASSERT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOS_ASSERT_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assertion_failure</span><span class="params">(<span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">char</span> *file, <span class="type">char</span> *base, <span class="type">int</span> line)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">__FILE__是一个预定义的宏，在C语言中表示当前源文件的文件名。</span></span><br><span class="line"><span class="comment">在预处理阶段，编译器会将所有的__FILE__宏替换为当前源文件的文件名字符串。</span></span><br><span class="line"><span class="comment">__BASE_FILE__是一个预定义的宏，在某些编译器中用于表示当前编译单元的顶层源文件的文件名，</span></span><br><span class="line"><span class="comment">即当前源文件所属的工程或者库的主文件名。</span></span><br><span class="line"><span class="comment">__LINE__是一个预定义的宏，在C语言中表示当前代码所在的行号。</span></span><br><span class="line"><span class="comment">在预处理阶段，编译器会将所有的__LINE__宏替换为当前代码所在的行号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(exp) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (exp)        \</span></span><br><span class="line"><span class="meta">        ;           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>            \</span></span><br><span class="line"><span class="meta">        assertion_failure(#exp, __FILE__, __BASE_FILE__, __LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制阻塞</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">spin</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;spinning in %s ...\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//提示报错信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assertion_failure</span><span class="params">(<span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">char</span> *file, <span class="type">char</span> *base, <span class="type">int</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(</span><br><span class="line">        <span class="string">&quot;\n--&gt; assert(%s) failed!!!\n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; file: %s \n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; base: %s \n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; line: %d \n&quot;</span>,</span><br><span class="line">        <span class="built_in">exp</span>, file, base, line);</span><br><span class="line"></span><br><span class="line">    spin(<span class="string">&quot;assertion_failure()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-xv6的内存映射实现"><a href="#2-2-xv6的内存映射实现" class="headerlink" title="2.2 xv6的内存映射实现"></a>2.2 xv6的内存映射实现</h2><p>xv6的内存映射代码实现在这里：<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c">xv6-riscv&#x2F;kernel&#x2F;vm.c at riscv · mit-pdos&#x2F;xv6-riscv (github.com)</a></p><ul><li>首先来看第一个函数<code>kvmmake</code>，在这个函数里先创建了一个根页表，为其分配一页内存，然后调用<code>kvmmap</code>函数来进行内存映射。这里建立的是恒等映射关系，把<code>PHYSTOP</code>以下的内存全部映射了，使用一个多级页表将内核的内存全部映射了。</li></ul><p><img src="/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/v2-9c287c7d7384525eae9a37022322fd78_720w.png" alt="img"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  c(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后我们来看一下<code>kvmmap</code>的实现，它实际上会去调<code>mappages</code>函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继续看<code>mappages</code>函数，此函数有五个参数，分别是：三级页表地址，需要建立映射的虚拟地址和物理地址，映射的内存大小，映射的内存的属性。这个函数干的事情就是根据虚拟地址遍历三级页表，如果没有映射就新建页表项填充，最后返回一级页表的页表项指针，最后对其赋值就完成了映射操作，这个函数就对应着在上面rCore中实现的map函数的逻辑，区别在于这里由于传入了一个映射内存的长度，所以在映射完一页内存后，虚拟地址和需要映射的物理内存地址都将向上增长一页继续映射，直到全部映射完成。查找和建立页表项的操作是在<code>walk</code>函数中完成的</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="comment">//如果映射的大小为0，则panic</span></span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 按页对齐 */</span></span><br><span class="line">  a = PGROUNDDOWN(va); </span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//遍历三级页表，分配物理页帧，建立映射关系，第一级页表中指定虚拟地址 va 对应的页表项的指针</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 如果已经被映射过了，则panic</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    <span class="comment">//设置pte</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 一页一页映射</span></span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>walk</code>函数其实就对应着上面实现的<code>find_pte_create</code>函数，实现逻辑一摸一样</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">//如果已经映射到一个下一级页表，则将 pagetable 更新为下一级页表的物理地址。</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回第一级页表中指定虚拟地址 va 对应的页表项的指针</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="https://blog.csdn.net/lhwhit/article/details/119998259">xv6–内存管理_panic remap_lhw—9999的博客-CSDN博客</a></p></li><li><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/4sv39-implementation-2.html">管理 SV39 多级页表 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户态printf以及物理内存管理</title>
      <link href="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-os文件架构修改"><a href="#1-os文件架构修改" class="headerlink" title="1. os文件架构修改"></a>1. os文件架构修改</h1><p> 在开始启用<code>mmu</code>之前我对<code>os</code>的文件编译体系进行了修改，如下：</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230830204941589.png" alt="image-20230830204941589"></p><p>将头文件全部放在了<code>include/timeros</code>下，内核的源码放在了<code>src</code>目录下，<code>lib</code>目录下放的是一些通用的函数库，比如之前的<code>string.c</code>，以及马上要新增的和<code>printf</code>相关的代码。</p><p>所有的头文件都被修改成了这种形式：添加了一个<code>TOS</code>的前缀</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TOS_OS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOS_OS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改了<code>makefile</code></p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230830205303783.png" alt="image-20230830205303783"></p><p>修改的地方用红色方框圈了起来，主要就是用于调整文件结构后的编译。</p><h1 id="2-用户态的printf实现"><a href="#2-用户态的printf实现" class="headerlink" title="2. 用户态的printf实现"></a>2. 用户态的<code>printf</code>实现</h1><p>在之前的应用程序中，我们一直使用<code>sys_write</code>的系统调用来向串口输出数据，这样及其不方便，因此需要实现一个用户态的<code>printf</code>函数。实现方式和之前的内核实现的基本一样。</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230830205658123.png" alt="image-20230830205658123"></p><p>差别就在于需要把上面这个<code>uart_puts</code>函数换成<code>sys_write</code>就行了。</p><p>我首先把之前实现的<code>printf</code>函数名改成了<code>printk</code>，这是内核专属的，在S态用到的<code>printf</code>都要更改成<code>printk</code>,</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230830205850660.png" alt="image-20230830205850660"></p><p>然后在<code>lib</code>目录下新增<code>printf.c</code>和<code>vsprintf.c</code>,其中<code>vsprintf.c</code>的内容就是把之前的<code>_vsnprintf</code>函数移动到了此文件而已，然后<code>printf.c</code>如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> out_buf[<span class="number">1000</span>]; <span class="comment">// buffer for vprintf()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br><span class="line">_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br><span class="line">sys_write(<span class="built_in">stdout</span>,out_buf,res + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">va_list vl;</span><br><span class="line">va_start(vl, s);</span><br><span class="line">res = <span class="built_in">vprintf</span>(s, vl);</span><br><span class="line">va_end(vl);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见和<code>printk</code>的实现一模一样，只是使用了<code>sys_write(stdout,out_buf,res + 1);</code>来输出数据，<code>_vsnprintf</code>函数作为<code>printf</code>和<code>printk</code>公用函数。同时新增了一个头文件<code>stdio.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _vsnprintf(<span class="type">char</span> * out, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span>* s, va_list vl);</span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件描述符 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">std_fd_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">stdin</span>,  </span><br><span class="line">    <span class="built_in">stdout</span>,</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">&#125; <span class="type">std_fd_t</span>;</span><br></pre></td></tr></table></figure><h1 id="3-riscv的分页机制"><a href="#3-riscv的分页机制" class="headerlink" title="3. riscv的分页机制"></a>3. riscv的分页机制</h1><p>在<code>riscv</code>体系中，有三种地址转换机制：</p><ul><li>Sv32：仅支持32位riscv处理器，是一个二级页表结构，支持32位虚拟地址转换</li><li>Sv39：支持64位riscv处理器，是一个三级页表结构，支持39位虚拟地址转换</li><li>Sv48：支持64位riscv处理器，是一个四级页表结构，支持48位虚拟地址转换</li></ul><p>目前RISCV体系通常支持4KB大小的页面粒度，也支持2MB，1GB大小的块粒度。在我们的操作系统中用到的是Sv39页表映射，关于Sv39的具体内容本博客不做解释，主要是写起来他麻烦了哈哈，网上有很多资料：</p><p>首先先来看一下<code>satp</code>寄存器，这是一个S特权级的控制寄存器</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230831124613425.png" alt="image-20230831124613425"></p><ul><li><code>MODE</code> 控制 CPU 使用哪种页表实现；当 <code>MODE</code> 设置为 0 的时候，代表所有访存都被视为物理地址；而设置为 8 的时候，SV39 分页机制被启用，所有 S&#x2F;U 特权级的访存被视为一个 39 位的虚拟地址，它们需要先经过 MMU 的地址转换流程，如果顺利的话，则会变成一个 56 位的物理地址来访问物理内存；否则则会触发异常。</li><li><code>ASID</code> 表示地址空间标识符，这里还没有涉及到进程的概念，我们不需要管这个地方；</li><li><code>PPN</code> 存的是根页表所在的物理页号。这样，给定一个虚拟页号，CPU 就可以从三级页表的根页表开始一步步的将其映射到一个物理页号。</li></ul><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Sv39.png" alt="img"></p><ul><li><p>首先从<code>satp</code>寄存器的低44位取出一级页表的物理页号，乘以 PAGESIZE (4 KiB) 后，得到 3 级页表地址，取出虚拟地址的<code>VPN[2]</code>,去3级页表中寻找对应的页表项。</p></li><li><p>然后从三级页表中得到的页表项中存储了二级页表的物理页号，乘以 PAGESIZE (4 KiB) 后，得到 2级页表地址，取出虚拟地址的<code>VPN[1]</code>,去2级页表中寻找对应的页表项。</p></li><li><p>然后从二级页表中得到的页表项中存储了1级页表的物理页号，乘以 PAGESIZE (4 KiB) 后，得到 1级页表地址，取出虚拟地址的<code>VPN[0]</code>,去1级页表中寻找对应的页表项。</p></li><li><p>将1级页表中得到的页表项中存储了虚拟地址的物理页号，乘以 PAGESIZE (4 KiB) 后，得到实际的物理页号，然后再加上虚拟地址的最后12位offset就最终得到了物理地址。</p></li></ul><p>页表项的最后10bit代表的是页表项的属性：</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230831125451059.png" alt="image-20230831125451059"></p><ul><li>V(Valid)：仅当位 V 为 1 时，页表项才是合法的；</li><li>R(Read)&#x2F;W(Write)&#x2F;X(eXecute)：分别控制索引到这个页表项的对应虚拟页面是否允许读&#x2F;写&#x2F;执行；</li><li>U(User)：控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；</li><li>G：暂且不理会；</li><li>A(Accessed)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；</li><li>D(Dirty)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过</li><li>RSW：预留位</li></ul><table><thead><tr><th align="center">X</th><th align="center">W</th><th align="center">R</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="left">Pointer to next level of page table.</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="left">Read-only page.</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="left"><em>Reserved for future use.</em></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="left">Read-write page.</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="left">Execute-only page.</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="left">Read-execute page.</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="left"><em>Reserved for future use.</em></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="left">Read-write-execute page.</td></tr></tbody></table><h1 id="4-物理内存管理"><a href="#4-物理内存管理" class="headerlink" title="4. 物理内存管理"></a>4. 物理内存管理</h1><p>要开启mmu之前，内核需要对拥有的物理内存进行分配管理，对物理内存一页为单位进行分配和释放。</p><h2 id="4-1-xv6-riscv的物理内存管理"><a href="#4-1-xv6-riscv的物理内存管理" class="headerlink" title="4.1 xv6-riscv的物理内存管理"></a>4.1 xv6-riscv的物理内存管理</h2><p>首先先来看，<code>xv6</code>是如何管理的，代码在这里：<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c">xv6-riscv&#x2F;kernel&#x2F;kalloc.c at riscv · mit-pdos&#x2F;xv6-riscv (github.com)</a></p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/v2-9c287c7d7384525eae9a37022322fd78_720w.png" alt="img"></p><p>xv6内核的起始地址是从<code>KERNBASE=0x80000000</code>开始，结束的地方是<code>PHYSTOP=0x88000000</code>，这之间128M的地方，其中内核的代码段是可读可执行的，内核数据段代码是可读可写的。所以我们实际可以分配和管理的地址是从内核段的代码结束的地方开始的，在xv6的链接文件中指明了空闲物理内存开始的地方：</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230831153446728.png" alt="image-20230831153446728"></p><p>所以现在来看xv6的<code>kalloc.c</code>:</p><ul><li>首先就是拿到了<code>end</code>所代表的地址</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[]; <span class="comment">// first address after kernel.</span></span><br><span class="line">                   <span class="comment">// defined by kernel.ld.</span></span><br></pre></td></tr></table></figure><ul><li>然后定义了一个数据结构<code>kmem</code>，这个数据结构包含一个锁和一个链表，这就是xv6管理物理内存的核心数据结构，我们可以先忽略掉锁</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><ul><li>然后定义了<code>kinit()</code>函数，这个函数用来扫描从<code>end~PHYSTOP</code>之间可用的物理内存页，将可用的物理内存页通过<code>kmem</code>维护起来，同时将可用的空闲物理页中的每个字节的数据进行填充，这是用于初始化的时候</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>freerange</code>就是用来扫描内存的，可以看见从物理内存开始位置到结束，<code>freerange</code>会以页为单位来释放内存，其中会去调用<code>kfree</code>这个函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<code>kfree</code>中，对此页内存进行数据填充，然后将指向此页内存的指针放到<code>kmem</code>的链表头部，然后再让链表头指针前移</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与<code>kfree</code>与之对应的就是分配一页内存的函数<code>kalloc</code>函数，此函数将返回分配的物理内存页的指针。发配的逻辑就是从<code>kmemd</code>的链表头部取出一个空闲页块的指针，然后将链表头指针后移</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最后空闲链表就把空闲的物理内存串了起来：</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/v2-7286c486abbfbf8a98218e97e1e19b09_720w.png" alt="img"></p><p>可以看见xv6对空闲物理内存的管理十分的简洁明了。</p><h2 id="4-2-rCore的物理内存管理"><a href="#4-2-rCore的物理内存管理" class="headerlink" title="4.2 rCore的物理内存管理"></a>4.2 rCore的物理内存管理</h2><p>接下来我们再来看看操蛋的rCore，不知道是不是因为为了使用rust的语法特性，<code>rCore</code>的物理内存管理搞得我迷迷糊糊，绕过来绕过去。</p><p><code>rCore</code>采用的是栈式物理页帧管理策略，核心的数据结构如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,  <span class="comment">//空闲内存的起始物理页号</span></span><br><span class="line">    end: <span class="type">usize</span>,      <span class="comment">//空闲内存的结束物理页号</span></span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中各字段的含义是：物理页号区间 [ <code>current</code> , <code>end</code> ) 此前均 <em>从未</em> 被分配出去过，而向量 <code>recycled</code> 以后入先出的方式保存了被回收的物理页号。</p><p>因此为了实现这种栈式的管理，我们先得来实现一个栈的数据结构，在rust&#x2F;c++中倒是有方便的vector可以使用，但是我们使用的是c，所以有点麻烦，在<code>lib</code>目录下新建了一个<code>stack.c</code>的文件，在<code>timeros</code>目录下新建了<code>stack.h</code>的头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/stack.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, u64 value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Stack overflow\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈操作</span></span><br><span class="line">u64 <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Stack underflow\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 表示栈为空或操作失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line">u64 <span class="title function_">top</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 表示栈为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TOS_STACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOS_STACK_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u64 data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">// 不能定义成无符号类型，不然会导致 -1 &gt; 0</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, u64 value)</span>;</span><br><span class="line">u64 <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line">u64 <span class="title function_">top</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>stack的数据结构代码还是比较简单的，这里有一点说明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u64 data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">// 不能定义成无符号类型，不然会导致 -1 &gt; 0</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure><p>栈顶需要定义成int类型，不能定义成无符号类型，因为对栈初始化时，top的值被设置为-1，但是后面会让top和0进行大小比较，如果设置成无符号会导致结果出错。第二个就是data是一个u64的数组，因为栈中维护的是物理页号，物理页号是u64类型的。</p><p>在<code>src</code>目录下新建一个<code>address.c</code>，<code>timeros</code>目录下新建了<code>address.h</code>的头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TOS_ADDRESS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOS_ADDRESS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/os.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/stack.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000      <span class="comment">// 4kb  一页的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE_BITS   0xc  <span class="comment">// 12   页内偏移地址长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA_WIDTH_SV39 56      <span class="comment">//物理地址长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_WIDTH_SV39 39      <span class="comment">//虚拟地址长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPN_WIDTH_SV39 (PA_WIDTH_SV39 - PAGE_SIZE_BITS)  <span class="comment">// 物理页号 44位 [55:12]</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VPN_WIDTH_SV39 (VA_WIDTH_SV39 - PAGE_SIZE_BITS)  <span class="comment">// 虚拟页号 27位 [38:12]</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_END 0x80800000    <span class="comment">// 0x80200000 ~ 0x80800000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_START 0x80400000  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理地址 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value; </span><br><span class="line">&#125; PhysAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 虚拟地址 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value;</span><br><span class="line">&#125; VirtAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理页号 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value;</span><br><span class="line">&#125; PhysPageNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 虚拟页号 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value;</span><br><span class="line">&#125; VirtPageNum;</span><br></pre></td></tr></table></figure><p><code>address.h</code>中定义了<code>PhysAddr、VirtAddr、PhysPageNum、VirtPageNum</code>，全部定义成结构体的类型，在rCore中可以为这些结构体实现操作函数，但是c语言没有面向对象的特性，因此就只有一个手动实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个u64 转换为PhysAddr */</span></span><br><span class="line">PhysAddr <span class="title function_">phys_addr_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    PhysAddr addr;</span><br><span class="line">    addr.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; PA_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给定一个u64 转换为PhysPageNum */</span></span><br><span class="line">PhysPageNum <span class="title function_">phys_page_num_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    PhysPageNum pageNum;</span><br><span class="line">    pageNum.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; PPN_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pageNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个PhysAddr转换为u64 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_phys_addr</span><span class="params">(PhysAddr v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个PhysPageNum 转换为u64 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_phys_page_num</span><span class="params">(PhysPageNum v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从物理页号转换为实际物理地址 */</span></span><br><span class="line">PhysAddr <span class="title function_">phys_addr_from_phys_page_num</span><span class="params">(PhysPageNum ppn)</span></span><br><span class="line">&#123;</span><br><span class="line">    PhysAddr addr;</span><br><span class="line">    addr.value = ppn.value &lt;&lt; PAGE_SIZE_BITS ;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个u64 转换为VirtAddr  */</span></span><br><span class="line">VirtAddr <span class="title function_">virt_addr_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    VirtAddr addr;</span><br><span class="line">    addr.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; VA_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个u64 转换为VirtPageNum  */</span></span><br><span class="line">VirtPageNum <span class="title function_">virt_page_num_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    VirtPageNum pageNum;</span><br><span class="line">    pageNum.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; VPN_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pageNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给定一个VirtAddr 转换为一个u64 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_virt_addr</span><span class="params">(VirtAddr v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v.value &gt;= (<span class="number">1ULL</span> &lt;&lt; (VA_WIDTH_SV39 - <span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> v.value | ~((<span class="number">1ULL</span> &lt;&lt; VA_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个VirtPageNum 转换为 u64*/</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_virt_page_num</span><span class="params">(VirtPageNum v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理地址向下取整 */</span></span><br><span class="line">PhysPageNum <span class="title function_">floor_phys</span><span class="params">(PhysAddr phys_addr)</span> &#123;</span><br><span class="line">    PhysPageNum phys_page_num;</span><br><span class="line">    phys_page_num.value = phys_addr.value / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> phys_page_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理地址向上取整 */</span></span><br><span class="line">PhysPageNum <span class="title function_">ceil_phys</span><span class="params">(PhysAddr phys_addr)</span> &#123;</span><br><span class="line">    PhysPageNum phys_page_num;</span><br><span class="line">    phys_page_num.value = (phys_addr.value + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> phys_page_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把虚拟地址转换为虚拟页号 */</span></span><br><span class="line">VirtPageNum <span class="title function_">virt_page_num_from_virt_addr</span><span class="params">(VirtAddr virt_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtPageNum vpn;</span><br><span class="line">    vpn.value =  virt_addr.value / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> vpn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数都是做一些转换工作，然后我们来定义栈式的内存管理数据结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> current;   <span class="comment">//空闲内存的起始物理页号</span></span><br><span class="line">    <span class="type">uint64_t</span>  end;      <span class="comment">//空闲内存的结束物理页号</span></span><br><span class="line">    Stack recycled;     <span class="comment">// </span></span><br><span class="line">&#125;StackFrameAllocator;</span><br></pre></td></tr></table></figure><p>首先是第一个new函数，用于创建<code>FrameAllocator</code>的实例：只需将区间两端均设为 0 ，然后创建一个初始化栈；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackFrameAllocator_new</span><span class="params">(StackFrameAllocator* allocator)</span> &#123;</span><br><span class="line">    allocator-&gt;current = <span class="number">0</span>;</span><br><span class="line">    allocator-&gt;end = <span class="number">0</span>;</span><br><span class="line">    initStack(&amp;allocator-&gt;recycled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>init</code>函数，用于将自身的<code> [current,end)</code> 初始化为可用物理页号区间：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackFrameAllocator_init</span><span class="params">(StackFrameAllocator *allocator, PhysPageNum l, PhysPageNum r)</span> &#123;</span><br><span class="line">    allocator-&gt;current = l.value;</span><br><span class="line">    allocator-&gt;end = r.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是物理页帧的分配和实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PhysPageNum <span class="title function_">StackFrameAllocator_alloc</span><span class="params">(StackFrameAllocator *allocator)</span> &#123;</span><br><span class="line">    PhysPageNum ppn;</span><br><span class="line">    <span class="keyword">if</span> (allocator-&gt;recycled.top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ppn.value = pop(&amp;(allocator-&gt;recycled));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (allocator-&gt;current == allocator-&gt;end) &#123;</span><br><span class="line">            ppn.value = <span class="number">0</span>; <span class="comment">// Return 0 as None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ppn.value = allocator-&gt;current++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清空此页内存 ： 注意不能覆盖内核代码区，分配的内存只能是未使用部分*/</span></span><br><span class="line">    PhysAddr addr = phys_addr_from_phys_page_num(ppn);</span><br><span class="line">    <span class="built_in">memset</span>(addr.value,<span class="number">0</span>,PAGE_SIZE);</span><br><span class="line">    <span class="keyword">return</span> ppn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在分配 <code>alloc</code> 的时候，首先会检查栈 <code>recycled</code> 内有没有之前回收的物理页号，如果有的话直接弹出栈顶并返回；否则的话我们只能从之前从未分配过的物理页号区间 [ <code>current</code> , <code>end</code> ) 上进行分配，我们分配它的左端点 <code>current</code> ，同时将管理器内部维护的 <code>current</code> 加 <code>1</code> 代表 <code>current</code> 已被分配了。然后清空此页内存，全部初始化为0，最后返回分配的页的物理页号。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackFrameAllocator_dealloc</span><span class="params">(StackFrameAllocator *allocator, PhysPageNum ppn)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> ppnValue = ppn.value;</span><br><span class="line">    <span class="comment">// 检查回收的页面之前一定被分配出去过</span></span><br><span class="line">    <span class="keyword">if</span> (ppnValue &gt;= allocator-&gt;current) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Frame ppn=%lx has not been allocated!\n&quot;</span>, ppnValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查未在回收列表中</span></span><br><span class="line">    <span class="keyword">if</span>(allocator-&gt;recycled.top&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= allocator-&gt;recycled.top; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ppnValue ==allocator-&gt;recycled.data[i] )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回收物理内存页号</span></span><br><span class="line">    push(&amp;(allocator-&gt;recycled), ppnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回收 <code>dealloc</code> 的时候，我们需要检查回收页面的合法性，然后将其压入 <code>recycled</code> 栈中。回收页面合法有两个条件：</p><ul><li>该页面之前一定被分配出去过，因此它的物理页号一定 &lt; <code>current</code> ；</li><li>该页面没有正处在回收状态，即它的物理页号不能在栈 <code>recycled</code> 中找到。</li></ul><p>在上面的代码中用到了一个<code>memset</code>函数，这个函数实现在<code>string.c</code>中:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复制字符 ch（一个无符号字符）到参数 dest 所指向的字符串的前 n 个字符。</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">memset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">int</span> ch, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr = dest;</span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line">    &#123;</span><br><span class="line">        *ptr++ = ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来编写测试代码测试一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> StackFrameAllocator FrameAllocatorImpl;</span><br><span class="line"><span class="type">void</span> <span class="title function_">frame_allocator_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    StackFrameAllocator_new(&amp;FrameAllocatorImpl);</span><br><span class="line">    StackFrameAllocator_init(&amp;FrameAllocatorImpl, \</span><br><span class="line">            floor_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_START)), \</span><br><span class="line">            ceil_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_END)));</span><br><span class="line">    printk(<span class="string">&quot;Memoery start:%d\n&quot;</span>,floor_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_START)));</span><br><span class="line">    printk(<span class="string">&quot;Memoery end:%d\n&quot;</span>,ceil_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_END)));</span><br><span class="line">    PhysPageNum frame[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         frame[i] = StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">         printk(<span class="string">&quot;frame id:%d\n&quot;</span>,frame[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        StackFrameAllocator_dealloc(&amp;FrameAllocatorImpl,frame[i]);</span><br><span class="line">        printk(<span class="string">&quot;allocator-&gt;recycled.data.value:%d\n&quot;</span>,FrameAllocatorImpl.recycled.data[i]);</span><br><span class="line">        printk(<span class="string">&quot;frame id:%d\n&quot;</span>,frame[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">    PhysPageNum frame_test[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         frame[i] = StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">        printk(<span class="string">&quot;frame id:%d\n&quot;</span>,frame[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的测试函数一次调用了<code>new，init</code> ，然后尝试分配五页内存，并打印五页内存的物理页号，然后将分配的五页内存释放掉，此时这五页内存应该会全部被压入<code>recycled</code>栈中，然后再次分配五页内存，此时分配的话就是从<code>recycled</code>中<code>pop</code>的内存了。强调一下在<code>StackFrameAllocator_init</code>函数中传入的起始物理内存的地址和上面xv6的一样，必须在内核代码段之上，在头文件中进行了定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_END 0x80800000    <span class="comment">// 0x80200000 ~ 0x80800000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_START 0x80400000  </span></span><br></pre></td></tr></table></figure><p>来编译测试一下：修改一下main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">frame_allocator_test</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   printk(<span class="string">&quot;hello timer os!\n&quot;</span>);</span><br><span class="line">   frame_allocator_test();</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// trap_init();</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// task_init();</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// timer_init();</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// run_first_task();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230831162651340.png" alt="image-20230831162651340"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/4sv39-implementation-2.html">管理 SV39 多级页表 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li><li><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html">SV39 多级页表的硬件机制 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/643749962">xv6 物理内存管理 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sec:sv32">The RISC-V Instruction Set Manual, Volume II: Privileged Architecture | Five EmbedDev (five-embeddev.com)</a></p></li><li><p><a href="https://dingfen.github.io/risc-v/2020/08/29/riscv-from-scratch-7.html">RISC-V from Scratch 7 - 峰子的乐园 (dingfen.github.io)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分时多任务系统与抢占式调度</title>
      <link href="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/"/>
      <url>/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="分时多任务系统"><a href="#分时多任务系统" class="headerlink" title="分时多任务系统"></a>分时多任务系统</h1><p>在上一章中我们实现了一个协作式的调度方案，用户程序通过调用<code>sys_yield</code>的系统调用来主动放弃cpu的使用权，然后内核使用轮转调度的方式切换至下一个任务。何为分时多任务系统呢，任务的切换不是通过用户程序来自行放弃cpu的使用权作为前提的，而是内核自己来决定何时切换任务，这个切换的原则就是每个任务一次只能运行一段时间，时间一到就会被操作系统强制切换到下一个任务执行，这就需要内核有一个定时器的东西，这个定时器是通过硬件提供的时钟中断来实现的。</p><h2 id="riscv的时钟中断"><a href="#riscv的时钟中断" class="headerlink" title="riscv的时钟中断"></a>riscv的时钟中断</h2><p>RISC-V 的中断可以分成三类：</p><ul><li><strong>软件中断</strong> (Software Interrupt)：由软件控制发出的中断</li><li><strong>时钟中断</strong> (Timer Interrupt)：由时钟电路发出的中断</li><li><strong>外部中断</strong> (External Interrupt)：由外设发出的中断</li></ul><p>在介绍trap机制时我们用到了<code>scause</code>寄存器，<code>scause</code>最高位为1时代表此次触发的异常为中断类型：</p><table><thead><tr><th>Interrupt</th><th>Exception Code</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>Supervisor software interrupt</td></tr><tr><td>1</td><td>3</td><td>Machine software interrupt</td></tr><tr><td>1</td><td>5</td><td>Supervisor timer interrupt</td></tr><tr><td>1</td><td>7</td><td>Machine timer interrupt</td></tr><tr><td>1</td><td>9</td><td>Supervisor external interrupt</td></tr><tr><td>1</td><td>11</td><td>Machine external interrupt</td></tr></tbody></table><p>可以看到这三种中断每一个都有 M&#x2F;S 特权级两个版本。中断的特权级可以决定该中断是否会被屏蔽，以及需要 Trap 到 CPU 的哪个特权级进行处理。我们的目标是在S态使用时钟中断，这涉及到两个个在S态控制中断的寄存器<code>sstatus</code>,<code>sie</code></p><p><code>sstatus</code>的<code>bit[2]</code>用来使能S态模式下的所有中断</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820114526155.png" alt="image-20230820114526155"></p><p><code>sie</code>的<code>bit[5]</code>用来专门使能S态的时钟中断</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820113357943.png" alt="image-20230820113357943"></p><p>当设置<code>STIE</code>位为1时代表启动S态的时钟中断。</p><p><code>sstatus</code> 的 <code>sie</code> 为 S 特权级的中断使能，能够同时控制三种中断，如果将其清零则会将它们全部屏蔽。即使 <code>sstatus.sie</code> 置 1 ，还要看 <code>sie</code> 这个 CSR，它的三个字段 <code>ssie/stie/seie</code> 分别控制 S 特权级的软件中断、时钟中断和外部中断的中断使能。比如对于 S 态时钟中断来说，如果 CPU 不高于 S 特权级，需要 <code>sstatus.sie</code> 和 <code>sie.stie</code> 均为 1 该中断才不会被屏蔽；如果 CPU 当前特权级高于 S 特权级，则该中断一定会被屏蔽。</p><p>由于软件（特别是操作系统）需要一种计时机制，RISC-V 架构要求处理器要有一个内置时钟，其频率一般低于 CPU 主频。此外，还有一个计数器用来统计处理器自上电以来经过了多少个内置时钟的时钟周期。在 RISC-V 64 架构上，该计数器保存在一个 64 位的 CSR <code>mtime</code> 中，我们无需担心它的溢出问题，在内核运行全程可以认为它是一直递增的。这个计数器一般我们叫做RTC。另外一个 64 位的 CSR <code>mtimecmp</code> 的作用是：一旦计数器 <code>mtime</code> 的值超过了 <code>mtimecmp</code>，就会触发一次时钟中断。</p><p>所以我们现在来设置时钟中断，在os目录下新建一个<code>timer.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCK_FREQ 10000000 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TICKS_PER_SEC 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置下次时钟中断的cnt值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_next_trigger</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sbi_set_timer(r_mtime() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开启S模式下的时钟中断 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">reg_t</span> sstatus =r_sstatus();</span><br><span class="line">   sstatus |= (<span class="number">1L</span> &lt;&lt; <span class="number">1</span>) ;</span><br><span class="line">   w_sstatus(sstatus);</span><br><span class="line">   <span class="type">reg_t</span> sie = r_sie();</span><br><span class="line">   sie |= SIE_STIE;</span><br><span class="line">   w_sie(sie);</span><br><span class="line">   set_next_trigger();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 以us为单位返回时间 */</span></span><br><span class="line"><span class="comment">/* 以us为单位返回时间 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">get_time_us</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> time =  r_mtime() / (CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>timer_init()</code>函数中，分别将<code>sstatus.sie</code> 置 1 和<code>sie.stie</code> ，操作<code>sie</code>寄存器的代码放在<code>riscv.h</code>中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Supervisor Interrupt Enable</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_SEIE (1L &lt;&lt; 9) <span class="comment">// external</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_STIE (1L &lt;&lt; 5) <span class="comment">// timer</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_SSIE (1L &lt;&lt; 1) <span class="comment">// software</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_sie</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sie&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sie</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sie, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了设置时钟中断的频率我们需要先读到<code>mtime</code>的值，然后设置<code>mtimecmp</code>，这两个寄存器都是m模式下的，在S模式下不能直接访问，可惜的是在<code>opensbi</code>中只提供了设置<code>mtimecmp</code>的接口，因此需要想办法在S态下获取<code>mtime</code>的值，经过查找，有两种方式可以去得到<code>mtime</code>的值：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_mtime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;rdtime %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(x))</span>;</span><br><span class="line">  <span class="comment">// asm volatime(&quot;csrr %0, 0x0C01&quot; : &quot;=r&quot; (x) )</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种是使用<code>rdtime</code>这个伪指令，这里是在哪里找的呢，在<code>opensbi</code>的源码中，在<code>lib/sbi/sbi_timer.c</code>有这么一个函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64 <span class="title function_">sbi_timer_value</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (get_time_val)</span><br><span class="line"><span class="keyword">return</span> get_time_val();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>opensbi</code>用此函数来获取时间，<code>opensbi</code>在进行时钟初始化时，在<code>sbi_timer_init</code>函数中，对<code>sbi_timer_value</code>进行了赋值，所以在<code>opensbi</code>中实际是通过<code>get_ticks</code>函数来获取时间的</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820120641356.png" alt="image-20230820120641356"></p><p><code>get_ticks</code>定义如下:</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820120859926.png" alt="image-20230820120859926"></p><p>第二种方式是<code>asm volatime(&quot;csrr %0, 0x0C01&quot; : &quot;=r&quot; (x) )</code>来读取，<code>mtime</code>这个寄存器通过<code>MMIO</code>映射到了一个确定的地址，这个地址和平台有关，在<code>opensbi</code>源码的<code>sbi_emulate_csr.c</code>中，<code>opensbi</code>将<code>mtime</code>的值映射到了<code>0xc01</code>的地方，这是<code>opensbi</code>做了二次映射，用于S态的程序来读取，实际<code>mtime</code>的映射地址应该由<code>qemu</code>来做的，具体的映射方式我也不太清楚……，看下面代码实际上<code>opensbi</code>也是通过<code>rdtime</code>去读取的该值：</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820122507968.png" alt="image-20230820122507968"></p><p>所以我也不知道<code>rdtime</code>如何与<code>rtc</code>关联上的，疑惑…….</p><p>总之得到了<code>mtime</code>的值。<code>mtimecmp</code>的值可以通过<code>opensbi</code>提供的接口来设置：在<code>sbi.c</code>中定义如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_set_timer() - Program the timer for next timer event.</span></span><br><span class="line"><span class="comment"> * @stime_value: The value after which next timer event should fire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_set_timer</span><span class="params">(<span class="type">uint64_t</span> stime_value)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_TIME, SBI_FID_SET_TIMER, stime_value,</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820123213958.png" alt="image-20230820123213958"></p><p>调用号为<code>0x54494D45</code>，定义在<code>sbi.h</code>中。</p><p>在<code>qemu</code>中<code>rtc</code>的频率为<code>10mhz</code>，即10^7，在上面的代码中，我将1s分成了1000个时间片，即每隔1us触发一次时钟中断，因此每次触发时钟中断设置的<code>mtimecmp</code>值为：<code>r_mtime() + CLOCK_FREQ / TICKS_PER_SEC</code>。这个频率应该是和设备树中的保持一致的</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820142830588.png" alt="image-20230820142830588"></p><p><code>0x986980</code>换算成10进制就是<code>10mhz</code></p><h2 id="分时多任务"><a href="#分时多任务" class="headerlink" title="分时多任务"></a>分时多任务</h2><p>有了时钟中断后，切换任务就简单许多了，只需要在时钟中断到来时，设置下一次时钟中断的<code>mtimecmp</code>的值，并切换一次任务。因此对<code>trap.c</code>修改如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TrapContext* <span class="title function_">trap_handler</span><span class="params">(TrapContext* cx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> scause = r_scause();</span><br><span class="line"><span class="type">reg_t</span> cause_code = scause &amp; <span class="number">0xfff</span>;</span><br><span class="line"><span class="keyword">if</span>(scause &amp; <span class="number">0x8000000000000000</span>)  <span class="comment">// 1 &lt;&lt; 63 = 0x8000000000000000</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (cause_code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* rtc 中断*/</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">set_next_trigger();</span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;undfined interrrupt scause:%x\n&quot;</span>,scause);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (cause_code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* U模式下的syscall */</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">cx-&gt;a0 = __SYSCALL(cx-&gt;a7,cx-&gt;a0,cx-&gt;a1,cx-&gt;a2);</span><br><span class="line">cx-&gt;sepc += <span class="number">8</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;undfined exception scause:%x\n&quot;</span>,scause);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scause</code>最高位为1时代表为中断则进入中断的判断分支，否则进入异常的处理分支。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>app.c</code>修改:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task1 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task2 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task3 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (sys_gettime() &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在三个任务中注释掉了<code>sys_yield()</code>，我们让内核自主来进行任务切换，</p><p>编译测试：<code>./build.sh , ./run.sh</code>，测试的时候发现<code>#define TICKS_PER_SEC 1000</code>这里切换频率太高会触发一个异常，暂时不知道如何引起的，因此降低一下频率为500，测试成功。</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/GIF-fre.gif" alt="GIF-fre"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/456568228">操作系统lab2时钟中断处理 - 知乎 (zhihu.com)</a></p></li><li><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/4time-sharing-system.html">分时多任务系统与抢占式调度 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li><li><p><a href="https://github.com/LiuJiLan/RVOS_On_VisionFive2">LiuJiLan&#x2F;RVOS_On_VisionFive2: RVOS在VisionFive2开发板上的移植。 (github.com)</a></p></li><li><p><a href="https://five-embeddev.com/baremetal/timer/">Timer | Five EmbedDev (five-embeddev.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协作式多任务调度</title>
      <link href="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
      <url>/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-代码的一些修改"><a href="#1-代码的一些修改" class="headerlink" title="1. 代码的一些修改"></a>1. 代码的一些修改</h1><h2 id="1-1-trap的bug修改"><a href="#1-1-trap的bug修改" class="headerlink" title="1.1 trap的bug修改"></a>1.1 trap的bug修改</h2><p>在上一节实现U模式的trap机制时，我在<code>trap_handler</code>函数中，在函数最后通过<code>__restore(cx)</code>来切换回用户态，这里实际是不用的，我就说为啥我在用户程序里为啥不加一个while循环卡在那儿就会报奇怪的错误。</p><p>原因在于当程序从<code>trap_handler</code> 返回之后会从调用 <code>trap_handler</code> 的下一条指令开始执行：</p><p><img src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20230810215940227.png" alt="image-20230810215940227"></p><p><code>call trap_handler</code> 实际的汇编会被转换一条<code>jal</code>的跳转指令:</p><p><img src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20230810220243193.png" alt="image-20230810220243193"></p><p><code>jal ra,1876</code>会做两个操作，一是将当前<code>PC+8</code>存到<code>ra</code>寄存器中，然后跳转到和当前地址相差1876的地方执行即<code>0x802007ba</code>，而<code>0x802007ba</code>就是<code>trap_handler</code>函数的地址，各个函数的地址可以在生成的<code>os.map</code>中找到。因此在执行完毕<code>trap_handler</code>函数后就会跳转到<code>call trap_handler</code> 的下一条指令，这下一条指令就是<code>_restore</code>的第一条指令，编译器在编译时是这样编译的。所以直接将<code>trap_handler</code>函数的<code>__restore(cx)</code>干掉。</p><h2 id="1-2-实现sys-write"><a href="#1-2-实现sys-write" class="headerlink" title="1.2 实现sys_write"></a>1.2 实现sys_write</h2><p>我再<code>os</code>目录下新建了一个<code>app.c</code>，上一节的<code>batch.c</code>在本章内容中可以干掉，在<code>app.c</code>中首先了实现了用户态的<code>sys_write</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// Move syscall id to a7 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// Move args[0] to a1 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// Move args[1] to a2 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// Move args[2] to a3 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// Perform syscall</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// Move return value to &#x27;ret&#x27; variable</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">sys_wirte</span><span class="params">(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(__NR_write,fd,buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write</code>的系统调用号是64定义在<code>os.h</code>中，然后需要修改内核的<code>trap_handler</code>函数，对系统调用号进行分发：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TrapContext* <span class="title function_">trap_handler</span><span class="params">(TrapContext* cx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> scause = r_scause();</span><br><span class="line"><span class="keyword">switch</span> (scause)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">__SYSCALL(cx-&gt;a7,cx-&gt;a0,cx-&gt;a1,cx-&gt;a2);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;undfined scause:%d\n&quot;</span>,scause);</span><br><span class="line"><span class="comment">//panic(&quot;error!&quot;);</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cx-&gt;sepc += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__SYSCALL</code>函数定义在<code>syscall.c</code>中，需要新建<code>syscall.c</code>，可以看见其实调用内核的<code>printf</code>函数去输出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* syscall.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __SYSCALL(<span class="type">size_t</span> syscall_id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (syscall_id)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> __NR_write:</span><br><span class="line">            __sys_write(arg1, arg2, arg3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unsupported syscall id:%d\n&quot;</span>,syscall_id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sys_write(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd ==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;Unsupported fd in sys_write!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>sys_wirte</code>的其中一个参数是字符串的长度，需要调用<code>strlen</code>去计算，如果我们调用编译器的标准库会产生重定义错误，因此我们自己来实现一个，新建一个<code>string.c</code>，实现了两个辅助函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* string.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="comment">//计算字符串的长度 </span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr = (<span class="type">char</span> *)str;</span><br><span class="line">    <span class="keyword">while</span> (*ptr != EOS)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr - str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从存储区 src 复制 n 个字节到存储区 dest。</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr = dest;</span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line">    &#123;</span><br><span class="line">        *ptr++ = *((<span class="type">char</span> *)(src++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，现在就可以在用户态的程序调用<code>sys_write</code>来实现串口输出数据了。</p><h1 id="2-协作式多任务"><a href="#2-协作式多任务" class="headerlink" title="2. 协作式多任务"></a>2. 协作式多任务</h1><h2 id="2-1-任务的切换"><a href="#2-1-任务的切换" class="headerlink" title="2.1 任务的切换"></a>2.1 任务的切换</h2><p>在上一节中我们可以编写一个应用程序让它运行下去，运行完毕后可以让CPU接着运行下一个程序，这叫做批处理系统，cpu可以按照顺序依次运行用户程序。什么是协作式多任务呢就是如果一个用户程序在做一些等待的事情的时候比如等待外设响应而不需要占用cpu计算资源的时候可以让出cpu的使用权让下一个用户程序执行，当外设响应完毕后重新拿到cpu使用权继续执行，这大大的提高了cpu的执行效率。从一个程序的任务切换到另外一个程序的任务称为 任务切换 。为了确保切换后的任务能够正确继续执行，操作系统需要支持让任务的执行“暂停”和“继续”。</p><p>和<code>trap</code>一样从用户态切换到内核态时需要保存用户态的执行状态，同样从一个任务切换到另一个任务也需要保存当前任务的执行状态，该任务重新拿到<code>cpu</code>使用权后能够恢复执行状态继续执行。</p><p>实现协作式多任务的关键在于任务主动放弃<code>cpu</code>执行权，用户态的程序会去调用一个<code>sys_yield</code>的系统调用来告诉操作系统我要放弃<code>cpu</code>使用权了，然后操作系统就可以进行任务切换了，所以任务的切换是发生在S态的，任务在操作系统切换完毕后，同样通过<code>_restore</code>回到用户态执行程序，不过此时已经进行了任务切换，所以<code>_restore</code>回到的是切换后的任务。</p><p>所以，任务切换其实是来自两个不同应用在内核中的 <code>Trap</code> 控制流之间的切换。当一个应用 Trap 到 S 模式的操作系统内核中进行进一步处理的时候，我们可以设计一个函数来给Trap 控制流调用，从而进行任务切换。这个函数我们定义为<code>__switch</code></p><p>这个函数表面上就是一个普通的函数调用：在 <code>__switch</code> 返回之后，将继续从调用该函数的位置继续向下执行。但是其间却隐藏着复杂的控制流切换过程。具体来说，调用 <code>__switch</code> 之后直到它返回前的这段时间，原 Trap 控制流 A 会先被暂停并被切换出去， CPU 转而运行另一个应用在内核中的 Trap 控制流 B 。然后在某个合适的时机，原 Trap 控制流 A 才会从某一条 Trap 控制流 C （很有可能不是它之前切换到的 B ）切换回来继续执行并最终返回。</p><p>同样在内核进行切换时我们需要保存任务在内核执行trap时的执行状态，任务从用户态通过trap进入内核态后，内核栈上首先保存了用户态的trap上下文，然后会保存内核在对Trap处理过程中留下的调用栈信息，如下图所示：</p><p><img src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20230811144230318.png" alt="image-20230811144230318"></p><p>任务在切换后还需要回来继续执行，因此需要在执行<code>__switch</code> 函数时保存当前任务的CPU寄存器的信息，这里我们称为任务上下文(<code>Task Context</code>)。每个任务都有自己的任务上下文，每个任务也有自己的内核栈和用户栈空间，所以我们首先需要为每个任务定义内核栈和用户栈。新建一个<code>task.c</code>文件:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TASKS 10   <span class="comment">/* 操作系统支持的最大任务数量 */</span></span></span><br><span class="line"><span class="type">uint8_t</span> KernelStack[MAX_TASKS][KERNEL_STACK_SIZE]; <span class="comment">/* 任务内核栈 */</span></span><br><span class="line"><span class="type">uint8_t</span> UserStack[MAX_TASKS][USER_STACK_SIZE];    <span class="comment">/* 任务用户栈 */</span></span><br></pre></td></tr></table></figure><p>接下来我们来定义<code>TaskContext</code>，在<code>context.h</code>新增如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* S模式的任务上下文 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">reg_t</span> ra;</span><br><span class="line"><span class="type">reg_t</span> sp;</span><br><span class="line"><span class="type">reg_t</span> s0;</span><br><span class="line"><span class="type">reg_t</span> s1;</span><br><span class="line"><span class="type">reg_t</span> s2;</span><br><span class="line"><span class="type">reg_t</span> s3;</span><br><span class="line"><span class="type">reg_t</span> s4;</span><br><span class="line"><span class="type">reg_t</span> s5;</span><br><span class="line"><span class="type">reg_t</span> s6;</span><br><span class="line"><span class="type">reg_t</span> s7;</span><br><span class="line"><span class="type">reg_t</span> s8;</span><br><span class="line"><span class="type">reg_t</span> s9;</span><br><span class="line"><span class="type">reg_t</span> s10;</span><br><span class="line"><span class="type">reg_t</span> s11;</span><br><span class="line">&#125;TaskContext;</span><br></pre></td></tr></table></figure><p>可以看见需要保存的寄存器包括<code>ra</code>寄存器，<code>sp</code>寄存器，<code>s0~s11</code>寄存器，，因为从本质上来讲<code>__switch</code>属于一个函数调用，我们需要遵守riscv的函数调用规范：</p><table><thead><tr><th>寄存器组</th><th>保存者</th><th>功能</th></tr></thead><tbody><tr><td>a0<del>a7（ &#96;x10</del>x17&#96; ）</td><td>调用者保存</td><td>用来传递输入参数。其中的 a0 和 a1 还用来保存返回值。</td></tr><tr><td>t0<del>t6( &#96;x5</del>x7,x28~x31&#96; )</td><td>调用者保存</td><td>作为临时寄存器使用，在被调函数中可以随意使用无需保存。</td></tr><tr><td>s0<del>s11( &#96;x8</del>x9,x18~x27&#96; )</td><td>被调用者保存</td><td>作为临时寄存器使用，被调函数保存后才能在被调函数中使用。</td></tr></tbody></table><p> <code>ra</code> 很重要，它记录了 <code>__switch</code> 函数返回之后应该跳转到哪里继续执行，从而在任务切换完成并 <code>ret</code> 之后能到正确的位置。对于一般的函数而言，Rust&#x2F;C 编译器会在函数的起始位置自动生成代码来保存 <code>s0~s11</code> 这些被调用者保存的寄存器。但 <code>__switch</code> 是一个用汇编代码写的特殊函数，它不会被 Rust&#x2F;C 编译器处理，所以我们需要在 <code>__switch</code> 中手动编写保存 <code>s0~s11</code> 的汇编代码。 不用保存其它寄存器是因为：其它寄存器中，属于调用者保存的寄存器是由编译器在高级语言编写的调用函数中自动生成的代码来完成保存的；还有一些寄存器属于临时寄存器，不需要保存和恢复。</p><p>所以在调用<code>__switch</code>函数进行任务切换时，我们需要将当前任务的这些寄存器保存，然后将下一个要切换的任务的寄存器从拿出来然后完成寄存器替换。</p><p>因此每个任务都有一个保存自己任务上下文的地方，这个地方我们定义为<code>TaskControlBlock</code>，在<code>TaskControlBlock</code>不止可以保存任务的上下文信息，还可以保存任务的运行状态，在新建一个<code>task.h</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TASK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">TaskState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">UnInit, <span class="comment">// 未初始化</span></span><br><span class="line">    Ready, <span class="comment">// 准备运行</span></span><br><span class="line">    Running, <span class="comment">// 正在运行</span></span><br><span class="line">    Exited, <span class="comment">// 已退出</span></span><br><span class="line">&#125;TaskState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TaskState task_state; </span><br><span class="line">    TaskContext task_context; </span><br><span class="line">&#125;TaskControlBlock;</span><br></pre></td></tr></table></figure><p>在task.h文件中我定义了一个<code>TaskControlBlock</code>来保存任务的信息，一个任务的信息包括这个任务的状态和任务上下文的信息，然后在t<code>ask.c</code>中定义一个数组，由此每个任务都有保存自己任务上下文的地方了。任务的状态有4钟：未初始化、准备执行、正在执行、已退出。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span> <span class="title">tasks</span>[<span class="title">MAX_TASKS</span>];</span></span><br></pre></td></tr></table></figure><p>对于当前正在执行的任务的 <code>Trap</code> 控制流，我们用一个名为 <code>current_task_cx_ptr </code>的变量来保存放置当前任务上下文的地址；而用<code>next_task_cx_ptr</code>的变量来保存放置下一个要执行任务的上下文的地址。利用 C 语言的引用来描述的话就是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskContext *current_task_cx_ptr = &amp;tasks[current].task_cx;</span><br><span class="line">TaskContext *next_task_cx_ptr    = &amp;tasks[next].task_cx;</span><br></pre></td></tr></table></figure><p>接下来我们从栈上内容的角度来看<code>__switch</code>的整体流程：</p><p><img src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20230811150744675.png" alt="image-20230811150744675"></p><p>Trap 控制流在调用 <code>__switch</code> 之前就需要明确知道即将切换到哪一条目前正处于暂停状态的 Trap 控制流，因此 <code>__switch</code> 有两个参数，第一个参数代表它自己，第二个参数则代表即将切换到的那条 Trap 控制流。这里我们用上面提到过的 <code>current_task_cx_ptr</code> 和 <code>next_task_cx_ptr</code> 作为代表。在上图中我们假设某次 <code>__switch</code> 调用要从 Trap 控制流 A 切换到 B，一共可以分为四个阶段，在每个阶段中我们都给出了 A 和 B 内核栈上的内容。</p><ul><li>阶段 [1]：在 Trap 控制流 A 调用 <code>__switch</code> 之前，A 的内核栈上只有 Trap 上下文和 Trap 处理函数的调用栈信息，而 B 是之前被切换出去的；</li><li>阶段 [2]：A 在 A 任务上下文空间在里面保存 CPU 当前的寄存器快照；</li><li>阶段 [3]：这一步极为关键，读取 <code>next_task_cx_ptr</code> 指向的 B 任务上下文，根据 B 任务上下文保存的内容来恢复 <code>ra</code> 寄存器、<code>s0~s11</code> 寄存器以及 <code>sp</code> 寄存器。只有这一步做完后， <code>__switch</code> 才能做到一个函数跨两条控制流执行，即 <em>通过换栈也就实现了控制流的切换</em> 。</li><li>阶段 [4]：上一步寄存器恢复完成后，可以看到通过恢复 <code>sp</code> 寄存器换到了任务 B 的内核栈上，进而实现了控制流的切换。这就是为什么 <code>__switch</code> 能做到一个函数跨两条控制流执行。此后，当 CPU 执行 <code>ret</code> 汇编伪指令完成 <code>__switch</code> 函数返回后，任务 B 可以从调用 <code>__switch</code> 的位置继续向下执行。</li></ul><p>从结果来看，我们看到 A 控制流 和 B 控制流的状态发生了互换， A 在保存任务上下文之后进入暂停状态，而 B 则恢复了上下文并在 CPU 上继续执行。</p><p>所以<code>__switch</code>的实现代码如下，新建一个<code>switch.S</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_SN n</span><br><span class="line">    sd s\n, (\n+2)*8(a0)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_SN n</span><br><span class="line">    ld s\n, (\n+2)*8(a1)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __switch</span><br><span class="line">__switch:</span><br><span class="line">    # 阶段 [1]</span><br><span class="line">    # __switch(</span><br><span class="line">    #     current_task_cx_ptr</span><br><span class="line">    #     next_task_cx_ptr</span><br><span class="line">    # )</span><br><span class="line">    # 阶段 [2]</span><br><span class="line">    # save kernel stack of current task</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    # save ra &amp; s0~s11 of current execution</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        SAVE_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # 阶段 [3]</span><br><span class="line">    # restore ra &amp; s0~s11 of next execution</span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        LOAD_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # restore kernel stack of next task</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    # 阶段 [4]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>综上所述，<code>__switch</code>进行了一个换栈的操作，在内核态悄悄地把寄存器地执行状态全部修改了，再次回到用户态执行时，执行的就是另外一个用户程序了。</p><h2 id="2-2-协作式调度"><a href="#2-2-协作式调度" class="headerlink" title="2.2 协作式调度"></a>2.2 协作式调度</h2><p>首先在<code>app.c</code>中封装一下<code>sys_yield()</code>函数:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">sys_yield</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(__NR_sched_yield,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改一下内核的<code>__SYSCALL</code>分发函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __SYSCALL(<span class="type">size_t</span> syscall_id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (syscall_id)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> __NR_write:</span><br><span class="line">            __sys_write(arg1, arg2, arg3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __NR_sched_yield:</span><br><span class="line">            __sys_yield();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unsupported syscall id:%d\n&quot;</span>,syscall_id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sys_yield()</span><br><span class="line">&#123;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__NR_sched_yield</code>定义在<code>os.h</code>中：<code>#define __NR_sched_yield 124</code></p><p>可以看见当用户态程序调用<code>sys_yield()</code>来手动放弃cpu使用权时，内核会去调用一个<code>schedule();</code>的函数来完成任务切换，这个函数我是定义在<code>task.c</code>中的</p><p>来看一下<code>task.c</code>中做了哪些修改：</p><ul><li>首先定义了两个变量，一个用来表示当前的执行的任务号，一个用来表示用户常见的任务数量。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _current = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _top = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>然后定义了一个<code>task_create(void (*task_entry)(void))</code>函数来创建任务，此函数传入的参数为一个函数指针，即用户态的应用程序的地址。在创建任务时我们首先需要为每个任务先构造该任务的trap上下文，包括入口地址和用户栈指针，并将其压入到内核栈顶，然后设置<code>sepc、sstatus、sp</code>寄存器的值。这一步和上一章一样，下一步就是需要为每一个任务构造一个初始的内核的任务上下文，这里会调用一个<code>tcx_init</code>的函数，在这个函数里面我们会初始化任务的任务上下文。再完成<code>trap</code>上下文和任务上下文的构造后会将<code>_top</code>的值加一代表多了一个任务</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_create</span><span class="params">(<span class="type">void</span> (*task_entry)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_top &lt; MAX_TASKS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 对于每个任务先构造该任务的trap上下文，包括入口地址和用户栈指针，并将其压入到内核栈顶*/</span></span><br><span class="line">        TrapContext* cx_ptr = &amp;KernelStack[_top] + KERNEL_STACK_SIZE - <span class="keyword">sizeof</span>(TrapContext);</span><br><span class="line">        <span class="type">reg_t</span> user_sp = &amp;UserStack[_top] + USER_STACK_SIZE;</span><br><span class="line">        <span class="type">reg_t</span> sstatus = r_sstatus();</span><br><span class="line">        <span class="comment">// 设置 sstatus 寄存器第8位即SPP位为0 表示为U模式</span></span><br><span class="line">        sstatus &amp;= (<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        w_sstatus(sstatus);</span><br><span class="line">        <span class="comment">/* 设置用户程序内核栈 ，填充用户栈指针*/</span></span><br><span class="line">        cx_ptr-&gt;sepc = (<span class="type">reg_t</span>)task_entry;</span><br><span class="line">        cx_ptr-&gt;sstatus = sstatus; </span><br><span class="line">        cx_ptr-&gt;sp = user_sp;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 构造每个任务任务控制块中的任务上下文，设置 ra 寄存器为 __restore 的入口地址*/</span></span><br><span class="line">        tasks[_top].task_context = tcx_init((<span class="type">reg_t</span>)cx_ptr);</span><br><span class="line">        <span class="comment">// 初始化 TaskStatus 字段为 Ready</span></span><br><span class="line">        tasks[_top].task_state = Ready;</span><br><span class="line"></span><br><span class="line">        _top++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后定义了一个<code>tcx_init</code>的函数用来初始化创建的任务的任务上下文信息，传入的参数为任务的内核栈地址，这里为啥把任务的<code>ra</code>寄存器的值设置为<code>__restore</code>，那是因为在应用真正跑起来之前，需要 CPU 第一次从内核态进入用户态。我们在上一篇文章中也介绍过实现方法，只需在内核栈上压入构造好的 Trap 上下文，然后 <code>__restore</code> 即可。但是现在我们是通过<code>__switch</code>来进行任务切换的，而<code>__switch</code>切换完成后会返回到<code>ra</code>的地方执行，我们这里第一次将<code>ra</code>设置为<code>__restore</code>，那么程序就可以从内核态切换回用户态执行了，为此我们需要定义一个<code>run_first_task()</code>的函数来完成第一次切换。可以看见在<code>run_first_task()</code>函数中，先构造了一个<code>_unused</code>的任务上下文，然后调用<code>__switch</code>函数让切换到<code>tasks[0]</code>进行执行，用于初始化时<code>tasks[0]</code>的<code>ra</code>被设置成了<code>__restore</code>的地址，所以就能去返回用户态运行<code>task0</code>了。需要注意的是， <code>__restore</code> 的实现需要做出变化：它 不再需要 在开头 <code>mv sp, a0</code> 了。因为在 <code>__switch</code> 之后，<code>sp</code> 就已经正确指向了我们需要的 <code>Trap </code>上下文地址。</li></ul><blockquote><p>这里我有个疑惑，要是正常的<code>trap</code>执行流，从<code>trap_handler</code>返回后去执行<code>__restore</code>函数，此时难道不应该需要&#96;&#96;mv sp, a0<code> 吗，还是说在</code>trap_handler<code>函数中并没有修改栈指针，从代码逻辑上来看确实不会修改栈指针的值，即使由于一些计算操作需要压栈存储局部变量的值，但是</code>trap_handler<code>执行完毕后，</code>sp&#96;会移动到原本的位置。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TaskContext <span class="title function_">tcx_init</span><span class="params">(<span class="type">reg_t</span> kstack_ptr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> <span class="title">task_ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    task_ctx.ra = __restore;</span><br><span class="line">    task_ctx.sp = kstack_ptr;</span><br><span class="line">    task_ctx.s0 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s1 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s2 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s3 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s4 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s5 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s6 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s7 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s8 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s9 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s10 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s11 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task_ctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run_first_task</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    tasks[<span class="number">0</span>].task_state = Running;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> *<span class="title">next_task_cx_ptr</span> =</span> &amp;(tasks[<span class="number">0</span>].task_context);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> _<span class="title">unused</span> ;</span></span><br><span class="line"></span><br><span class="line">    __switch(&amp;_unused,next_task_cx_ptr);</span><br><span class="line">    panic(<span class="string">&quot;unreachable in run_first_task!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后我们来看<code>schedule()</code>函数，首先判断一下创建的任务数量不为0，然后进行轮转调度，如果下一个任务的状态是<code>ready</code>，那么就切换到下一个任务执行，并且将当前任务的状态置为<code>ready</code>，这里其实应该用for循环的，但是用于我在<code>task_create</code>默认任务的状态为<code>ready</code>，所以这里就无所谓了。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_top &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">panic(<span class="string">&quot;Num of task should be greater than zero!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 轮转调度 */</span></span><br><span class="line">    <span class="type">int</span> next = _current + <span class="number">1</span>;</span><br><span class="line">    next = next % _top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tasks[next].task_state == Ready)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> *<span class="title">current_task_cx_ptr</span> =</span> &amp;(tasks[_current].task_context);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> *<span class="title">next_task_cx_ptr</span> =</span> &amp;(tasks[next].task_context);</span><br><span class="line">        tasks[next].task_state = Running;</span><br><span class="line">        tasks[_current].task_state = Ready;</span><br><span class="line">        _current = next;</span><br><span class="line">        __switch(current_task_cx_ptr,next_task_cx_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h2><p>首先在app.c中新建三个应用程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task1 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        task_delay(<span class="number">10000</span>);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task2 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        task_delay(<span class="number">10000</span>);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task3 is running!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        task_delay(<span class="number">10000</span>);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>task_delay</code>函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a very rough implementaion, just to consume the cpu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_delay</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">count *= <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">while</span> (count--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后调用<code>task_create</code>来创建任务：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">task_create(task1);</span><br><span class="line">task_create(task2);</span><br><span class="line">    task_create(task3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改main函数来执行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;hello timer os!\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   trap_init();</span><br><span class="line"><span class="comment">/* 创建任务 */</span></span><br><span class="line">   task_init();</span><br><span class="line"><span class="comment">/* 执行第一个任务 */</span></span><br><span class="line">   run_first_task();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译测试：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p><img src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/GIF-task.gif" alt="GIF-task"></p><p>可以看见三个任务交替执行打印，没问题！</p><p>这里说一个比较难理解的点就是只有第一次执行应用程序A的时候的<code>ra</code>是<code>__restore</code>，当A任务执行完毕<code>__switch</code>后，它的<code>ra</code>就变成了<code>__switch</code>的下一条地址，就是<code>schedule()</code>函数执行完毕了。第二次B任务调用<code>__switch</code>切换回A的时候，此时就会返回到<code>__switch</code>的下一条地址执行，我们是在<code>__sys_yield()</code>中调用<code>schedule</code>的，所以会依次完成函数调用返回，从<code>schedule</code>返回到<code>__sys_yield</code>，再返回到<code>__SYSCALL</code>，最后返回到<code>trap_handler</code>，而在本文开头提到过<code>trap_handler</code>执行完毕后会去执行<code>__restore</code>，所以这样A才能返回到用户空间程序继续执行。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/2task-switching.html">任务切换 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></li><li><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/3multiprogramming.html">多道程序与协作式调度 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现U模式的trap机制</title>
      <link href="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>好久没更新了，最近在摆烂，天天打瓦洛兰特………………..瓦洛兰特是真好玩啊hhhhh</p></blockquote><h1 id="1-测试用户态的syscall"><a href="#1-测试用户态的syscall" class="headerlink" title="1. 测试用户态的syscall"></a>1. 测试用户态的syscall</h1><h2 id="1-1-riscv特权级切换"><a href="#1-1-riscv特权级切换" class="headerlink" title="1.1 riscv特权级切换"></a>1.1 riscv特权级切换</h2><p><code>RISC-V</code> 架构中一共定义了 4 种特权级：</p><table><thead><tr><th>级别</th><th>编码</th><th>名称</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>用户&#x2F;应用模式 (U, User&#x2F;Application)</td></tr><tr><td>1</td><td>01</td><td>监督模式 (S, Supervisor)</td></tr><tr><td>2</td><td>10</td><td>虚拟监督模式 (H, Hypervisor)</td></tr><tr><td>3</td><td>11</td><td>机器模式 (M, Machine)</td></tr></tbody></table><p>其中级别数值越大，特权级越高，对硬件的控制能力越强。之前移植的Opensbi运行在M模式下，S模式下的程序通过ecall指令去调用Opensbi提供的服务，U模式下的程序同样也可通过ecall指令来获取S模式下提供的服务。</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804215308995.png" alt="image-20230804215308995"></p><p>我们编写的os程序就是运行在S态的，向用户态提供的接口标准被称为ABI。用户态应用直接触发从用户态到内核态的异常的原因总体上可以分为两种：其一是用户态软件为获得内核态操作系统的服务功能而执行特殊指令；其二是在执行某条指令期间产生了错误（如执行了用户态不允许执行的指令或者其他错误）并被 CPU 检测到。特权切换的机制如下图：</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804215429736.png" alt="image-20230804215429736"></p><h2 id="1-2-riscv-系统调用简介"><a href="#1-2-riscv-系统调用简介" class="headerlink" title="1.2 riscv 系统调用简介"></a>1.2 riscv 系统调用简介</h2><p>我们知道我们在<code>linux</code>系统下编写的应用程序是去调用C库的函数去实现对应的功能，而C库呢会去使用内核提供的一组接口去访问硬件设备和操作系统资源，这组接口就被称为系统调用。</p><p>在<code>X86</code>平台上，Linux在用<code>int 0x80</code>进行系统调用时，调用号存在于<code>EAX</code>中，第一个参数存在于<code>EBX</code>，第二个参数存在于<code>ECX</code>，第三个参数存在于<code>EDX</code>。而在<code>riscv</code>平台下，系统调用是通过<code>ecall</code>指令来触发的，<code>ecall</code> 指令规范中没有其他的参数，<code>Syscall</code> 的调用参数和返回值传递通过遵循如下约定实现：</p><ul><li>调用参数<ul><li><code>a7</code> 寄存器存放系统调用号，区分是哪个<code> Syscall</code></li><li><code>a0-a5</code> 寄存器依次用来表示 <code>Syscall </code>编程接口中定义的参数</li></ul></li><li>返回值<ul><li><code>a0</code> 寄存器存放 <code>Syscall </code>的返回值</li></ul></li></ul><p><code>ecall </code>指令会根据当前所处模式触发不同的执行环境切换异常：</p><ul><li>in U-mode: environment-call-from-U-mode exception</li><li>in S-mode: environment-call-from-S-mode exception</li><li>in M-mode: environment-call-from-M-mode exception</li></ul><p><code>Syscall</code> 场景下是在 U-mode（用户模式）下执行 <code>ecall</code> 指令，主要会触发如下变更：</p><ul><li>处理器特权级别由 User-mode（用户模式）提升为 Supervisor-mode（内核模式）</li><li>当前指令地址保存到 <code>sepc</code> 特权寄存器</li><li>设置 <code>scause</code> 特权寄存器</li><li>跳转到 <code>stvec</code> 特权寄存器指向的指令地址</li></ul><h2 id="1-3-riscv-系统调用测试"><a href="#1-3-riscv-系统调用测试" class="headerlink" title="1.3 riscv 系统调用测试"></a>1.3 riscv 系统调用测试</h2><p>首先我在<code>test</code>文件夹下新建了一个<code>syscall</code>目录，里面新建了三个文件：</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804112421014.png" alt="image-20230804112421014"></p><p>首先看<code>Makefile</code>:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=riscv64-unknown-elf-gcc</span><br><span class="line"></span><br><span class="line"><span class="section">write:test_write.c syscall.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$^</span>  -o write.out</span><br></pre></td></tr></table></figure><p>很简单就是编译两个源文件，生成<code>write.out</code></p><p>然后是<code>syscall.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stddef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">uintptr_t</span> arg1, <span class="type">uintptr_t</span> arg2, <span class="type">uintptr_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// Move syscall id to a0 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// Move args[0] to a1 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// Move args[1] to a2 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// Move args[2] to a3 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// Perform syscall</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// Move return value to &#x27;ret&#x27; variable</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见在这里定义了一个<code>syscall</code>函数，传入的参数为系统调用号以及三个参数，通过内联汇编的形式将系统调用号写入了<code>a7</code>寄存器，然后将传入的三个参数分别写入了<code>a0,a1,a2</code>寄存器，然后调用<code>ecall</code>指令进入内核的异常处理程序。再调用完成后内核会将返回值放在<code>a0</code>寄存器中。</p><blockquote><p>在这段代码中，”memory” 是一种内联汇编（inline assembly）中的约束（constraint）。内联汇编是一种在C或C++代码中嵌入汇编指令的技术，它允许直接在高级语言中嵌入底层的汇编代码。</p><p>在这里，”memory” 约束告诉编译器该内联汇编代码可能会读取或修改内存中的数据，因此编译器不能对与内存访问相关的操作进行优化或重排。</p><p>为什么需要这个约束呢？因为系统调用（syscall）可能会对内存中的数据进行读取或修改，而编译器在进行代码优化时通常会假设汇编代码不会影响内存中的数据。如果没有加上 “memory” 约束，编译器可能会错误地优化掉对内存的读写操作，导致系统调用出现问题。</p></blockquote><p><code>test_write.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stddef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">uintptr_t</span> arg1, <span class="type">uintptr_t</span> arg2, <span class="type">uintptr_t</span> arg3)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, RISC-V!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="type">int</span> ret = syscall(<span class="number">0x40</span>,<span class="number">1</span>,message, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>,ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是去调用syscall函数去执行系统调用，它传递了四个参数：<code>0x40</code>代表系统调用号64，它是<code>write</code>系统调用的号码，在RISC-V下是用于输出信息到标准输出的；<code>1</code>是标准输出的文件描述符，<code>message</code>是要输出的字符串的地址，<code>len</code>是要输出的字符串的长度。</p><p>我一直想找在<code>RV64</code>的<code>linux</code>系统下的系统调用号是多少的文档，找了一圈找不到，最后没办法只有去看<code>linux</code>源码中的定义，在内核源码的<code>arch/riscv/include/uapi/asm/unistd.h</code>中，如下：</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804120542275.png" alt="image-20230804120542275"></p><p>打开上面红色箭头这个头文件就能找到系统调用号的定义：</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804120647237.png" alt="image-20230804120647237"></p><p>可以看见<code>write</code>的系统调用号是<code>64</code>即<code>0x40</code>。</p><p>编译，然后用qemu运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star/test/syscall$ make</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star/test/syscall$ qemu-riscv64 wirte.out</span><br><span class="line">Hello, RISC-V!</span><br><span class="line">ret:15</span><br></pre></td></tr></table></figure><p>可以看见输出了<code>Hello, RISC-V!</code>，系统调用成功。<code>qemu-riscv64</code>模拟了一个<code>64</code>位的<code>linux</code>系统，所以可以加载<code>elf</code>格式的可执行文件运行。</p><h1 id="2-内核trap机制简介"><a href="#2-内核trap机制简介" class="headerlink" title="2. 内核trap机制简介"></a>2. 内核trap机制简介</h1><p>首先先明确一下我们的目标是用户态的程序通过ecall指令陷入S态即我们的os，os需要对此次ecall进行处理，处理完毕后返回到用户态继续执行。应用程序被切换回来之后需要从发出系统调用请求的执行位置恢复应用程序上下文并继续执行，这需要在切换前后维持应用程序的上下文保持不变。应用程序的上下文包括通用寄存器和栈两个主要部分。由于 CPU 在不同特权级下共享一套通用寄存器，所以在运行操作系统的 Trap 处理过程中，操作系统也会用到这些寄存器，这会改变应用程序的上下文。因此，与函数调用需要保存函数调用上下文&#x2F;活动记录一样，在执行操作系统的 Trap 处理过程（会修改通用寄存器）之前，我们需要在某个地方（某内存块或内核的栈）保存这些寄存器并在 Trap 处理结束后恢复这些寄存器。这里显而易见我们会使用栈来保存相关的寄存器。</p><h2 id="2-1-与S模式相关的异常寄存器"><a href="#2-1-与S模式相关的异常寄存器" class="headerlink" title="2.1 与S模式相关的异常寄存器"></a>2.1 与S模式相关的异常寄存器</h2><p>与特权级无关的一般的指令和通用寄存器 <code>x0</code> ~ <code>x31</code> 在任何特权级都可以执行。而每个特权级都对应一些特殊指令和 <strong>控制状态寄存器</strong> (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态。当然特权指令不仅具有读写 CSR 的指令，还有其他功能的特权指令。</p><p>如果处于低特权级状态的处理器执行了高特权级的指令，会产生非法指令错误的异常。这样，位于高特权级的执行环境能够得知低特权级的软件出现了错误，这个错误一般是不可恢复的，此时执行环境会将低特权级的软件终止。</p><p>在RV64架构下，寄存器的长度是64位。</p><h3 id="2-1-1-Supervisor-Status-Register-sstatus"><a href="#2-1-1-Supervisor-Status-Register-sstatus" class="headerlink" title="2.1.1 Supervisor Status Register (sstatus)"></a>2.1.1 Supervisor Status Register (sstatus)</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804220746499.png" alt="image-20230804220746499"></p><p>这个寄存器我们主要关注的是<code>bit[8]:SPP</code>，该位表示cpu在进入S模式之前正在执行的特权级别。当接收到trap时，如果该trap来自用户模式，则SPP设置为0，否则设置为1。当执行一条SRET指令从trap处理程序返回时，如果SPP位为0，则特权级别被设置为U模式，如果SPP位为1，则特权级别被设置为S模式;SPP设置为0。</p><h3 id="2-1-2-Supervisor-Trap-Vector-Base-Address-Register-stvec"><a href="#2-1-2-Supervisor-Trap-Vector-Base-Address-Register-stvec" class="headerlink" title="2.1.2 Supervisor Trap Vector Base Address Register (stvec)"></a>2.1.2 Supervisor Trap Vector Base Address Register (<code>stvec</code>)</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804221559975.png" alt="image-20230804221559975"></p><p>stvec寄存器用于设置发生trap时，异常处理程序的地址。</p><ul><li>MODE 位于 [1:0]，长度为 2 bits；</li><li>BASE 位于 [63:2]，长度为 62 bits。</li></ul><p>当 MODE 字段为 0 的时候， <code>stvec</code> 被设置为 Direct 模式，此时进入 S 模式的 Trap 无论原因如何，处理 Trap 的入口地址都是 <code>BASE&lt;&lt;2</code> ，CPU 会跳转到这个地方进行异常处理。当 MODE 字段为 1 的时候，异常触发后会跳转到以BASE字段对应的异常向量表钟，每个向量占4个字节。</p><h3 id="2-1-3-Supervisor-Scratch-Register-sscratch"><a href="#2-1-3-Supervisor-Scratch-Register-sscratch" class="headerlink" title="2.1.3 Supervisor Scratch Register (sscratch)"></a>2.1.3 Supervisor Scratch Register (sscratch)</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804222006617.png" alt="image-20230804222006617"></p><p>sscratch寄存器是一个可读&#x2F;写的辅助寄存器，通常，在hart执行用户代码时，sscratch用于切换上下文的栈。</p><h3 id="2-1-4-Supervisor-Exception-Program-Counter-sepc"><a href="#2-1-4-Supervisor-Exception-Program-Counter-sepc" class="headerlink" title="2.1.4 Supervisor Exception Program Counter (sepc)"></a>2.1.4 Supervisor Exception Program Counter (<code>sepc</code>)</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804222155968.png" alt="image-20230804222155968"></p><p>sepc记录了 Trap 发生之前执行的最后一条指令的地址</p><h3 id="2-1-5-Supervisor-Cause-Register-scause"><a href="#2-1-5-Supervisor-Cause-Register-scause" class="headerlink" title="2.1.5 Supervisor Cause Register (scause)"></a>2.1.5 Supervisor Cause Register (<code>scause</code>)</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804222445725.png" alt="image-20230804222445725"></p><p>scause寄存器记录了S模式下异常发生的原因，最高位为<code>interrupt</code>字段，如下表所示，当<code>interrupt</code>字段为1时，代表触发的异常类型为中断类型。否则为同步类型异常。</p><table><thead><tr><th align="right">Interrupt</th><th align="right">Exception Code</th><th align="left">Description</th><th align="left"></th></tr></thead><tbody><tr><td align="right">1</td><td align="right">0</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">1</td><td align="left">Supervisor software interrupt</td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">2–4</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">5</td><td align="left">Supervisor timer interrupt</td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">6–8</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">9</td><td align="left">Supervisor external interrupt</td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">10–15</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">≥16</td><td align="left"><em>Designated for platform use</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">0</td><td align="left">Instruction address misaligned</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">1</td><td align="left">Instruction access fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">2</td><td align="left">Illegal instruction</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">3</td><td align="left">Breakpoint</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">4</td><td align="left">Load address misaligned</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">5</td><td align="left">Load access fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">6</td><td align="left">Store&#x2F;AMO address misaligned</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">7</td><td align="left">Store&#x2F;AMO access fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">8</td><td align="left">Environment call from U-mode</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">9</td><td align="left">Environment call from S-mode</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">10–11</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">12</td><td align="left">Instruction page fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">13</td><td align="left">Load page fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">14</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">15</td><td align="left">Store&#x2F;AMO page fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">16–23</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">24–31</td><td align="left"><em>Designated for custom use</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">32–47</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">48–63</td><td align="left"><em>Designated for custom use</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">≥64</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr></tbody></table><h3 id="2-1-6-Supervisor-Trap-Value-stval-Register"><a href="#2-1-6-Supervisor-Trap-Value-stval-Register" class="headerlink" title="2.1.6 Supervisor Trap Value (stval) Register"></a>2.1.6 Supervisor Trap Value (<code>stval</code>) Register</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804223000840.png" alt="image-20230804223000840"></p><p>当处理器陷入S模式时，stval寄存器记录了发生异常的虚拟地址。</p><blockquote><p>更详细的寄存器解释可在这里看见：</p><p><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html">The RISC-V Instruction Set Manual, Volume II: Privileged Architecture | Five EmbedDev (five-embeddev.com)</a></p></blockquote><h2 id="2-2-特权级切换的软硬件控制机制"><a href="#2-2-特权级切换的软硬件控制机制" class="headerlink" title="2.2 特权级切换的软硬件控制机制"></a>2.2 特权级切换的软硬件控制机制</h2><p>当 CPU 执行完一条指令（如 ecall ）并准备从用户特权级 陷入（ Trap ）到 S 特权级的时候，硬件会自动完成如下这些事情：</p><ul><li><code>sstatus</code> 的 <code>SPP</code> 字段会被修改为 CPU 当前的特权级（U&#x2F;S）。</li><li><code>sepc</code> 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。</li><li><code>scause/stval</code> 分别会被修改成这次 Trap 的原因以及相关的附加信息。</li><li>CPU 会跳转到 <code>stvec</code> 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。这里会根据<code>scause</code>中保存的异常原因进行分发处理</li></ul><p>而当 CPU 完成 Trap 处理准备返回的时候，需要通过一条 S 特权级的特权指令 <code>sret</code> 来完成，这一条指令具体完成以下功能：</p><ul><li>CPU 会将当前的特权级按照 <code>sstatus</code> 的 <code>SPP</code> 字段设置为 U 或者 S ；</li><li>CPU 会跳转到 <code>sepc</code> 寄存器指向的那条指令，然后继续执行。</li></ul><p>在具体执行trap处理程序时，由于执行完毕后我们需要恢复到原来的地址继续执行所以我们需要保存寄存器的值，需要恢复知情trap前后的上下文信息，因此需要定义一个栈段来保存用户态的寄存器的值。所以os需要做的软件工作如下：</p><ul><li>应用程序通过 <code>ecall</code> 进入到内核状态时，操作系统保存被打断的应用程序的 Trap 上下文；</li><li>操作系统根据Trap相关的CSR寄存器内容，完成系统调用服务的分发与处理；</li><li>操作系统完成系统调用服务后，需要恢复被打断的应用程序的Trap 上下文，并通 <code>sret</code> 让应用程序继续执行。</li></ul><h1 id="3-为timer-os实现trap机制"><a href="#3-为timer-os实现trap机制" class="headerlink" title="3. 为timer_os实现trap机制"></a>3. 为timer_os实现trap机制</h1><p>我在os目录下新增了一个types.h的文件，里面声明了一些数据定义类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TYPES_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TYPES_H__</span></span><br><span class="line"><span class="comment">// 定义无符号整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RISCV64: 寄存器的大小是64位的</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> <span class="type">reg_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>rv64</code>的寄存器是<code>64</code>位的，用<code>typedef</code>定义了一个<code>reg_t</code>的类型用于定义使用的寄存器</p><h2 id="3-1-寄存器读写"><a href="#3-1-寄存器读写" class="headerlink" title="3.1 寄存器读写"></a>3.1 寄存器读写</h2><p>我在os的目录下新建了一个riscv.h的文件，此文件中定义了一些获取寄存器值的函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RISCV_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RISCV_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 读取 sepc 寄存器的值 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_sepc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sepc&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* scause 记录了异常原因 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_scause</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, scause&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// stval 记录了trap发生时的地址</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_stval</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stval&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* sstatus记录S模式下处理器内核的运行状态*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_sstatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sstatus&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>  <span class="title function_">w_sstatus</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sstatus, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* stvec寄存器 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>  <span class="title function_">w_stvec</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw stvec, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_stvec</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看见用内联汇编的方式来读写与S态相关的控制寄存器的值。</p><h2 id="3-2-用户栈和内核栈定义"><a href="#3-2-用户栈和内核栈定义" class="headerlink" title="3.2 用户栈和内核栈定义"></a>3.2 用户栈和内核栈定义</h2><p>当应用程序在用户态执行ecall指令陷入内核时，内核需要保存应用程序的各个寄存器的值，在内核中我们可以定义一个栈段来进行保存，同时为了为了安全机制，让用户程序不会干扰到内核栈，我们当用户程序在执行时专门为用户程序分配一段栈。由此需要定义一个内核栈专门给S态的内核使用，专门定义一个用户栈给用户程序使用。我在os目录下新建了一个<code>batch.c</code>的文件，在此文件中定义了<code>KernelStack</code>和<code>UserStack</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USER_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="type">uint8_t</span> KernelStack[KERNEL_STACK_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> UserStack[USER_STACK_SIZE];</span><br></pre></td></tr></table></figure><p><code>KernelStack</code>和<code>UserStack</code>的大小被定义为8kb。</p><h2 id="3-3-Trap上下文执行流定义"><a href="#3-3-Trap上下文执行流定义" class="headerlink" title="3.3 Trap上下文执行流定义"></a>3.3 Trap上下文执行流定义</h2><p>Trap上下文执行流的数据就是寄存器中的数据，有<code>x0~x31</code>总共<code>32</code>个通用寄存器以及<code>sstatus</code>和<code>sepc</code>等控制寄存器需要保存。在os目录下新建了一个<code>context.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CONTEXT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CONTEXT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="comment">/*S模式的trap上下文*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="type">reg_t</span> x0;</span><br><span class="line"><span class="type">reg_t</span> ra;</span><br><span class="line"><span class="type">reg_t</span> sp;</span><br><span class="line"><span class="type">reg_t</span> gp;</span><br><span class="line"><span class="type">reg_t</span> tp;</span><br><span class="line"><span class="type">reg_t</span> t0;</span><br><span class="line"><span class="type">reg_t</span> t1;</span><br><span class="line"><span class="type">reg_t</span> t2;</span><br><span class="line"><span class="type">reg_t</span> s0;</span><br><span class="line"><span class="type">reg_t</span> s1;</span><br><span class="line"><span class="type">reg_t</span> a0;</span><br><span class="line"><span class="type">reg_t</span> a1;</span><br><span class="line"><span class="type">reg_t</span> a2;</span><br><span class="line"><span class="type">reg_t</span> a3;</span><br><span class="line"><span class="type">reg_t</span> a4;</span><br><span class="line"><span class="type">reg_t</span> a5;</span><br><span class="line"><span class="type">reg_t</span> a6;</span><br><span class="line"><span class="type">reg_t</span> a7;</span><br><span class="line"><span class="type">reg_t</span> s2;</span><br><span class="line"><span class="type">reg_t</span> s3;</span><br><span class="line"><span class="type">reg_t</span> s4;</span><br><span class="line"><span class="type">reg_t</span> s5;</span><br><span class="line"><span class="type">reg_t</span> s6;</span><br><span class="line"><span class="type">reg_t</span> s7;</span><br><span class="line"><span class="type">reg_t</span> s8;</span><br><span class="line"><span class="type">reg_t</span> s9;</span><br><span class="line"><span class="type">reg_t</span> s10;</span><br><span class="line"><span class="type">reg_t</span> s11;</span><br><span class="line"><span class="type">reg_t</span> t3;</span><br><span class="line"><span class="type">reg_t</span> t4;</span><br><span class="line"><span class="type">reg_t</span> t5;</span><br><span class="line"><span class="type">reg_t</span> t6;</span><br><span class="line"><span class="comment">/* S模式下的寄存器 */</span></span><br><span class="line"><span class="type">reg_t</span> sstatus;</span><br><span class="line"><span class="type">reg_t</span> sepc;</span><br><span class="line">&#125;pt_regs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="3-4-Trap上下文的保存和恢复"><a href="#3-4-Trap上下文的保存和恢复" class="headerlink" title="3.4 Trap上下文的保存和恢复"></a>3.4 Trap上下文的保存和恢复</h2><p>在os目录下新建了一个<code>kerneltrap.S</code>的文件，此汇编文件中定义了两个函数：<code>__alltraps 、__restore</code>。</p><p>首先来看<code>__alltraps </code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl __alltraps</span><br><span class="line">.align 4</span><br><span class="line">__alltraps:</span><br><span class="line">    # 从sscratch获取S模式下的SP，把U模式下的SP保存到sscratch寄存器中</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    # allocate a TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, -34*8</span><br><span class="line">    # save general-purpose registers</span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    # skip sp(x2), we will save it later</span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    # skip tp(x4), application does not use it</span><br><span class="line">    # save x5~x31</span><br><span class="line">    sd x4, 4*8(sp)</span><br><span class="line">    sd x5, 5*8(sp)</span><br><span class="line">    sd x6, 6*8(sp)</span><br><span class="line">    sd x7, 7*8(sp)</span><br><span class="line">    sd x8, 8*8(sp)</span><br><span class="line">    sd x9, 9*8(sp)</span><br><span class="line">    sd x10,10*8(sp)</span><br><span class="line">    sd x11, 11*8(sp)</span><br><span class="line">    sd x12, 12*8(sp)</span><br><span class="line">    sd x13, 13*8(sp)</span><br><span class="line">    sd x14, 14*8(sp)</span><br><span class="line">    sd x15, 15*8(sp)</span><br><span class="line">    sd x16, 16*8(sp)</span><br><span class="line">    sd x17, 17*8(sp)</span><br><span class="line">    sd x18, 18*8(sp)</span><br><span class="line">    sd x19, 19*8(sp)</span><br><span class="line">    sd x20, 20*8(sp)</span><br><span class="line">    sd x21, 21*8(sp)</span><br><span class="line">    sd x22, 22*8(sp)</span><br><span class="line">    sd x23, 23*8(sp)</span><br><span class="line">    sd x24, 24*8(sp)</span><br><span class="line">    sd x25, 25*8(sp)</span><br><span class="line">    sd x26, 26*8(sp)</span><br><span class="line">    sd x27, 27*8(sp)</span><br><span class="line">    sd x28, 28*8(sp)</span><br><span class="line">    sd x29, 29*8(sp)</span><br><span class="line">    sd x30, 30*8(sp)</span><br><span class="line">    sd x31, 31*8(sp)</span><br><span class="line"></span><br><span class="line">    # we can use t0/t1/t2 freely, because they were saved on kernel stack</span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    # read user stack from sscratch and save it on the kernel stack</span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    # set input argument of trap_handler(TrapContext)</span><br><span class="line">    mv a0, sp</span><br><span class="line">    call trap_handler</span><br></pre></td></tr></table></figure><p><code>__alltraps </code>函数就是发生异常时的处理函数，在此函数中：</p><ul><li>第五行中将sscratch和sp的值进行了交换，在进入此函数时sp指向的是用户栈，sscratch中的值保存的是内核栈的栈顶。进行交换后，由于此时进入了S态，所以需要切换栈，由此就切换到了内核栈。</li><li>然后就是将寄存器的值保存进内核栈中，在上面上下文的定义可以看见pt_regs中定义了34个寄存器，所以通过<code>addi sp, sp, -34*8</code>指令来压栈，然后依次保存寄存器的值</li><li>最后两行将内核栈的sp保存进a0寄存器用于传参，所以将用户态寄存器保存进内核栈后，调用了<code>trap_handler</code>函数，在此函数中可通过a0传入的参数访问内核栈中储存的寄存器的值。</li></ul><p>然后是<code>__restore</code>函数，此函数需要将内核栈中的存储的寄存器的值恢复，然后通过<code>sret</code>指令返回从S态到用户态继续执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl __restore</span><br><span class="line">.align 4</span><br><span class="line">__restore:</span><br><span class="line">    # case1: start running app by __restore</span><br><span class="line">    # case2: back to U after handling trap</span><br><span class="line">    mv sp, a0</span><br><span class="line">    # now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack</span><br><span class="line">    # restore sstatus/sepc</span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    ld t2, 2*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    csrw sscratch, t2</span><br><span class="line">    # restore general-purpuse registers except sp/tp</span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    ld x4, 4*8(sp)</span><br><span class="line">    ld x5, 5*8(sp)</span><br><span class="line">    ld x6, 6*8(sp)</span><br><span class="line">    ld x7, 7*8(sp)</span><br><span class="line">    ld x8, 8*8(sp)</span><br><span class="line">    ld x9, 9*8(sp)</span><br><span class="line">    ld x10,10*8(sp)</span><br><span class="line">    ld x11, 11*8(sp)</span><br><span class="line">    ld x12, 12*8(sp)</span><br><span class="line">    ld x13, 13*8(sp)</span><br><span class="line">    ld x14, 14*8(sp)</span><br><span class="line">    ld x15, 15*8(sp)</span><br><span class="line">    ld x16, 16*8(sp)</span><br><span class="line">    ld x17, 17*8(sp)</span><br><span class="line">    ld x18, 18*8(sp)</span><br><span class="line">    ld x19, 19*8(sp)</span><br><span class="line">    ld x20, 20*8(sp)</span><br><span class="line">    ld x21, 21*8(sp)</span><br><span class="line">    ld x22, 22*8(sp)</span><br><span class="line">    ld x23, 23*8(sp)</span><br><span class="line">    ld x24, 24*8(sp)</span><br><span class="line">    ld x25, 25*8(sp)</span><br><span class="line">    ld x26, 26*8(sp)</span><br><span class="line">    ld x27, 27*8(sp)</span><br><span class="line">    ld x28, 28*8(sp)</span><br><span class="line">    ld x29, 29*8(sp)</span><br><span class="line">    ld x30, 30*8(sp)</span><br><span class="line">    ld x31, 31*8(sp)</span><br><span class="line"></span><br><span class="line">    # release TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, 34*8</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;user stack, sscratch-&gt;kernel stack</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure><ul><li><code>__restore</code>函数的定义为<code>__restore(pt_regs *next)</code>，所以在第一行传入内核栈地址，然后将内核栈中存放的寄存器的值恢复，然后切换sp，最后通过sret返回用户态继续执行</li><li>在最后两行会将<code>sp</code>指向用户栈，<code>sscratch</code>指向内核栈</li></ul><h2 id="3-5-编写应用程序测试"><a href="#3-5-编写应用程序测试" class="headerlink" title="3.5 编写应用程序测试"></a>3.5 编写应用程序测试</h2><h3 id="3-5-1-编写应用程序"><a href="#3-5-1-编写应用程序" class="headerlink" title="3.5.1 编写应用程序"></a>3.5.1 编写应用程序</h3><p>我在<code>batch.c</code>中新增了一段用户代码的程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// Move syscall id to a7 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// Move args[0] to a1 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// Move args[1] to a2 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// Move args[2] to a3 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// Perform syscall</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// Move return value to &#x27;ret&#x27; variable</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testsys</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    syscall(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    syscall(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    syscall(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见在<code>testsys()</code>函数中，调用了三次syscall函数进行测试，每一次传入的参数都不同，仅用于测试。</p><h3 id="3-5-2-trap-c"><a href="#3-5-2-trap-c" class="headerlink" title="3.5.2 trap.c"></a>3.5.2 trap.c</h3><p>在上面的<code>__alltraps</code>函数中，调用了<code>trap_handler</code>函数对异常进行处理，因此我们需要实现此函数，我在os目录下定义了一个<code>trap.c</code>的文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __alltraps(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __restore(pt_regs *next);</span><br><span class="line">pt_regs* <span class="title function_">trap_handler</span><span class="params">(pt_regs* cx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> scause = r_scause() ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cause:%x\n&quot;</span>,scause);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a0:%x\n&quot;</span>,cx-&gt;a0);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a1:%x\n&quot;</span>,cx-&gt;a1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a2:%x\n&quot;</span>,cx-&gt;a2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a7:%x\n&quot;</span>,cx-&gt;a7);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sepc:%x\n&quot;</span>,cx-&gt;sepc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sstatus:%x\n&quot;</span>,cx-&gt;sstatus);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sp:%x\n&quot;</span>,cx-&gt;sp);</span><br><span class="line"></span><br><span class="line">cx-&gt;sepc += <span class="number">8</span>;</span><br><span class="line">__restore(cx);</span><br><span class="line"><span class="keyword">return</span> cx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trap_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置 trap 时调用函数的基地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">w_stvec((<span class="type">reg_t</span>)__alltraps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了两个函数，其中<code>trap_init</code>用于设置<code>stvec</code>寄存器的值，这里是告诉cpu发生异常时处理函数的地址，将其设置为<code>__alltraps</code>的地址。</p><p><code>trap_handler</code>函数中打印了内核栈中储存的寄存器的值，在syscall中对a0,a1,a2,a7寄存器的值进行了修改，这些寄存器的值通过<code>__alltraps</code>函数会保存在内核栈中，然后将内核栈的地址放入a0寄存器中作为函数参数传了出来，因为我们可以在此来进行异常的分发，这里只是打印传入的系统调用参数来验证。在系统调用的逻辑处理完后，需要将sepc 的值+8，然后调用</p><p><code>__restore</code>函数来恢复寄存器的值，同时切换栈指针到用户栈，并通过<code>sret</code>返回到<code>sepc+8</code>的地址处继续执行代码。</p><h3 id="3-5-3-测试代码"><a href="#3-5-3-测试代码" class="headerlink" title="3.5.3 测试代码"></a>3.5.3 测试代码</h3><p>我们直接看代码，再分析逻辑，在<code>batch.c</code>中新增了如下代码：</p><p>代码测试逻辑是：伪造一个内核栈，然后通过<code>__restore</code>函数从S态返回U态进行函数执行，返回的地址设置为testsys()函数的地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __restore(pt_regs *next);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">tasks</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_init_context</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">reg_t</span> user_sp = &amp;UserStack + USER_STACK_SIZE;</span><br><span class="line"></span><br><span class="line">    trap_init();</span><br><span class="line"></span><br><span class="line">    <span class="type">reg_t</span> sstatus = r_sstatus();</span><br><span class="line">    <span class="comment">// 设置 sstatus 寄存器第8位即SPP位为0 表示为U模式</span></span><br><span class="line">    sstatus &amp;= (<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    w_sstatus(sstatus);</span><br><span class="line"></span><br><span class="line">    tasks.sepc = (<span class="type">reg_t</span>)testsys;</span><br><span class="line">    tasks.sstatus = sstatus;</span><br><span class="line">    tasks.sp = user_sp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pt_regs* cx_ptr = &amp;KernelStack[<span class="number">0</span>] + KERNEL_STACK_SIZE - <span class="keyword">sizeof</span>(pt_regs);</span><br><span class="line">    cx_ptr-&gt;sepc = tasks.sepc;</span><br><span class="line">    cx_ptr-&gt;sstatus = tasks.sstatus;</span><br><span class="line">    cx_ptr-&gt;sp = tasks.sp;</span><br><span class="line"></span><br><span class="line">    __restore(cx_ptr); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先得到了用户栈的地址，因为栈是从高地址往低地址向下增长的，所以用户栈的地址为<code>&amp;UserStack + USER_STACK_SIZE</code></li><li>然后调用<code>trap_init</code>函数来设置<code>stvec</code>寄存器的值为<code>__alltraps</code>，这里告诉cpu发生trap时去哪里执行</li><li>然后设置sstatus寄存器的SPP位为0。这是为啥呢？在上面对寄存器的介绍中提到“当执行一条SRET指令从trap处理程序返回时，如果SPP位为0，则特权级别被设置为U模式，如果SPP位为1，则特权级别被设置为S模式;”所以我们为了从S模式返回用户模式去执行testsys()中的代码，我们需要将SPP位设置为0。</li><li>然后就是事先构造一段内核栈，设置<code>sstatus</code>、<code>sepc</code>、<code>sp</code>的值，这里由于下一阶段为用户模式，所以sepc会设置成用户态程序的地址，sp设置为用户栈的地址。</li><li>设置完成后调用<code>__restore</code>函数，让其返回用户态执行程序。</li></ul><h3 id="3-5-4-编译测试"><a href="#3-5-4-编译测试" class="headerlink" title="3.5.4 编译测试"></a>3.5.4 编译测试</h3><p>在<code>main.c</code>中调用<code>app_init_context();</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;hello timer os!\n&quot;</span>);</span><br><span class="line">   app_init_context();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>Makefile</code>，添加新增的源文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SRCS_ASM = \</span><br><span class="line">entry.S \</span><br><span class="line">kerneltrap.S \</span><br><span class="line"></span><br><span class="line">SRCS_C = \</span><br><span class="line">sbi.c \</span><br><span class="line">main.c \</span><br><span class="line"><span class="built_in">printf</span>.c \</span><br><span class="line">batch.c \</span><br><span class="line">trap.c \</span><br></pre></td></tr></table></figure><p><code>Makefile</code>还修改了一个地方</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">os.elf: $&#123;OBJS&#125;</span></span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; -T os.ld -Wl,-Map=os.map -o os.elf <span class="variable">$^</span></span><br><span class="line">$&#123;OBJCOPY&#125; -O binary os.elf os.bin</span><br></pre></td></tr></table></figure><p>这里新增了<code>-Wl,-Map=os.map</code>选项，会在编译时生成一个<code>os.map</code>的符号表用于调试。</p><p>回到<code>timer@DESKTOP-JI9EVEH:~/quard-star$</code>目录，构建执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230805152216059.png" alt="image-20230805152216059"></p><p>可以看见进行系统调用的参数都成功打印，验证成功。cause的值为8，对应上面的异常原因表可以看见是U模式的系统调用。</p><blockquote><p>但是这里有个很奇怪的点就是，每次返回的sepc都是同一个地址，我很奇怪，按道理来说每次syscall都会去调用一次ecall指令，所以sepc应该会被设置成每次syscall的ecall的地址，由于我进行了多次syscall调用sepc会不同，但是实际上每次都sepc都被设置成了同一个ecall的地址。转念一想，编译器确实在处理syscall函数时，其中ecall这条指令的地址始终是不会变的，但是我疑惑为什么将此地址+8后，就能跳到下一条正确的地址执行…………</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>说明一下，我的<code>timer_os</code>其实是在复现并修改<code>rCore</code>，<code>rCore</code>是<code>rust</code>编写的<code>os</code>，我想把它改成c语言的用于个人学习。此篇文章对应的是<code>rCore</code>第二章-批处理系统的内容</p><ul><li><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/index.html">第二章：批处理系统 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></li><li><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html">The RISC-V Instruction Set Manual, Volume II: Privileged Architecture | Five EmbedDev (five-embeddev.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>riscv编译工具链构建说明</title>
      <link href="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="riscv编译工具链构建说明"><a href="#riscv编译工具链构建说明" class="headerlink" title="riscv编译工具链构建说明"></a>riscv编译工具链构建说明</h2><p>构建<code>riscv-gnu-toolchain</code>有几种方式：</p><ul><li>第一种是直接下载源码然后本地编译，然后 <code>make install</code></li><li>第二种如果使用的是<code>ubuntu20</code>，可以直接使用 apt 安装</li><li>第三种就是下载别人已经编译好的文件，然后解压，配置一下工具链路径</li></ul><p>编译器有这几种类型，以64位的编译器为例子，三种不同类型编译器的区别后面会说明</p><ul><li>riscv64-linux-gnu-gcc</li><li>riscv64-unknown-elf-gcc</li><li>riscv64-unknown-linux-gnu-gcc</li></ul><h2 id="源码构建"><a href="#源码构建" class="headerlink" title="源码构建"></a><strong>源码构建</strong></h2><p><code>riscv-gnu-toolchain</code>的官方仓库在：<a href="https://github.com/riscv-collab/riscv-gnu-toolchain">riscv-collab&#x2F;riscv-gnu-toolchain: GNU toolchain for RISC-V, including GCC (github.com)</a>，下载上面的源码，然后按照官方提供的编译命令进行编译安装，但是绝大多数时候是编译不过的，因为官方的源码依赖种的第三方文件我们下载不下来，有一个解决办法就是去<code>gittee</code>镜像上去把对应的包下载然后放进源码种，这样编译是能成功。关于如何在<code>gittee</code>上去下载第三方依赖请各位百度。</p><p>官网提供的编译方式如下：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716140122180.png" alt="image-20230716140122180"></p><p>这里建议直接使用第三种配置编译方式，可以编译生成32位和64位的编译器：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/opt/riscv --enable-multilib</span><br></pre></td></tr></table></figure><blockquote><p>这里使用源码编译太操蛋了，我捣鼓了好久，不推荐</p></blockquote><h2 id="apt-构建"><a href="#apt-构建" class="headerlink" title="apt 构建"></a><strong>apt 构建</strong></h2><p><code>apt</code>构建会比较简单，这里只针对<code>ubuntu20.04</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libc6-riscv64-cross</span><br><span class="line">sudo apt install binutils-riscv64-linux-gnu</span><br><span class="line">sudo apt install gcc-riscv64-linux-gnu</span><br><span class="line">sudo apt install binutils-riscv64-unknown-elf</span><br><span class="line">sudo apt install gcc-riscv64-unknown-elf</span><br></pre></td></tr></table></figure><p>执行上面的命令会生成两种类型的编译器：</p><ul><li>riscv64-linux-gnu-gcc</li><li>riscv64-unknown-elf-gcc</li></ul><p>但是<code>riscv64-unknown-elf-gcc</code>这个编译器是不含c库的，比如你的代码种如果包含了<code>stdio.h</code>想使用<code>printf</code>函数就会报错。不推荐使用<code>apt install</code>安装的<code>riscv64-unknown-elf-gcc</code>编译器。</p><p><code>riscv64-linux-gnu-gcc</code>，使用这个编译器就可以使用C库了，例如我有下面这样一段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用编译器来编译：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc hello.c</span><br></pre></td></tr></table></figure><p>然后使用<code>qemu</code>来执行</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-riscv64 a.out</span><br></pre></td></tr></table></figure><p>这里应该会报一个错误：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-riscv64: Could not open <span class="string">&#x27;/lib/ld-linux-riscv64-lp64.d.so.1&#x27;</span>:No such file or direcyory</span><br></pre></td></tr></table></figure><p>没找到文件的原因是，因为文件下载的地方，和查找的地方不一样，只要把文件cp一下就可以了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /usr/riscv64-linux-gnu/lib/* /lib/</span><br></pre></td></tr></table></figure><p>然后再运行应该就没问题了。</p><h2 id="下载二进制文件构建"><a href="#下载二进制文件构建" class="headerlink" title="下载二进制文件构建"></a><strong>下载二进制文件构建</strong></h2><p>进入<code>riscv-gnu-toolchain</code>的<code>github</code>仓库，找到右边的<code>tags</code></p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143145875.png" alt="image-20230716143145875"></p><p>点击进入：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143217518.png" alt="image-20230716143217518"></p><p>可以看见这里有已经编译好的二进制文件，截至我打开的时候，最新的版本是2023.07.07，点击进入</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143310196.png" alt="image-20230716143310196"></p><p>这里有已经编译好的编译器，分别对应不同的ubuntu版本，有32位和64位两个版本的。</p><p>其中<code>riscv64-elf-ubuntu-20.04-gcc-nightly-2023.07.07-nightly.tar.gz</code>解压后的编译器就是：<code>riscv64-unknown-elf-gcc</code>，<strong>但是官方编译的版本是带C库的</strong>。</p><p><code>riscv64-glibc-ubuntu-20.04-llvm-nightly-2023.07.07-nightly.tar.gz</code>解压后的编译器是：<code>riscv64-unknown-linux-gnu-gcc</code>，假设你用这个编译器去编译上面的<code>hello.c</code>文件，编译是没问题的，但是如果你使用<code>qemu-riscv64 a.out</code>去执行，同样会报错误：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> qemu-riscv64: Could not open <span class="string">&#x27;/lib/ld-linux-riscv64-lp64.d.so.1&#x27;</span>:No such file or direcyory</span><br></pre></td></tr></table></figure><p>同样我们也想到可以将这个编译器的<code>lib</code>文件拷贝过去，但是我在它的<code>lib</code>种却找不到这个动态库，如下：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716144055264.png" alt="image-20230716144055264"></p><p>如果说你拷贝了<code>riscv64-linux-gnu-gcc</code>,那么这里执行应该不会报错。</p><blockquote><p>riscv的编译工具链真的很操蛋！！！！！！！！！！</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://blog.csdn.net/bebebug/article/details/127829361">qemu-riscv64: could not open ‘&#x2F;lib&#x2F;ld-linux-riscv64-lp64d.so.1‘_qemu-x86_64: could not open ‘&#x2F;lib64&#x2F;ld-linux-x86-6_嵌入一下？的博客-CSDN博客</a></p></li><li><p><a href="https://blog.csdn.net/Longyu_wlz/article/details/109150134">(69条消息) qemu 运行 riscv 内核失败记录_longyu_wlz的博客-CSDN博客</a></p></li><li><p><a href="https://gitee.com/unicornx/riscv-operating-system-mooc/issues/I4D6N9">stdio.h 头文件找不到 · Issue #I4D6N9 · unicornx&#x2F;riscv-operating-system-mooc - Gitee.com</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> riscv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装printf函数</title>
      <link href="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/"/>
      <url>/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-可变参数"><a href="#1-可变参数" class="headerlink" title="1. 可变参数"></a>1. 可变参数</h1><h2 id="1-1-可变参数的使用"><a href="#1-1-可变参数的使用" class="headerlink" title="1.1 可变参数的使用"></a>1.1 可变参数的使用</h2><p>在实现<code>printf</code>函数之前，我们必须先了解以下在可变参数是如何实现的，在C语言标准库中，可变参数是通过如下几个函数或者宏定义来实现的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va_list；</span><br><span class="line">va_start(ap,v);</span><br><span class="line">va_arg(ap,type)</span><br><span class="line">va_end(ap)</span><br></pre></td></tr></table></figure><p>先举一个在x86架构下使用可变参数的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStrings</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* str = va_arg(args, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    printStrings(<span class="number">3</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码就会打印：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">!</span><br></pre></td></tr></table></figure><p><code>va_list</code>的使用方法：</p><ul><li><p>首先在函数中定义一个具有<code>va_list</code>型的变量，这个变量是指向参数的指针。</p></li><li><p>然后用<code>va_start</code>宏初始化变量刚定义的<code>va_list</code>变量，使其指向第一个可变参数的地址。</p></li><li><p>然后<code>va_arg</code>返回可变参数，<code>va_arg</code>的第二个参数是你要返回的参数的类型（如果多个可变参数，依次调用<code>va_arg</code>获取各个参数）。</p></li><li><p>最后使用<code>va_end</code>宏结束可变参数的获取。</p></li></ul><p>在使用<code>va_list</code>是应该注意以下问题：</p><ul><li><p>可变参数的类型和个数完全由代码控制，<strong>它并不能智能地识别不同参数的个数和类型</strong>，正因为如此所以在上面的测试打印代码中我们需要传入一个参数的count值：3</p></li><li><p>如果我们不需要一一详解每个参数，只需要将可变列表拷贝到某个缓冲区，可以用vsprintf函数。</p></li><li><p>因为编译器对可变参数的函数原型检查不够严格，对编程查错不利，不利于我们写出高质量的代码</p></li></ul><h2 id="1-2-可变参数在不同架构下的体现"><a href="#1-2-可变参数在不同架构下的体现" class="headerlink" title="1.2 可变参数在不同架构下的体现"></a>1.2 可变参数在不同架构下的体现</h2><p>首先我们来看一下在i386架构下的一个可变参数的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将可变参数全部入栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"><span class="comment">//在32位系统栈帧分配的单元大小是4字节(一个参数占4字节)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap,v) (ap = (va_list)&amp;v )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap,t) (*(t*)(ap += sizeof(t *)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap = (va_list)0)   <span class="comment">//直接将va_list 置为空指针</span></span></span><br></pre></td></tr></table></figure><p>在32位x86架构下ABI的规定中函数的参数会被依次入栈，从右往左依次压入栈中，因此可变参数的实现可以以上面的形式实现，va_start指向的是第一个参数的地址，由于参数依次排列在栈中，所以其余的参数可以依次取出来，32位的栈帧的单元大小是4字节。</p><p>所以上面的测试代码在i386架构下参数的排列方式如下：参数1就是 count：3</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714125352038.png" alt="image-20230714125352038"></p><p>我们来做个测试验证以下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">//将可变参数全部入栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* Va_list;</span><br><span class="line"><span class="comment">//在64位系统栈帧分配的单元大小是8字节(一个参数占8字节)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Va_start(ap,v) (ap = (Va_list)&amp;v )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Va_arg(ap,t) (*(t*)(ap += sizeof(t *)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Va_end(ap) (ap = (Va_list)0)   <span class="comment">//直接将Va_list 置为空指针</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_str</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1 <span class="comment">//i386</span></span></span><br><span class="line">    <span class="comment">/*这里就是复现上面可变参数的逻辑*/</span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;count;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(<span class="type">int</span> *)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// riscv64</span></span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;fmt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">int</span>*)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**) * <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s1 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span> * s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s3 = <span class="string">&quot;fuck you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s4 = <span class="string">&quot;riscv&quot;</span>;</span><br><span class="line">    print_str(s1,s2,s3,s4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后用<code>qemu-i386</code>运行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -O0 -m32   va_list.c -o i386.out</span><br><span class="line">qemu-i386 i386.out</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714130132793.png" alt="image-20230714130132793"></p><p>可以看见正常答应所有的参数，证明在i386架构下参数是依次排列在栈中的，至于我为什么要打印“fuck you riscv”等下就会知道啦哈哈哈。</p><p>所以在32为X86架构下我们可以自己实现一个可变参数宏，但是我们的quard_star是64位的riscv架构，函数参数在栈中的排布是和编译器息息相关的，为了方便测试，我们建立如下文件夹：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714130510136.png" alt="image-20230714130510136"></p><p>其中<code>va_list.c</code>做了一点修改：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_str</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;fmt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;fmt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**) * <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> * s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s3 = <span class="string">&quot;fuck you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s4 = <span class="string">&quot;riscv&quot;</span>;</span><br><span class="line">    print_str(s1,s2,s3,s4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.c先不管，<code>build.sh</code>的内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -O0 -m32   va_list.c -o i386.out</span><br><span class="line">riscv64-unknown-elf-gcc -O0 va_list.c -o riscv64.out</span><br><span class="line">riscv32-unknown-elf-gcc -O0   va_list.c -o riscv32.out</span><br><span class="line"></span><br><span class="line">objdump -D i386.out &gt; i386_debug.txt</span><br><span class="line">riscv64-unknown-elf-objdump -D riscv64.out &gt; riscv64_debug.txt</span><br><span class="line">riscv32-unknown-elf-objdump -D riscv32.out &gt; riscv32_debug.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  qemu-i386 i386.out</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  qemu-riscv64 riscv64.out</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  qemu-riscv32 riscv32.out</span></span><br></pre></td></tr></table></figure><p>可以看见会分别把<code>va_list.c</code>编译成I386架构、riscv32架构、riscv64架构的可执行程序，然后将可执行程序反汇编输出到各自的.txt文件中。</p><p>我们来<code>qemu-i386 i386.out</code>，可以看见正常输出没问题：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714132744656.png" alt="image-20230714132744656"></p><p>如果riscv64架构下编译器也把函数参数一个个依次排放在栈中，那么执行的结果肯定和i386一样，ok，我们<code>qemu-riscv64 riscv64.out</code>运行一下。</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714132823543.png" alt="image-20230714132823543"></p><p>可以看见除了第一个参数正常输出了，后面的直接报错了。这是为啥呢，我们来看一下生成的汇编代码，打开<code>riscv64_debug.txt</code>，找到<code>main</code>函数和<code>print_str</code>函数</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714133334185.png" alt="image-20230714133334185"></p><p>可以看见在main函数中将4个函数参数分别放进了a0,a1,a2,a3寄存器，这是riscv的ABI规定的：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714133447075.png" alt="image-20230714133447075"></p><p>a0~a7用于函数传参，然后我们找到<code>print_str</code>函数：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714133548385.png" alt="image-20230714133548385"></p><p>在<code>print_str</code>函数的栈帧中，可以看见编译器将a0放在了栈中一个奇怪的位置，这里的a0中存的就是第一个参数，后面三个参数的值是依次排放的，ok我们来做一下测试：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_str</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;fmt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">//riscv64</span></span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;fmt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**) * <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> * s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s3 = <span class="string">&quot;fuck you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s4 = <span class="string">&quot;riscv&quot;</span>;</span><br><span class="line">    print_str(s1,s2,s3,s4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中我在获取第一个参数后，在获取第二个参数时：<code>ap += sizeof(char**) * 6;</code>，将偏移量乘了6，那是因为在上面汇编代码中，我们发现a0和a1在栈中的偏移量是48个字节，在64位系统中栈帧每个单元为8个字节，因此乘以六刚刚好可以访问到。运行看一下结果：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714134132200.png" alt="image-20230714134132200"></p><p>正常输出没问题，因此在riscv64下编译器有自己的一套存放参数的方式，我无法自己实现一个类似i386架构下的可变参数宏，不知道写编译器的人做了哪些操作，我去看源码里riscv架构也没定义va_list宏。可以看看这篇博客：</p><p><a href="https://blog.csdn.net/guoqx/article/details/128510503">编程参考 - va_list的定义问题_va_list 头文件_夜流冰的博客-CSDN博客</a></p><h1 id="2-实现printf函数"><a href="#2-实现printf函数" class="headerlink" title="2. 实现printf函数"></a>2. 实现printf函数</h1><p>由于printf函数需要用到可变参数，但是上面的分析中不知道如何在riscv64下实现自己的va_list系列的宏，那我们就只有使用编译器提供的了</p><p>先看一下os目录下新增了哪些文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star/os$ <span class="built_in">ls</span></span><br><span class="line">Makefile  entry.S  main.c  os.h  os.ld  printf.c  sbi.c  sbi.h</span><br></pre></td></tr></table></figure><p><code>os.h</code>：用extern声明了两个函数，包含了<code>&lt;stdarg.h&gt;</code>头文件，这里有可变参数相关的宏</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OS_H__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* printf */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span>  <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __OS_H__ */</span></span></span><br></pre></td></tr></table></figure><p><code>printf.c</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_puts</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (*s) &#123;</span><br><span class="line">sbi_console_putchar(*s++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _vsnprintf(<span class="type">char</span> * out, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> format = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> longarg = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; *s; s++) &#123;</span><br><span class="line"><span class="keyword">if</span> (format) &#123;</span><br><span class="line"><span class="keyword">switch</span>(*s) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: &#123;</span><br><span class="line">longarg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: &#123;</span><br><span class="line">longarg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: &#123;</span><br><span class="line"><span class="type">long</span> num = longarg ? va_arg(vl, <span class="type">long</span>) : va_arg(vl, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> hexdigits = <span class="number">2</span>*(longarg ? <span class="keyword">sizeof</span>(<span class="type">long</span>) : <span class="keyword">sizeof</span>(<span class="type">int</span>))<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = hexdigits; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="type">int</span> d = (num &gt;&gt; (<span class="number">4</span>*i)) &amp; <span class="number">0xF</span>;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = (d &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+d : <span class="string">&#x27;a&#x27;</span>+d<span class="number">-10</span>);</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">longarg = <span class="number">0</span>;</span><br><span class="line">format = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: &#123;</span><br><span class="line"><span class="type">long</span> num = longarg ? va_arg(vl, <span class="type">long</span>) : va_arg(vl, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">num = -num;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> digits = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> nn = num; nn /= <span class="number">10</span>; digits++);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = digits<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos + i &lt; n) &#123;</span><br><span class="line">out[pos + i] = <span class="string">&#x27;0&#x27;</span> + (num % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">num /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos += digits;</span><br><span class="line">longarg = <span class="number">0</span>;</span><br><span class="line">format = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s2 = va_arg(vl, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line"><span class="keyword">while</span> (*s2) &#123;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = *s2;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">s2++;</span><br><span class="line">&#125;</span><br><span class="line">longarg = <span class="number">0</span>;</span><br><span class="line">format = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: &#123;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = (<span class="type">char</span>)va_arg(vl,<span class="type">int</span>);</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">longarg = <span class="number">0</span>;</span><br><span class="line">format = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">format = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = *s;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (out &amp;&amp; n) &#123;</span><br><span class="line">out[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> out_buf[<span class="number">1000</span>]; <span class="comment">// buffer for _vprintf()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _vprintf(<span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br><span class="line"><span class="keyword">if</span> (res+<span class="number">1</span> &gt;= <span class="keyword">sizeof</span>(out_buf)) &#123;</span><br><span class="line">uart_puts(<span class="string">&quot;error: output string size overflow\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br><span class="line">uart_puts(out_buf);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">va_list vl;</span><br><span class="line">va_start(vl, s);</span><br><span class="line">res = _vprintf(s, vl);</span><br><span class="line">va_end(vl);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;panic: &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码抄的是<a href="https://github.com/plctlab/riscv-operating-system-mooc/tree/main">plctlab&#x2F;riscv-operating-system-mooc: 《从头写一个RISC-V OS》课程配套的资源 (github.com)</a>里的代码，简单说一下实现<code>printf</code>函数的逻辑，</p><p>一般来说printf函数有多个参数，其中第一个参数为一个字符串，后面的可变参数是为了对应到如<code>%d,%s,%c</code>等格式化性质，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arg1:%d arg2:%s&quot;</span>,<span class="number">5</span>,<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>所以printf函数的定义形式为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br></pre></td></tr></table></figure><p>根据上面的代码来分析，首先定义printf函数:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">va_list vl;</span><br><span class="line">va_start(vl, s);</span><br><span class="line">res = _vprintf(s, vl);</span><br><span class="line">va_end(vl);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的res实际上是第一个参数的字符串的长度，核心的函数为<code>_vprintf</code>，代码中将第一个参数的指针即<code>va_list vl;</code>和第一个参数实际的值传给了_vprintf</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> out_buf[<span class="number">1000</span>]; <span class="comment">// buffer for _vprintf()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _vprintf(<span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br><span class="line"><span class="keyword">if</span> (res+<span class="number">1</span> &gt;= <span class="keyword">sizeof</span>(out_buf)) &#123;</span><br><span class="line">uart_puts(<span class="string">&quot;error: output string size overflow\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br><span class="line">uart_puts(out_buf);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在_vprintf函数中首先先执行可一段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br></pre></td></tr></table></figure><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714153025258.png" alt="image-20230714153025258"></p><p>分析一下发现这里会返回printf函数第一个参数的长度，比如：<code>printf(&quot;arg:%s&quot;,&quot;hello&quot;)</code>,那么res的值就是<code>&quot;arg:%s&quot;</code>的长度即6。然后判断一下是否超过最大长度。然后再调用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br></pre></td></tr></table></figure><p><code>_vsnprintf</code>就是用来对字符串进行格式化的，通过判断第一个参数里<code>%</code>的个数来确定可变参数的个数，详细的实现可以看上面代码。</p><p><code>main.c</code>:比较简单，就是调用printf函数来输出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;hello timer os!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Makefile</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SRCS_C = \</span><br><span class="line">sbi.c \</span><br><span class="line">main.c \</span><br><span class="line">printf.c \</span><br><span class="line">#加一行</span><br></pre></td></tr></table></figure><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714154140591.png" alt="image-20230714154140591"></p><p>成功打印！</p><p>如果发现编译错误，在makefile里加一个编译命令：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = -nostdlib -fno-builtin -mcmodel=medany</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://blog.csdn.net/guoqx/article/details/128510503"> 编程参考 - va_list的定义问题_va_list 头文件_夜流冰的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/124197544"> riscv代码调试遇到过的问题及坑___pop_的博客-CSDN博客</a></li><li><a href="https://www.cnblogs.com/qiwu1314/p/9844039.html">va_list函数学习 - 小雨滴答 - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/119185091">risc-v与SBI与ABI_sbi 操作系统___pop_的博客-CSDN博客</a></li><li><a href="https://softwareengineering.stackexchange.com/questions/232838/what-is-the-underlying-mechanism-behind-va-list-and-where-is-it-defined">c - What is the underlying mechanism behind va_list and where is it defined? - Software Engineering Stack Exchange</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> opensbi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Opensbi服务完成控制台输出</title>
      <link href="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/"/>
      <url>/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中我们移植了Opensbi，大概了解了Opensbi是用来干嘛的，这一篇文章我们来详细介绍一下RISC-V Supervisor Binary Interface，即SBI。并且开启手写操作系统之路，首先利用Opensbi提供的服务来是实现串口打印。</p><h1 id="1-RISC-V-Supervisor-Binary-Interface"><a href="#1-RISC-V-Supervisor-Binary-Interface" class="headerlink" title="1. RISC-V Supervisor Binary Interface"></a>1. RISC-V Supervisor Binary Interface</h1><p>SBI允许在所有RISC-V实现上，通过定义平台（或虚拟化管理程序）特定功能的抽象，使监管者模式（S模式或VS模式）的软件具备可移植性。简单来说就是RISCV官方定义了一个规范接口，运行在S模式或VS模式的软件如os可以使用这些标准接口使得能够在不同的硬件平台上具有良好的移植性而不用去适配。SBI有两种架构，一种是CPU未启动虚拟化拓展，一种是启动了虚拟化功能的CPU。</p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710111828688.png" alt="image-20230710111828688"></p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710111842503.png" alt="image-20230710111842503"></p><p>如上图，SBI就是M模式和S模式之间的桥梁，是一套接口规范，我们已未启动虚拟化即未支持H拓展的CPU为例子。Opensbi就是上图中的SEE，向上给OS提供了接口，这些接口可以认为是不同的SBI函数，通过ecall指令来进行调用。所有的SBI函数共享一种二进制编码方式。</p><p>sbi规范到现在已经有两个大版本：v0.1 v0.2。为了保持兼容性，SBI扩展ID（EID）和SBI函数ID（FID）被编码为有符号的32位整数。新版本为0.2，在0.2版本中，函数调用的规定如下：</p><ul><li><p>在监管者和SEE之间，使用ECALL作为控制传输指令，监管者就是S模式的软件程序</p></li><li><p>a7编码SBI扩展ID（EID）</p></li><li><p>a6编码SBI函数ID（FID），对于任何在a7中编码的SBI扩展，其定义在SBI v0.2之后。</p></li><li><p>在SBI调用期间，除了a0和a1寄存器外，所有寄存器都必须由被调用方保留。</p></li><li><p>SBI函数必须在a0和a1中返回一对值，其中a0返回错误代码。类似于返回C结构体。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">long</span> error;</span><br><span class="line"> <span class="type">long</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>错误类型</th><th>值</th></tr></thead><tbody><tr><td>SBI_SUCCESS 成功</td><td>0</td></tr><tr><td>SBI_ERR_FAILED 失败</td><td>-1</td></tr><tr><td>SBI_ERR_NOT_SUPPORTED 不支持操作</td><td>-2</td></tr><tr><td>SBI_ERR_INVALID_PARAM 非法参数</td><td>-3</td></tr><tr><td>SBI_ERR_DENIED 拒绝</td><td>-4</td></tr><tr><td>SBI_ERR_INVALID_ADDRESS 非法地址</td><td>-5</td></tr><tr><td>SBI_ERR_ALREADY_AVAILABLE (资源)已可用</td><td>-6</td></tr><tr><td>SBI_ERR_ALREADY_STARTED (操作)已启动</td><td>-7</td></tr><tr><td>SBI_ERR_ALREADY_STOPPED (操作)已停止</td><td>-8</td></tr></tbody></table><p>EID和FID共同决定了调用的函数是什么，其中基本拓展函数如下：EID都为0x10</p><table><thead><tr><th>函数名</th><th>SBI 版本</th><th>FID</th><th>EID</th><th>用途</th></tr></thead><tbody><tr><td>sbi_get_sbi_spec_version</td><td>0.2</td><td>0</td><td>0x10</td><td>获取SBI规范版本</td></tr><tr><td>sbi_get_sbi_impl_id</td><td>0.2</td><td>1</td><td>0x10</td><td>获取SBI实现标识符</td></tr><tr><td>sbi_get_sbi_impl_version</td><td>0.2</td><td>2</td><td>0x10</td><td>获取SBI实现版本</td></tr><tr><td>sbi_probe_extension</td><td>0.2</td><td>3</td><td>0x10</td><td>探测SBI扩展功能</td></tr><tr><td>sbi_get_mvendorid</td><td>0.2</td><td>4</td><td>0x10</td><td>获取机器供应商标识符</td></tr><tr><td>sbi_get_marchid</td><td>0.2</td><td>5</td><td>0x10</td><td>获取机器体系结构标识符</td></tr><tr><td>sbi_get_mimpid</td><td>0.2</td><td>6</td><td>0x10</td><td>获取机器实现标识符ID</td></tr></tbody></table><p>传统的 SBI 扩展与 SBI v0.2（或更高版本）规范相比，遵循略微不同的调用约定，其中：</p><ul><li>a6 寄存器中的 SBI 函数ID 字段被忽略，因为这些被编码为多个 SBI 扩展 ID。</li><li>a1寄存器中不返回任何值。</li><li>在 SBI 调用期间，除 a0 寄存器外的所有寄存器都必须由被调用者保留。</li><li>a0 寄存器中返回的值是特定于 SBI 传统扩展的。</li><li>SBI 实现在监管者访问内存时发生的页面和访问故障会被重定向回监管者，并且 sepc 寄存器指向故障的 ECALL指令。</li></ul><table><thead><tr><th>函数名</th><th>SBI 版本</th><th>FID</th><th>EID</th><th>替代 EID</th><th>函数用途</th></tr></thead><tbody><tr><td>sbi_set_timer</td><td>0.1</td><td>0</td><td>0x00</td><td>0x54494D45</td><td>设置时钟</td></tr><tr><td>sbi_console_putchar</td><td>0.1</td><td>0</td><td>0x01</td><td>N&#x2F;A</td><td>控制台字符输出</td></tr><tr><td>sbi_console_getchar</td><td>0.1</td><td>0</td><td>0x02</td><td>N&#x2F;A</td><td>控制台字符输入</td></tr><tr><td>sbi_clear_ipi</td><td>0.1</td><td>0</td><td>0x03</td><td>N&#x2F;A</td><td>清除IPI</td></tr><tr><td>sbi_send_ipi</td><td>0.1</td><td>0</td><td>0x04</td><td>0x735049</td><td>发送IPI</td></tr><tr><td>sbi_remote_fence_i</td><td>0.1</td><td>0</td><td>0x05</td><td>0x52464E43</td><td>远程FENCE.I</td></tr><tr><td>sbi_remote_sfence_vma</td><td>0.1</td><td>0</td><td>0x06</td><td>0x52464E43</td><td>远程SFENCE.VMA</td></tr><tr><td>sbi_remote_sfence_vma_asid</td><td>0.1</td><td>0</td><td>0x07</td><td>0x52464E43</td><td>远程SFENCE.VMA（指定地址空间标识符）</td></tr><tr><td>sbi_shutdown</td><td>0.1</td><td>0</td><td>0x08</td><td>0x53525354</td><td>系统关闭</td></tr><tr><td>保留</td><td></td><td></td><td>0x09-0x0F</td><td></td><td></td></tr></tbody></table><p>我们使用到的sbi的函数不多，初步了解这些就够了，sbi的所有的详细规范定义请参考如下文档：</p><ul><li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">riscv-sbi-doc</a></li><li><a href="https://zhuanlan.zhihu.com/p/634337322">RISC-V SBI-1.0.0版本 中文 - 知乎 (zhihu.com)</a></li></ul><h1 id="2-基于Opensbi完成控制台输出"><a href="#2-基于Opensbi完成控制台输出" class="headerlink" title="2. 基于Opensbi完成控制台输出"></a>2. 基于Opensbi完成控制台输出</h1><p>目标：在S模式下使用<code>ecall</code>指定调用<code>sbi_console_putchar</code>函数向控制台打印字符</p><h2 id="2-1-untrusted-domain-起始地址修改"><a href="#2-1-untrusted-domain-起始地址修改" class="headerlink" title="2.1 untrusted-domain 起始地址修改"></a>2.1 untrusted-domain 起始地址修改</h2><p>在上一篇文章中，我们为<code>quard_star</code>划分了<code>domain</code>，<code>opensbi</code>是运行在<code>untrusted-domain</code>中的，在<code>quard_star</code>的设备树文件中指定了两个<code>domain</code>的地址参数：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">next-arg1 = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x82200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">next-addr</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x82000000</span>&gt;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure><p>这两个参数一个是下级程序的参数，一个是下级程序的起始地址，在前面提到我们的下级程序是uboot也可以直接是内核，为了使这个项目更有意义，我们来手写一个操作系统，就不使用uboot和linux系统了，关于如何移植uboot和linux内核请按照第一篇中参考博客中的方法继续走下去。在我的代码仓库中也移植成功了，可以参考一下移植uboot的commit。</p><blockquote><p>这里需要说明一下在移植uboot时，使用riscv64-unknown-elf-gcc这个编译器是不行的，编译uboot需要riscv64-unknown-linux-gnu-gcc，关于交叉编译工具链的编译配置这里我就不详解了，网上有许多教程。我的项目中使用的uboot版本为<code>uboot-2023.04</code></p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710135412615.png" alt="image-20230710135412615"></p></blockquote><p>因此下级程序即为我们编写的OS，这里修改一下下级程序的地址和参数，将下级程序的起始地址改成了<code>0x80200000</code>，下级程序的参数随便给，这里先留着不修改吧</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next-arg1 = &lt;0x0 0x82000000&gt;; </span><br><span class="line">next-addr = &lt;0x0 0x80200000&gt;; </span><br></pre></td></tr></table></figure><h2 id="2-2-创建OS"><a href="#2-2-创建OS" class="headerlink" title="2.2 创建OS"></a>2.2 创建OS</h2><p>在quard_star目录下新建os文件夹，在此文件夹中编写我们的操作系统程序，然后新建了这些文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star/os$ <span class="built_in">ls</span></span><br><span class="line">Makefile   entry.S  main.c  os.ld  sbi.c  sbi.h</span><br></pre></td></tr></table></figure><h3 id="2-2-1-entry-S"><a href="#2-2-1-entry-S" class="headerlink" title="2.2.1 entry.S"></a>2.2.1 entry.S</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     .section .text.entry</span><br><span class="line">     .globl _start</span><br><span class="line">_start:</span><br><span class="line">    la sp, boot_stack_top</span><br><span class="line">    call os_main</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:</span><br></pre></td></tr></table></figure><p>这段代码主要就是定义了一个大小为 4096 * 16 字节 &#x3D; 64kb的连续内存空间，用作栈空间。将栈指针sp指向栈顶位置，然后调用os_main这个函数，os_main函数定义在main.c中</p><h3 id="2-2-2-sbi-c-和-sbi-h"><a href="#2-2-2-sbi-c-和-sbi-h" class="headerlink" title="2.2.2 sbi.c 和 sbi.h"></a>2.2.2 sbi.c 和 sbi.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*sbi.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SBI_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SBI_H__</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_id</span> &#123;</span></span><br><span class="line">SBI_EXT_0_1_SET_TIMER = <span class="number">0x0</span>,</span><br><span class="line">SBI_EXT_0_1_CONSOLE_PUTCHAR = <span class="number">0x1</span>,</span><br><span class="line">SBI_EXT_0_1_CONSOLE_GETCHAR = <span class="number">0x2</span>,</span><br><span class="line">SBI_EXT_0_1_CLEAR_IPI = <span class="number">0x3</span>,</span><br><span class="line">SBI_EXT_0_1_SEND_IPI = <span class="number">0x4</span>,</span><br><span class="line">SBI_EXT_0_1_REMOTE_FENCE_I = <span class="number">0x5</span>,</span><br><span class="line">SBI_EXT_0_1_REMOTE_SFENCE_VMA = <span class="number">0x6</span>,</span><br><span class="line">SBI_EXT_0_1_REMOTE_SFENCE_VMA_ASID = <span class="number">0x7</span>,</span><br><span class="line">SBI_EXT_0_1_SHUTDOWN = <span class="number">0x8</span>,</span><br><span class="line">SBI_EXT_BASE = <span class="number">0x10</span>,</span><br><span class="line">SBI_EXT_TIME = <span class="number">0x54494D45</span>,</span><br><span class="line">SBI_EXT_IPI = <span class="number">0x735049</span>,</span><br><span class="line">SBI_EXT_RFENCE = <span class="number">0x52464E43</span>,</span><br><span class="line">SBI_EXT_HSM = <span class="number">0x48534D</span>,</span><br><span class="line">SBI_EXT_SRST = <span class="number">0x53525354</span>,</span><br><span class="line">SBI_EXT_PMU = <span class="number">0x504D55</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sbi 返回结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> &#123;</span></span><br><span class="line"><span class="type">long</span> error;</span><br><span class="line"><span class="type">long</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*sbi.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> sbiret <span class="title function_">sbi_ecall</span><span class="params">(<span class="type">int</span> ext, <span class="type">int</span> fid, <span class="type">unsigned</span> <span class="type">long</span> arg0,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg1, <span class="type">unsigned</span> <span class="type">long</span> arg2,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg3, <span class="type">unsigned</span> <span class="type">long</span> arg4,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg5)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用GCC的扩展语法，用于将一个值存储到RISC-V架构中的寄存器a0中。</span></span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a0 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a0&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg0);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a1 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a1&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg1);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a2 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a2&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg2);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a3 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a3&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg3);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a4 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a4&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg4);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a5 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a5&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg5);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a6 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a6&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(fid);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a7 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a7&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(ext);</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ecall&quot;</span></span></span><br><span class="line"><span class="params">      : <span class="string">&quot;+r&quot;</span> (a0), <span class="string">&quot;+r&quot;</span> (a1)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a3), <span class="string">&quot;r&quot;</span> (a4), <span class="string">&quot;r&quot;</span> (a5), <span class="string">&quot;r&quot;</span> (a6), <span class="string">&quot;r&quot;</span> (a7)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">ret.error = a0;</span><br><span class="line">ret.value = a1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_console_putchar() - Writes given character to the console device.</span></span><br><span class="line"><span class="comment"> * @ch: The data to be written to the console.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_0_1_CONSOLE_PUTCHAR, <span class="number">0</span>, ch, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sbi的头文件中定义了EID的枚举变量和sbi 的返回结构体，然后再sbi.c中定义了一个sbi_ecall的函数用于调用Opensbi提供的服务，最后定义了sbi_console_putchar函数传入想要输出的字符，然后传入EID和FID，去查上面的表EID&#x3D;0x01,FID&#x3D;0。</p><blockquote><p>这里的代码我是抄的uboot的，有兴趣的可以去看一下uboot的源码</p><p>参考链接：<a href="https://chsgcxy.github.io/messy_notes/riscv/opensbi.html">OpenSBI - Messy Notes (chsgcxy.github.io)</a></p></blockquote><h3 id="2-2-3-main-c"><a href="#2-2-3-main-c" class="headerlink" title="2.2.3 main.c"></a>2.2.3 main.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c定义了os_main()函数，在os_main()函数中依次打印字符输出“hello!”</p><h3 id="2-2-4-os-ld"><a href="#2-2-4-os-ld" class="headerlink" title="2.2.4 os.ld"></a>2.2.4 os.ld</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123; </span><br><span class="line">ram (rxai!w) : ORIGIN = 0x80200000, LENGTH = 128M</span><br><span class="line">&#125;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">.text : &#123;</span><br><span class="line">*(.text .text.*)</span><br><span class="line">&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">.rodata : &#123;</span><br><span class="line">*(.rodata .rodata.*)</span><br><span class="line">&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">.data : &#123;</span><br><span class="line">. = ALIGN(4096);</span><br><span class="line">*(.sdata .sdata.*)</span><br><span class="line">*(.data .data.*)</span><br><span class="line">PROVIDE(_data_end = .);</span><br><span class="line">&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">.bss :&#123;</span><br><span class="line">*(.sbss .sbss.*)</span><br><span class="line">*(.bss .bss.*)</span><br><span class="line">*(COMMON)</span><br><span class="line">&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接脚本如上，其中os的可执行文件会被链接到0x80200000的位置</p><h3 id="2-2-5-makefile"><a href="#2-2-5-makefile" class="headerlink" title="2.2.5 makefile"></a>2.2.5 makefile</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CROSS_COMPILE = riscv64-unknown-elf-</span><br><span class="line">CFLAGS = -nostdlib -fno-builtin </span><br><span class="line"></span><br><span class="line"><span class="comment"># riscv64-unknown-elf-gcc 工具链可以同时编译汇编和 C 代码</span></span><br><span class="line">CC = $&#123;CROSS_COMPILE&#125;gcc</span><br><span class="line">OBJCOPY = $&#123;CROSS_COMPILE&#125;objcopy</span><br><span class="line">OBJDUMP = $&#123;CROSS_COMPILE&#125;objdump</span><br><span class="line"></span><br><span class="line">SRCS_ASM = \</span><br><span class="line">entry.S</span><br><span class="line"></span><br><span class="line">SRCS_C = \</span><br><span class="line">sbi.c \</span><br><span class="line">main.c \</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将源文件替换为 .o 文件</span></span><br><span class="line">OBJS = $(SRCS_ASM:.S=.o)</span><br><span class="line">OBJS += $(SRCS_C:.c=.o)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">os.elf: $&#123;OBJS&#125;</span></span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; -T os.ld  -o os.elf <span class="variable">$^</span></span><br><span class="line">$&#123;OBJCOPY&#125; -O binary os.elf os.bin</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line">%.o : %.S</span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o *.bin *.elf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译链接生成os.bin</p><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h1><p>首先修改一下build.sh，先编译os，新增如下内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译os</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/os&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/os</span><br><span class="line">fi</span><br><span class="line">cd $SHELL_FOLDER/os</span><br><span class="line">make</span><br><span class="line">cp $SHELL_FOLDER/os/os.bin $SHELL_FOLDER/output/os/os.bin</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>合成固件：</p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710133710167.png" alt="image-20230710133710167"></p><p>然后将修改<code>boot/start.s</code>将<code>os.bin</code>加载到<em>0x80200000</em>的位置</p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710133940156.png" alt="image-20230710133940156"></p><p>编译运行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./build.sh</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure><p>运行结果如下，可以看见成功打印“hello！”</p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710134405374.png" alt="image-20230710134405374"></p><p>现在的内存布局如下：</p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710140718546.png" alt="image-20230710140718546"></p>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> opensbi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于opensbi为quard_star创建domain</title>
      <link href="/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/"/>
      <url>/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Opensbi之domain机制"><a href="#1-Opensbi之domain机制" class="headerlink" title="1. Opensbi之domain机制"></a>1. Opensbi之domain机制</h1><p>OpenSBI（Open Source Supervisor Binary Interface）的 domain 机制是一种用于管理和隔离不同软件实体（例如操作系统、虚拟机）的机制。它提供了一种在系统中划分资源和权限的方法，以确保软件实体之间的相互隔离和安全性。</p><p>在 OpenSBI 中，domain 是一种逻辑上的实体，它代表了一个软件实体，可以是一个操作系统、一个虚拟机或其他一些执行环境。每个 domain 都有自己的一组资源和权限，包括处理器（Hart）、内存、设备和中断等。domain 之间是相互隔离的，它们不能直接访问或干扰彼此的资源。</p><p>OpenSBI 的 domain 机制通过以下方式实现：</p><ol><li>Domain ID：每个 domain 都有一个唯一的标识符，称为 Domain ID。它用于区分不同的 domain。</li><li>Hart Mask：OpenSBI 使用 Hart Mask 来表示哪些处理器属于特定的 domain。Hart Mask 是一个位图，每个位代表一个处理器，可以将相应的位设置为 1 表示该处理器属于某个 domain。</li><li>SBI 接口：OpenSBI 提供了一组 SBI（Supervisor Binary Interface）接口，用于 domain 之间的通信和资源管理。这些接口包括中断处理、内存管理、设备访问等，可以由 domain 使用来请求和管理资源。</li></ol><p>通过 domain 机制，OpenSBI 可以实现不同软件实体的隔离和安全性。每个 domain 只能访问自己被授权的资源，并且不能越权访问其他 domain 的资源。这样可以确保系统的稳定性和安全性，并支持多个软件实体在同一硬件平台上共存和运行。</p><p>在opensbi的doc目录下的<code>domain_support.md</code>文档介绍了如何使用设备树来基于opensbi来划分domain，在文档中提到默认情况下，所有的 HART 都被分配给 <code>ROOT domain</code>。OpenSBI 平台支持可以通过平台特定的回调函数提供 HART 到 domain 实例的分配。同时也可以使用设备树来定义<code>domain</code>，文档中举了一个设备树的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chosen &#123;</span><br><span class="line">    opensbi-domains &#123;</span><br><span class="line">        compatible = &quot;opensbi,domain,config&quot;;</span><br><span class="line"></span><br><span class="line">        tmem: tmem &#123;</span><br><span class="line">            compatible = &quot;opensbi,domain,memregion&quot;;</span><br><span class="line">            base = &lt;0x0 0x80100000&gt;;</span><br><span class="line">            order = &lt;20&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        tuart: tuart &#123;</span><br><span class="line">            compatible = &quot;opensbi,domain,memregion&quot;;</span><br><span class="line">            base = &lt;0x0 0x10011000&gt;;</span><br><span class="line">            order = &lt;12&gt;;</span><br><span class="line">            mmio;</span><br><span class="line">            devices = &lt;&amp;uart1&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        allmem: allmem &#123;</span><br><span class="line">            compatible = &quot;opensbi,domain,memregion&quot;;</span><br><span class="line">            base = &lt;0x0 0x0&gt;;</span><br><span class="line">            order = &lt;64&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        tdomain: trusted-domain &#123;</span><br><span class="line">            compatible = &quot;opensbi,domain,instance&quot;;</span><br><span class="line">            possible-harts = &lt;&amp;cpu0&gt;;</span><br><span class="line">            regions = &lt;&amp;tmem 0x7&gt;, &lt;&amp;tuart 0x7&gt;;</span><br><span class="line">            boot-hart = &lt;&amp;cpu0&gt;;</span><br><span class="line">            next-arg1 = &lt;0x0 0x0&gt;;</span><br><span class="line">            next-addr = &lt;0x0 0x80100000&gt;;</span><br><span class="line">            next-mode = &lt;0x0&gt;;</span><br><span class="line">            system-reset-allowed;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        udomain: untrusted-domain &#123;</span><br><span class="line">            compatible = &quot;opensbi,domain,instance&quot;;</span><br><span class="line">            possible-harts = &lt;&amp;cpu1 &amp;cpu2 &amp;cpu3 &amp;cpu4&gt;;</span><br><span class="line">            regions = &lt;&amp;tmem 0x0&gt;, &lt;&amp;tuart 0x0&gt;, &lt;&amp;allmem 0x7&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpus &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;0&gt;;</span><br><span class="line">    timebase-frequency = &lt;10000000&gt;;</span><br><span class="line"></span><br><span class="line">    cpu0: cpu@0 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        reg = &lt;0x00&gt;;</span><br><span class="line">        compatible = &quot;riscv&quot;;</span><br><span class="line">        opensbi-domain = &lt;&amp;tdomain&gt;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        reg = &lt;0x01&gt;;</span><br><span class="line">        compatible = &quot;riscv&quot;;</span><br><span class="line">        opensbi-domain = &lt;&amp;udomain&gt;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu2: cpu@2 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        reg = &lt;0x02&gt;;</span><br><span class="line">        compatible = &quot;riscv&quot;;</span><br><span class="line">        opensbi-domain = &lt;&amp;udomain&gt;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu3: cpu@3 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        reg = &lt;0x03&gt;;</span><br><span class="line">        compatible = &quot;riscv&quot;;</span><br><span class="line">        opensbi-domain = &lt;&amp;udomain&gt;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu4: cpu@4 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        reg = &lt;0x04&gt;;</span><br><span class="line">        compatible = &quot;riscv&quot;;</span><br><span class="line">        opensbi-domain = &lt;&amp;udomain&gt;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uart1: serial@10011000 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这份设备树中需要定义如下三个节点：</p><ul><li><p><code>Domain Configuration Node</code></p><p>这里就是要定义compatible &#x3D; “opensbi,domain,config”;</p></li><li><p><code>Domain Memory Region Node</code></p><p>这里是定义和内存相关的节点，域内存区域设备树节点的属性如下：</p><ul><li>compatible（必选）- 域内存区域的兼容字符串。该设备树属性的值应为 “opensbi,domain,memregion”。</li><li>base（必选）- 域内存区域的基地址。该设备树属性应为2^order对齐的64位地址（即两个设备树单元）。</li><li>order（必选）- 域内存区域的阶数。该设备树属性应为32位值（即一个设备树单元），取值范围为 3 &lt;&#x3D; order &lt;&#x3D; __riscv_xlen。</li><li>mmio（可选）- 一个布尔标志，表示域内存区域是否为内存映射I&#x2F;O（MMIO）区域。</li><li>devices（可选）- 设备列表，其中包含属于此域内存区域的设备设备树节点的句柄。</li></ul></li><li><p><code>Domain Instance Node</code></p><ul><li><p><code>compatible</code>（必选）-:域实例的兼容字符串。该设备树属性的值应为 “opensbi,domain,instance”。</p></li><li><p><code>possible-harts</code>（可选）- 域实例的CPU设备树节点句柄列表。该列表表示域实例的可能HART集合。 </p></li><li><p><code>regions</code>（可选）- 域实例的域内存区域设备树节点句柄和访问权限列表。每个列表条目都是一个设备树节点句柄和访问权限的对。访问权限以32位掩码表示，具有可读（BIT[0]）、可写（BIT[1]）、可执行（BIT[2]）和M模式（BIT[3]）的位。</p></li><li><p><code>boot-hart</code>（可选）- 引导域实例的HART的设备树节点句柄。如果将冷启动HART分配给域实例，则忽略此设备树属性，并假定冷启动HART是域实例的引导HART。 </p></li><li><p><code>next-arg1</code>（可选）- 域实例的64位下一个引导阶段arg1。如果此设备树属性不可用且未将冷启动HART分配给域实例，则使用默认值0x0。如果此设备树属性不可用且将冷启动HART分配给域实例，则使用冷启动HART的下一个引导阶段arg1作为默认值。 </p></li><li><p><code>next-addr</code>（可选）- 域实例的64位下一个引导阶段地址。如果此设备树属性不可用且未将冷启动HART分配给域实例，则使用默认值0x0。如果此设备树属性不可用且将冷启动HART分配给域实例，则使用冷启动HART的下一个引导阶段地址作为默认值。</p></li><li><p><code> next-mode</code>（可选）- 域实例的32位下一个引导阶段模式。该设备树属性的可能值为：0x1（s模式）和0x0（u模式）。如果此设备树属性不可用且未将冷启动HART分配给域实例，则使用默认值0x1。如果此设备树属性不可用且将冷启动HART分配给域实例，则使用冷启动HART的下一个引导阶段模式作为默认值。</p></li><li><p><code> system-reset-allowed</code>（可选）- 一个布尔标志，表示是否允许域实例进行系统复位。</p></li></ul></li></ul><h1 id="2-为quard-star划分domain"><a href="#2-为quard-star划分domain" class="headerlink" title="2. 为quard_star划分domain"></a>2. 为quard_star划分domain</h1><h2 id="2-1-修改quard-star设备树"><a href="#2-1-修改quard-star设备树" class="headerlink" title="2.1 修改quard_star设备树"></a>2.1 修改quard_star设备树</h2><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">stdout-path</span> <span class="operator">=</span> <span class="string">&quot;/soc/uart0@10000000&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">opensbi-domains</span> <span class="punctuation">&#123;</span>  <span class="comment">/* 定义opensbi-domains描述节点 */</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,config&quot;</span><span class="punctuation">;</span> <span class="comment">/* 节点名称 */</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">           tmem:</span> <span class="title class_">tmem</span> <span class="punctuation">&#123;</span>   <span class="comment">/* 定义内存节点 */</span></span><br><span class="line">               <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,memregion&quot;</span><span class="punctuation">;</span>  <span class="comment">/* 节点名称 */</span></span><br><span class="line">               <span class="attr">base</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xb0000000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 起始地址注意64位地址哦 */</span></span><br><span class="line">               <span class="attr">order</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">28</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 内存大小即size=2^28 */</span></span><br><span class="line">           <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">           tuart:</span> <span class="title class_">tuart</span> <span class="punctuation">&#123;</span>  <span class="comment">/* 定义mmio节点 */</span></span><br><span class="line">               <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,memregion&quot;</span><span class="punctuation">;</span>  <span class="comment">/* 节点名称 */</span></span><br><span class="line">               <span class="attr">base</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x10002000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 起始地址 */</span></span><br><span class="line">               <span class="attr">order</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">8</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* size=2^8 */</span></span><br><span class="line">               <span class="attr">mmio</span><span class="punctuation">;</span>  <span class="comment">/* mmio属性 */</span></span><br><span class="line">               <span class="attr">devices</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;uart2</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 关联到设备节点上 */</span></span><br><span class="line">           <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    allmem:</span> <span class="title class_">allmem</span> <span class="punctuation">&#123;</span> <span class="comment">/* 定义内存节点，这个节点保护所有地址 */</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,memregion&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">base</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">order</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">           tdomain:</span> <span class="title class_">trusted-domain</span> <span class="punctuation">&#123;</span> <span class="comment">/* 定义domian节点 */</span></span><br><span class="line">               <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,instance&quot;</span><span class="punctuation">;</span>  <span class="comment">/* 节点名称 */</span></span><br><span class="line">               <span class="attr">possible-harts</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu7</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* dumian中允许使用的cpu core */</span></span><br><span class="line">               <span class="attr">regions</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;tmem</span> <span class="number">0x7</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;tuart</span> <span class="number">0x7</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;allmem</span> <span class="number">0x7</span>&gt;</span><span class="punctuation">;</span><span class="comment">/* 各个内存/mmio区域的权限，3bit读写运行权限 0x7拥有全部权限 */</span></span><br><span class="line">               <span class="attr">boot-hart</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu7</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* domian中用于boot的core */</span></span><br><span class="line">               next-arg1 = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x00000000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 下级程序的参数 */</span></span><br><span class="line">        <span class="attr">next-addr</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xb0000000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 下级程序的起始地址 */</span></span><br><span class="line">        <span class="attr">next-mode</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 下级程序的允许模式 0为U模式，1为S模式 */</span></span><br><span class="line">               <span class="attr">system-reset-allowed</span><span class="punctuation">;</span> <span class="comment">/* 允许复位 */</span></span><br><span class="line">           <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    udomain:</span> <span class="title class_">untrusted-domain</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,instance&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">possible-harts</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu0</span> <span class="variable">&amp;cpu1</span> <span class="variable">&amp;cpu2</span> <span class="variable">&amp;cpu3</span> <span class="variable">&amp;cpu4</span> <span class="variable">&amp;cpu5</span> <span class="variable">&amp;cpu6</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">regions</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;tmem</span> <span class="number">0x0</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;tuart</span> <span class="number">0x0</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;allmem</span> <span class="number">0x7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">boot-hart</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        next-arg1 = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x82200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">next-addr</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x82000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">next-mode</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">system-reset-allowed</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>可以看见为<code>quard_star</code>划分了两个<code>domain</code>，一个为<code>trusted-domain</code>，使用了cpu7，下级程序的起始地址为<code>0xb0000000</code>，模式为<code>U</code>模式，这个<code>domain</code>可以用来运行类似<code>freertos</code>的实时操作系统；一个domain为<code>untrusted-domain</code>，这个<code>domain</code>使用了<code>cpu0~cpu6</code>，用于运行<code>linux</code>系统，下级程序的起始地址为<code>0x82000000</code></p><h2 id="2-2-编写domain测试代码"><a href="#2-2-编写domain测试代码" class="headerlink" title="2.2 编写domain测试代码"></a>2.2 编写domain测试代码</h2><p>在quard_star目录下新建一个<code>trusted_domain</code>的文件夹，在此文件夹下新建<code>link.lds</code>和<code>startup.s</code>两个文件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star/trusted_domain$ <span class="built_in">ls</span></span><br><span class="line">link.lds  startup.s</span><br></pre></td></tr></table></figure><p><code>link.lds</code>如下，这里需要注意的是运行起始地址和设备树中的保持一致，即：<code>0xb0000000</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line"></span><br><span class="line">ENTRY( _start )</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123; </span><br><span class="line">ddr (rxai!w) : ORIGIN = 0xb0000000, LENGTH = 256M</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP(*(.text))</span><br><span class="line">  &#125; &gt;ddr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startup.s</code>如下：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">.type _start,@function</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">lit0,<span class="number">0x100</span></span><br><span class="line">sllit0,t0, <span class="number">20</span></span><br><span class="line">lit1,<span class="number">0x200</span></span><br><span class="line">sllit1,t1, <span class="number">4</span></span><br><span class="line"><span class="keyword">add</span>     t0, t0, t1</span><br><span class="line">lit1,<span class="string">&#x27;H&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;e&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;l&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;l&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;o&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;Q&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;u&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;d&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;S&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;t&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;b&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;o&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;d&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;!&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;\r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line"><span class="symbol">_loop:</span></span><br><span class="line">j_loop</span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure><p>这里需要注意的是串口的输出地址为<code>0x10002000</code>，即<code>UART2</code>的地址，和设备树中<code>tuart</code>的地址保持一致</p><p>这里需要生成<code>trusted_domain</code>的固件并将其加载到<code>0xb0000000</code>处执行，所以先修改<code>build.sh</code></p><p>先编译生成<code>trusted_domain.bin</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译trusted_domain</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/trusted_domain&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/trusted_domain</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/trusted_domain</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -x assembler-with-cpp -c startup.s -o <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/startup.o</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -nostartfiles -T./link.lds -Wl,-Map=<span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.map -Wl,--gc-sections <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/startup.o -o <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objcopy -O binary -S <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.bin</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objdump --<span class="built_in">source</span> --demangle --disassemble --reloc --wide <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf &gt; <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.lst</span></span><br></pre></td></tr></table></figure><p>然后合成<code>fw.bin</code>，新增一行如下：</p><p><img src="/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/image-20230624155945404.png" alt="image-20230624155945404"></p><p>将<code>trusted_domain.bin</code>写入到了地址偏移为：<code>0x400000</code>的地方，下一步就要将固件加载到<code>0xb0000000</code>，因此还需要修改一下boot下的<code>start.s</code>，修改如下：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">//load trusted_fw.bin</span><br><span class="line">//[<span class="number">0x20400000</span>:<span class="number">0x20800000</span>] --&gt; [<span class="number">0xb0000000</span>:<span class="number">0xb0400000</span>]</span><br><span class="line">   lia0,<span class="number">0x204</span></span><br><span class="line">sllia0,a0, <span class="number">20</span>      //a0 = <span class="number">0x20400000</span></span><br><span class="line">   lia1,<span class="number">0xb00</span></span><br><span class="line">sllia1,a1, <span class="number">20</span>      //a1 = <span class="number">0xb0000000</span></span><br><span class="line">   lia2,<span class="number">0xb04</span></span><br><span class="line">sllia2,a2, <span class="number">20</span>      //a2 = <span class="number">0xb0400000</span></span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure><h2 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h2><p><code>run.sh</code>修改：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line">DEFAULT_VC=&quot;1080x1920&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/fw/fw.bin \</span></span><br><span class="line"><span class="language-bash">-d in_asm -D qemu.log \</span></span><br><span class="line"><span class="language-bash">--serial vc:<span class="variable">$DEFAULT_VC</span> --serial vc:<span class="variable">$DEFAULT_VC</span> --serial vc:<span class="variable">$DEFAULT_VC</span> --monitor vc:<span class="variable">$DEFAULT_VC</span> --parallel none</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-nographic --parallel none \</span></span><br></pre></td></tr></table></figure><p>用<code>DEFAULT_VC</code>来指定了qemu显示的分辨率，这个分辨率我随便设置的，还需要新增三个<code>-serial</code>选项让qemu输出三个串口终端，运行结果如下：</p><p><img src="/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/GIF%202023-6-24%2016-10-13.gif" alt="GIF 2023-6-24 16-10-13"></p><p>所以现在的内存布局如下：</p><p><img src="/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/memory.png" alt="memory"></p>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> opensbi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为quard-star移植opensbi-1.2</title>
      <link href="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/"/>
      <url>/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-RISCV的多级启动流程"><a href="#1-RISCV的多级启动流程" class="headerlink" title="1. RISCV的多级启动流程"></a>1. RISCV的多级启动流程</h1><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/ch5-1.png" alt="ch5-1"></p><p>​如上图RISCV的多级启动流程从ROM上的代码开始，实心黑箭头代表加载操作，虚线黑箭头代表跳转操作，因此rom上的代码负责把LOADER的代码加载到SARM上然后跳转到LOADER处执行，LOADER的代码会初始化DDR然后加载Opensbi固件到DDR，然后跳转到Opensbi处执行，或者直接加载BOOTLOADER，然后跳转到BOOTLOADER处执行，最后BOOTLOADER会加载OS然后跳转到OS处启动操作系统</p><p>第一阶段为ZSBL，运行在M模式下，对应到quard-star的ROM上的代码就是复位向量代码就是那个reset_vec里的代码，由于我们通过qemu将固件通过-drive命令直接加载到了flash的地方，所以rom上的代码不用执行load操作。</p><p>第二阶段为FSBL，运行在M模式下，对应到quard-star就是flash上的代码，在这段代码里我们需要加载Opensbi固件，加载设备树，然后跳转到Opensbi处执行</p><p>第三阶段就是Opensbi了，Opensbi是运行在M模式下的一段运行时代码</p><p>第四阶段为U-boot</p><p>第五阶段为OS</p><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/1337491-20220915202755816-964760955.png" alt="RISC-V 引导流程图"></p><h1 id="2-Opensbi简介"><a href="#2-Opensbi简介" class="headerlink" title="2. Opensbi简介"></a>2. Opensbi简介</h1><blockquote><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/578765652">OpenSBI三种固件的区别 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/YjmStr/p/16697848.html">QEMU 启动方式分析 （1）：QEMU 及 RISC-V 启动流程简介 - yjmstr - 博客园 (cnblogs.com)</a></p></blockquote><p>RISC-V 的 Runtime 通常是 OpenSBI，它是运行在 M 模式下的程序，但能够为 S 模式提供一些特定的服务，这些服务由 SBI (Supervisor Binary Interface) 规范定义。</p><p>SBI 是指 Supervisor Binary Interface，它是运行在 M 模式下的程序，操作系统通过 SBI 来调用 M 模式的硬件资源。而 OpenSBI 是指西数开发的一种开源 SBI 实现。</p><p>OpenSBI 有三种 Firmware：</p><ul><li>FW_PAYLOAD ：下一引导阶段被作为 payload 打包进来，通常是 U-Boot 或 Linux。这是兼容 Linux 的 RISC-V 硬件所使用的默认 firmware 。</li><li>FW_JUMP ：跳转到一个固定地址，该地址上需存有下一个加载器。QEMU 的早期版本曾经使用过它。</li><li>FW_DYNAMIC ：根据前一个阶段传入的信息加载下一个阶段。通常是 U-Boot SPL 使用它。现在 QEMU 默认使用 FW_DYNAMIC。</li></ul><p>下载Opensbi源码：<a href="https://github.com/riscv-software-src/opensbi/releases">Releases · riscv-software-src&#x2F;opensbi (github.com)</a></p><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/image-20230623145527293.png" alt="image-20230623145527293"></p><p>截至笔者下载的时候，最新的版本为<code>1.2</code>，不同的版本有一定的区别，<code>0.9</code>和<code>1.2</code>版本在配置方面有许多差距，下载完成源码后解压到<code>quard-star</code>目录下。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ <span class="built_in">ls</span></span><br><span class="line">README.md  boot  build.sh  dts  opensbi-1.2  output  qemu-8.0.2  qemu.log   run.sh</span><br></pre></td></tr></table></figure><h1 id="3-移植Opensbi-1-2到quard-star上"><a href="#3-移植Opensbi-1-2到quard-star上" class="headerlink" title="3. 移植Opensbi-1.2到quard-star上"></a>3. 移植Opensbi-1.2到quard-star上</h1><p>在移植之前需要明确几个东西:</p><ul><li>我们采用<code>Opensbi</code>的固件是<code>FW_JUMP </code>类型的，会被加载到DRAM处执行即<code>0x80000000</code></li><li>需要自行编写设备树编译将设备树的地址传递给<code>Opensbi</code>，<code>rom</code>上的<code>fw_dynamic_info</code>用不到</li><li>需要编写在flah上运行的代码来将opensbi的固件加载到DRAM处，然后跳转执行</li></ul><h2 id="3-1-在opensbi中新增quard-star支持"><a href="#3-1-在opensbi中新增quard-star支持" class="headerlink" title="3.1 在opensbi中新增quard-star支持"></a>3.1 在opensbi中新增quard-star支持</h2><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/image-20230623145957055.png" alt="image-20230623145957055"></p><p>可以看到opensbi的源码并不是特别多，我们先看看docs下的<code>platform_guide.md</code>，里面有这么一段话：</p><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/image-20230623150123684.png" alt="image-20230623150123684"></p><p>这里告诉了我们如何在为<code>quard_star</code>新增<code>opensbi</code>的支持，如下：</p><ul><li>在palform文件夹下新建一个名为<code>quard_star</code>的文件夹</li><li>在quard_star文件夹下新增三个文件<code>Kconfig</code>，<code>objects.mk</code>，<code>platform.c</code></li><li>在quard_satr文件夹下新增一个文件夹脚<code>configs</code>，在<code>configs</code>目录下新建一个名为<code>defconfig</code>的文件</li></ul><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/image-20230623150525508.png" alt="image-20230623150525508"></p><p>可以看到在patform文件夹下还有一些其他平台，比如<code>kendryte-k210</code>，还有一个名为<code>generic</code>的平台，这是一个通用的板级平台，我们的<code>quard_star</code>就是参考<code>generic</code>的代码实现的，还有一个叫<code>template</code>的平台，这是<code>opensbi</code>官方提供的默认工程。</p><p>Kconfig文件的内容，这里照着generci中的内容copy了过来，看样子是选择使用FDT以及支持fdt的domain配置和fdt的pmu配置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># SPDX-License-Identifier: BSD-2-Clause</span><br><span class="line"></span><br><span class="line">config PLATFORM_QUARD_STAR</span><br><span class="line">bool</span><br><span class="line">select FDT  </span><br><span class="line">select FDT_DOMAIN </span><br><span class="line">select FDT_PMU</span><br><span class="line">default y</span><br></pre></td></tr></table></figure><p>objects的内容比较简单，配置固件为JUMP类型，同时指定jump的地址</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: BSD-2-Clause</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compiler flags</span></span><br><span class="line">platform-cppflags-y =</span><br><span class="line">platform-cflags-y =</span><br><span class="line">platform-asflags-y =</span><br><span class="line">platform-ldflags-y =</span><br><span class="line"></span><br><span class="line"><span class="comment"># Objects to build</span></span><br><span class="line">platform-objs-y += platform.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># Blobs to build</span></span><br><span class="line">FW_JUMP=y</span><br><span class="line">FW_TEXT_START=0x80000000</span><br><span class="line">FW_JUMP_ADDR=0x0</span><br></pre></td></tr></table></figure><p><code>defconfig</code>的内容是指定配置支持哪些硬件，这里也是把<code>generic</code>中的内容<code>copy</code>了过来，虽然现在<code>quard_star</code>的硬件比较少，但是不管，先把所有的都添加进去</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CONFIG_PLATFORM_ALLWINNER_D1=y</span><br><span class="line">CONFIG_PLATFORM_ANDES_AE350=y</span><br><span class="line">CONFIG_PLATFORM_RENESAS_RZFIVE=y</span><br><span class="line">CONFIG_PLATFORM_SIFIVE_FU540=y</span><br><span class="line">CONFIG_PLATFORM_SIFIVE_FU740=y</span><br><span class="line">CONFIG_FDT_GPIO=y</span><br><span class="line">CONFIG_FDT_GPIO_SIFIVE=y</span><br><span class="line">CONFIG_FDT_I2C=y</span><br><span class="line">CONFIG_FDT_I2C_SIFIVE=y</span><br><span class="line">CONFIG_FDT_IPI=y</span><br><span class="line">CONFIG_FDT_IPI_MSWI=y</span><br><span class="line">CONFIG_FDT_IPI_PLICSW=y</span><br><span class="line">CONFIG_FDT_IRQCHIP=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_APLIC=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_IMSIC=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_PLIC=y</span><br><span class="line">CONFIG_FDT_RESET=y</span><br><span class="line">CONFIG_FDT_RESET_ATCWDT200=y</span><br><span class="line">CONFIG_FDT_RESET_GPIO=y</span><br><span class="line">CONFIG_FDT_RESET_HTIF=y</span><br><span class="line">CONFIG_FDT_RESET_SIFIVE_TEST=y</span><br><span class="line">CONFIG_FDT_RESET_SUNXI_WDT=y</span><br><span class="line">CONFIG_FDT_RESET_THEAD=y</span><br><span class="line">CONFIG_FDT_SERIAL=y</span><br><span class="line">CONFIG_FDT_SERIAL_CADENCE=y</span><br><span class="line">CONFIG_FDT_SERIAL_GAISLER=y</span><br><span class="line">CONFIG_FDT_SERIAL_HTIF=y</span><br><span class="line">CONFIG_FDT_SERIAL_RENESAS_SCIF=y</span><br><span class="line">CONFIG_FDT_SERIAL_SHAKTI=y</span><br><span class="line">CONFIG_FDT_SERIAL_SIFIVE=y</span><br><span class="line">CONFIG_FDT_SERIAL_LITEX=y</span><br><span class="line">CONFIG_FDT_SERIAL_UART8250=y</span><br><span class="line">CONFIG_FDT_SERIAL_XILINX_UARTLITE=y</span><br><span class="line">CONFIG_FDT_TIMER=y</span><br><span class="line">CONFIG_FDT_TIMER_MTIMER=y</span><br><span class="line">CONFIG_FDT_TIMER_PLMT=y</span><br><span class="line">CONFIG_SERIAL_SEMIHOSTING=y</span><br></pre></td></tr></table></figure><p><code>platform.c</code>:</p><p>在platform.c中第一个比较重要的函数为<code>fw_platform_init</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">fw_platform_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg0, <span class="type">unsigned</span> <span class="type">long</span> arg1,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg2, <span class="type">unsigned</span> <span class="type">long</span> arg3,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg4)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *model;</span><br><span class="line"><span class="type">void</span> *fdt = (<span class="type">void</span> *)arg1;</span><br><span class="line">u32 hartid, hart_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> rc, root_offset, cpus_offset, cpu_offset, len;</span><br><span class="line"></span><br><span class="line">root_offset = fdt_path_offset(fdt, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (root_offset &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">model = fdt_getprop(fdt, root_offset, <span class="string">&quot;model&quot;</span>, &amp;len);</span><br><span class="line"><span class="keyword">if</span> (model)</span><br><span class="line">sbi_strncpy(platform.name, model, <span class="keyword">sizeof</span>(platform.name));</span><br><span class="line"></span><br><span class="line">cpus_offset = fdt_path_offset(fdt, <span class="string">&quot;/cpus&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (cpus_offset &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">fdt_for_each_subnode(cpu_offset, fdt, cpus_offset) &#123;</span><br><span class="line">rc = fdt_parse_hart_id(fdt, cpu_offset, &amp;hartid);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SBI_HARTMASK_MAX_BITS &lt;= hartid)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">quard_star_hart_index2id[hart_count++] = hartid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">platform.hart_count = hart_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return original FDT pointer */</span></span><br><span class="line"><span class="keyword">return</span> arg1;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">wfi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的五个arg依次对应着上一启动阶段传递过来的参数，为a0~a4寄存器，其中a0中放的是hard id，a1中放的是设备树的地址，arg1 被强制转换为一个指向设备树（Device Tree）的指针，即 fdt。函数主要的逻辑如下：</p><ol><li>首先，通过解析设备树来获取平台的模型名称（”model” 属性），并将其存储在 platform.name 变量中。</li><li>接下来，在设备树的 “&#x2F;cpus” 路径下遍历处理器节点，获取每个处理器的 hartid（处理器标识符）。</li><li>根据获取的 hartid，将其存储在 quard_star_hart_index2id 数组中，并增加 hart_count 变量的计数。</li><li>最后，设置 platform.hart_count 变量为 hart_count，表示平台上处理器的数量。</li><li>函数返回 arg1，即原始的设备树指针。</li></ol><p>第二个重要的定义为<code>platform_ops</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_platform_operations</span> <span class="title">platform_ops</span> =</span> &#123;</span><br><span class="line">.early_init= quard_star_early_init,             <span class="comment">//早期初始化，不需要</span></span><br><span class="line">.final_init= quard_star_final_init,            <span class="comment">//最终初始化，需要</span></span><br><span class="line">.early_exit= quard_star_early_exit,            <span class="comment">//早期退出，不需要</span></span><br><span class="line">.final_exit= quard_star_final_exit,            <span class="comment">//最终退出，不需要</span></span><br><span class="line">.domains_init= quard_star_domains_init,      <span class="comment">//从设备树填充域，需要</span></span><br><span class="line">.console_init= fdt_serial_init,              <span class="comment">//初始化控制台</span></span><br><span class="line">.irqchip_init= fdt_irqchip_init,             <span class="comment">//初始化中断</span></span><br><span class="line">.irqchip_exit= fdt_irqchip_exit,             <span class="comment">//中断退出</span></span><br><span class="line">.ipi_init= fdt_ipi_init,                     <span class="comment">//中断通信</span></span><br><span class="line">.ipi_exit= fdt_ipi_exit,</span><br><span class="line">.pmu_init= quard_star_pmu_init,              <span class="comment">//电源配置</span></span><br><span class="line">.pmu_xlate_to_mhpmevent = quard_star_pmu_xlate_to_mhpmevent,</span><br><span class="line">.get_tlbr_flush_limit= quard_star_tlbr_flush_limit, <span class="comment">//需要</span></span><br><span class="line">.timer_init= fdt_timer_init,</span><br><span class="line">.timer_exit= fdt_timer_exit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为 “platform_ops” 的结构体变量，类型为 “const struct sbi_platform_operations”，用于指定平台相关的操作函数。</p><p>这个结构体包含了多个成员，每个成员对应一个平台相关的操作函数。以下是每个成员和对应的函数名：</p><ul><li><code>early_init</code>：quard_star_early_init</li><li><code>final_init</code>：quard_star_final_init</li><li><code>early_exit</code>：quard_star_early_exit</li><li><code>final_exit</code>：quard_star_final_exit</li><li><code>domains_init</code>：quard_star_domains_init</li><li><code>console_init</code>：fdt_serial_init</li><li><code>irqchip_init</code>：fdt_irqchip_init</li><li><code>irqchip_exit</code>：fdt_irqchip_exit</li><li><code>ipi_init</code>：fdt_ipi_init</li><li><code>ipi_exit</code>：fdt_ipi_exit</li><li><code>pmu_init</code>：quard_star_pmu_init</li><li><code>pmu_xlate_to_mhpmevent</code>：quard_star_pmu_xlate_to_mhpmevent</li><li><code>get_tlbr_flush_limit</code>：quard_star_tlbr_flush_limit</li><li><code>timer_init</code>：fdt_timer_init</li><li><code>timer_exit</code>：fdt_timer_exit</li></ul><p>这些函数是平台特定的操作函数，用于在 OpenSBI 初始化过程中进行特定的操作和配置。每个函数在相应的阶段被调用，以完成与平台相关的初始化、配置和资源管理等工作。</p><p>通过定义这个结构体并填充相应的函数指针，OpenSBI 可以根据平台的特性和需求，调用适当的操作函数，以确保其在不同平台上的正确运行和适配性。</p><p>其中这些操作函数的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_early_init</span><span class="params">(<span class="type">bool</span> cold_boot)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_final_init</span><span class="params">(<span class="type">bool</span> cold_boot)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *fdt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cold_boot)</span><br><span class="line">fdt_reset_init();</span><br><span class="line"><span class="keyword">if</span> (!cold_boot)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fdt = sbi_scratch_thishart_arg1_ptr();</span><br><span class="line"></span><br><span class="line">fdt_cpu_fixup(fdt);</span><br><span class="line">fdt_fixups(fdt);</span><br><span class="line">fdt_domain_fixup(fdt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_early_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_final_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_domains_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> fdt_domains_populate(fdt_get_address());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_pmu_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> fdt_pmu_setup(fdt_get_address());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">quard_star_pmu_xlate_to_mhpmevent</span><span class="params">(<span class="type">uint32_t</span> event_idx,</span></span><br><span class="line"><span class="params">       <span class="type">uint64_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint64_t</span> evt_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data is valid only for raw events and is equal to event selector */</span></span><br><span class="line"><span class="keyword">if</span> (event_idx == SBI_PMU_EVENT_RAW_IDX)</span><br><span class="line">evt_val = data;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic platform follows the SBI specification recommendation</span></span><br><span class="line"><span class="comment"> * i.e. zero extended event_idx is used as mhpmevent value for</span></span><br><span class="line"><span class="comment"> * hardware general/cache events if platform does&#x27;t define one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">evt_val = fdt_pmu_get_select_value(event_idx);</span><br><span class="line"><span class="keyword">if</span> (!evt_val)</span><br><span class="line">evt_val = (<span class="type">uint64_t</span>)event_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> evt_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">quard_star_tlbr_flush_limit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> SBI_PLATFORM_TLB_RANGE_FLUSH_LIMIT_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后定义了patform结构体，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbi_platform</span> <span class="title">platform</span> =</span> &#123;</span><br><span class="line">.opensbi_version= OPENSBI_VERSION,</span><br><span class="line">.platform_version= SBI_PLATFORM_VERSION(<span class="number">0x0</span>, <span class="number">0x01</span>),</span><br><span class="line">.name= <span class="string">&quot;Quard-Star&quot;</span>,</span><br><span class="line">.features= SBI_PLATFORM_DEFAULT_FEATURES,</span><br><span class="line">.hart_count= SBI_HARTMASK_MAX_BITS,</span><br><span class="line">.hart_index2id= quard_star_hart_index2id,</span><br><span class="line">.hart_stack_size= SBI_PLATFORM_DEFAULT_HART_STACK_SIZE,</span><br><span class="line">.platform_ops_addr= (<span class="type">unsigned</span> <span class="type">long</span>)&amp;platform_ops</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为 “platform” 的结构体变量，类型为 “struct sbi_platform”，用于描述平台的相关信息和配置。</p><p>这个结构体包含了多个成员，每个成员用于存储特定的平台属性和配置。以下是每个成员和对应的值或指针：</p><ul><li><code>opensbi_version</code>：OPENSBI_VERSION，指定了 OpenSBI 的版本号。</li><li><code>platform_version</code>：SBI_PLATFORM_VERSION(0x0, 0x01)，指定了平台的版本号。</li><li><code>name</code>：”Quard-Star”，指定了平台的名称。</li><li><code>features</code>：SBI_PLATFORM_DEFAULT_FEATURES，指定了平台的默认特性。</li><li><code>hart_count</code>：SBI_HARTMASK_MAX_BITS，指定了平台上处理器（Hart）的数量。</li><li><code>hart_index2id</code>：quard_star_hart_index2id，一个指向处理器标识符数组的指针，用于将处理器索引映射到唯一的处理器标识符。</li><li><code>hart_stack_size</code>：SBI_PLATFORM_DEFAULT_HART_STACK_SIZE，指定了每个处理器的默认堆栈大小。</li><li><code>platform_ops_addr</code>：(unsigned long)&amp;platform_ops，指向平台操作函数结构体的指针，用于指定平台操作函数的地址。</li></ul><p>通过定义这个结构体并填充相应的值或指针，OpenSBI 可以了解和配置特定平台的相关信息，以在运行时正确地适配和操作该平台。这些信息包括版本号、特性支持、处理器数量、堆栈大小和操作函数等。</p><h2 id="3-2-编写设备树"><a href="#3-2-编写设备树" class="headerlink" title="3.2 编写设备树"></a>3.2 编写设备树</h2><p>在<code>quard_star</code>目录下新建<code>dts</code>文件夹，在此文件夹下新建<code>quard_star_sbi.dts</code>，设备树文件如下：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">/dts-v1/</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;0x2&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0x2&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv-quard-star&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;riscv-quard-star,qemu&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">stdout-path</span> <span class="operator">=</span> <span class="string">&quot;/soc/uart0@10000000&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x80000000</span> <span class="number">0x0</span> <span class="number">0x40000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0x0&gt;;</span></span><br><span class="line"><span class="attr">timebase-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x989680</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xf</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x10</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="title class_">cpu@1</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xd</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xe</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu2:</span> <span class="title class_">cpu@2</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xb</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x2</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xc</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu3:</span> <span class="title class_">cpu@3</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x9</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xa</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu4:</span> <span class="title class_">cpu@4</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x4</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu5:</span> <span class="title class_">cpu@5</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x5</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x5</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x6</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu6:</span> <span class="title class_">cpu@6</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x6</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x4</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu7:</span> <span class="title class_">cpu@7</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x2</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">cpu-map</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">cluster0</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xf</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core1</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xd</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core2</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xb</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core3</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x9</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core4</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core5</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x5</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core6</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core7</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">soc</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;0x2&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0x2&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;simple-bus&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">ranges</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">uart0:</span> <span class="title class_">uart0@10000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xa</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x11</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x384000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x10000000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;ns16550a&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">uart1:</span> <span class="title class_">uart1@10001000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xa</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x11</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x384000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x10001000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;ns16550a&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">        uart2:</span> <span class="title class_">uart2@10002000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xa</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x11</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x384000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x10002000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;ns16550a&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">plic@c000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x11</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,ndev</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x35</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xc000000</span> <span class="number">0x0</span> <span class="number">0x210000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x10</span> <span class="number">0xb</span> <span class="number">0x10</span> <span class="number">0x9</span> <span class="number">0xe</span> <span class="number">0xb</span> <span class="number">0xe</span> <span class="number">0x9</span> <span class="number">0xc</span> <span class="number">0xb</span> <span class="number">0xc</span> <span class="number">0x9</span> <span class="number">0xa</span> <span class="number">0xb</span> <span class="number">0xa</span> <span class="number">0x9</span> <span class="number">0x8</span> <span class="number">0xb</span> <span class="number">0x8</span> <span class="number">0x9</span> <span class="number">0x6</span> <span class="number">0xb</span> <span class="number">0x6</span> <span class="number">0x9</span> <span class="number">0x4</span> <span class="number">0xb</span> <span class="number">0x4</span> <span class="number">0x9</span> <span class="number">0x2</span> <span class="number">0xb</span> <span class="number">0x2</span> <span class="number">0x9</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,plic0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;0x0&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">clint@2000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x10</span> <span class="number">0x3</span> <span class="number">0x10</span> <span class="number">0x7</span> <span class="number">0xe</span> <span class="number">0x3</span> <span class="number">0xe</span> <span class="number">0x7</span> <span class="number">0xc</span> <span class="number">0x3</span> <span class="number">0xc</span> <span class="number">0x7</span> <span class="number">0xa</span> <span class="number">0x3</span> <span class="number">0xa</span> <span class="number">0x7</span> <span class="number">0x8</span> <span class="number">0x3</span> <span class="number">0x8</span> <span class="number">0x7</span> <span class="number">0x6</span> <span class="number">0x3</span> <span class="number">0x6</span> <span class="number">0x7</span> <span class="number">0x4</span> <span class="number">0x3</span> <span class="number">0x4</span> <span class="number">0x7</span> <span class="number">0x2</span> <span class="number">0x3</span> <span class="number">0x2</span> <span class="number">0x7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x2000000</span> <span class="number">0x0</span> <span class="number">0x10000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,clint0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>关于设备树的语法和详细解释请参考我另外一篇博客：<a href="https://yanglianoo.github.io/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/">设备树详解 | TimerのBlog (yanglianoo.github.io)</a></p><h2 id="3-3-重新编写start-s"><a href="#3-3-重新编写start-s" class="headerlink" title="3.3 重新编写start.s"></a>3.3 重新编写start.s</h2><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">.macro</span> loop,cunt</span><br><span class="line">    lit1,<span class="number">0xffff</span></span><br><span class="line">    lit2,\cunt</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line">addi    t1, t1, <span class="number">-1</span></span><br><span class="line">bnet1, x0, <span class="number">1</span>b</span><br><span class="line">    lit1,<span class="number">0xffff</span></span><br><span class="line">addi    t2, t2, <span class="number">-1</span></span><br><span class="line">bnet2, x0, <span class="number">1</span>b</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line"><span class="meta">.macro</span> load_data,_src_start,_dst_start,_dst_end</span><br><span class="line">bgeu\_dst_start, \_dst_end, <span class="number">2</span>f</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">lw      t0, (\_src_start)</span><br><span class="line">sw      t0, (\_dst_start)</span><br><span class="line">addi    \_src_start, \_src_start, <span class="number">4</span></span><br><span class="line">addi    \_dst_start, \_dst_start, <span class="number">4</span></span><br><span class="line">bltu    \_dst_start, \_dst_end, <span class="number">1</span>b</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">.type _start,@function</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">//load opensbi_fw.bin </span><br><span class="line">//[<span class="number">0x20200000</span>:<span class="number">0x20400000</span>] --&gt; [<span class="number">0x80000000</span>:<span class="number">0x80200000</span>]</span><br><span class="line">    lia0,<span class="number">0x202</span></span><br><span class="line">sllia0,a0, <span class="number">20</span>      //a0 = <span class="number">0x20200000</span></span><br><span class="line">    lia1,<span class="number">0x800</span></span><br><span class="line">sllia1,a1, <span class="number">20</span>      //a1 = <span class="number">0x80000000</span></span><br><span class="line">    lia2,<span class="number">0x802</span></span><br><span class="line">sllia2,a2, <span class="number">20</span>      //a2 = <span class="number">0x80200000</span></span><br><span class="line">load_data a0,a1,a2</span><br><span class="line"></span><br><span class="line">//load qemu_sbi.dtb</span><br><span class="line">//[<span class="number">0x20080000</span>:<span class="number">0x20100000</span>] --&gt; [<span class="number">0x82200000</span>:<span class="number">0x82280000</span>]</span><br><span class="line">    lia0,<span class="number">0x2008</span></span><br><span class="line">sllia0,a0, <span class="number">16</span>       //a0 = <span class="number">0x20080000</span></span><br><span class="line">    lia1,<span class="number">0x822</span></span><br><span class="line">sllia1,a1, <span class="number">20</span>       //a1 = <span class="number">0x82200000</span></span><br><span class="line">    lia2,<span class="number">0x8228</span></span><br><span class="line">sllia2,a2, <span class="number">16</span>       //a2 = <span class="number">0x82280000</span></span><br><span class="line">load_data a0,a1,a2</span><br><span class="line"></span><br><span class="line">    csrr    a0, mhartid</span><br><span class="line">    lit0,<span class="number">0x0</span>     </span><br><span class="line">beqa0, t0, _no_wait</span><br><span class="line">loop<span class="number">0x1000</span></span><br><span class="line"><span class="symbol">_no_wait:</span></span><br><span class="line">    lia1,<span class="number">0x822</span></span><br><span class="line">sllia1,a1, <span class="number">20</span>       //a1 = <span class="number">0x82200000</span></span><br><span class="line">    li    t0,<span class="number">0x800</span></span><br><span class="line">sllit0,t0, <span class="number">20</span>       //t0 = <span class="number">0x80000000</span></span><br><span class="line">    jr      t0</span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure><p>这段代码会被加载到flash执行，主要工作是加载opensbi的固件和设备树，然后跳转到DRAM处执行<code>opensbi</code>的代码</p><ol><li>宏定义：<ul><li><code>loop,cunt</code> 宏用于执行循环，根据给定的次数进行空操作。</li><li><code>load_data</code> 宏用于从源地址加载数据，并将其存储到目标地址，直到目标地址达到结束地址。</li></ul></li><li><code>_start</code> 函数：<ul><li>加载 <code>opensbi_fw.bin</code> 文件的内容到指定内存区域 <code>[0x80000000:0x80200000]</code>。</li><li>加载 <code>qemu_sbi.dtb</code> 文件的内容到指定内存区域 <code>[0x82200000:0x82280000]</code>。</li><li>获取当前处理器的 ID，并与零进行比较。如果相等，执行 <code>_no_wait</code> 标签处的代码。</li><li><code>_no_wait</code> 标签处的代码加载一个地址到寄存器 <code>a1</code>，然后将控制权跳转到寄存器 <code>t0</code> 指向的地址。</li></ul></li></ol><p>这里固件的地址和在build.sh合成的固件的地址相关，下面就来修改build.sh</p><h2 id="3-4-合成固件"><a href="#3-4-合成固件" class="headerlink" title="3.4 合成固件"></a>3.4 合成固件</h2><p>在build.sh中新增如下代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译 opensbi</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/opensbi&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/opensbi</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/opensbi-1.2</span><br><span class="line">make CROSS_COMPILE=$CROSS_PREFIX- PLATFORM=quard_star</span><br><span class="line">cp -r $SHELL_FOLDER/opensbi-1.2/build/platform/quard_star/firmware/*.bin $SHELL_FOLDER/output/opensbi/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成sbi.dtb</span></span><br><span class="line">cd $SHELL_FOLDER/dts</span><br><span class="line">dtc -I dts -O dtb -o $SHELL_FOLDER/output/opensbi/quard_star_sbi.dtb quard_star_sbi.dts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合成firmware固件</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/fw&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/fw</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/output/fw</span><br><span class="line">rm -rf fw.bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">填充 32K的0</span></span><br><span class="line">dd of=fw.bin bs=1k count=32k if=/dev/zero   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># 写入 lowlevel_fw.bin 偏移量地址为 0</span></span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=0 if=$SHELL_FOLDER/output/lowlevelboot/lowlevel_fw.bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 quard_star_sbi.dtb 地址偏移量为 512K，因此 fdt的地址偏移量为 0x80000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=512 if=$SHELL_FOLDER/output/opensbi/quard_star_sbi.dtb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 fw_jump.bin 地址偏移量为 2K*1K= 0x2000000，因此 fw_jump.bin的地址偏移量为  0x2000000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=2k if=$SHELL_FOLDER/output/opensbi/fw_jump.bin</span><br></pre></td></tr></table></figure><ul><li><p>首先编译<code>Opensbi</code>，在编译时需要指定<code>PLATFORM=quard_star</code></p></li><li><p>然后编译生成<code>dtb</code></p></li><li><p>最后合成<code>firmware</code>固件</p></li></ul><p>根据dd命令的使用可以看见将quard_star_sbi.dtb写入到了偏移地址为0x80000的地方，用于这个固件会被加载到flash处，所以设备树的地址为：0x20080000</p><p>fw_jump.bin 地址偏移量为 2K*1K&#x3D; 0x2000000，因此 fw_jump.bin的地址偏移量为  0x2000000，所以opensbi固件的地址为：0x20200000</p><p>lowlevel_fw.bin 偏移量地址为 0，因此lowlevel_fw.bin 的地址为：0x20000000</p><p>这里要说明一下为啥要使用<code>dd of=fw.bin bs=1k count=32k if=/dev/zero   </code>来填充填充 32K的0，这是qemu使用-drive加载的固件的大小要大于等于定义的flash的大小，不然会报错。</p><h2 id="3-5-编译运行"><a href="#3-5-编译运行" class="headerlink" title="3.5 编译运行"></a>3.5 编译运行</h2><p><code>run.sh修改</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/fw/fw.bin \</span></span><br><span class="line"><span class="language-bash">-d in_asm -D qemu.log \</span></span><br><span class="line"><span class="language-bash">-nographic --parallel none \</span></span><br></pre></td></tr></table></figure><p>这里添加了一个qemu.log会生成汇编代码，可以根据这个log来查看固件是否有正确的加载、跳转。</p><p>依次执行<code>.build.sh，.run.sh</code>，出现如下就代表移植成功了：</p><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/image-20230623160359806.png" alt="image-20230623160359806"></p><p>可以看到显示Opensbi的版本为v1.2，固件的起始地址为：0x80000000，大小为252kb。</p><p>所以现在的内存布局如下：</p><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/memory.png"></p><h1 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h1><p>关于Opensbi还有很多指得学习的地方，后续有时间可深入分析其源码，这里先把它跑起来。</p>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> riscv </tag>
            
            <tag> opensbi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写STL之List</title>
      <link href="/2023/06/20/%E6%89%8B%E5%86%99STL-List/"/>
      <url>/2023/06/20/%E6%89%8B%E5%86%99STL-List/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码仓库：<a href="https://github.com/yanglianoo/My_STL/tree/timer">yanglianoo&#x2F;My_STL at timer (github.com)</a></p></blockquote><h1 id="1-List概述"><a href="#1-List概述" class="headerlink" title="1.List概述"></a>1.List概述</h1><p>C++标准模板库（STL）中的<code>list</code>是一个双向链表容器，提供了在链表中高效存储和访问数据的功能。它是一个模板类具有以下特性：</p><ol><li>链表结构：<code>list</code>是由节点组成的链表，每个节点包含数据以及指向前一个节点和后一个节点的指针。这种结构使得在<code>list</code>中插入、删除和移动元素非常高效，因为不需要像动态数组那样进行内存的移动和重分配。</li><li>双向访问：<code>list</code>支持双向访问，可以从链表的开头或末尾快速访问元素。你可以使用迭代器进行正向或反向遍历，也可以使用<code>front()</code>和<code>back()</code>函数访问第一个和最后一个元素。</li><li>动态大小：<code>list</code>的大小可以动态增长或缩小，无需预先分配固定大小的内存。</li><li>插入和删除：在<code>list</code>中插入和删除元素非常高效。通过使用迭代器，可以在常数时间内在任意位置插入或删除元素。</li><li>不支持随机访问：<code>list</code>不支持通过索引进行随机访问，这意味着不能像数组那样使用索引来访问元素。如果需要随机访问，<code>vector</code>可能更适合。</li><li>没有连续存储：由于<code>list</code>是一个链表，它的元素在内存中不是连续存储的，这可能会对缓存性能产生一些影响。</li><li>不支持快速的随机访问、排序和二分查找：由于没有随机访问，对<code>list</code>进行排序和二分查找会比较低效。如果需要这些功能，你可以考虑使用<code>vector</code>或<code>deque</code>容器。</li></ol><p><code>STL</code>库中<code>list</code>的定义如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Allocator</span> = std::allocator&lt;T&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> list;</span><br></pre></td></tr></table></figure><table><thead><tr><th>T</th><th>元素的类型。<code>T</code> 必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>Allocator</th><th>用于获取&#x2F;释放内存及构造&#x2F;析构内存中元素的分配器。类型必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/Allocator"><em>分配器</em> <em>(Allocator)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>成员函数</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/list">(构造函数)</a></td><td>构造 <code>list</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/~list">(析构函数)</a></td><td>析构 <code>list</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/operator%3D">operator&#x3D;</a></td><td>赋值给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/assign">assign</a></td><td>将值赋给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/get_allocator">get_allocator</a></td><td>返回相关的分配器 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/push_front">push_front</a></td><td>插入元素到容器起始 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace_front">emplace_front</a>(C++11)</td><td>在容器头部原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/pop_front">pop_front</a></td><td>移除首元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/swap">swap</a></td><td>交换内容 (公开成员函数)</td></tr></tbody></table><blockquote><p>参考链接：<a href="https://zh.cppreference.com/w/cpp/container/list">std::list - cppreference.com</a></p></blockquote><h1 id="2-构造节点"><a href="#2-构造节点" class="headerlink" title="2. 构造节点"></a>2. 构造节点</h1><p>list的数据结构有两种，一种是双向链表，结构如下：</p><p><img src="/2023/06/20/%E6%89%8B%E5%86%99STL-List/1632118785.jpg" alt="图解几种常见的线性表 - 命中水"></p><p>在双向链表中，每一个节点为一个node，node包含一个指向上一个节点的prev指针和指向下一个节点的next指针，头节点的prev指针指向nullptr，尾节点的next指针指向nullptr。</p><p>一种是双向循环链表，和双向链表不同的就是，双向循环链表头节点的prev指针指向了尾节点，尾节点的next指针指向了头节点，由此组成了一个循环。</p><p><img src="/2023/06/20/%E6%89%8B%E5%86%99STL-List/3650507100.jpg" alt="图解几种常见的线性表 - 命中水"></p><p>我们实现的list是基于双向链表的，list是一个C++的类，由很多个节点构成，因此先来定义一下节点的数据结构，node节点由两个指针和存储的数据组成，是一个模板类，定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">list_node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    list_node&lt;T&gt;* prev;</span><br><span class="line">    list_node&lt;T&gt;* next;</span><br><span class="line">    <span class="built_in">list_node</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">            :<span class="built_in">next</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            ,<span class="built_in">prev</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            ,<span class="built_in">data</span>(value)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-构造迭代器"><a href="#3-构造迭代器" class="headerlink" title="3.构造迭代器"></a>3.构造迭代器</h1><p>在list的使用种，用两种类型的迭代器，一种是普通的<code>iterator</code>，还有一种就是不可修改的<code>const_iterator</code>，这里的不可修改是指节点的数据不可修改，迭代器构造如下，和vector的迭代器类似，需要去重载不同的操作符。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, Ref, ptr&gt; self;</span><br><span class="line"><span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">list_iterator</span>(Node* node)</span><br><span class="line">:_node(node)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//拷贝构造、赋值重载，默认浅拷贝即可</span></span><br><span class="line"><span class="comment">//析构函数，指针指向的节点不属于迭代器的，无需自己销毁</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//解引用,*it = it.operator*()</span></span><br><span class="line">Ref&amp; <span class="keyword">operator</span>* ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line">ptr <span class="keyword">operator</span>-&gt; () <span class="comment">//本来调用为it-&gt;-&gt;_value,编译器通过处理省略了一个-&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_node-&gt;_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置--</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置--</span></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != it._node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node == it._node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>list_iterator</code>内部维护了一个<code>list_node&lt;T&gt;*</code>类型的指针，用来指向<code>list</code>的每一个节点，这里解释一下为啥<code>list_iterator</code>模板类为啥有三个模板参数，那是为了方便通过typedef来定义<code>iterator</code>和<code>const_iterator</code>，在后面list类中可以如下定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br></pre></td></tr></table></figure><h1 id="4-构造list类"><a href="#4-构造list类" class="headerlink" title="4.构造list类"></a>4.构造list类</h1><p>首先list类中包含了如下的成员变量，除了一个node类型的指针还维护了一个_size，当对list容器进行操作时，需要对_size实现增减操作。由于采用循环链表实现，所以当初始化链表时只需要定义一个头节点，让<code>head</code>节点的<code>prev</code>和<code>next</code>指针都指向自己就可以了.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">list</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, T&amp;, T*&gt; iterator; <span class="comment">//普通迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator; <span class="comment">//const迭代器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* _head;</span><br><span class="line">    <span class="type">size_t</span> _size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty_initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="built_in">T</span>());</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line"></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义默认构造函数</span></span><br><span class="line">   <span class="built_in">list</span>()&#123; <span class="built_in">empty_initialize</span>(); &#125;</span><br><span class="line">    <span class="comment">//定义析构函数</span></span><br><span class="line">   ~<span class="built_in">list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span>[] _head;</span><br><span class="line">        _head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后我们来定义一些和迭代器有关的函数，首先是<code>begin()</code>和<code>end()</code>，用来返回头节点指针和尾节点指针，这里我们定义<code>_head-&gt;next</code>为<code>begin</code>，<code>end</code>为<code>_head</code>，然后有两个重载版本。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(_head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-容量"><a href="#2-1-容量" class="headerlink" title="2.1 容量"></a>2.1 容量</h2><p>和容量相关的接口比较简单，这里不赘述，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-修改器"><a href="#2-2-修改器" class="headerlink" title="2.2 修改器"></a>2.2 修改器</h2><p>在实现其他修改器之前，可先定义<code>insert</code>和<code>erase</code>函数,代码逻辑并不复杂，实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//往pos位置插入元素T</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node* cur = pos._node;</span><br><span class="line">        Node* prev = cur-&gt;_prev;</span><br><span class="line"></span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">        new_node-&gt;_prev = prev;</span><br><span class="line">        new_node-&gt;_next = cur;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        prev-&gt;_next = new_node;</span><br><span class="line">        cur-&gt;_prev = new_node;</span><br><span class="line"></span><br><span class="line">        _size++;</span><br><span class="line">        <span class="comment">//隐式转换为iterator</span></span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//删除pos位置的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(pos != <span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        Node* cur = pos._node;</span><br><span class="line">        Node* prev = cur-&gt;_prev;</span><br><span class="line">        Node* next = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        prev-&gt;_next = next;</span><br><span class="line">        next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line">        _size--;</span><br><span class="line">        <span class="keyword">delete</span> [] cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除范围为 [first, last) 的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator first, iterator last )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == last) &#123; <span class="keyword">return</span> last;&#125;</span><br><span class="line"></span><br><span class="line">        Node* first_node = first._node;</span><br><span class="line">        Node* last_node = last._node;</span><br><span class="line"></span><br><span class="line">        Node* prev = first_node-&gt;_prev;</span><br><span class="line">        Node* next = last_node;</span><br><span class="line"></span><br><span class="line">        prev-&gt;_next = next;</span><br><span class="line">        next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (first_node != last_node)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* cur = first_node;</span><br><span class="line">            first_node = first_node-&gt;_next;</span><br><span class="line">            <span class="keyword">delete</span> [] cur;</span><br><span class="line">            count++; </span><br><span class="line">        &#125;</span><br><span class="line">        _size-=count;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他的修改器就可基于insert和erase函数来实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>(),<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">begin</span>(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-元素访问"><a href="#2-3-元素访问" class="headerlink" title="2.3 元素访问"></a>2.3 元素访问</h2><p>提供了访问头节点和尾节点数据的接口：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(--<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-其他构造函数"><a href="#2-4-其他构造函数" class="headerlink" title="2.4 其他构造函数"></a>2.4 其他构造函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>(<span class="type">size_t</span> count, <span class="type">const</span> T&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(<span class="type">size_t</span> count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(<span class="built_in">T</span>());</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt&gt;</span><br><span class="line">    <span class="built_in">list</span>(InputIt first, InputIt last) : <span class="built_in">list</span>() </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">while</span> (first != last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">push_back</span>(*first);</span><br><span class="line">++first;</span><br><span class="line">            _size++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(<span class="type">const</span> list&amp; other): <span class="built_in">list</span>() </span><br><span class="line">    &#123;</span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">tmp</span><span class="params">(other.begin(), other.end())</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(_head, tmp._head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(std::initializer_list&lt;T&gt; init) : <span class="built_in">list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> T&amp; value : init) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list&lt;T&gt; &amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> T&amp; value : other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;T&gt;&amp; <span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> T&amp; value : ilist) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h1><p>list已完成，未进行测试，list是比较简单的，当然我们还有一些机制没有实现，比如逆向迭代器，assign函数等，不过核心的接口都已经实现，后续可完善。</p>]]></content>
      
      
      <categories>
          
          <category> 手写STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-制作测试固件验证串口打印</title>
      <link href="/2023/06/17/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF6-%E5%88%B6%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%9B%BA%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/"/>
      <url>/2023/06/17/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF6-%E5%88%B6%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%9B%BA%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考地址：<a href="https://quard-star-tutorial.readthedocs.io/zh_CN/latest/ch4.html">基于qemu-riscv从0开始构建嵌入式linux系统ch4. 制作测试固件验证串口打印 — 主页 (quard-star-tutorial.readthedocs.io)</a></p></blockquote><ul><li>在<code>quard-star</code>目录下新建boot文件夹，在此文件夹下新建<code>boot.lds</code>和<code>start.s</code>文件，如下</li></ul><p><img src="/2023/06/17/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF6-%E5%88%B6%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%9B%BA%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/image-20230617155423292.png" alt="image-20230617155423292"></p><ul><li><code>start.s</code>文件</li></ul><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">.section .text             //定义数据段名为.text</span><br><span class="line">.globl _start              //定义全局符号_start</span><br><span class="line">.type _start,@function     //_start为函数</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span>                        //函数入口</span><br><span class="line">    csrr    a0, mhartid        //csr是riscv专有的内核私有寄存器，独立编地在<span class="number">12</span>位地址</span><br><span class="line">                               //mhartid寄存是定义了内核的hart id，这里读取到a0寄存器里</span><br><span class="line">    lit0,<span class="number">0x0</span>            //li是伪指令，加载立即数<span class="number">0</span>到t0</span><br><span class="line">beqa0, t0, _core0     //比较a0和t0,相等则跳转到_core0地址处，否则向下执行</span><br><span class="line"><span class="symbol">_loop:</span>                         //定义一个_loop符号</span><br><span class="line">j_loop              //跳转到_loop，此处形成循环，用意为如果当前cpu core不为</span><br><span class="line">                               //hart <span class="number">0</span>则循环等待，为hart <span class="number">0</span>则继续向下执行</span><br><span class="line"><span class="symbol">_core0:</span>                        //定义一个core0才能执行到此处</span><br><span class="line">lit0,<span class="number">0x100</span>          //t0 = <span class="number">0x100</span></span><br><span class="line">sllit0,t0, <span class="number">20</span>         //t0左移<span class="number">20</span>位 t0 = <span class="number">0x10000000</span></span><br><span class="line">lit1,<span class="string">&#x27;H&#x27;</span>            //t1 = <span class="string">&#x27;H&#x27;</span> 字符的ASCII码值写入t1</span><br><span class="line">sbt1, <span class="number">0</span>(t0)          //s是store写入的意思，b是byte，这里指的是写入t1</span><br><span class="line">                               //的值到t0指向的地址，即为写入<span class="number">0x10000000</span>这个寄存器</span><br><span class="line">                               //这个寄存器正是uart0的发送data寄存器，此时串口会输出<span class="string">&quot;H&quot;</span></span><br><span class="line">lit1,<span class="string">&#x27;e&#x27;</span>            //接下来都是重复内容</span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;l&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;l&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;o&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;Q&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;u&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;d&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;S&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;t&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;b&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;o&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;d&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;!&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)          //到这里就会输出<span class="string">&quot;Hello Quard Star board!&quot;</span>  </span><br><span class="line">j_loop              //完成后进入loop</span><br><span class="line"></span><br><span class="line">    .end                       //汇编文件结束符号</span><br></pre></td></tr></table></figure><p>这里做的事情比较简单，首先读取hartid的值，如果是编号为0的hart就跳转到_core0处执行，如果不是就进入_loop循环卡住。在core0函数中就是往<code>uart0=0x10000000</code>处一个字节一个字节的写数据，数据会输出到主机的控制台上。</p><ul><li><code>boot.lds</code>文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )  /*输出可执行文件平台*/</span><br><span class="line"></span><br><span class="line">ENTRY( _start )         /*程序入口函数*/</span><br><span class="line"></span><br><span class="line">MEMORY                  /*定义内存域*/</span><br><span class="line">&#123; </span><br><span class="line">    /*定义名为flash的内存域属性以及起始地址，大小等*/</span><br><span class="line">flash (rxai!w) : ORIGIN = 0x20000000, LENGTH = 512k </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS                /*定义段域*/</span><br><span class="line">&#123;</span><br><span class="line">  .text :               /*.text段域*/</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP(*(.text))      /*将所有.text段链接在此域内，keep是保持防止优化，即无论如何都保留此段*/</span><br><span class="line">  &#125; &gt;flash              /*段域的地址(LMA和VMA相同)位于名为flash内存域*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>boot.lds</code>是给链接器传参数的，目的是为了把start.s里的代码连接到flash处。</p><ul><li><code>build.sh</code>修改</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CROSS_PREFIX=riscv64-unknown-elf</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/lowlevelboot&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/lowlevelboot</span><br><span class="line">fi  </span><br><span class="line">cd boot</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -x assembler-with-cpp -c start.s -o <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/start.o</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -nostartfiles -T./boot.lds -Wl,-Map=<span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.map -Wl,--gc-sections <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/start.o -o <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用gnu工具生成原始的程序bin文件</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objcopy -O binary -S <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.bin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用gnu工具生成反汇编文件，方便调试分析（当然我们这个代码太简单，不是很需要）</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objdump --<span class="built_in">source</span> --demangle --disassemble --reloc --wide <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf &gt; <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.lst</span></span><br><span class="line"></span><br><span class="line">cd $SHELL_FOLDER/output/lowlevelboot</span><br><span class="line">rm -rf fw.bin</span><br><span class="line">dd of=fw.bin bs=1k count=32k if=/dev/zero</span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=0 if=lowlevel_fw.bin</span><br></pre></td></tr></table></figure><p>这里需要riscv的编译器，我使用的是<code>riscv64-unknown-elf-gcc</code>，在build.sh中执行编译生成固件用于qemu启动。</p><ul><li><code>run.sh</code>修改</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"></span><br><span class="line">$SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span><br><span class="line">-M quard-star \</span><br><span class="line">-m 1G \</span><br><span class="line">-smp 8 \</span><br><span class="line">-bios none \</span><br><span class="line">#-monitor stdio \</span><br><span class="line">-drive if=pflash,bus=0,unit=0,format=raw,file=$SHELL_FOLDER/output/lowlevelboot/fw.bin \</span><br><span class="line">-nographic --parallel none</span><br></pre></td></tr></table></figure><ul><li>测试，执行 <code>./build.sh</code> 和 <code>./run.sh</code>，结果如下：可以看到在串口控制台输出了<code>Hello Quard Star board!</code></li></ul><p><img src="/2023/06/17/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF6-%E5%88%B6%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%9B%BA%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/image-20230617160911655.png" alt="image-20230617160911655"></p><ul><li>内存布局如下<img src="/2023/06/17/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF6-%E5%88%B6%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%9B%BA%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(2).png" alt="未命名文件 (2)"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.为quard-star添加RTC和UART</title>
      <link href="/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/"/>
      <url>/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/</url>
      
        <content type="html"><![CDATA[<h1 id="1-quard-star-h-修改"><a href="#1-quard-star-h-修改" class="headerlink" title="1.quard_star.h 修改"></a>1.quard_star.h 修改</h1><p><img src="/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/image-20230616181444462.png" alt="image-20230616181444462"></p><h1 id="2-quard-star-c-修改"><a href="#2-quard-star-c-修改" class="headerlink" title="2.quard_star.c 修改"></a>2.quard_star.c 修改</h1><ul><li><code>quard_star_memmap</code>修改</li></ul><p><img src="/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/image-20230616181828094.png" alt="image-20230616181828094"></p><ul><li>RTC</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_rtc_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;    </span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    sysbus_create_simple(<span class="string">&quot;goldfish_rtc&quot;</span>, quard_star_memmap[QUARD_STAR_RTC].base,</span><br><span class="line">        qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_RTC_IRQ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3路UART</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建3个 uart */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_serial_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegion *system_memory = get_system_memory();</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    </span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART0].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART0_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">0</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART1].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART1_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">1</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART2].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART2_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">2</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>machine_init</code></li></ul><p><img src="/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/image-20230616181618845.png" alt="image-20230616181618845"></p><h1 id="3-Kconfig修改"><a href="#3-Kconfig修改" class="headerlink" title="3. Kconfig修改"></a>3. Kconfig修改</h1><p>选中了RTC</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01</span><br><span class="line">    select RISCV_ACLINT</span><br><span class="line">    select RISCV_APLIC</span><br><span class="line">    select SIFIVE_PLIC</span><br><span class="line">    select GOLDFISH_RTC <span class="comment">//RTC</span></span><br></pre></td></tr></table></figure><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h1><p>在进行测试时，我们需要在<code>qemu</code>的<code>monitor</code>中使用<code>info qtree</code>来查看设备树信息，但是由于<code>qemu</code>无法滚屏，所以不能查看完整的设备树，这里修改了一下<code>run.sh</code>，将monitor映射到了控制台。<code>run.sh</code>修改如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-monitor stdio \   <span class="comment">#映射monitor</span></span></span><br></pre></td></tr></table></figure><p>执行脚本测试：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p>可以看到<code>monitor</code>中输出的内容被映射到控制台中了，且<code>RTC</code>和<code>UART</code>都挂载成功了。</p><p><img src="/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/image-20230616182310228.png" alt="image-20230616182310228"></p><blockquote><p>代码地址：<a href="https://github.com/yanglianoo/quard-star">yanglianoo&#x2F;quard-star: 从零基于qemu创建riscv嵌入式开发板，并移植操作系统 (github.com)</a></p><p>有问题请与我联系：wechat：13699648817</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.为quard-star添加中断控制器</title>
      <link href="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-quard-star-h-修改"><a href="#1-quard-star-h-修改" class="headerlink" title="1.quard_star.h 修改"></a>1.quard_star.h 修改</h1><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616134654638.png" alt="image-20230616134654638"></p><ul><li>在QuardStarState定义了一个plic设备，为一个数组，因为有8个CPU</li><li>定义了一些与riscv中plic相关的信息</li></ul><h1 id="2-quard-star-c-修改"><a href="#2-quard-star-c-修改" class="headerlink" title="2.quard_star.c 修改"></a>2.quard_star.c 修改</h1><ul><li>修改内存映射数组，新增<code>PLIC</code>和<code>CLINT</code></li></ul><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616134912981.png" alt="image-20230616134912981"></p><ul><li>新建<code>quard_star_plic_create</code>函数，plic的创建和virt.c中保持一致，virt.c中创建plic的源码如下，调用了<code>virt_create_plic</code>函数，使用的硬件为<code>SIFIVE_PLIC</code></li></ul><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616135305524.png" alt="image-20230616135305524"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建plic */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_plic_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> socket_count = riscv_socket_count(machine);</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    <span class="type">int</span> i,hart_count,base_hartid;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; socket_count; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        hart_count = riscv_socket_hart_count(machine, i);</span><br><span class="line">        base_hartid = riscv_socket_first_hartid(machine, i);</span><br><span class="line">        <span class="type">char</span> *plic_hart_config;</span><br><span class="line">        <span class="comment">/* Per-socket PLIC hart topology configuration string */</span></span><br><span class="line">        plic_hart_config = riscv_plic_hart_config_string(machine-&gt;smp.cpus);</span><br><span class="line">        </span><br><span class="line">        s-&gt;plic[i] = sifive_plic_create(</span><br><span class="line">            quard_star_memmap[QUARD_STAR_PLIC].base + i *quard_star_memmap[QUARD_STAR_PLIC].size ,</span><br><span class="line">            plic_hart_config, hart_count , base_hartid,</span><br><span class="line">            QUARD_STAR_PLIC_NUM_SOURCES,</span><br><span class="line">            QUARD_STAR_PLIC_NUM_PRIORITIES,</span><br><span class="line">            QUARD_STAR_PLIC_PRIORITY_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_PENDING_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_ENABLE_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_ENABLE_STRIDE,</span><br><span class="line">            QUARD_STAR_PLIC_CONTEXT_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_CONTEXT_STRIDE,</span><br><span class="line">            quard_star_memmap[QUARD_STAR_PLIC].size);</span><br><span class="line">        g_free(plic_hart_config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新增<code>quard_star_aclint_create</code>函数，相比于virt简化了许多，使用的硬件是<code>SiFive CLINT</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_aclint_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i , hart_count,base_hartid;</span><br><span class="line">    <span class="type">int</span> socket_count = riscv_socket_count(machine);</span><br><span class="line">    <span class="comment">//每个CPU都需要创建 aclint</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; socket_count; i++) &#123;</span><br><span class="line"></span><br><span class="line">        base_hartid = riscv_socket_first_hartid(machine, i);</span><br><span class="line">        hart_count = riscv_socket_hart_count(machine, i);</span><br><span class="line"></span><br><span class="line">        riscv_aclint_swi_create(</span><br><span class="line">        quard_star_memmap[QUARD_STAR_CLINT].base + i *quard_star_memmap[QUARD_STAR_CLINT].size,</span><br><span class="line">        base_hartid, hart_count, <span class="literal">false</span>);</span><br><span class="line">        riscv_aclint_mtimer_create(quard_star_memmap[QUARD_STAR_CLINT].base +</span><br><span class="line">             + i *quard_star_memmap[QUARD_STAR_CLINT].size+ RISCV_ACLINT_SWI_SIZE,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_MTIMER_SIZE, base_hartid, hart_count,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_MTIMECMP, RISCV_ACLINT_DEFAULT_MTIME,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_TIMEBASE_FREQ, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>machine_init</code>函数修改，新增两个硬件</li></ul><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616135109899.png" alt="image-20230616135109899"></p><h1 id="3-Kconfig修改"><a href="#3-Kconfig修改" class="headerlink" title="3. Kconfig修改"></a>3. Kconfig修改</h1><p>新增了ACLINT和PLIC设备</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01 <span class="comment">//Pflash</span></span><br><span class="line">    select RISCV_ACLINT <span class="comment">//ACLINT</span></span><br><span class="line">    select RISCV_APLIC  <span class="comment">//APLIC</span></span><br><span class="line">    select SIFIVE_PLIC  <span class="comment">//SIFIVE_PLIC</span></span><br></pre></td></tr></table></figure><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h1><p>在进行测试时可将<code>quard_star_flash_create</code>先注释掉，一个个硬件依次测试。</p><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616140512366.png" alt="image-20230616140512366"></p><p>运行脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p>如下中断控制器添加成功：</p><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616140403678.png" alt="image-20230616140403678"></p><blockquote><p>代码地址：<a href="https://github.com/yanglianoo/quard-star">yanglianoo&#x2F;quard-star: 从零基于qemu创建riscv嵌入式开发板，并移植操作系统 (github.com)</a></p><p>有问题请与我联系：wechat：13699648817</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.为quard-star添加flash</title>
      <link href="/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/"/>
      <url>/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/</url>
      
        <content type="html"><![CDATA[<h1 id="1-quard-star-h-修改"><a href="#1-quard-star-h-修改" class="headerlink" title="1.quard_star.h 修改"></a>1.quard_star.h 修改</h1><p><img src="/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/image-20230615180235745.png" alt="image-20230615180235745"></p><h1 id="2-quard-star-c-修改"><a href="#2-quard-star-c-修改" class="headerlink" title="2.quard_star.c 修改"></a>2.quard_star.c 修改</h1><ul><li>定义flash起始地址和映射大小</li></ul><p><img src="/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/image-20230615180456071.png" alt="image-20230615180456071"></p><ul><li>创建flash并映射</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建flash并映射 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_flash_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> QUARD_STAR_FLASH_SECTOR_SIZE (256 * KiB)  <span class="comment">//0x40000 </span></span></span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    MemoryRegion *system_memory = get_system_memory();</span><br><span class="line">    DeviceState *dev = qdev_new(TYPE_PFLASH_CFI01);</span><br><span class="line"></span><br><span class="line">    qdev_prop_set_uint64(dev, <span class="string">&quot;sector-length&quot;</span>, QUARD_STAR_FLASH_SECTOR_SIZE);</span><br><span class="line">    qdev_prop_set_uint8(dev, <span class="string">&quot;width&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    qdev_prop_set_uint8(dev, <span class="string">&quot;device-width&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    qdev_prop_set_bit(dev, <span class="string">&quot;big-endian&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    qdev_prop_set_uint16(dev, <span class="string">&quot;id0&quot;</span>, <span class="number">0x89</span>);</span><br><span class="line">    qdev_prop_set_uint16(dev, <span class="string">&quot;id1&quot;</span>, <span class="number">0x18</span>);</span><br><span class="line">    qdev_prop_set_uint16(dev, <span class="string">&quot;id2&quot;</span>, <span class="number">0x00</span>);</span><br><span class="line">    qdev_prop_set_uint16(dev, <span class="string">&quot;id3&quot;</span>, <span class="number">0x00</span>);</span><br><span class="line">    qdev_prop_set_string(dev, <span class="string">&quot;name&quot;</span>,<span class="string">&quot;quard-star.flash0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    object_property_add_child(OBJECT(s), <span class="string">&quot;quard-star.flash0&quot;</span>, OBJECT(dev));</span><br><span class="line">    object_property_add_alias(OBJECT(s), <span class="string">&quot;pflash0&quot;</span>,</span><br><span class="line">                              OBJECT(dev), <span class="string">&quot;drive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s-&gt;flash = PFLASH_CFI01(dev);</span><br><span class="line">    pflash_cfi01_legacy_drive(s-&gt;flash,drive_get(IF_PFLASH, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    hwaddr flashsize = quard_star_memmap[QUARD_STAR_FLASH].size;</span><br><span class="line">    hwaddr flashbase = quard_star_memmap[QUARD_STAR_FLASH].base;</span><br><span class="line"></span><br><span class="line">    assert(QEMU_IS_ALIGNED(flashsize, QUARD_STAR_FLASH_SECTOR_SIZE));</span><br><span class="line">    assert(flashsize / QUARD_STAR_FLASH_SECTOR_SIZE &lt;= UINT32_MAX);</span><br><span class="line">    qdev_prop_set_uint32(dev, <span class="string">&quot;num-blocks&quot;</span>, flashsize / QUARD_STAR_FLASH_SECTOR_SIZE);</span><br><span class="line">    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &amp;error_fatal);</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(system_memory, flashbase,</span><br><span class="line">                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev),</span><br><span class="line">                                                       <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   quard_star_memory_create(machine);</span><br><span class="line">   <span class="comment">//创建flash</span></span><br><span class="line">   quard_star_flash_create(machine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还需要修改一下主存的代码，在第一篇博客中提到如果板子支持pflash需要修改<code>riscv_setup_rom_reset_vec</code>的入参。</li></ul><p><img src="/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/image-20230615190240109.png" alt="image-20230615190240109"></p><h1 id="3-Kconfig修改"><a href="#3-Kconfig修改" class="headerlink" title="3. Kconfig修改"></a>3. Kconfig修改</h1><p>新增PFLASH_CFI01 设备</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    bool</span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01  //选中FLASH</span><br></pre></td></tr></table></figure><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p><img src="/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/image-20230615180850693.png" alt="image-20230615180850693"></p><p>可以看到pflash设备成功被添加，挂载在系统总线上。</p><blockquote><p>代码地址：<a href="https://github.com/yanglianoo/quard-star">yanglianoo&#x2F;quard-star: 从零基于qemu创建riscv嵌入式开发板，并移植操作系统 (github.com)</a></p><p>有问题请与我联系：wechat：13699648817</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.virt源码分析</title>
      <link href="/2023/06/14/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF2-virt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/06/14/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF2-virt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-QEMU内置开发板riscv-virt硬件介绍"><a href="#1-QEMU内置开发板riscv-virt硬件介绍" class="headerlink" title="1. QEMU内置开发板riscv-virt硬件介绍"></a>1. QEMU内置开发板riscv-virt硬件介绍</h1><p>官方介绍文档：<a href="https://www.qemu.org/docs/master/system/riscv/virt.html">‘virt’ Generic Virtual Platform (virt) — QEMU documentation</a></p><p>riscv-virt是QEMU（Quick Emulator）中提供的一块虚拟开发板，用于模拟RISC-V架构的虚拟硬件环境。</p><p>virt提供的硬件信息如下：</p><p><img src="/2023/06/14/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF2-virt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20230614164814878.png" alt="image-20230614164814878"></p><ol><li>RV32GC&#x2F;RV64GC处理器核心：<ul><li>最多支持8个通用的RV32GC或RV64GC处理器核心。</li><li>可选择性添加扩展指令集。</li></ul></li><li>Core Local Interruptor (CLINT)：<ul><li>模拟的Core Local Interruptor用于处理核心级的中断和计时器。</li></ul></li><li>Platform-Level Interrupt Controller (PLIC)：<ul><li>模拟的Platform-Level Interrupt Controller用于处理平台级的中断，分发给各个处理器核心。</li></ul></li><li>CFI并行NOR闪存存储器：<ul><li>模拟的CFI并行NOR闪存用于存储固件或其他数据。</li></ul></li><li>1个NS16550兼容串口（UART）：<ul><li>模拟的串口设备，用于与虚拟开发板进行输入输出和调试。</li></ul></li><li>1个Google Goldfish RTC：<ul><li>模拟的RTC（实时时钟）设备，用于提供计时和时间相关的功能。</li></ul></li><li>1个SiFive Test设备：<ul><li>模拟的SiFive Test设备，用于进行测试和验证。</li></ul></li><li>8个virtio-mmio传输设备：<ul><li>提供了8个virtio-mmio传输设备，用于与虚拟机中运行的客户操作系统进行通信。</li></ul></li><li>1个通用的PCIe主机桥：<ul><li>模拟的PCIe主机桥，用于支持PCIe设备的连接和通信。</li></ul></li><li>fw_cfg设备：<ul><li>提供了fw_cfg设备，允许虚拟机从QEMU获取数据。这个设备可用于传递配置信息和数据给虚拟机。</li></ul></li></ol><h1 id="2-virt源码分析"><a href="#2-virt源码分析" class="headerlink" title="2.  virt源码分析"></a>2.  virt源码分析</h1><h2 id="2-1-Kconfig"><a href="#2-1-Kconfig" class="headerlink" title="2.1 Kconfig"></a>2.1 Kconfig</h2><p>在Kconfig中关于virt的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config RISCV_VIRT</span><br><span class="line">    bool</span><br><span class="line">    imply PCI_DEVICES</span><br><span class="line">    imply VIRTIO_VGA</span><br><span class="line">    imply TEST_DEVICES</span><br><span class="line">    imply TPM_TIS_SYSBUS</span><br><span class="line">    select RISCV_NUMA</span><br><span class="line">    select GOLDFISH_RTC</span><br><span class="line">    select PCI</span><br><span class="line">    select PCI_EXPRESS_GENERIC_BRIDGE</span><br><span class="line">    select PFLASH_CFI01</span><br><span class="line">    select SERIAL</span><br><span class="line">    select RISCV_ACLINT</span><br><span class="line">    select RISCV_APLIC</span><br><span class="line">    select RISCV_IMSIC</span><br><span class="line">    select SIFIVE_PLIC</span><br><span class="line">    select SIFIVE_TEST</span><br><span class="line">    select VIRTIO_MMIO</span><br><span class="line">    select FW_CFG_DMA</span><br><span class="line">    select PLATFORM_BUS</span><br><span class="line">    select ACPI</span><br></pre></td></tr></table></figure><p>select：select关键字表示启用RISCV_VIRT选项时，会自动选择（即启用）其他相关选项。</p><ul><li><code>select RISCV_NUMA</code>：选择RISCV_NUMA选项，表示虚拟机将支持RISC-V架构的NUMA（非一致性存储访问）特性。</li><li><code>select GOLDFISH_RTC</code>：选择GOLDFISH_RTC选项，表示虚拟机将支持Google Goldfish RTC设备，用于提供计时和时间相关的功能。</li><li><code>select PCI</code>：选择PCI选项，表示虚拟机将支持PCI（Peripheral Component Interconnect）总线。</li><li><code>select PCI_EXPRESS_GENERIC_BRIDGE</code>：选择PCI_EXPRESS_GENERIC_BRIDGE选项，表示虚拟机将支持通用PCI Express桥接器。</li><li><code>select PFLASH_CFI01</code>：选择PFLASH_CFI01选项，表示虚拟机将支持CFI（Common Flash Interface）规范的并行 NOR Flash 存储器。</li><li><code>select SERIAL</code>：选择SERIAL选项，表示虚拟机将支持串口设备，用于输入输出和调试。</li><li><code>select RISCV_ACLINT</code>：选择RISCV_ACLINT选项，表示虚拟机将支持ACLINT（Architectural Core Local Interruptor）设备，用于处理核心级的中断和计时器。</li><li><code>select RISCV_APLIC</code>：选择RISCV_APLIC选项，表示虚拟机将支持APLIC（Architectural Platform-Level Interrupt Controller）设备，用于处理平台级的中断。</li><li><code>select RISCV_IMSIC</code>：选择RISCV_IMSIC选项，表示虚拟机将支持IMSIC（Interrupt-Management Standardized Interface Controller）设备。</li><li><code>select SIFIVE_PLIC</code>：选择SIFIVE_PLIC选项，表示虚拟机将支持SiFive PLIC（Platform-Level Interrupt Controller）设备。</li><li><code>select SIFIVE_TEST</code>：选择SIFIVE_TEST选项，表示虚拟机将支持SiFive Test设备，用于测试和验证。</li><li><code>select VIRTIO_MMIO</code>：选择VIRTIO_MMIO选项，表示虚拟机将支持VirtIO MMIO传输设备，用于与客户操作系统进行通信。</li><li><code>select FW_CFG_DMA</code>：选择FW_CFG_DMA选项，表示虚拟机将支持DMA（Direct Memory Access）传输，用于从QEMU获取数据。</li><li><code>select PLATFORM_BUS</code>：选择PLATFORM_BUS选项，表示虚拟机将支持平台总线，用作硬件组件之间的通信接口。</li><li><code>select ACPI</code>：选择ACPI选项，表示虚拟机将支持ACPI（Advanced Configuration and Power Interface）标准，用于管理系统配置和电源管理。</li></ul><h2 id="2-2-virt-h"><a href="#2-2-virt-h" class="headerlink" title="2.2 virt.h"></a>2.2 virt.h</h2><h3 id="2-2-1-DECLARE-INSTANCE-CHECKER"><a href="#2-2-1-DECLARE-INSTANCE-CHECKER" class="headerlink" title="2.2.1 DECLARE_INSTANCE_CHECKER"></a>2.2.1 <code>DECLARE_INSTANCE_CHECKER</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_RISCV_VIRT_MACHINE MACHINE_TYPE_NAME(<span class="string">&quot;virt&quot;</span>)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RISCVVirtState</span> <span class="title">RISCVVirtState</span>;</span>   <span class="comment">//结构体前向声明</span></span><br><span class="line">DECLARE_INSTANCE_CHECKER(RISCVVirtState, RISCV_VIRT_MACHINE,</span><br><span class="line">                         TYPE_RISCV_VIRT_MACHINE)</span><br></pre></td></tr></table></figure><p>首先调用<code>DECLARE_INSTANCE_CHECKER</code>这个宏，这个宏在qemu源码中的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span></span><br><span class="line"><span class="meta">    static inline G_GNUC_UNUSED InstanceType * \</span></span><br><span class="line"><span class="meta">    OBJ_NAME(const void *obj) \</span></span><br><span class="line"><span class="meta">    &#123; return OBJECT_CHECK(InstanceType, obj, TYPENAME); &#125;</span></span><br></pre></td></tr></table></figure><p><code>DECLARE_INSTANCE_CHECKER</code>宏用于为QOM（QEMU Object Model）类型提供实例类型转换函数。它接受三个参数：<code>InstanceType</code>表示实例结构体的名称，<code>OBJ_NAME</code>表示以大写字母和下划线分隔的对象名称，<code>TYPENAME</code>表示类型名称。</p><p>因此这里就是用来将<code>RISCVVirtState</code>转换为一个<code>QOM</code>类型的结构体，后续需要去定义这个结构体，经过这一步可以认为声明了一个名交<code>virt</code>的riscv板子。</p><h3 id="2-2-2-RISCVVirtState定义"><a href="#2-2-2-RISCVVirtState定义" class="headerlink" title="2.2.2 RISCVVirtState定义"></a>2.2.2 <code>RISCVVirtState</code>定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">RISCVVirtAIAType</span> &#123;</span></span><br><span class="line">    VIRT_AIA_TYPE_NONE = <span class="number">0</span>,</span><br><span class="line">    VIRT_AIA_TYPE_APLIC,</span><br><span class="line">    VIRT_AIA_TYPE_APLIC_IMSIC,</span><br><span class="line">&#125; RISCVVirtAIAType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RISCVVirtState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;    <span class="comment">//继承MachineState </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    Notifier machine_done;  <span class="comment">// </span></span><br><span class="line">    DeviceState *platform_bus_dev;</span><br><span class="line">    RISCVHartArrayState soc[VIRT_SOCKETS_MAX];</span><br><span class="line">    DeviceState *irqchip[VIRT_SOCKETS_MAX];</span><br><span class="line">    PFlashCFI01 *flash[<span class="number">2</span>];   <span class="comment">//flash</span></span><br><span class="line">    FWCfgState *fw_cfg;      <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fdt_size;</span><br><span class="line">    <span class="type">bool</span> have_aclint;</span><br><span class="line">    RISCVVirtAIAType aia_type;</span><br><span class="line">    <span class="type">int</span> aia_guests;</span><br><span class="line">    <span class="type">char</span> *oem_id;</span><br><span class="line">    <span class="type">char</span> *oem_table_id;</span><br><span class="line">    OnOffAuto acpi;</span><br><span class="line">    <span class="type">const</span> MemMapEntry *memmap; <span class="comment">//内存映射</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>RISCVVirtState</code>这个结构体中，定义了很多其他设备和成员变量，在qemu中各个硬件都是虚拟的，可以将一种硬件看作是一个结构体类，virt这块板子有哪些硬件就要在<code>RISCVVirtState</code>这个本体结构体中去包含这些属性，和硬件相关的设备定义基本都在<code>hw/</code>目录下。</p><h3 id="2-2-3-枚举变量"><a href="#2-2-3-枚举变量" class="headerlink" title="2.2.3 枚举变量"></a>2.2.3 枚举变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    VIRT_DEBUG,</span><br><span class="line">    VIRT_MROM,</span><br><span class="line">    VIRT_TEST,</span><br><span class="line">    VIRT_RTC,</span><br><span class="line">    VIRT_CLINT,</span><br><span class="line">    VIRT_ACLINT_SSWI,</span><br><span class="line">    VIRT_PLIC,</span><br><span class="line">    VIRT_APLIC_M,</span><br><span class="line">    VIRT_APLIC_S,</span><br><span class="line">    VIRT_UART0,</span><br><span class="line">    VIRT_VIRTIO,</span><br><span class="line">    VIRT_FW_CFG,</span><br><span class="line">    VIRT_IMSIC_M,</span><br><span class="line">    VIRT_IMSIC_S,</span><br><span class="line">    VIRT_FLASH,</span><br><span class="line">    VIRT_DRAM,</span><br><span class="line">    VIRT_PCIE_MMIO,</span><br><span class="line">    VIRT_PCIE_PIO,</span><br><span class="line">    VIRT_PLATFORM_BUS,</span><br><span class="line">    VIRT_PCIE_ECAM</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    UART0_IRQ = <span class="number">10</span>, <span class="comment">//串口中断号</span></span><br><span class="line">    RTC_IRQ = <span class="number">11</span>,   <span class="comment">// RTC 中断号</span></span><br><span class="line">    VIRTIO_IRQ = <span class="number">1</span>, <span class="comment">/* 1 to 8 */</span></span><br><span class="line">    VIRTIO_COUNT = <span class="number">8</span>,</span><br><span class="line">    PCIE_IRQ = <span class="number">0x20</span>, <span class="comment">/* 32 to 35 */</span></span><br><span class="line">    VIRT_PLATFORM_BUS_IRQ = <span class="number">64</span>, <span class="comment">/* 64 to 95 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就是使用枚举定义了一些和硬件、中断号相关的变量。</p><h3 id="2-2-4-宏定义"><a href="#2-2-4-宏定义" class="headerlink" title="2.2.4 宏定义"></a>2.2.4 宏定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLATFORM_BUS_NUM_IRQS 32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_IRQCHIP_NUM_MSIS 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_IRQCHIP_NUM_SOURCES 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_IRQCHIP_NUM_PRIO_BITS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_IRQCHIP_MAX_GUESTS_BITS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_IRQCHIP_MAX_GUESTS ((1U &lt;&lt; VIRT_IRQCHIP_MAX_GUESTS_BITS) - 1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_PRIORITY_BASE 0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_PENDING_BASE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_ENABLE_BASE 0x2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_ENABLE_STRIDE 0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_CONTEXT_BASE 0x200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_CONTEXT_STRIDE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_SIZE(__num_context) \</span></span><br><span class="line"><span class="meta">    (VIRT_PLIC_CONTEXT_BASE + (__num_context) * VIRT_PLIC_CONTEXT_STRIDE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PCI_ADDR_CELLS    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PCI_INT_CELLS     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PLIC_ADDR_CELLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PLIC_INT_CELLS    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_APLIC_INT_CELLS   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_IMSIC_INT_CELLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAX_INT_CELLS     2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAX_INT_MAP_WIDTH (FDT_PCI_ADDR_CELLS + FDT_PCI_INT_CELLS + \</span></span><br><span class="line"><span class="meta">                                 1 + FDT_MAX_INT_CELLS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PLIC_INT_MAP_WIDTH  (FDT_PCI_ADDR_CELLS + FDT_PCI_INT_CELLS + \</span></span><br><span class="line"><span class="meta">                                 1 + FDT_PLIC_INT_CELLS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_APLIC_INT_MAP_WIDTH (FDT_PCI_ADDR_CELLS + FDT_PCI_INT_CELLS + \</span></span><br><span class="line"><span class="meta">                                 1 + FDT_APLIC_INT_CELLS)</span></span><br></pre></td></tr></table></figure><h2 id="2-3-virt-c"><a href="#2-3-virt-c" class="headerlink" title="2.3 virt.c"></a>2.3 virt.c</h2><h3 id="2-3-1-硬件内存映射定义"><a href="#2-3-1-硬件内存映射定义" class="headerlink" title="2.3.1 硬件内存映射定义"></a>2.3.1 硬件内存映射定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const MemMapEntry virt_memmap[] = &#123;</span><br><span class="line">    [VIRT_DEBUG] =        &#123;        0x0,         0x100 &#125;,</span><br><span class="line">    [VIRT_MROM] =         &#123;     0x1000,        0xf000 &#125;,</span><br><span class="line">    [VIRT_TEST] =         &#123;   0x100000,        0x1000 &#125;,</span><br><span class="line">    [VIRT_RTC] =          &#123;   0x101000,        0x1000 &#125;,</span><br><span class="line">    [VIRT_CLINT] =        &#123;  0x2000000,       0x10000 &#125;,</span><br><span class="line">    [VIRT_ACLINT_SSWI] =  &#123;  0x2F00000,        0x4000 &#125;,</span><br><span class="line">    [VIRT_PCIE_PIO] =     &#123;  0x3000000,       0x10000 &#125;,</span><br><span class="line">    [VIRT_PLATFORM_BUS] = &#123;  0x4000000,     0x2000000 &#125;,</span><br><span class="line">    [VIRT_PLIC] =         &#123;  0xc000000, VIRT_PLIC_SIZE(VIRT_CPUS_MAX * 2) &#125;,</span><br><span class="line">    [VIRT_APLIC_M] =      &#123;  0xc000000, APLIC_SIZE(VIRT_CPUS_MAX) &#125;,</span><br><span class="line">    [VIRT_APLIC_S] =      &#123;  0xd000000, APLIC_SIZE(VIRT_CPUS_MAX) &#125;,</span><br><span class="line">    [VIRT_UART0] =        &#123; 0x10000000,         0x100 &#125;,</span><br><span class="line">    [VIRT_VIRTIO] =       &#123; 0x10001000,        0x1000 &#125;,</span><br><span class="line">    [VIRT_FW_CFG] =       &#123; 0x10100000,          0x18 &#125;,</span><br><span class="line">    [VIRT_FLASH] =        &#123; 0x20000000,     0x4000000 &#125;,</span><br><span class="line">    [VIRT_IMSIC_M] =      &#123; 0x24000000, VIRT_IMSIC_MAX_SIZE &#125;,</span><br><span class="line">    [VIRT_IMSIC_S] =      &#123; 0x28000000, VIRT_IMSIC_MAX_SIZE &#125;,</span><br><span class="line">    [VIRT_PCIE_ECAM] =    &#123; 0x30000000,    0x10000000 &#125;,</span><br><span class="line">    [VIRT_PCIE_MMIO] =    &#123; 0x40000000,    0x40000000 &#125;,</span><br><span class="line">    [VIRT_DRAM] =         &#123; 0x80000000,           0x0 &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MemMapEntry 结构体定义如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemMapEntry</span> &#123;</span></span><br><span class="line">    hwaddr base;</span><br><span class="line">    hwaddr size;</span><br><span class="line">&#125; MemMapEntry;</span><br></pre></td></tr></table></figure><p>可以看到上面内存映射的第一个参数为硬件映射的地址，第二个参数为映射的内存长度。</p><h3 id="2-3-2-注册virt机器"><a href="#2-3-2-注册virt机器" class="headerlink" title="2.3.2 注册virt机器"></a>2.3.2 注册virt机器</h3><p>在virt.c代码的最下方可以看到注册相关的代码，首先需要定义一个<code>virt_machine_typeinfo</code>，然后调用<code>type_register_static</code>函数，最后调用 type_init这个宏。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo virt_machine_typeinfo = &#123;</span><br><span class="line">    .name       = MACHINE_TYPE_NAME(<span class="string">&quot;virt&quot;</span>),  <span class="comment">//注册板卡，定义名称</span></span><br><span class="line">    .parent     = TYPE_MACHINE,  <span class="comment">//父类名称</span></span><br><span class="line">    .class_init = virt_machine_class_init,    <span class="comment">// </span></span><br><span class="line">    .instance_init = virt_machine_instance_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(RISCVVirtState),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">         &#123; TYPE_HOTPLUG_HANDLER &#125;,</span><br><span class="line">         &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virt_machine_init_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;virt_machine_typeinfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(virt_machine_init_register_types)</span><br></pre></td></tr></table></figure><p>这里有几个重要的成员变量：</p><ul><li><p>@class_init: 函数指针，该函数在所有父类初始化完成后调用，允许类设置其默认的虚拟方法指针。也可以使用该函数覆盖父类的虚拟方法。</p></li><li><p>@instance_init: 函数指针，该函数用于初始化一个对象。父类已经完成初始化，因此该类型只需负责初始化自己的成员。</p></li><li><p>@instance_size: 对象的大小（派生自 #Object）。如果 @instance_size 为 0，则对象的大小将为父对象的大小。</p></li><li><p>@interfaces: 与该类型关联的接口列表。应指向以零填充的静态数组作为终止元素。</p></li></ul><p>在qemu中想要定义自己的板卡是采用类似C++中继承的方式来实现的，在virt.h中可以认为<code>RISCVVirtState</code>为一个子类，继承了qemu中的统一的machine的父类，我们需要在子类中来创建属于自己的硬件。所以下一步就需要来定义<code>virt_machine_class_init</code>和<code>virt_machine_instance_init</code>这两个函数。</p><h3 id="2-3-3-virt-machine-class-init函数定义"><a href="#2-3-3-virt-machine-class-init函数定义" class="headerlink" title="2.3.3 virt_machine_class_init函数定义"></a>2.3.3 <code>virt_machine_class_init</code>函数定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virt_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">128</span>];</span><br><span class="line">    MachineClass *mc = MACHINE_CLASS(oc);</span><br><span class="line">    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V VirtIO board&quot;</span>;</span><br><span class="line">    mc-&gt;init = virt_machine_init;</span><br><span class="line">    mc-&gt;max_cpus = VIRT_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;default_ram_id = <span class="string">&quot;riscv_virt_board.ram&quot;</span>;</span><br><span class="line">    assert(!mc-&gt;get_hotplug_handler);</span><br><span class="line">    mc-&gt;get_hotplug_handler = virt_machine_get_hotplug_handler;</span><br><span class="line"></span><br><span class="line">    hc-&gt;plug = virt_machine_device_plug_cb;</span><br><span class="line"></span><br><span class="line">    machine_class_allow_dynamic_sysbus_dev(mc, TYPE_RAMFB_DEVICE);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TPM</span></span><br><span class="line">    machine_class_allow_dynamic_sysbus_dev(mc, TYPE_TPM_TIS_SYSBUS);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    object_class_property_add_bool(oc, <span class="string">&quot;aclint&quot;</span>, virt_get_aclint,</span><br><span class="line">                                   virt_set_aclint);</span><br><span class="line">    object_class_property_set_description(oc, <span class="string">&quot;aclint&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;Set on/off to enable/disable &quot;</span></span><br><span class="line">                                          <span class="string">&quot;emulating ACLINT devices&quot;</span>);</span><br><span class="line"></span><br><span class="line">    object_class_property_add_str(oc, <span class="string">&quot;aia&quot;</span>, virt_get_aia,</span><br><span class="line">                                  virt_set_aia);</span><br><span class="line">    object_class_property_set_description(oc, <span class="string">&quot;aia&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;Set type of AIA interrupt &quot;</span></span><br><span class="line">                                          <span class="string">&quot;conttoller. Valid values are &quot;</span></span><br><span class="line">                                          <span class="string">&quot;none, aplic, and aplic-imsic.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    object_class_property_add_str(oc, <span class="string">&quot;aia-guests&quot;</span>,</span><br><span class="line">                                  virt_get_aia_guests,</span><br><span class="line">                                  virt_set_aia_guests);</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;Set number of guest MMIO pages for AIA IMSIC. Valid value &quot;</span></span><br><span class="line">                 <span class="string">&quot;should be between 0 and %d.&quot;</span>, VIRT_IRQCHIP_MAX_GUESTS);</span><br><span class="line">    object_class_property_set_description(oc, <span class="string">&quot;aia-guests&quot;</span>, str);</span><br><span class="line">    object_class_property_add(oc, <span class="string">&quot;acpi&quot;</span>, <span class="string">&quot;OnOffAuto&quot;</span>,</span><br><span class="line">                              virt_get_acpi, virt_set_acpi,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    object_class_property_set_description(oc, <span class="string">&quot;acpi&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;Enable ACPI&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-virt创建CPU"><a href="#2-3-4-virt创建CPU" class="headerlink" title="2.3.4 virt创建CPU"></a>2.3.4 virt创建CPU</h3><h3 id="2-3-5-virt创建PLIC"><a href="#2-3-5-virt创建PLIC" class="headerlink" title="2.3.5 virt创建PLIC"></a>2.3.5 virt创建PLIC</h3><h3 id="2-3-6-virt创建ACLINT"><a href="#2-3-6-virt创建ACLINT" class="headerlink" title="2.3.6 virt创建ACLINT"></a>2.3.6 virt创建ACLINT</h3>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础-存储访问</title>
      <link href="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/"/>
      <url>/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-存储器使用场景"><a href="#1-存储器使用场景" class="headerlink" title="1.存储器使用场景"></a>1.存储器使用场景</h1><p>先来看如下这一张图，CPU运行程序的流程如下：</p><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614133226741.png" alt="image-20230614133226741"></p><p>1：假设我现在在电脑上编译了一个<code>hello.c</code>的程序，编译完成后为<code>hello.bin</code>的一个二进制文件，此时这个程序还存储在我们电脑的硬盘上，这个硬盘可能是机械硬盘也可能是固态硬盘，这些都是外存储器。</p><p>2：将<code>hello.bin</code>装载进内存，这里的内存就是插在电脑上的内存条，<code>hello.bin</code>包含了cpu要执行的指令和运行所需要的数据。</p><p>3：CPU从内存中逐条读取指令及相关指令，然后依次执行完成对数据的处理。</p><p>4：将处理结果送回内存保存，然后再将处理结果送到外存储器。</p><p>所以其实在CPU运行的过程中主要是分为两类存储器：</p><ul><li><p>内存储器</p><p>存取速度快 </p><p>成本高、容量相对较小 </p><p>直接与CPU连接，CPU对内存 中可直接进行读、写操作 </p><p>属于易失性存储器(volatile)， 用于临时存放正在运行的程序和数据，掉电就没了数据。</p></li><li><p>外存储器（简称外存或辅存）</p><p>– 存取速度慢 – 成本低、容量很大 </p><p>– 不与CPU直接连接，先传送到内 存，然后才能被CPU使用。</p><p> – 属于非易失性存储器，用于长久存放系统中几乎所有的信息</p></li></ul><blockquote><p>这里可能会有个疑问，CPU访问内存的方式是通过地址总线来访问的，CPU是如何访问外存的呢：</p><p>CPU访问外部存储器（外存）的方式通常是通过输入输出（I&#x2F;O）指令和I&#x2F;O总线来实现的。外存通常指的是硬盘、固态硬盘（SSD）、光盘、磁带等非易失性存储介质。</p><p>与内存访问不同，外存的访问速度相对较慢，因此CPU在执行指令时通常不直接与外存进行交互，而是通过操作系统和设备控制器等中间层来实现。以下是CPU访问外存的一般过程：</p><ol><li>CPU发送I&#x2F;O指令：当需要读取或写入外存中的数据时，CPU会发出相应的I&#x2F;O指令，这些指令通常包括读取（IN）和写入（OUT）操作。</li><li>I&#x2F;O总线传输：CPU将I&#x2F;O指令发送到I&#x2F;O总线上。I&#x2F;O总线是一种特殊的总线，用于传输CPU和外部设备之间的数据和控制信号。</li><li>设备控制器响应：I&#x2F;O总线上连接着各种外部设备控制器，如硬盘控制器或磁带控制器。当设备控制器接收到CPU发送的I&#x2F;O指令时，它会解析指令并准备执行相应的读取或写入操作。</li><li>数据传输：设备控制器根据指令从外存读取数据或将数据写入外存。这个过程涉及到设备控制器与外存之间的数据传输，可能需要通过外存总线或其他特定接口进行。</li><li>完成操作：设备控制器完成读取或写入操作后，将状态信息返回给CPU，指示操作是否成功或是否有错误发生。</li></ol></blockquote><p>主存的结构如下：</p><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614140500484.png" alt="image-20230614140500484"></p><p>一个存储单元为一个bit，按字节编址的话一个地址对应的就是8个字节，数据总线读取一个地址的数据就一次性读取8个bit，这8个bit的地址都是一样的</p><p>如果CPU的数据总线是64位，则一次性最大可以读取64bit的数据也就是8个字节。</p><p>地址线为36位，则可以寻址的范围是0~2^36-1，即主存地址空间为64GB。</p><h1 id="2-存储器分类"><a href="#2-存储器分类" class="headerlink" title="2.存储器分类"></a>2.存储器分类</h1><h2 id="2-1-RAM"><a href="#2-1-RAM" class="headerlink" title="2.1 RAM"></a>2.1 RAM</h2><p>内存（主存，RAM，Random Access Memory）：</p><ol><li>主存是CPU直接访问的存储器，用于存储当前执行的程序、数据和临时计算结果。</li><li>分类：<ul><li>随机访问存储器（RAM）：包括动态随机访问存储器（DRAM）和静态随机访问存储器（SRAM）。DRAM存储器成本较低，容量较大，但读写速度相对较慢；SRAM存储器读写速度快，但成本较高。</li><li>缓存（Cache）：用于在CPU和主存之间提供快速数据访问，减少CPU等待数据的时间。根据接近CPU的级别不同，可以分为一级缓存（L1 Cache）、二级缓存（L2 Cache）等多级别缓存。</li></ul></li><li>应用场景：<ul><li>执行指令和存储数据：CPU从内存中读取指令和数据进行运算和处理。</li><li>运行操作系统和应用程序：操作系统和应用程序加载到内存中运行，提供计算、存储和交互功能。</li></ul></li></ol><h2 id="2-2-ROM"><a href="#2-2-ROM" class="headerlink" title="2.2 ROM"></a>2.2 ROM</h2><p>ROM是只读存储器（Read-Only Memory）的缩写，它是一种用于存储固定数据的存储器类型。与可写的存储器（如RAM）不同，ROM中的数据在制造或编程之后就无法被修改。</p><p>以下是一些关键特点和应用场景，以帮助更好理解ROM：</p><p>特点：</p><ol><li>只读性质：ROM中的数据在制造或编程之后就无法被修改或擦除。</li><li>非易失性：与RAM不同，ROM中的数据在断电或重新启动后仍然保持不变。</li><li>持久存储：ROM用于存储固定的数据，如固件、引导程序、不经常更改的配置信息等。</li></ol><p>应用场景：</p><ol><li>固件：ROM常用于存储计算机系统或电子设备的固件，包括BIOS（基本输入&#x2F;输出系统）、固件程序和引导加载器等。</li><li>引导程序：计算机启动时，ROM中的引导程序负责初始化硬件和加载操作系统。</li><li>芯片固化数据：ROM用于存储芯片的校准数据、配置信息和厂商特定的数据，以便在设备制造后使用。</li><li>只读存储媒体：一些光盘和芯片类型，如CD-ROM、DVD-ROM、Blu-ray Disc、EPROM（可擦除可编程只读存储器）等，被设计为只读存储介质。</li></ol><p>需要注意的是，不同类型的ROM可以具有不同的特性。例如，EPROM是一种可擦除可编程只读存储器，允许通过特殊操作将其中的数据擦除并重新编程，而普通的ROM则不具备这种功能。此外，还有一些衍生类型的ROM，如EEPROM（可擦除可编程只读存储器）、Flash存储器等，它们具有一定的可擦除和可重新编程的能力。</p><h2 id="2-3-储存器功能分类"><a href="#2-3-储存器功能分类" class="headerlink" title="2.3 储存器功能分类"></a>2.3 储存器功能分类</h2><ul><li>寄存器(Register) <ul><li>封装在CPU内，用于存放当前正在执行的指令和使用的数据 </li><li>用触发器实现，速度快，容量小（几~几十个）</li></ul></li><li>高速缓存(Cache) </li><li>位于CPU内部或附近，用来存放当前要执行的局部程序段和数据 </li><li>-用SRAM实现，速度可与CPU匹配，容量小（几MB） </li><li>内存储器MM（主存储器Main (Primary) Memory）<ul><li>位于CPU之外，用来存放已被启动的程序及所用的数据 </li><li>用DRAM实现，速度较快，容量较大（几GB）</li></ul></li><li>外存储器AM (辅助存储器Auxiliary &#x2F; Secondary Storage) <ul><li>位于主机之外，用来存放暂不运行的程序、数据或存档文件</li><li>用磁盘、SSD等实现，容量大而速度慢</li></ul></li></ul><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614140240489.png" alt="image-20230614140240489"></p><h1 id="3-嵌入式存储实例"><a href="#3-嵌入式存储实例" class="headerlink" title="3.嵌入式存储实例"></a>3.嵌入式存储实例</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器 </tag>
            
            <tag> 计算机系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.新建quard-star开发板</title>
      <link href="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
      <url>/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-QEMU中新增虚拟开发板"><a href="#1-QEMU中新增虚拟开发板" class="headerlink" title="1. QEMU中新增虚拟开发板"></a>1. QEMU中新增虚拟开发板</h1><blockquote><p>参考链接：<a href="https://quard-star-tutorial.readthedocs.io/zh_CN/latest/ch2.html">基于qemu-riscv从0开始构建嵌入式linux系统ch2. 添加qemu仿真板——Quard-Star板 — 主页 (quard-star-tutorial.readthedocs.io)</a></p><p>本文主要参考了上面的博文，复现一下在qemu中自定义板卡的过程，用于个人学习。</p></blockquote><p>前言：qemu内置支持了一些开发板，我们可以基于这些内置的板子来做操作系统等软件的配置，但是实际市面上很多板子qemu中是没有提供支持的，要是直接在硬件中进行软件验证会十分麻烦，还好qemu中可以支持用户自定义开发板，这样就可以虚拟的对开发板进行验证了。</p><p>在向qemu中注册自定义的板子需要向qemu中添加源码，然后重新编译，qemu源码安装的编译过程我的这一篇博客：<a href="https://yanglianoo.github.io/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/">从源码构建Qemu | TimerのBlog (yanglianoo.github.io)</a></p><p>我们添加的板子cpu架构为riscv，进入qemu源码的<code>hw/riscv</code>目录下，可以看到如下图中的文件，其中qemu官方默认添加了几个riscv板子，比如：<code>virt</code>，<code>sifive</code>，其中<code>virt</code>，这块虚拟板子也是最常用的虚拟板子，常用于作为基于riscv操作系统的原型验证，比如<code>xv6，rvos</code>都是基于<code>qemu-virt</code>构建的。</p><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230612201442813.png" alt="image-20230612201442813"></p><p>再进入<code>include/hw/riscv</code>目录，这里放着虚拟板卡的头文件：</p><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230612202614817.png" alt="image-20230612202614817"></p><h1 id="2-quard-star开发板的硬件资源"><a href="#2-quard-star开发板的硬件资源" class="headerlink" title="2.quard_star开发板的硬件资源"></a>2.quard_star开发板的硬件资源</h1><p>我们将自定义的开发板名字命名为<code>quard_star</code>，理论上这块板子的硬件资源你可以随便定义，开发板的资源如下：</p><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/img3.png" alt="img3.png"></p><ul><li><p>CPU：8个64位的hart，<code>mmu</code>的虚拟地址翻译模式为<code>sv48</code></p></li><li><p>plic：平台级中断控制器</p></li><li><p>clint：内部中断控制器</p></li><li><p>mask-rom：32KB</p></li><li><p>PFLASH：32MB</p></li><li><p>DDR：1GB</p></li><li><p>NANO Flash：256MB</p></li><li><p>CAN：</p></li><li><p>DMA：</p></li><li><p>TIMER：</p></li><li><p>ETH：</p></li><li><p>USB：</p></li><li><p>SPI：</p></li><li><p>IIC：</p></li><li><p>ADC：</p></li><li><p>GPIO：</p></li><li><p>SDMMC：</p></li><li><p>UART：</p></li><li><p>RTC：</p></li><li><p>WATHDOG：</p></li></ul><p>我们的目标就是在qemu中创建这样一个开发板，需要依次在qemu中定义每一个硬件。接下来就来逐步添加每一个硬件</p><h1 id="3-添加quard-star板子"><a href="#3-添加quard-star板子" class="headerlink" title="3.添加quard-star板子"></a>3.添加quard-star板子</h1><blockquote><p>声明：以下使用的qemu源码版本均为<code>qemu-8.0.2</code>，参考代码为qemu的virt这块板子的代码，我们需要先让qemu识别到<code>quard-star</code>这块板子，然后再逐渐丰富板子的外设。</p></blockquote><p>注册<code>quard-star</code>板子需要修改如下几个文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`qemu-8.0.2/configs/devices/riscv64-softmmu/default.mak`</span><br><span class="line">`qemu-8.0.2/configs/devices/riscv32-softmmu/default.mak`</span><br><span class="line">`qemu-8.0.2/hw/riscv/meson.build`</span><br><span class="line">`qemu-8.0.2/hw/riscv/Kconfig`</span><br></pre></td></tr></table></figure><p>要在qemu中定义自己的虚拟板卡，需要在<code>hw/riscv</code>目录下增加一个和自己板子相关的<code>.c</code>文件，以及在<code>include/hw/riscv</code>目录下添加一个对应虚拟板子的<code>.h</code>文件，这里新增<code>quard_star.c</code>和<code>quard_star.h</code>文件，将其加入qemu编译体系内。</p><h2 id="3-1-文件修改"><a href="#3-1-文件修改" class="headerlink" title="3.1 文件修改"></a>3.1 文件修改</h2><ul><li><code>qemu-8.0.2/hw/riscv/meson.build</code></li></ul><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230613210722392.png" alt="image-20230613210722392"></p><ul><li><code>qemu-8.0.2/hw/riscv/Kconfig</code>：这里只暂时只选中一个串口设备。</li></ul><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230613210910355.png" alt="image-20230613210910355"></p><ul><li><code>qemu-8.0.2/configs/devices/riscv32-softmmu/default.mak</code></li></ul><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230613211119900.png" alt="image-20230613211119900"></p><ul><li><code>qemu-8.0.2/configs/devices/riscv64-softmmu/default.mak</code></li></ul><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230613215029879.png" alt="image-20230613215029879"></p><h2 id="3-2-添加源码"><a href="#3-2-添加源码" class="headerlink" title="3.2 添加源码"></a>3.2 添加源码</h2><p>这里先把源码添加上去，后续慢慢分析，源码来自于文章开头参考的项目以及<code>qemu</code>中<code>virt</code>的源码。这里只定义了和初始化了MROM、SRAM、DRAM三种硬件。</p><h3 id="3-2-1-quard-star-h"><a href="#3-2-1-quard-star-h" class="headerlink" title="3.2.1 quard_star.h"></a>3.2.1 quard_star.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HW_RISCV_QUARD_STAR__H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HW_RISCV_QUARD_STAR__H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/riscv_hart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/sysbus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qom/object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/block/flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_CPUS_MAX 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_SOCKETS_MAX 8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_RISCV_QUARD_STAR_MACHINE MACHINE_TYPE_NAME(<span class="string">&quot;quard-star&quot;</span>)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QuardStarState</span> <span class="title">QuardStarState</span>;</span></span><br><span class="line">DECLARE_INSTANCE_CHECKER(QuardStarState, RISCV_VIRT_MACHINE,</span><br><span class="line">                         TYPE_RISCV_QUARD_STAR_MACHINE)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuardStarState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_UART0_IRQ = <span class="number">10</span>,  <span class="comment">//定义了串口中断号为10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-2-1-quard-star-c"><a href="#3-2-1-quard-star-c" class="headerlink" title="3.2.1 quard_star.c"></a>3.2.1 quard_star.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/units.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/error-report.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/guest-random.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/boards.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/loader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/sysbus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-properties.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/char/serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;target/riscv/cpu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/riscv_hart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/quard_star.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/boot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/numa.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/intc/riscv_aclint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/intc/riscv_aplic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev/char.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/device_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/sysemu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/kvm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/tpm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 创建CPU */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_cpu_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, base_hartid, hart_count;</span><br><span class="line">    <span class="type">char</span> *soc_name;</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QUARD_STAR_SOCKETS_MAX &lt; riscv_socket_count(machine)) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;number of sockets/nodes should be less than %d&quot;</span>,</span><br><span class="line">            QUARD_STAR_SOCKETS_MAX);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; riscv_socket_count(machine); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!riscv_socket_check_hartids(machine, i)) &#123;</span><br><span class="line">            error_report(<span class="string">&quot;discontinuous hartids in socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        base_hartid = riscv_socket_first_hartid(machine, i);</span><br><span class="line">        <span class="keyword">if</span> (base_hartid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error_report(<span class="string">&quot;can&#x27;t find hartid base for socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hart_count = riscv_socket_hart_count(machine, i);</span><br><span class="line">        <span class="keyword">if</span> (hart_count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error_report(<span class="string">&quot;can&#x27;t find hart count for socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        soc_name = g_strdup_printf(<span class="string">&quot;soc%d&quot;</span>, i);</span><br><span class="line">        object_initialize_child(OBJECT(machine), soc_name, &amp;s-&gt;soc[i],</span><br><span class="line">                                TYPE_RISCV_HART_ARRAY);</span><br><span class="line">        g_free(soc_name);</span><br><span class="line">        object_property_set_str(OBJECT(&amp;s-&gt;soc[i]), <span class="string">&quot;cpu-type&quot;</span>,</span><br><span class="line">                                machine-&gt;cpu_type, &amp;error_abort);</span><br><span class="line">        object_property_set_int(OBJECT(&amp;s-&gt;soc[i]), <span class="string">&quot;hartid-base&quot;</span>,</span><br><span class="line">                                base_hartid, &amp;error_abort);</span><br><span class="line">        object_property_set_int(OBJECT(&amp;s-&gt;soc[i]), <span class="string">&quot;num-harts&quot;</span>,</span><br><span class="line">                                hart_count, &amp;error_abort);</span><br><span class="line">        sysbus_realize(SYS_BUS_DEVICE(&amp;s-&gt;soc[i]), &amp;error_abort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建内存 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_memory_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    MemoryRegion *system_memory = get_system_memory();</span><br><span class="line">    <span class="comment">//分配三片存储空间 dram sram mrom</span></span><br><span class="line">    MemoryRegion *dram_mem = g_new(MemoryRegion, <span class="number">1</span>);  <span class="comment">//DRAM</span></span><br><span class="line">    MemoryRegion *sram_mem = g_new(MemoryRegion, <span class="number">1</span>);  <span class="comment">//SRAM</span></span><br><span class="line">    MemoryRegion *mask_rom = g_new(MemoryRegion, <span class="number">1</span>);  <span class="comment">//MROM  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    memory_region_init_ram(dram_mem, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.dram&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_DRAM].size, &amp;error_fatal);</span><br><span class="line">    memory_region_add_subregion(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_DRAM].base, dram_mem);</span><br><span class="line"></span><br><span class="line">    memory_region_init_ram(sram_mem, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.sram&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_SRAM].size, &amp;error_fatal);</span><br><span class="line">    memory_region_add_subregion(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_SRAM].base, sram_mem);</span><br><span class="line"></span><br><span class="line">    memory_region_init_rom(mask_rom, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.mrom&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_MROM].size, &amp;error_fatal);</span><br><span class="line">    memory_region_add_subregion(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_MROM].base, mask_rom);</span><br><span class="line"></span><br><span class="line">    riscv_setup_rom_reset_vec(machine, &amp;s-&gt;soc[<span class="number">0</span>], </span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].size,</span><br><span class="line">                              <span class="number">0x0</span>, <span class="number">0x0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* quard-star 初始化各种硬件 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//创建CPU</span></span><br><span class="line">   quard_star_cpu_create(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   quard_star_memory_create(machine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建machine */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    MachineClass *mc = MACHINE_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V Quard Star board&quot;</span>;</span><br><span class="line">    mc-&gt;init = quard_star_machine_init;</span><br><span class="line">    mc-&gt;max_cpus = QUARD_STAR_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 注册 quard-star */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo quard_star_machine_typeinfo = &#123;</span><br><span class="line">    .name       = MACHINE_TYPE_NAME(<span class="string">&quot;quard-star&quot;</span>),</span><br><span class="line">    .parent     = TYPE_MACHINE,</span><br><span class="line">    .class_init = quard_star_machine_class_init,</span><br><span class="line">    .instance_init = quard_star_machine_instance_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(QuardStarState),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">         &#123; TYPE_HOTPLUG_HANDLER &#125;,</span><br><span class="line">         &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;quard_star_machine_typeinfo);</span><br><span class="line">&#125;</span><br><span class="line">type_init(quard_star_machine_init_register_types)</span><br></pre></td></tr></table></figure><h3 id="3-3-3-源码分析"><a href="#3-3-3-源码分析" class="headerlink" title="3.3.3 源码分析"></a>3.3.3 源码分析</h3><p>可以看见创建新的板子的流程为：</p><p>1.在<code>quard-star.h</code>中的<code>QuardStarState</code>结构体中为板子新建硬件，这些硬件表现在软件中为一个个的结构体，各种硬件结构体定义在<code>hw/</code>目录下，比如我现在只创建了CPU。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct QuardStarState &#123;</span><br><span class="line">    /*&lt; private &gt;*/</span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    /*&lt; public &gt;*/</span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.往<code>static const MemMapEntry quard_star_memmap[]</code>结构体数组中添加硬件的地址和映射的地址长度，注意这里的长度不能为0，不然会报错，其实这里DRAM的大小应该是qemu启动时需要用户输入的，例如<code>-m 1G</code>，这里暂不知道如何实现，所以指定了一个长度，不然会assert报错。<code>MemMapEntry </code>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemMapEntry</span> &#123;</span></span><br><span class="line">    hwaddr base; <span class="comment">//基址</span></span><br><span class="line">    hwaddr size; <span class="comment">//长度</span></span><br><span class="line">&#125; MemMapEntry;</span><br></pre></td></tr></table></figure><p>3.创建硬件，比如我这里创建并初始化了ram和rom，新建了<code>quard_star_memory_create</code>函数。在函数的最后这里调用了一个很重要的函数<code> riscv_setup_rom_reset_vec</code>，这个函数定义在<code>boot.c</code>中，函数主体如下：</p><blockquote><p>参考链接：<a href="https://github.com/wangzhou/notes/blob/master/%E5%A4%9A%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91">notes&#x2F;多核启动基本逻辑 at master · wangzhou&#x2F;notes · GitHub</a></p><p>参考链接：<a href="https://tinylab.org/qemu-riscv-zsbl/">QEMU 启动方式分析（3）: QEMU 代码与 RISCV virt 平台 ZSBL 分析 - 泰晓科技 (tinylab.org)</a></p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">riscv_setup_rom_reset_vec</span><span class="params">(MachineState *machine, RISCVHartArrayState *harts,</span></span><br><span class="line"><span class="params">                               hwaddr start_addr,</span></span><br><span class="line"><span class="params">                               hwaddr rom_base, hwaddr rom_size,</span></span><br><span class="line"><span class="params">                               <span class="type">uint64_t</span> kernel_entry,</span></span><br><span class="line"><span class="params">                               <span class="type">uint64_t</span> fdt_load_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> start_addr_hi32 = <span class="number">0x00000000</span>;</span><br><span class="line">    <span class="type">uint32_t</span> fdt_load_addr_hi32 = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!riscv_is_32bit(harts)) &#123;</span><br><span class="line">        start_addr_hi32 = start_addr &gt;&gt; <span class="number">32</span>;</span><br><span class="line">        fdt_load_addr_hi32 = fdt_load_addr &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* reset vector */</span></span><br><span class="line">    <span class="type">uint32_t</span> reset_vec[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="number">0x00000297</span>,                  <span class="comment">/* 1:  auipc  t0, %pcrel_hi(fw_dyn) */</span></span><br><span class="line">        <span class="number">0x02828613</span>,                  <span class="comment">/*     addi   a2, t0, %pcrel_lo(1b) */</span></span><br><span class="line">        <span class="number">0xf1402573</span>,                  <span class="comment">/*     csrr   a0, mhartid  */</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0x00028067</span>,                  <span class="comment">/*     jr     t0 */</span></span><br><span class="line">        start_addr,                  <span class="comment">/* start: .dword */</span></span><br><span class="line">        start_addr_hi32,</span><br><span class="line">        fdt_load_addr,               <span class="comment">/* fdt_laddr: .dword */</span></span><br><span class="line">        fdt_load_addr_hi32,</span><br><span class="line">                                     <span class="comment">/* fw_dyn: */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (riscv_is_32bit(harts)) &#123;</span><br><span class="line">        reset_vec[<span class="number">3</span>] = <span class="number">0x0202a583</span>;   <span class="comment">/*     lw     a1, 32(t0) */</span></span><br><span class="line">        reset_vec[<span class="number">4</span>] = <span class="number">0x0182a283</span>;   <span class="comment">/*     lw     t0, 24(t0) */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reset_vec[<span class="number">3</span>] = <span class="number">0x0202b583</span>;   <span class="comment">/*     ld     a1, 32(t0) */</span></span><br><span class="line">        reset_vec[<span class="number">4</span>] = <span class="number">0x0182b283</span>;   <span class="comment">/*     ld     t0, 24(t0) */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!harts-&gt;harts[<span class="number">0</span>].cfg.ext_icsr) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The Zicsr extension has been disabled, so let&#x27;s ensure we don&#x27;t</span></span><br><span class="line"><span class="comment">         * run the CSR instruction. Let&#x27;s fill the address with a non</span></span><br><span class="line"><span class="comment">         * compressed nop.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        reset_vec[<span class="number">2</span>] = <span class="number">0x00000013</span>;   <span class="comment">/*     addi   x0, x0, 0 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy in the reset vector in little_endian byte order */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(reset_vec); i++) &#123;</span><br><span class="line">        reset_vec[i] = cpu_to_le32(reset_vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rom_add_blob_fixed_as(<span class="string">&quot;mrom.reset&quot;</span>, reset_vec, <span class="keyword">sizeof</span>(reset_vec),</span><br><span class="line">                          rom_base, &amp;address_space_memory);</span><br><span class="line">    riscv_rom_copy_firmware_info(machine, rom_base, rom_size, <span class="keyword">sizeof</span>(reset_vec),</span><br><span class="line">                                 kernel_entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码执行以下操作：</p><ol><li>根据传入的参数，计算 <code>start_addr</code> 和 <code>fdt_load_addr</code> 的高 32 位（如果处理器不是 32 位的话）。</li><li>定义一个长度为 10 的 <code>reset_vec</code> 数组，用于存储复位向量的指令序列。</li><li>根据处理器是否为 32 位来设置不同的指令序列：<ul><li>如果是 32 位处理器，使用 <code>lw</code> 指令来加载 <code>a1</code> 和 <code>t0</code> 的值。</li><li>如果是 64 位处理器，使用 <code>ld</code> 指令来加载 <code>a1</code> 和 <code>t0</code> 的值。</li></ul></li><li>如果处理器的 <code>ext_icsr</code> 属性为假（即禁用了 Zicsr 扩展），则将复位向量的第 2 个指令替换为一个不压缩的 <code>nop</code> 指令（<code>addi x0, x0, 0</code>）。</li><li>将复位向量的指令按小端字节序进行拷贝。</li><li>使用 <code>rom_add_blob_fixed_as</code> 函数将复位向量的指令添加到固定地址的 ROM 中。</li><li>调用 <code>riscv_rom_copy_firmware_info</code></li></ol><p>我们先来看最后先了调用<code>rom_add_blob_fixed_as</code>函数将<code>reset_vec</code>中的代码拷贝到rom的起始位置，板子上电后最先执行的指令就是ROM起始位置处的这些指令。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rom_add_blob_fixed_as(<span class="string">&quot;mrom.reset&quot;</span>, reset_vec, <span class="keyword">sizeof</span>(reset_vec),</span><br><span class="line">                          rom_base, &amp;address_space_memory);  </span><br></pre></td></tr></table></figure><p>然后调用<code>riscv_rom_copy_firmware_info</code>，我们来看看这个函数，定义在<code>boot.c</code>中:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">riscv_rom_copy_firmware_info</span><span class="params">(MachineState *machine, hwaddr rom_base,</span></span><br><span class="line"><span class="params">                                  hwaddr rom_size, <span class="type">uint32_t</span> reset_vec_size,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint64_t</span> kernel_entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fw_dynamic_info</span> <span class="title">dinfo</span>;</span></span><br><span class="line">    <span class="type">size_t</span> dinfo_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(dinfo.magic) == <span class="number">4</span>) &#123;</span><br><span class="line">        dinfo.magic = cpu_to_le32(FW_DYNAMIC_INFO_MAGIC_VALUE);</span><br><span class="line">        dinfo.version = cpu_to_le32(FW_DYNAMIC_INFO_VERSION);</span><br><span class="line">        dinfo.next_mode = cpu_to_le32(FW_DYNAMIC_INFO_NEXT_MODE_S);</span><br><span class="line">        dinfo.next_addr = cpu_to_le32(kernel_entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dinfo.magic = cpu_to_le64(FW_DYNAMIC_INFO_MAGIC_VALUE);</span><br><span class="line">        dinfo.version = cpu_to_le64(FW_DYNAMIC_INFO_VERSION);</span><br><span class="line">        dinfo.next_mode = cpu_to_le64(FW_DYNAMIC_INFO_NEXT_MODE_S);</span><br><span class="line">        dinfo.next_addr = cpu_to_le64(kernel_entry);</span><br><span class="line">    &#125;</span><br><span class="line">    dinfo.options = <span class="number">0</span>;</span><br><span class="line">    dinfo.boot_hart = <span class="number">0</span>;</span><br><span class="line">    dinfo_len = <span class="keyword">sizeof</span>(dinfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * copy the dynamic firmware info. This information is specific to</span></span><br><span class="line"><span class="comment">     * OpenSBI but doesn&#x27;t break any other firmware as long as they don&#x27;t</span></span><br><span class="line"><span class="comment">     * expect any certain value in &quot;a2&quot; register.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dinfo_len &gt; (rom_size - reset_vec_size)) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;not enough space to store dynamic firmware info&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rom_add_blob_fixed_as(<span class="string">&quot;mrom.finfo&quot;</span>, &amp;dinfo, dinfo_len,</span><br><span class="line">                           rom_base + reset_vec_size,</span><br><span class="line">                           &amp;address_space_memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数初始化了一个<code>fw_dynamic_info</code>类型的结构体，这个结构体包含了下一阶段程序启动的地址、魔数、下一阶段CPU位于S态，初始化完毕后又调用<code>rom_add_blob_fixed_as</code>函数将<code>fw_dynamic_info</code>拷贝到rom的<code>reset_vec</code>之后，用于下一阶段的启动。在这里其实可以不用使用这个函数来传递设备树，后续需要我们自己来编写设备树然后编译，在下一阶段将固件中设备树的地址传给启动的下一阶段。</p><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p><p>所以现在再来看上面<code>reset_vec</code>的代码，将上面的代码翻译一下如下，以32位的cpu为例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reset_vec[<span class="number">0</span>] = <span class="number">0x00000297</span>;   <span class="comment">// auipc  t0, %pcrel_hi(fw_dyn)</span></span><br><span class="line">reset_vec[<span class="number">1</span>] = <span class="number">0x02828613</span>;   <span class="comment">// addi   a2, t0, %pcrel_lo(1b)</span></span><br><span class="line">reset_vec[<span class="number">2</span>] = <span class="number">0xf1402573</span>;   <span class="comment">// csrr   a0, mhartid</span></span><br><span class="line">reset_vec[<span class="number">3</span>] = <span class="number">0x0202a583</span>;   <span class="comment">// lw     a1, 32(t0)</span></span><br><span class="line">reset_vec[<span class="number">4</span>] = <span class="number">0x0182a283</span>;   <span class="comment">// lw     t0, 24(t0)</span></span><br><span class="line">reset_vec[<span class="number">5</span>] = <span class="number">0x00028067</span>;   <span class="comment">// jr     t0</span></span><br><span class="line">reset_vec[<span class="number">6</span>] = start_addr;   <span class="comment">// start: .dword (32-bit address)</span></span><br><span class="line">reset_vec[<span class="number">7</span>] = <span class="number">0</span>;            <span class="comment">// unused</span></span><br><span class="line">reset_vec[<span class="number">8</span>] = fdt_load_addr; <span class="comment">// fdt_laddr: .dword (32-bit address)</span></span><br><span class="line">reset_vec[<span class="number">9</span>] = <span class="number">0</span>;            <span class="comment">// unused</span></span><br></pre></td></tr></table></figure><p>具体来说，这段汇编代码完成了以下操作：</p><ol><li><code>auipc t0, %pcrel_hi(fw_dyn)</code>：使用当前 PC（程序计数器）的高 20 位（相对于 <code>fw_dyn</code> 标签的偏移量）来设置 <code>t0</code> 寄存器的值。这里的<code>fw_dyn</code>就是储存在<code>rom</code>的<code>fw_dynamic_info</code>的地址了，此时<code>PC=0x00000000</code>.从汇编语意上看，这句的意思是，<code>%pcrel_hi(fw_d</code>yn)表示计算<code>fw_dyn</code>这个符号相对于当前PC的偏移 的高20bit，而<code>auipc t0, imm</code>表示把<code>imm</code>和当前<code>PC</code>相加，结果保存到<code>t0</code>。所以，这条指令整体上的结果是会将<code>fw_dyn</code>相对于<code>pc</code>的高20位地址取出然后拓展为32位与pc相加，得到的结果保存到<code>t0</code>。这里执行完毕后<code>t0=0x00000000</code>。</li><li><code>addi a2, t0, %pcrel_lo(1b)</code>：使用当前 PC（相对于标签 <code>1b</code> 的偏移量）的低 12 位来设置 <code>a2</code> 寄存器的值。这个<code>1b</code>符号是啥我一直没搞懂，有没有大神告诉我，呜呜。看起来这两条指令的意思是将<code>fw_dynamic_info</code>的地址存到了<code>a2</code>中用于下一阶段启动的参数。</li><li><code>csrr a0, mhartid</code>：将处理器的硬件线程 ID（mhartid）存储到 <code>a0</code> 寄存器中。</li><li><code>lw a1, 32(t0)</code>：从 <code>t0</code> 寄存器指向的地址偏移 32 处加载一个字（32 位）的数据到 <code>a1</code> 寄存器中。<code>32(t0)</code>的地址刚好是<code>reset_vec</code>，所以fdt的地址被送到了a1寄存器中，fdt为设备树的地址，这里还没定义。</li><li><code>lw t0, 24(t0)</code>：从 <code>t0</code> 寄存器指向的地址偏移 24 处加载一个字（32 位）的数据到 <code>t0</code> 寄存器中。<code>24(t0)</code>的地址刚好是<code>reset_vec[6]</code>，存储的是<code>start_addr</code>,这了传入的参数为<code>flash</code>的地址。</li><li><code>jr t0</code>：跳转到 <code>t0</code> 寄存器中保存的地址，即跳转到了flash处开始执行下一阶段的引导程序。</li></ol><p>4.将所用创建硬件的函数用<code>static void quard_star_machine_init</code>包含起来,这里创建了CPU和主存。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* quard-star 初始化各种硬件 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//创建CPU</span></span><br><span class="line">   quard_star_cpu_create(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   quard_star_memory_create(machine);</span><br><span class="line">   <span class="comment">// 其他硬件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.注需要去初始化<code>machine</code>：创建<code>static void quard_star_machine_class_init</code>函数，并将<code>machine</code>结构体各个字段更新。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建machine */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    MachineClass *mc = MACHINE_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V Quard Star board&quot;</span>;</span><br><span class="line">    mc-&gt;init = quard_star_machine_init;</span><br><span class="line">    mc-&gt;max_cpus = QUARD_STAR_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.注册quard-star</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 注册 quard-star */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo quard_star_machine_typeinfo = &#123;</span><br><span class="line">    .name       = MACHINE_TYPE_NAME(<span class="string">&quot;quard-star&quot;</span>),</span><br><span class="line">    .parent     = TYPE_MACHINE,</span><br><span class="line">    .class_init = quard_star_machine_class_init,</span><br><span class="line">    .instance_init = quard_star_machine_instance_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(QuardStarState),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">         &#123; TYPE_HOTPLUG_HANDLER &#125;,</span><br><span class="line">         &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;quard_star_machine_typeinfo);</span><br><span class="line">&#125;</span><br><span class="line">type_init(quard_star_machine_init_register_types)</span><br></pre></td></tr></table></figure><h2 id="3-3-文件夹目录变更"><a href="#3-3-文件夹目录变更" class="headerlink" title="3.3 文件夹目录变更"></a>3.3 文件夹目录变更</h2><p>我原本qemu源码的目录为：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2/</span><br></pre></td></tr></table></figure><p>修改文件夹名变为如下：将最上层的qemu目录重命名为了quard_star</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard_star/qemu-8.0.2/</span><br></pre></td></tr></table></figure><p>然后在此目录下新建一个脚本文件用于编译qemu：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> build.sh</span><br></pre></td></tr></table></figure><p><code>build.sh</code>的内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前脚本文件所在的目录</span></span><br><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"></span><br><span class="line">cd qemu-8.0.2</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/qemu&quot; ]; then  </span><br><span class="line">./configure --prefix=$SHELL_FOLDER/output/qemu  --target-list=riscv64-softmmu --enable-gtk  --enable-virtfs --disable-gio</span><br><span class="line">fi  </span><br><span class="line">make -j16</span><br><span class="line">sudo make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><ol><li><code>cd qemu-8.0.2</code>：切换到 <code>qemu-8.0.2</code> 目录下。</li><li><code>if [ ! -d &quot;$SHELL_FOLDER/output/qemu&quot; ]; then</code>：如果目录 <code>$SHELL_FOLDER/output/qemu</code> 不存在，则执行下面的命令。</li><li><code>./configure --prefix=$SHELL_FOLDER/output/qemu --target-list=riscv64-softmmu --enable-gtk --enable-virtfs --disable-gio</code>：运行 <code>configure</code> 脚本，用于配置编译参数。这里指定了安装路径为 <code>$SHELL_FOLDER/output/qemu</code>，目标平台为 <code>riscv64-softmmu</code>，开启了 GTK 支持和 VirtFS 支持，禁用了 GIO 支持。</li><li><code>fi</code>：结束条件语句的块。</li><li><code>make -j16</code>：使用并发编译，编译生成目标文件。</li><li><code>make install</code>：将编译得到的目标文件安装到系统中。</li><li><code>cd ..</code>：切换回上一级目录。</li></ol><p>执行完build脚本后，编译完成后的qemu位于output文件夹下，再创建一个脚本文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard_star$ <span class="built_in">touch</span> run.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard_star$ <span class="built_in">chmod</span> +x run.sh</span><br></pre></td></tr></table></figure><p><code>run.sh</code>的内容如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(<span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span>;<span class="built_in">pwd</span>)</span><br><span class="line"><span class="variable">$SHELL_FOLDER</span>/output/qemu/bin/qemu-system-riscv64 \</span><br><span class="line">-M quard-star \</span><br><span class="line">-m 1G \</span><br><span class="line">-smp 8 \</span><br></pre></td></tr></table></figure><h2 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h2><p>运行脚本：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard_star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard_star$ ./run.sh</span><br></pre></td></tr></table></figure><p>板子启动后在qemu的monitor界面输入<code>info qtree</code>就可看见<code>quard-star</code>的硬件信息，如下：</p><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230613213926716.png" alt="image-20230613213926716"></p><p>这里我们只为quard-star板子创建了主存。</p><blockquote><p>源码地址：<a href="https://github.com/yanglianoo/quard-star">yanglianoo&#x2F;quard-star: 从零基于qemu创建riscv嵌入式开发板，并移植操作系统 (github.com)</a></p><p>有问题请与我联系：wechat：13699648817</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树详解</title>
      <link href="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-设备树简介"><a href="#1-设备树简介" class="headerlink" title="1.设备树简介"></a>1.设备树简介</h1><p>传统上，操作系统内核会直接编译进所有支持的硬件设备的驱动程序。但是，随着硬件设备的不断增多和变化，这种方法变得不够灵活。设备树的引入解决了这个问题。设备树将硬件的描述信息以一种结构化的方式存储在单独的文件中，然后在引导过程中由操作系统内核加载和解析。</p><p>设备树文件使用一种称为”Device Tree Source”（DTS）的语言编写，它是一种人类可读的文本格式。该文件描述了硬件设备的层次结构、寄存器地址、中断线路、DMA通道和其他相关属性。这些信息对于内核来说非常重要，因为它们允许内核正确地初始化和配置硬件设备。</p><p>设备树文件经过<code>DTC</code>编译后会生成一种称为”Device Tree Blob”（DTB）的二进制格式。DTB文件在引导过程中由引导加载程序（Bootloader）提供给内核。内核会解析DTB文件，根据其中的描述信息初始化硬件设备，并加载相应的驱动程序。</p><p>设备树的作用在于用来描述一个具体的硬件平台的硬件资源，如果没有设备树，当我有一个新的硬件平台时，在移植操作系统时需要去修改源码去适配这个具体的硬件平台。有了设备树之后，bootloader就能直接从设备树中获取硬件信息，而不需要去修改源码，使得Linux内核的兼容性和可移植性大大增强。</p><ul><li><p><code>DTS：</code>Device Tree Source，<code>.dts</code>格式的文件，是一种<code>ASII </code>文本格式的设备树描述，也是我们要编写的设备树源码，一般一个<code>.dts</code>文件对应一个硬件平台，位于Linux源码的<code>/arch/***/boot/dts”</code>目录下。</p></li><li><p><code>DTC：</code>Device Tree Compiler，是指编译设备树源码的工具，一般情况下我们需要手动安装这个编译工具。</p></li><li><p><code>DTB </code>：是设备树源码编译生成的文件，类似于我们C语言中“.C”文件编译生成“.bin”文件</p></li></ul><img src="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/1503563-20200915000144208-924995757.png" alt="Linux驱动之设备树的基础知识 - 山无言 - 博客园" style="zoom:67%;"><blockquote><p>参考链接：<a href="https://doc.embedfire.com/linux/imx6/base/zh/latest/linux_driver/driver_tree.html">doc.embedfire.com&#x2F;linux&#x2F;imx6&#x2F;base&#x2F;zh&#x2F;latest&#x2F;linux_driver&#x2F;driver_tree.html</a></p></blockquote><h1 id="2-设备树基本语法架构分析"><a href="#2-设备树基本语法架构分析" class="headerlink" title="2.设备树基本语法架构分析"></a>2.设备树基本语法架构分析</h1><h2 id="2-1-dts基本框架"><a href="#2-1-dts基本框架" class="headerlink" title="2.1 dts基本框架"></a>2.1 dts基本框架</h2><p><code>1.头文件</code>：设备树是可以像C语言那样使用“#include”引用“.h”后缀的头文件，也可以引用设备树“.dtsi”后缀的头文件。因此这里<code>k210.dts</code>引用了<code>k210.dtsi</code>中的文件</p><p><code>2.设备树节点</code>：每一个<code>&#123; &#125;</code>都是一个节点，<code>/ &#123;…&#125;</code>表示“根节点”， 在根节点内部的“aliases {…}”、“chosen {…}”、“memory {…}”等字符，都是根节点的子节点。</p><p><code>3.设备树节点追加内容</code>：向已经存在的子节点追加数据，这些已经存在的节点可能定义在<code>.dts</code>文件里，也可能定义在<code>.dtsi</code>文件里，这些节点比根节点下的子节点多了一个<code>&amp;</code>。</p><p>设备树由一个根节点和众多子节点组成，子节点也可以继续包含其他节点，也就是子节点的子节点。</p><h3 id="2-1-1节点基本格式"><a href="#2-1-1节点基本格式" class="headerlink" title="2.1.1节点基本格式"></a>2.1.1节点基本格式</h3><p>设备树中的每个节点都按照以下约定命名：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">node-name@unit-address<span class="punctuation">&#123;</span></span><br><span class="line">    属性<span class="number">1</span> = …</span><br><span class="line">    属性<span class="number">2</span> = …</span><br><span class="line">    属性<span class="number">3</span> = …</span><br><span class="line">    子节点…</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>节点格式中的<code> node-name</code> 用于指定节点的名称。 它的长度为1至31个字符，只能由如下字符组成:</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>0-9</td><td>数字</td></tr><tr><td>a-z</td><td>小写字母</td></tr><tr><td>A-Z</td><td>大写字母</td></tr><tr><td>,</td><td>英文逗号</td></tr><tr><td>.</td><td>英文句号</td></tr><tr><td>_</td><td>下划线</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>-</td><td>减号</td></tr></tbody></table><blockquote><p>注意：根节点没有节点名，它直接使用“&#x2F;”指代这是一个根节点。</p></blockquote><p><code>@unit-address</code> ：其中的符号“@”可以理解为是一个分割符，“unit-address”用于指定“单元地址”， 它的值要和节点“reg”属性的第一个地址一致。如果节点没有“reg”属性值，可以直接省略“@unit-address”， 不过要注意这时要求同级别的设备树下（相同级别的子节点）节点名唯一,从这个侧面也可以了解到， 同级别的子节点的节点名可以相同，但是要求“单元地址”不同，node-name@unit-address 的整体要求同级唯一。</p><h3 id="2-1-2-节点标签"><a href="#2-1-2-节点标签" class="headerlink" title="2.1.2 节点标签"></a>2.1.2 节点标签</h3><p>例如：</p><pre><code>sysctl: sysctl@50440000 &#123;        compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;;        reg = &lt;0x50440000 0x1000&gt;;        #clock-cells = &lt;1&gt;;&#125;;</code></pre><p>则<code>sysctl</code>就代表了<code>sysctl@50440000</code>这个节点的标签，用<code>:</code>来指明。通常节点标签是节点名的简写，所以它的作用是当其它位置需要引用时可以使用节点标签来向该节点中追加内容。</p><h3 id="2-1-3-节点路径"><a href="#2-1-3-节点路径" class="headerlink" title="2.1.3 节点路径"></a>2.1.3 节点路径</h3><p>通过指定从根节点到所需节点的完整路径，可以唯一地标识设备树中的节点，<code>不同层次的设备树节点名字可以相同，同层次的设备树节点要唯一</code>。 这有点类似于我们Windows上的文件，一个路径唯一标识一个文件或文件夹，不同目录下的文件文件名可以相同。</p><h3 id="2-1-4-节点属性"><a href="#2-1-4-节点属性" class="headerlink" title="2.1.4 节点属性"></a>2.1.4 节点属性</h3><ul><li><p><strong>compatible属性</strong>：属性值类型：字符串</p><p>compatible属性值由一个或多个字符串组成，有多个字符串时使用“,”分隔开。设备树中的每一个代表了一个设备的节点都要有一个compatible属性。 compatible是系统用来决定绑定到设备的设备驱动的关键。 compatible属性是用来查找节点的方法之一，另外还可以通过节点名或节点路径查找指定节点。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>model属性</strong>：属性值类型：字符串</p><p>model属性用于指定设备的制造商和型号，推荐使用“制造商, 型号”的格式，当然也可以自定义。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;Kendryte K210 generic&quot;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>status属性</strong></p><p>状态属性用于指示设备的“操作状态”，通过status可以去禁止设备或者启用设备，可用的操作状态如下表。默认情况下不设置status属性设备是使能的。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* External sound card */</span></span><br><span class="line"><span class="symbol">sound:</span> <span class="title class_">sound</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>reg属性</strong></p><p>reg属性描述设备资源在其父总线定义的地址空间内的地址。通常情况下用于表示一块内存的起始地址（偏移地址）和长度， 在特定情况下也有不同的含义。 ret属性的书写格式为reg &#x3D; &lt; cells cells cells cells cells cells…&gt;，长度根据实际情况而定， 这些数据分为地址数据（地址字段），长度数据（大小字段）</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure><p>这里描述了三段内存：起始地址为0x80000000，大小为0x400000；起始地址为：0x80400000 ，0x200000；起始地址为：0x80600000，大小为：0x200000。每一个cells都是32位的，如果想要描述一个64位的地址，需要先设置#address-cells 和 #size-cells属性的值。</p></li><li><p><strong>#address-cells 和 #size-cells</strong></p><p>#address-cells，用于指定子节点reg属性“地址字段”所占的长度（单元格cells的个数）。</p><p> #size-cells，用于指定子节点reg属性“大小字段”所占的长度（单元格cells的个数）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line">    ocrams: sram@900000 &#123;</span><br><span class="line">            compatible = &quot;fsl,lpm-sram&quot;;</span><br><span class="line">            reg = &lt;0x900000 0x4000&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如当#address-cells&#x3D;2，#address-cells&#x3D;1，则reg内的数据含义为<code>reg = &lt;address address size address address size&gt;</code>，这样就可以来描述一个64位的地址了。</p></li><li><p><strong>device_type</strong></p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">    <span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;arm,cortex-a7&quot;</span><span class="punctuation">;</span></span><br><span class="line">        device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>device_type属性也是一个很少用的属性，只用在CPU和内存的节点上。 如上例中所示，device_type用在了CPU节点。</p></li><li><p><strong>ranges</strong></p></li></ul><h3 id="2-1-5-特殊节点"><a href="#2-1-5-特殊节点" class="headerlink" title="2.1.5 特殊节点"></a>2.1.5 特殊节点</h3><ul><li><code>aliases</code>子节点：aliases子节点的作用就是为其他节点起一个别名，如下所示。</li></ul><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">    can0 = <span class="variable">&amp;flexcan1</span><span class="punctuation">;</span></span><br><span class="line">    can1 = <span class="variable">&amp;flexcan2</span><span class="punctuation">;</span></span><br><span class="line">    ethernet0 = <span class="variable">&amp;fec1</span><span class="punctuation">;</span></span><br><span class="line">    ethernet1 = <span class="variable">&amp;fec2</span><span class="punctuation">;</span></span><br><span class="line">    gpio0 = <span class="variable">&amp;gpio1</span><span class="punctuation">;</span></span><br><span class="line">    gpio1 = <span class="variable">&amp;gpio2</span><span class="punctuation">;</span></span><br><span class="line">    gpio2 = <span class="variable">&amp;gpio3</span><span class="punctuation">;</span></span><br><span class="line">    gpio3 = <span class="variable">&amp;gpio4</span><span class="punctuation">;</span></span><br><span class="line">    gpio4 = <span class="variable">&amp;gpio5</span><span class="punctuation">;</span></span><br><span class="line">    i2c0 = <span class="variable">&amp;i2c1</span><span class="punctuation">;</span></span><br><span class="line">    i2c1 = <span class="variable">&amp;i2c2</span><span class="punctuation">;</span></span><br><span class="line">    <span class="comment">/*----------- 以下省略------------*/</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以“can0 &#x3D; &amp;flexcan1;”为例。“flexcan1”是一个节点的名字， 设置别名后我们可以使用“can0”来指代flexcan1节点，与节点标签类似。 在设备树中更多的是为节点添加标签，没有使用节点别名，别名的作用是“快速找到设备树节点”。 在驱动中如果要查找一个节点，通常情况下我们可以使用“节点路径”一步步找到节点。 也可以使用别名“一步到位”找到节点。</p><ul><li><code>chosen子节点</code>：chosen子节点位于根节点下，如下所示</li></ul><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">stdout-path</span> <span class="operator">=</span> <span class="variable">&amp;uart1</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>chosen子节点不代表实际硬件，它主要用于给内核传递参数。 这里只设置了“stdout-path &#x3D;&amp;uart1;”一条属性，表示系统标准输出stdout使用串口uart1。 此外这个节点还用作uboot向linux内核传递配置参数的“通道”， 我们在Uboot中设置的参数就是通过这个节点传递到内核的， 这部分内容是uboot和内核自动完成的。</p><h1 id="3-Linux内核中K210设备树分析"><a href="#3-Linux内核中K210设备树分析" class="headerlink" title="3.Linux内核中K210设备树分析"></a>3.Linux内核中K210设备树分析</h1><p>从Linux 5.7 开始，Linux内核开始支持国产 RISC-V 芯片 K210，在本地的linux5.10版本中的<code>/arch/riscv/boot/dts</code>文件夹中可以找到kendryte的K210设备树文件，我们以此为例子，来分析设备树的语法与语义</p><p><img src="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/image-20230611222950267.png" alt="image-20230611222950267"></p><h2 id="3-1-k210-dts分析"><a href="#3-1-k210-dts分析" class="headerlink" title="3.1 k210.dts分析"></a>3.1 k210.dts分析</h2><p>其中<code>k210.dts</code>的文件如下：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;k210.dtsi&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">//设置节点基本属性</span></span><br><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;Kendryte K210 generic&quot;</span><span class="punctuation">;</span>  <span class="comment">//指定为嘉楠的K210</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span>     <span class="comment">//设置compatible属性</span></span><br><span class="line"><span class="comment">// 设置chosen特殊节点，</span></span><br><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">bootargs</span> <span class="operator">=</span> <span class="string">&quot;earlycon console=ttySIF0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">stdout-path</span> <span class="operator">=</span> <span class="string">&quot;serial0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;uarths0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li>第一行：引用头文件，<code>k210.dts</code>引用了<code>k210.dtsi</code>中的文件</li><li>3~12行：k210的根节点，每一个设备树只有一个根节点。 如果打开<code>k210.dtsi</code>文件可以发现它也有一个根节点，虽然<code>k210.dts</code>引用了<code>k210.dtsi</code>文件， 但这并不代表设备树有两个根节点，因为不同文件的根节点最终会合并为一个。<ul><li><code>bootargs = &quot;earlycon console=ttySIF0&quot;;</code> 是 “chosen” 节点的属性之一。它用于指定系统引导过程中传递给内核的启动参数（boot arguments）。在这里，设置的启动参数是 “earlycon console&#x3D;ttySIF0”，表示使用早期控制台（early console）并将其输出重定向到名为 “ttySIF0” 的串口设备。</li><li><code>stdout-path = &quot;serial0&quot;;</code> 是 “chosen” 节点的另一个属性。它用于指定标准输出（stdout）的路径。在这里，标准输出被设置为名为 “serial0” 的设备。</li></ul></li><li>13~15行：设备树增加内容。向<code>uarths0</code>子节点添加了一个属性，<code>status = &quot;okay&quot;;</code> 在这里，状态被设置为 “okay”，表示<code>uarths0</code>设备节点处于可用状态，可以正常使用。</li></ul><h2 id="3-2-k210-dtsi分析"><a href="#3-2-k210-dtsi分析" class="headerlink" title="3.2 k210.dtsi分析"></a>3.2 k210.dtsi分析</h2><h3 id="3-2-1-根节点"><a href="#3-2-1-根节点" class="headerlink" title="3.2.1 根节点"></a>3.2.1 根节点</h3><p><code>k210.dtsi</code>的文件如下：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dt-bindings/clock/k210-clk.h&gt;</span></span></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Although the K210 is a 64-bit CPU, the address bus is only 32-bits</span></span><br><span class="line"><span class="comment"> * wide, and the upper half of all addresses is ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">serial0 = <span class="variable">&amp;uarths0</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The K210 has an sv39 MMU following the priviledge specification v1.9.</span></span><br><span class="line"><span class="comment"> * Since this is a non-ratified draft specification, the kernel does not</span></span><br><span class="line"><span class="comment"> * support it and the K210 support enabled only for the !MMU case.</span></span><br><span class="line"><span class="comment"> * Be consistent with this by setting the CPUs MMU type to &quot;none&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">timebase-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7800000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="title class_">cpu@1</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu1_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">sram:</span> <span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-names</span> <span class="operator">=</span> <span class="string">&quot;sram0&quot;</span>, <span class="string">&quot;sram1&quot;</span>, <span class="string">&quot;aisram&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">clocks</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">in0:</span> <span class="title class_">oscillator</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fixed-clock&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">26000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">soc</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-soc&quot;</span>, <span class="string">&quot;simple-bus&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">ranges</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;plic0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">sysctl:</span> <span class="title class_">sysctl@50440000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-sysctl&quot;</span>, <span class="string">&quot;simple-mfd&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x50440000</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">clint0:</span> <span class="title class_">clint@2000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,clint0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x2000000</span> <span class="number">0xC000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span>  <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">3</span> <span class="variable">&amp;cpu0_intc</span> <span class="number">7</span></span></span><br><span class="line"><span class="params"><span class="variable">&amp;cpu1_intc</span> <span class="number">3</span> <span class="variable">&amp;cpu1_intc</span> <span class="number">7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_ACLK&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">plic0:</span> <span class="title class_">interrupt-controller@c000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-plic0&quot;</span>, <span class="string">&quot;riscv,plic0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xC000000</span> <span class="number">0x4000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">11</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">0xffffffff</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="variable">&amp;cpu1_intc</span> <span class="number">11</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cpu1_intc</span> <span class="number">0xffffffff</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,ndev</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">65</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,max-priority</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">uarths0:</span> <span class="title class_">serial@38000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-uarths&quot;</span>, <span class="string">&quot;sifive,uart0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x38000000</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">33</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>在第一行中包含了一个c语言中的头文件<code>#include &lt;dt-bindings/clock/k210-clk.h&gt;</code>，这个文件位于<code>linux-5.10.99/include/dt-bindings/clock</code>下，打开此文件如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> K210_CLK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Arbitrary identifiers for clocks.</span></span><br><span class="line"><span class="comment"> * The structure is: in0 -&gt; pll0 -&gt; aclk -&gt; cpu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since we use the hardware defaults for now, set all these to the same clock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_PLL0   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_PLL1   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_ACLK   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_CPU    0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* K210_CLK_H */</span></span></span><br></pre></td></tr></table></figure><p>可以看到，只是定义了一些宏定义，后续可能用到</p><p><code>7~13</code>行</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">serial0 = <span class="variable">&amp;uarths0</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>#address-cells = &lt;1&gt;;</code> 指定了设备树中地址单元的数量，这里设置为 1。</li><li><code>#size-cells = &lt;1&gt;;</code> 指定了设备树中大小单元的数量，这里也设置为 1。</li><li><code>compatible = &quot;kendryte,k210&quot;;</code> 表示设备树描述的硬件与 Kendryte K210 SoC 兼容。这个属性用于标识设备树所描述的硬件平台或设备的兼容性。</li><li><code>aliases</code>：定义了一个别名 <code>serial0</code>，它指向名为 <code>uarths0</code> 的设备。</li></ul><h3 id="3-2-2-cpu节点"><a href="#3-2-2-cpu节点" class="headerlink" title="3.2.2 cpu节点"></a>3.2.2 cpu节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;    <span class="comment">// 地址单元为1</span></span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;        <span class="comment">// 大小单元为0</span></span></span><br><span class="line"><span class="attr">timebase-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7800000</span>&gt;</span><span class="punctuation">;</span>  <span class="comment">//指定cpu时钟基准频率7800000hz</span></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="title class_">cpu@1</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu1_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>cpu单元定义了两个核心分别为cpu0和cpu1，两个cpu核心的配置差不都，下面依次描述一下具体描述了哪些信息，这里以cpu0为例子：</p><ul><li><p>device_type &#x3D; “cpu”：表示此节点为cpu。</p></li><li><p>reg &#x3D; &lt;0&gt;：标明这是0号处理器。</p></li><li><p>compatible &#x3D; “kendryte,k210”, “sifive,rocket0”, “riscv”：指定cpu的标识。</p></li><li><p>riscv,isa &#x3D; “rv64imafdc”：表明该cpu为rv64imafdc架构。</p></li><li><p>mmu-type &#x3D; “none”：cpu不启用mmu，未开启虚拟内存功能。</p></li><li><p>i-cache-size &#x3D; &lt;0x8000&gt;：指令缓存的大小为 0x8000，即 32768 字节（或 32 KB）。</p></li><li><p>i-cache-block-size &#x3D; &lt;64&gt;：指令缓存的块大小为 64 字节。</p></li><li><p>d-cache-size &#x3D; &lt;0x8000&gt;：数据缓存（Data Cache）的大小为 0x8000，即 32768 字节（或 32 KB）。</p></li><li><p>d-cache-block-size &#x3D; &lt;64&gt;：数据缓存的块大小为 64 字节。</p></li><li><p>clocks &#x3D; &lt;&amp;sysctl K210_CLK_CPU&gt;：指向设备树中名为 <code>sysctl</code> 的节点， <code>sysctl</code> 定义在下面的<code>soc</code>节点中,并使用 K210_CLK_CPU 作为其子节点，K210_CLK_CPU这个宏定义在<code>k210-clk.h</code>中，值为：0。表明cpu0的时钟是 <code>sysctl</code> 节点中的0号子时钟</p></li><li><p>clock-frequency &#x3D; &lt;390000000&gt;：指定时钟的频率为390MHZ</p></li><li><p>cpu0_intc：中断控制器节点，用于处理与 CPU 0 相关的中断。</p><ul><li><code>#interrupt-cells = &lt;1&gt;</code>：指定了中断单元的数量，即中断号码的位数。在这种情况下，每个中断使用一个单元（一个整数值）来表示。</li><li><code>interrupt-controller</code>：表示该节点是中断控制器。</li><li><code>compatible = &quot;riscv,cpu-intc&quot;</code>：指定了该中断控制器节点与 RISC-V 架构的 CPU 中断控制器兼容。</li></ul></li></ul><h3 id="3-2-3-SRAM节点"><a href="#3-2-3-SRAM节点" class="headerlink" title="3.2.3 SRAM节点"></a>3.2.3 SRAM节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sram:</span> <span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-names</span> <span class="operator">=</span> <span class="string">&quot;sram0&quot;</span>, <span class="string">&quot;sram1&quot;</span>, <span class="string">&quot;aisram&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>memory@80000000</code>：指定了 SRAM 的基地址为 <code>0x80000000</code>。</li><li><code>device_type = &quot;memory&quot;</code>：指定了设备类型为内存。</li><li><code>reg</code>：指定了 SRAM 的物理地址范围。在这种情况下，SRAM 被划分为三个连续的地址范围：<ul><li><code>&lt;0x80000000 0x400000&gt;</code>：<code>sram0</code> 的地址范围为从 <code>0x80000000</code> 到 <code>0x803FFFFF</code>，大小为 4 MB。</li><li><code>&lt;0x80400000 0x200000&gt;</code>：<code>sram1</code> 的地址范围为从 <code>0x80400000</code> 到 <code>0x805FFFFF</code>，大小为 2 MB。</li><li><code>&lt;0x80600000 0x200000&gt;</code>：<code>aisram</code> 的地址范围为从 <code>0x80600000</code> 到 <code>0x807FFFFF</code>，大小为 2 MB。</li></ul></li><li><code>reg-names = &quot;sram0&quot;, &quot;sram1&quot;, &quot;aisram&quot;</code>：指定了对应于每个地址范围的名称</li></ul><h3 id="3-2-4-clocks节点"><a href="#3-2-4-clocks节点" class="headerlink" title="3.2.4 clocks节点"></a>3.2.4 clocks节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">clocks</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">in0:</span> <span class="title class_">oscillator</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fixed-clock&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">26000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>该设备树中的 <code>clocks</code> 节点定义了一个名为 <code>in0</code> 的时钟，具体如下：</p><ul><li><code>in0</code>：时钟的名称为 <code>in0</code>。</li><li><code>oscillator</code>：指定了该时钟源为一个振荡器。</li><li><code>compatible = &quot;fixed-clock&quot;</code>：指定了时钟的类型为固定频率时钟。</li><li><code>#clock-cells = &lt;0&gt;</code>：表示该时钟节点不需要附加的时钟单元属性。</li><li><code>clock-frequency = &lt;26000000&gt;</code>：指定了时钟的频率为 26 MHz。</li></ul><h3 id="3-2-5-soc节点"><a href="#3-2-5-soc节点" class="headerlink" title="3.2.5 soc节点"></a>3.2.5 soc节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;kendryte,k210-soc&quot;, &quot;simple-bus&quot;;</span><br><span class="line">ranges;  //省略ranges属性，不存在地址映射</span><br><span class="line">interrupt-parent = &lt;&amp;plic0&gt;;   </span><br><span class="line"></span><br><span class="line">sysctl: sysctl@50440000 &#123;</span><br><span class="line">compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;;</span><br><span class="line">reg = &lt;0x50440000 0x1000&gt;;</span><br><span class="line">#clock-cells = &lt;1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">clint0: clint@2000000 &#123;</span><br><span class="line">#interrupt-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;riscv,clint0&quot;;</span><br><span class="line">reg = &lt;0x2000000 0xC000&gt;;</span><br><span class="line">interrupts-extended =  &lt;&amp;cpu0_intc 3 &amp;cpu0_intc 7</span><br><span class="line">&amp;cpu1_intc 3 &amp;cpu1_intc 7&gt;;</span><br><span class="line">clocks = &lt;&amp;sysctl K210_CLK_ACLK&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">plic0: interrupt-controller@c000000 &#123;</span><br><span class="line">#interrupt-cells = &lt;1&gt;;</span><br><span class="line">interrupt-controller;</span><br><span class="line">compatible = &quot;kendryte,k210-plic0&quot;, &quot;riscv,plic0&quot;;</span><br><span class="line">reg = &lt;0xC000000 0x4000000&gt;;</span><br><span class="line">interrupts-extended = &lt;&amp;cpu0_intc 11&gt;, &lt;&amp;cpu0_intc 0xffffffff&gt;,</span><br><span class="line">      &lt;&amp;cpu1_intc 11&gt;, &lt;&amp;cpu1_intc 0xffffffff&gt;;</span><br><span class="line">riscv,ndev = &lt;65&gt;;</span><br><span class="line">riscv,max-priority = &lt;7&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uarths0: serial@38000000 &#123;</span><br><span class="line">compatible = &quot;kendryte,k210-uarths&quot;, &quot;sifive,uart0&quot;;</span><br><span class="line">reg = &lt;0x38000000 0x1000&gt;;</span><br><span class="line">interrupts = &lt;33&gt;;</span><br><span class="line">clocks = &lt;&amp;sysctl K210_CLK_CPU&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>interrupt-parent = &lt;&amp;plic0&gt;</code>：指定了中断控制器的父节点，这里使用的是 plic0 中断控制器的引用。</p></li><li><p><code>sysctl: sysctl@50440000</code>：这是一个子节点，描述了系统控制器 (sysctl)。它有以下属性：</p><ul><li><code>compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;</code>：指定了系统控制器的兼容性标识符，表示该节点描述的是 Kendryte K210 SoC 的系统控制器，并且它是一个多功能设备。</li><li><code>reg = &lt;0x50440000 0x1000&gt;</code>：指定了系统控制器在内存中的地址范围。</li><li><code>#clock-cells = &lt;1&gt;</code>：指定了该节点使用的时钟单元数。</li></ul></li><li><p><code>clint0: clint@2000000</code>：这是另一个子节点，描述了 CLINT (Core Local Interruptor)。它有以下属性：</p><ul><li><code>compatible = &quot;riscv,clint0&quot;</code>：指定了 CLINT 的兼容性标识符。</li><li><code>reg = &lt;0x2000000 0xC000&gt;</code>：指定了 CLINT 在内存中的地址范围。</li><li><code>interrupts-extended</code>：指定了 CLINT 支持的中断引脚，这里使用的是 <code>cpu0_intc</code> 和 <code>cpu1_intc</code> 的引用。</li><li><code>clocks = &lt;&amp;sysctl K210_CLK_ACLK&gt;</code>：指定了 CLINT 使用的时钟源，这里使用的是 <code>sysctl</code> 节点中的 <code>K210_CLK_ACLK</code> 时钟。</li></ul></li><li><p><code>plic0: interrupt-controller@c000000</code>：这是另一个子节点，描述了 PLIC (Platform-Level Interrupt Controller)。它有以下属性：</p><ul><li><code>compatible = &quot;kendryte,k210-plic0&quot;, &quot;riscv,plic0&quot;</code>：指定了 PLIC 的兼容性标识符。</li><li><code>reg = &lt;0xC000000 0x4000000&gt;</code>：指定了 PLIC 在内存中的地址范围。</li><li><code>interrupts-extended</code>：指定了 PLIC 支持的中断引脚，这里使用的是 <code>cpu0_intc</code> 和 <code>cpu1_intc</code> 的引用。</li><li><code>riscv,ndev = &lt;65&gt;</code>：指定了 PLIC 支持的设备数量。</li><li><code>riscv,max-priority = &lt;7&gt;</code>：指定了 PLIC 支持的最大优先级</li></ul></li><li><p><code>uarths0: serial@38000000</code>：这是串口设备的节点定义，名称为 <code>uarths0</code>，描述了串口在内存中的地址范围。</p><ul><li><code>compatible = &quot;kendryte,k210-uarths&quot;, &quot;sifive,uart0&quot;</code>：指定了串口设备的兼容性标识符，表示该节点描述的是 Kendryte K210 SoC 的 <code>uarths0</code> 串口，并且它兼容 SiFive 的 UART0 设备。</li><li><code>reg = &lt;0x38000000 0x1000&gt;</code>：指定了串口设备在内存中的地址范围。</li><li><code>interrupts = &lt;33&gt;</code>：指定了串口设备的中断引脚，这里使用的是中断号 33。</li><li><code>clocks = &lt;&amp;sysctl K210_CLK_CPU&gt;</code>：指定了串口设备使用的时钟源，这里使用的是 <code>sysctl</code> 节点中的 <code>K210_CLK_CPU</code> 时钟。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 设备树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源码构建Qemu</title>
      <link href="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/"/>
      <url>/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Qemu介绍"><a href="#1-Qemu介绍" class="headerlink" title="1.Qemu介绍"></a>1.Qemu介绍</h1><p>QEMU（Quick Emulator）是一个开源的虚拟化软件，它可以模拟多个硬件平台，包括处理器和外设，从而允许在一个平台上运行多个不同的操作系统。QEMU可以运行在多个主机平台上，包括Linux、Windows、macOS等。</p><p>QEMU的主要功能是模拟一个完整的计算机系统，包括处理器、内存、存储器、网络接口等，它可以将客户操作系统（例如Linux、Windows等）当作应用程序运行在主机操作系统之上，从而实现虚拟化。QEMU还支持通过二进制代码转换的方式实现虚拟化加速，例如使用KVM（Kernel-based Virtual Machine）模块加速虚拟机的运行。</p><p>QEMU可以用于多种用途，包括：</p><ol><li>系统仿真：可以模拟不同的处理器架构（如x86、ARM等）来运行和测试操作系统和应用程序，方便开发人员进行交叉平台开发和调试。</li><li>虚拟机：可以在一个物理机上运行多个虚拟机实例，每个虚拟机可以运行不同的操作系统，实现资源的隔离和共享，提供虚拟化环境。</li><li>可移植性：QEMU可以将一个操作系统或应用程序打包成一个虚拟机镜像，这个镜像可以在不同的平台上运行，提供了一种便携式的软件分发方式。</li></ol><blockquote><p>官方源码地址：<a href="https://github.com/qemu/qemu">Qemu的github源码</a></p><p>官网地址：<a href="https://www.qemu.org/">QEMU</a></p><p>qemu的文档地址：<a href="https://www.qemu.org/docs/master/">Welcome to QEMU’s documentation! — QEMU documentation</a></p></blockquote><h1 id="2-源码下载"><a href="#2-源码下载" class="headerlink" title="2.源码下载"></a>2.源码下载</h1><p>在笔者下载源码的时间，目前<code>qemu</code>的版本已经更新到了<code>8.0.2</code>，我的ubuntu环境为：<code>WSL2 ubuntu20.04.05</code></p><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611160604923.png" alt="image-20230611160604923"></p><p>安装所需编译环境：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install ninja-build pkg-config libglib2.0-dev libpixman-1-dev libgtk-3-dev libcap-ng-dev libattr1-dev libsdl2-dev device-tree-compiler bison flex gperf intltool mtd-utils libslirp-dev</span><br></pre></td></tr></table></figure><p>源码下载与编译：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~$ <span class="built_in">mkdir</span> qemu</span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ <span class="built_in">cd</span> qemu/</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ wget https://download.qemu.org/qemu-8.0.2.tar.xz</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ tar xvJf qemu-8.0.2.tar.xz</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ <span class="built_in">cd</span> qemu-8.0.2/</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ ./configure</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ make -j8</span><br></pre></td></tr></table></figure><p>编译完成后会生成一个<code>./build</code>目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ <span class="built_in">cd</span> build/</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由于我之前使用package的方式在本地安装了一个qemu，因此先将其卸载</span></span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ sudo apt-get remove --auto-remove qemu-system-x86</span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ sudo apt-get purge --auto-remove qemu-system-x86</span><br><span class="line"><span class="comment">#卸载完成后进入build目录执行安装命令，需要sudo不然会报错</span></span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2/build$ sudo make install</span><br></pre></td></tr></table></figure><p>测试，查看<code>qemu</code>版本号，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-img -V</span><br></pre></td></tr></table></figure><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611164450596.png" alt="image-20230611164450596"></p><p>启动qemu，这里以riscv64为例：<code>qemu-system-riscv64</code></p><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611164621585.png" alt="image-20230611164621585"></p><p>大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> Qemu&amp;虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-3.实模式</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-X86cpu工作原理"><a href="#1-X86cpu工作原理" class="headerlink" title="1. X86cpu工作原理"></a>1. X86cpu工作原理</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611121633671.png" alt="image-20230611121633671"></p><p>程序计数器<code>PC</code>存储了下一条要运行的指定的地址，在x86cpu上，<code>PC</code>就是：<code>cs：ip</code>，控制单元读取<code>ip</code>寄存器中的地址后，将此地址送上地址总线，<code>cpu</code>由此得到了要执行的指令，然后将指令存入指令寄存器<code>IR</code>中。下一步指令译码器将此指令解码，解码后得到了操作数和操作码，于是操作控制器<code>OC</code>就给运算单元下令，运算单元就开始执行指令。<code>ip</code>寄存器的值被加上当前指令的大小，由此循环。</p><p>IA32的指令格式如下：</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611123557111.png" alt="image-20230611123557111"></p><h2 id="2-实模式的寻址"><a href="#2-实模式的寻址" class="headerlink" title="2. 实模式的寻址"></a>2. 实模式的寻址</h2><p>8086的地址总线是20位宽，意味着寻址范围为：<code>2^20=1MB</code>，但内部寄存器都是16位的，若采用单一寄存器来寻址只能访问：<code>2^16=64KB</code>空间。</p><p>为了解决16位寄存器不能寻址20位的问题，因此通过先把16位的段基址左移四位变成20位后，在加上段内偏移地址，这样就形成了20位地址，只要保证了段基址是20位的，偏移地址是多少位就不用关心了。</p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU3RyaXZlIGZvciB0aGUgYmVzdO-8gQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="3.操作系统——CPU的实模式、保护模式和长模式_Strive for the best！的博客-CSDN博客" style="zoom: 50%;"><p>下面列举一下寻址实例：所有的利用寄存器寻址的方式，每个寄存器都有对应的段基址，寄存器的默认段基址见上一章</p><ol><li><p>直接寻址（Direct addressing）：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> AX, [<span class="number">0x1234</span>]</span><br><span class="line"><span class="keyword">mov</span> ax, [fs:<span class="number">0x5678</span>]</span><br></pre></td></tr></table></figure><p>0x1234是段内偏移地址，默认的段地址是DS，这一条指令是将内存地址<code>DS:0x1234</code>处的值写入<code>ax</code>寄存器。</p><p>第二条指定显示指定段基址为<code>fs</code>,因此是将内存地址<code>FS:0x5678</code>处的值写入<code>ax</code>寄存器。</p><p>注意：段基址都需要先左移4位再与段内偏移相加</p></li><li><p>基址寻址（Base addressing）：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> AX, [BX + <span class="number">0x10</span>]</span><br></pre></td></tr></table></figure><p>这个例子中，将从BX寄存器所指定的内存地址加上偏移量0x10处读取一个字（16位）的数据，并将其存储在AX寄存器中。bx默认的段寄存器为DS，因此实际的寻址地址为：<code>DS:bx+0x10</code></p></li></ol><h2 id="3-栈的布局"><a href="#3-栈的布局" class="headerlink" title="3.栈的布局"></a>3.栈的布局</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611131141910.png" alt="image-20230611131141910"></p><p>栈空间也是内存中一段区域，我们程序员可以自由分配，SS栈段寄存器左移4位指向栈底，栈的生长是向低地址方向发展，sp指向了栈顶。</p><p>在进行函数调用时，例如使用call指令，需要将PC压栈，然后跳转。</p>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-2.X86寄存器详解</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是寄存器"><a href="#1-什么是寄存器" class="headerlink" title="1.什么是寄存器"></a>1.什么是寄存器</h1><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果以及一些CPU运行需要的信息</p><p>x86架构CPU走的是<code>复杂指令集（CISC）</code> 路线，提供了丰富的指令来实现强大的功能，与此同时也提供了大量寄存器来辅助功能实现。寄存器分为两类，一类对程序员不可见，这一类寄存器用于支撑CPU内部运行，程序员无法操作。一类对程序员可见，在进行汇编编写程序时，能够直接操作。</p><ul><li>通用寄存器：<code>EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP</code></li><li>标志寄存器：<code>EFLAGS</code></li><li>指令寄存器：<code>EIP</code></li><li>段寄存器：<code>CS、DS、ES、FS、GS、SS</code></li><li>控制寄存器：<code>CR0、CR1、CR2、CR3、CR4</code></li><li>调试寄存器：<code>DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7</code></li><li>描述符寄存器：<code>GDTR、IDTR、LDTR、TR</code></li></ul><h1 id="2-实模式下寄存器（16bit）"><a href="#2-实模式下寄存器（16bit）" class="headerlink" title="2.实模式下寄存器（16bit）"></a>2.实模式下寄存器（16bit）</h1><p>在x86架构下，实模式可以使用的通用寄存器有 <code>AX、BX、CX、DX、SI、DI、BP</code> 和 <code>SP</code>。这些寄存器都是16位的，可以分为两个8位的寄存器来使用。</p><p>此外，还有一些特殊用途的寄存器，包括：</p><ul><li><code>IP</code>（指令指针寄存器）：保存当前执行的指令地址。</li><li><code>CS</code>（代码段寄存器）：保存代码段的起始地址。</li><li><code>DS</code>（数据段寄存器）：保存数据段的起始地址。</li><li><code>ES</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>GS</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>FS</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>SS</code>（堆栈段寄存器）：保存堆栈段的起始地址。</li><li><code>FLAGS</code>（标志寄存器）：包含各种标志位，如零标志、进位标志、符号标志等</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230611122704382.png" alt="image-20230611122704382"></p><p>其中<code>FS</code>,<code>GS</code>附加段寄存器是在32位CPU中增加的，但是在32位CPU中在实模式下同样可以使用，因为32位CPU兼容16位CPU的特性。</p><table><thead><tr><th>16位寄存器</th><th>功能</th><th>高8位</th><th>低8位</th></tr></thead><tbody><tr><td><code>AX</code></td><td>累加寄存器，常用于算术运算，保存与外设输入输出的数据</td><td><code>AH</code></td><td><code>AL</code></td></tr><tr><td><code>CX</code></td><td>计数寄存器，常用于循环指令中的循环次数</td><td><code>CH</code></td><td><code>CL</code></td></tr><tr><td><code>DX</code></td><td>数据寄存器，通常情况下只用于保存外设控制器的端口号地址</td><td><code>DH</code></td><td><code>DL</code></td></tr><tr><td><code>BX</code></td><td>基址寄存器，来存储内存地址，段基址为DS</td><td><code>BH</code></td><td><code>BL</code></td></tr><tr><td><code>SP</code></td><td>栈指针寄存器，段基址为SS，用来指向栈顶</td><td></td><td></td></tr><tr><td><code>BP</code></td><td>栈帧的基址寄存器，段基址为SS</td><td></td><td></td></tr><tr><td><code>SI</code></td><td>源变址寄存器，存储数据源地址,段基址为DS</td><td></td><td></td></tr><tr><td><code>DI</code></td><td>目的变址寄存器，存储数据目的地址,段基址为DS</td><td></td><td></td></tr></tbody></table><blockquote><p>BP指向栈底，SP指向栈顶，两者共同维护了栈空间。<code>push</code> 和 <code>pop</code> 可更改<code>SP</code>的值,<code>sp</code>指针的值会自动更新</p></blockquote><h2 id="2-1-寄存器用法举例"><a href="#2-1-寄存器用法举例" class="headerlink" title="2.1 寄存器用法举例"></a>2.1 寄存器用法举例</h2><ul><li><p><code>SI、DI</code></p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">mov</span> ecx, <span class="number">10</span>  <span class="comment">; 设置循环计数为10</span></span><br><span class="line">    <span class="keyword">mov</span> esi, <span class="number">0</span>  <span class="comment">; 设置SI寄存器为0作为初始值</span></span><br><span class="line">    <span class="keyword">mov</span> edi, <span class="number">100</span>  <span class="comment">; 设置DI寄存器为100作为初始值</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">loop_start:</span></span><br><span class="line">    <span class="keyword">mov</span> eax, [esi]  <span class="comment">; 从源地址(SI)读取数据到EAX寄存器</span></span><br><span class="line">    <span class="keyword">mov</span> [edi], eax  <span class="comment">; 将数据存储到目的地址(DI)</span></span><br><span class="line">    <span class="keyword">add</span> esi, <span class="number">4</span>  <span class="comment">; 增加SI的值，以便读取下一个双字</span></span><br><span class="line">    <span class="keyword">add</span> edi, <span class="number">4</span>  <span class="comment">; 增加DI的值，以便存储到下一个地址</span></span><br><span class="line">    loop loop_start  <span class="comment">; 循环，减少ECX计数，直到为零</span></span><br></pre></td></tr></table></figure><p>在这个例子中，SI和DI寄存器用作源地址和目的地址。循环从源地址读取数据，然后将其存储到目的地址，然后递增SI和DI以访问下一个元素。通过loop指令和ECX计数器，循环执行直到计数为零。</p></li><li><p><code>BP、SP</code></p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">push</span> ebp         <span class="comment">; 保存当前函数的旧的基址到堆栈中</span></span><br><span class="line"><span class="keyword">mov</span> ebp, esp     <span class="comment">; 将当前堆栈指针存储到基址指针寄存器BP中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sub</span> esp, <span class="number">16</span>      <span class="comment">; 分配16字节的局部变量空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> dword ptr [ebp<span class="number">-4</span>], <span class="number">10</span>   <span class="comment">; 将值10存储到基址指针寄存器BP-4指向的位置（局部变量）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> eax, dword ptr [ebp<span class="number">-4</span>]  <span class="comment">; 从基址指针寄存器BP-4指向的位置读取值到EAX寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> esp, <span class="number">16</span>      <span class="comment">; 释放局部变量空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pop</span> ebp          <span class="comment">; 恢复旧的基址到基址指针寄存器BP中</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-保护模式下寄存器（32bit）"><a href="#3-保护模式下寄存器（32bit）" class="headerlink" title="3.保护模式下寄存器（32bit）"></a>3.保护模式下寄存器（32bit）</h1><h2 id="3-1-保护模式寄存器介绍"><a href="#3-1-保护模式寄存器介绍" class="headerlink" title="3.1 保护模式寄存器介绍"></a>3.1 保护模式寄存器介绍</h2><p>在32位保护模式下，x86架构提供了更多的通用寄存器以及扩展功能。以下是32位保护模式下可以使用的寄存器：</p><ol><li>通用寄存器（General Purpose Registers）：<ul><li><code>EAX</code>：累加器寄存器（Accumulator Register）。</li><li><code>EBX</code>：基址寄存器（Base Register）。</li><li><code>ECX</code>：计数寄存器（Counter Register）。</li><li><code>EDX</code>：数据寄存器（Data Register）。</li><li><code>ESI</code>：源索引寄存器（Source Index Register）。</li><li><code>EDI</code>：目的索引寄存器（Destination Index Register）。</li><li><code>EBP</code>：基址指针寄存器（Base Pointer Register）。</li><li><code>ESP</code>：堆栈指针寄存器（Stack Pointer Register）。</li></ul></li><li>扩展通用寄存器：<ul><li><code>EIP</code>：指令指针寄存器（Instruction Pointer Register）。</li><li><code>EFLAGS</code>：标志寄存器（Flags Register），用于存储各种标志位，如零标志、进位标志、符号标志等。</li></ul></li><li>段寄存器（Segment Registers）：<ul><li><code>CS</code>：代码段寄存器（Code Segment Register）。</li><li><code>DS</code>：数据段寄存器（Data Segment Register）。</li><li><code>ES</code>：附加段寄存器（Extra Segment Register）。</li><li><code>FS、GS、SS</code>：附加段寄存器，用于访问额外的数据段。</li></ul></li><li>控制寄存器（Control Registers）：<ul><li><code>CR0、CR2、CR3、CR4</code>：用于控制和管理保护模式的特性，如分页机制、特权级等。</li></ul></li><li>段描述符寄存器（Descriptor Registers）：<ul><li><code>GDTR</code>：全局描述符表寄存器（Global Descriptor Table Register）。</li><li><code>IDTR</code>：中断描述符表寄存器（Interrupt Descriptor Table Register）。</li><li><code>LDTR</code>：局部描述符表寄存器（Local Descriptor Table Register）。</li><li><code>TR</code>：任务寄存器（Task Register）。</li></ul></li></ol><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230128173803324.png" alt="image-20230128173803324" style="zoom: 80%;"><h2 id="3-2-控制寄存器"><a href="#3-2-控制寄存器" class="headerlink" title="3.2 控制寄存器"></a>3.2 控制寄存器</h2><h3 id="3-2-1-CR0寄存器"><a href="#3-2-1-CR0寄存器" class="headerlink" title="3.2.1 CR0寄存器"></a>3.2.1 <code>CR0</code>寄存器</h3><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230609214128132.png" alt="image-20230609214128132"></p><ul><li><p><code>PE: Protection Enble </code></p><p>当此位为0，代表在CPU处在实模式，此位为1，表示CPU处在保护模式；从实模式切换到保护模式时需要将此位置为1.</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="meta">#进入保护模式</span></span><br><span class="line"><span class="keyword">mov</span> eax, cr0</span><br><span class="line"><span class="keyword">or</span> eax, <span class="number">0x00000001</span></span><br><span class="line"><span class="keyword">mov</span> cr0, eax</span><br></pre></td></tr></table></figure></li><li><p><code>TS：Task Switched</code></p></li><li><p><code>WP：Write Protect</code></p><p>对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志。当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作；当该位复位时则反之。该标志有利于UNIX类操作系统在创建进程时实现写时复制（Copy on Write）技术。</p></li><li><p><code>AM：Alignment Mask</code></p></li><li><p><code>NW：Not Writethrough</code></p></li><li><p><code>CD：Cache Disable</code></p></li><li><p><code>PG：Paging</code></p><p>是否启动分页机制的位，只有在保护模式以上才能开启分页机制。PG位为1开启分页机制，PG位为0关闭分页机制</p></li></ul><p>在CPU刚上电时，处理器被复位成PE&#x3D;0,PG&#x3D;0。</p><h3 id="3-2-2-CR2寄存器"><a href="#3-2-2-CR2寄存器" class="headerlink" title="3.2.2 CR2寄存器"></a>3.2.2 <code>CR2</code>寄存器</h3><h3 id="3-2-3-CR3寄存器"><a href="#3-2-3-CR3寄存器" class="headerlink" title="3.2.3 CR3寄存器"></a>3.2.3 <code>CR3</code>寄存器</h3><h3 id="3-2-4-CR4寄存器"><a href="#3-2-4-CR4寄存器" class="headerlink" title="3.2.4 CR4寄存器"></a>3.2.4 <code>CR4</code>寄存器</h3><h2 id="3-3-EFLAGS寄存器"><a href="#3-3-EFLAGS寄存器" class="headerlink" title="3.3 EFLAGS寄存器"></a>3.3 <code>EFLAGS</code>寄存器</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230611124419683.png" alt="image-20230611124419683"></p><ul><li>CF：进位标志</li><li>PF：奇偶位标志</li><li>AF：辅助进位标志</li><li>ZF：零标志位</li><li>SF：符号标注位</li><li>TF：陷阱标志位</li><li>IF：中断标志位。若IF为1，表示中断开启；若为0，表示中断关闭</li><li>DF：方向标志位。</li><li>OF：溢出标志位。</li><li>IOPL：特权级标志位，占2个bit，标志了4个特权级</li><li>NT：任务嵌套标志位</li><li>RF：恢复标志位</li><li>VM：虚拟8086模式</li><li>AC：对齐检查</li><li>VIF：虚拟中断标志位</li><li>VIP：虚拟中断挂起标志位</li><li>ID：识别标志位</li><li>22~31：没有实际用途，占位用，为了将来拓展</li></ul><h2 id="3-4-段描述符寄存器"><a href="#3-4-段描述符寄存器" class="headerlink" title="3.4 段描述符寄存器"></a>3.4 段描述符寄存器</h2><h3 id="3-4-1-GDTR寄存器"><a href="#3-4-1-GDTR寄存器" class="headerlink" title="3.4.1 GDTR寄存器"></a>3.4.1 <code>GDTR</code>寄存器</h3><p>GDTR是个48位的寄存器，专门用来储存GDT的内存地址和大小</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626124256061.png" alt="image-20230626124256061"></p><p>GDT：Global Descriptor Table，全局段描述符，在保护模式下，GDT在内存中有且只有一个，GDT的数据结构如下，每个描述符8个字节，64个bit，可以存放在内存当中任意位置，addr相当于GDT的内存起始地址，GDT的总长度就就是GDT界限</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/20201026145225176.png" alt="在这里插入图片描述"></p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626124507958.png" alt="image-20230626124507958"></p><p>段描述符的主要属性都在高32位：</p><ul><li><p>0~7位：段基址的16-23</p></li><li><p>24~31位：段基址的24-31</p></li><li><p>8~11位：type字段，共四位，用来指定本描述符的类型</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626132808111.png" alt="image-20230626132808111"></p></li><li><p>12位：S字段，用于指示系统是否是系统段。S为0表示系统段，S为1表示数据段，type字段要和S字段配合在一起才能确定段描述符的确切类型。</p></li><li><p>15位：Present，即段是否存在。如果段存在于内存中，P为1，否则为0</p></li><li><p>16~19位：段界限的16-19位</p></li><li><p>20位：AVL，随便用，操作系统可以随便用这一位</p></li><li><p>21位：L字段，用来设置是否是64位代码段。L为1表示64位代码段，否则表示32位代码段。</p></li><li><p>22位：D&#x2F;B字段</p></li><li><p>23位：G字段，用来设置段界限的单位大小，若G为0，表示段界限的单位是4KB，若界为1，表示段界限的单位是4KB</p></li><li><p>24~31位：段基址的最后8位</p></li></ul><p>在实模式下，段寄存器中存储的是段基地址，即内存段的起始地址，而在保护模式下，由于段基址已经存入了段描述符中，所以段寄存器不再存放段基址，而是存放一个叫选择子的东西，选择子用来在段描述符表中索引相应的段描述符，数据结构如下：</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626133735851.png" alt="image-20230626133735851"></p><ul><li>0~1位：RPL，存储请求特权级，总共有0、1、2、3四个特权级</li><li>2位：TI，用来表示是GDT还是LDT，TI为0表示在GDT中索引描述符，TI为1表示在LDT中索引描述符</li></ul><p>在代码中我们可以定义对应的结构体来定义GDT和选择子以及全局描述符表指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">descriptor_t</span> /* 共 8 个字节 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> limit_low;      <span class="comment">// 段界限 0 ~ 15 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> base_low : <span class="number">24</span>;    <span class="comment">// 基地址 0 ~ 23 位 16M</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> type : <span class="number">4</span>;        <span class="comment">// 段类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> segment : <span class="number">1</span>;     <span class="comment">// 1 表示代码段或数据段即非系统段，0 表示系统段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> DPL : <span class="number">2</span>;         <span class="comment">// Descriptor Privilege Level 描述符特权等级 0 ~ 3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> present : <span class="number">1</span>;     <span class="comment">// 存在位，1 在内存中，0 在磁盘上</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> limit_high : <span class="number">4</span>;  <span class="comment">// 段界限 16 ~ 19;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> available : <span class="number">1</span>;   <span class="comment">// 该安排的都安排了，送给操作系统吧</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> long_mode : <span class="number">1</span>;   <span class="comment">// 64 位扩展标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> big : <span class="number">1</span>;         <span class="comment">// 32 位 还是 16 位;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> granularity : <span class="number">1</span>; <span class="comment">// 粒度 4KB 或 1B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base_high;       <span class="comment">// 基地址 24 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">descriptor_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 段选择子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">selector_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u8 RPL : <span class="number">2</span>; <span class="comment">// Request Privilege Level</span></span><br><span class="line">    u8 TI : <span class="number">1</span>;  <span class="comment">// Table Indicator</span></span><br><span class="line">    u16 index : <span class="number">13</span>;</span><br><span class="line">&#125; <span class="type">selector_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pointer_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 limit;</span><br><span class="line">    u32 base;</span><br><span class="line">&#125; _packed <span class="type">pointer_t</span>;</span><br></pre></td></tr></table></figure><p>下一步就是填充GDT和GDT_PTR</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充GDT</span></span><br><span class="line"><span class="type">descriptor_t</span> gdt[GDT_SIZE]; <span class="comment">//内核全局描述符表</span></span><br><span class="line">    <span class="built_in">memset</span>(gdt, <span class="number">0</span>, <span class="keyword">sizeof</span>(gdt));</span><br><span class="line"></span><br><span class="line">    <span class="type">descriptor_t</span> *desc;</span><br><span class="line">    desc = gdt + KERNEL_CODE_IDX;</span><br><span class="line">    descriptor_init(desc, <span class="number">0</span>, <span class="number">0xFFFFF</span>);</span><br><span class="line">    desc-&gt;segment = <span class="number">1</span>;     <span class="comment">// 代码段</span></span><br><span class="line">    desc-&gt;granularity = <span class="number">1</span>; <span class="comment">// 4K</span></span><br><span class="line">    desc-&gt;big = <span class="number">1</span>;         <span class="comment">// 32 位</span></span><br><span class="line">    desc-&gt;long_mode = <span class="number">0</span>;   <span class="comment">// 不是 64 位</span></span><br><span class="line">    desc-&gt;present = <span class="number">1</span>;     <span class="comment">// 在内存中</span></span><br><span class="line">    desc-&gt;DPL = <span class="number">0</span>;         <span class="comment">// 内核特权级</span></span><br><span class="line">    desc-&gt;type = <span class="number">0b1010</span>;   <span class="comment">// 代码 / 非依从 / 可读 / 没有被访问过</span></span><br><span class="line"><span class="comment">//填充 gdt_ptr</span></span><br><span class="line">    gdt_ptr.base = (u32)&amp;gdt;</span><br><span class="line">    gdt_ptr.limit = <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>然后使用lgdt命令将全局描述符表指针加载到GDTR寄存器中:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">lgdt [gdt_ptr]</span><br></pre></td></tr></table></figure><h3 id="3-4-2-IDTR寄存器"><a href="#3-4-2-IDTR寄存器" class="headerlink" title="3.4.2 IDTR寄存器"></a>3.4.2 <code>IDTR</code>寄存器</h3><p>idtr寄存器用于存储中断描述符表的地址和表界限</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626145545075.png" alt="image-20230626145545075"></p><p>在中断描述符表中可以存储的是中断描述符，这里的中断描述符分为四类，以不同门的叫法来描述，在上面描述GDT的时候，提到S字段和type字段一起决定了这个描述符是什么，对于GDT来说，我们设置S位为1，代表非系统段，对于中断描述符来说需要将S位设为0，由此延申出了四种描述符：</p><ul><li>任务门描述符</li></ul><p>​任务门和任务状态段 (Task Status Segment，TSS) 是Intel处理器在硬件一级提供的任务切换机制，所以任务门需要和TSS配合在一起使用，在任务门中记录的是TSS选择子，偏移量未使用。任务门可以存在于全局描述符表GDT、局部描述符表LDT、中断描述符表IDT中。描述符中任务门的type值为二进制0101，其结构如下图所示。顺便说一句大多数操作系统 (包括Linux) 都未用TSS实现任务切换</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150722494.png" alt="image-20230626150722494"></p><ul><li>中断门描述符</li></ul><p>​中断门包含了中断处理程序所在段的段选择子和段内偏移地址。当通过此方式进入中断后，标志寄存器eflags中的IF位自动置0，也就是在进入中断后，自动把中断关闭，避免中断嵌套。Linux就是利用中断门实现的系统调用，就是那个著名的int0x80。中断门只允许存在于IDT中。描述符中中断门的type值为二进制1110，其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150752429.png" alt="image-20230626150752429"></p><ul><li>陷阱门描述符</li></ul><p>​陷阱门和中断门非常相似，区别是由陷阱门进入中断后，标志寄存器eflags中的IF位不会自动置0。陷阱门只允许存在于IDT中。描述符中陷阱门的type值为二进制1111。其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150816386.png" alt="image-20230626150816386"></p><ul><li>调用门描述符</li></ul><p>​调用门是提供给用户进程进入特权0级的方式，其DPL为3。调用门中记录例程的地址，它不能用int指令调用，只能用call和imp指令。调用门可以安装在GDT和LDT中。描述符中调用门的type值为二进制1100。其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150841553.png" alt="image-20230626150841553"></p><p>同样我们可以使用一个结构体来描述中断描述符：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 offset0;     <span class="comment">//段内偏移 0 ~ 15位</span></span><br><span class="line">    u16 selector;    <span class="comment">//代码段选择子</span></span><br><span class="line">    u8 reserved;     <span class="comment">//保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;     <span class="comment">//任务们/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>;  <span class="comment">//segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;      <span class="comment">//使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>;  <span class="comment">//是否有效</span></span><br><span class="line">    u16 offset1;     <span class="comment">//段内偏移 16 ~ 31位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br></pre></td></tr></table></figure><p>然后填充中断描述符和中断</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="type">void</span>* <span class="type">handler_t</span>; <span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="comment">//定义idt</span></span><br><span class="line">   <span class="type">gate_t</span> idt[IDT_SIZE];</span><br><span class="line"><span class="comment">//中断处理程序段内偏移</span></span><br><span class="line">   <span class="keyword">extern</span> <span class="type">handler_t</span> handler_entry_table[ENTRY_SIZE];</span><br><span class="line"><span class="comment">//初始化中断描述符表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; IDT_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line">        <span class="type">handler_t</span> handler = handler_entry_table[i];</span><br><span class="line">        gate-&gt;offset0 = (u32)handler &amp; <span class="number">0xffff</span>;         <span class="comment">//段内偏移 0 ~ 15位</span></span><br><span class="line">        gate-&gt;offset1 = ((u32)handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>; <span class="comment">//段内偏移 16 ~ 31位</span></span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;    <span class="comment">//代码段选择子</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;         <span class="comment">//保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;        </span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;              <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;          <span class="comment">// 是否有效</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后将idt_ptr填充进IDTR寄存器中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载中断描述符表</span></span><br><span class="line">idt_ptr.base = (u32)idt;</span><br><span class="line">idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-LDTR寄存器"><a href="#3-4-3-LDTR寄存器" class="headerlink" title="3.4.3 LDTR寄存器"></a>3.4.3 <code>LDTR</code>寄存器</h3><h3 id="3-4-4-TR寄存器"><a href="#3-4-4-TR寄存器" class="headerlink" title="3.4.4 TR寄存器"></a>3.4.4 <code>TR</code>寄存器</h3><h1 id="4-长模式下寄存器（64bit）"><a href="#4-长模式下寄存器（64bit）" class="headerlink" title="4.长模式下寄存器（64bit）"></a>4.长模式下寄存器（64bit）</h1><p>在长模式下，也称为64位保护模式（64-bit Protected Mode）或x86-64架构，x86处理器提供了更广泛的寄存器集合。以下是长模式下可以使用的寄存器：</p><ol><li>通用寄存器（General Purpose Registers）：<ul><li><code>RAX</code>：累加器寄存器（Accumulator Register）。</li><li><code>RBX</code>：基址寄存器（Base Register）。</li><li><code>RCX</code>：计数寄存器（Counter Register）。</li><li><code>RDX</code>：数据寄存器（Data Register）。</li><li><code>RSI</code>：源索引寄存器（Source Index Register）。</li><li><code>RDI</code>：目的索引寄存器（Destination Index Register）。</li><li><code>RBP</code>：基址指针寄存器（Base Pointer Register）。</li><li><code>RSP</code>：堆栈指针寄存器（Stack Pointer Register）。</li><li><code>R8-R15</code>：扩展的通用寄存器。</li></ul></li><li>扩展通用寄存器：<ul><li><code>RIP</code>：指令指针寄存器（Instruction Pointer Register）。</li><li><code>RFLAGS</code>：标志寄存器（Flags Register），包含各种标志位。</li></ul></li><li>段寄存器（Segment Registers）：<ul><li><code>CS</code>：代码段寄存器（Code Segment Register）。</li><li><code>DS</code>：数据段寄存器（Data Segment Register）。</li><li><code>ES</code>：附加段寄存器（Extra Segment Register）。</li><li><code>FS、GS、SS</code>：附加段寄存器，用于访问额外的数据段。</li></ul></li><li>控制寄存器（Control Registers）：<ul><li><code>CR0、CR2、CR3、CR4、CR8</code>：用于控制和管理保护模式的特性，如分页机制、特权级等。</li></ul></li><li>段描述符寄存器（Descriptor Registers）：<ul><li><code>GDTR</code>：全局描述符表寄存器（Global Descriptor Table Register）。</li><li><code>IDTR</code>：中断描述符表寄存器（Interrupt Descriptor Table Register）。</li><li><code>LDTR</code>：局部描述符表寄存器（Local Descriptor Table Register）。</li><li><code>TR</code>：任务寄存器（Task Register）。</li></ul></li><li>XMM寄存器（SSE寄存器）：<ul><li><code>XMM0-XMM15</code>：128位的向量寄存器，用于执行SSE（Streaming SIMD Extensions）指令集中的向量运算。</li></ul></li><li>YMM寄存器（AVX寄存器）：<ul><li><code>YMM0-YMM15</code>：256位的向量寄存器，用于执行AVX（Advanced Vector Extensions）指令集中的向量运算。</li></ul></li><li>ZMM寄存器（AVX-512寄存器）：<ul><li><code>ZMM0-ZMM31</code>：512位的向量寄存器，用于执行AVX-512指令集中的向量运算。</li></ul></li></ol><h1 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5. 参考链接"></a>5. 参考链接</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/400007642">中断描述符表 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://blog.csdn.net/abc123lzf/article/details/109289567">(67条消息) x86保护模式——全局描述符表GDT详解_gdt全局描述符表_A__Plus的博客-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-1.概述</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h2><ul><li><p>开发环境：</p><ul><li><code>ubuntu20.04.5 WSL</code></li><li><code>sudo apt install nasm</code>: 安装汇编编译器 nasm</li><li><code>sudo apt install bochs-x</code>: 安装虚拟机 bochs</li><li><code>sudo apt-get install qemu-system</code> ：下载安装可以模拟全部硬件的qemu</li><li><code>sudo apt install gdb</code> ：安装gdb调试器</li><li><code>sudo apt-get install gcc-multilib</code>&amp;&amp;<code>sudo apt-get install g++-multilib</code>： 安装在64位的机器上产生32位的程序</li></ul></li><li><p>参考书籍:</p><ul><li>操作系统真相还原</li><li>30天自制操作系统</li><li>Orange’S:一个操作系统的实现</li></ul></li></ul><blockquote><p>源码地址：<a href="https://github.com/yanglianoo/Onix">yanglianoo&#x2F;Onix: 基于X86的操作系统，C语言 (github.com)</a></p></blockquote><h2 id="2-操作系统大纲"><a href="#2-操作系统大纲" class="headerlink" title="2.操作系统大纲"></a>2.操作系统大纲</h2><ul><li>系统引导<ul><li>自写bootloader</li><li>grub 引导</li></ul></li><li>硬件及驱动<ul><li>CPU : 32位X86架构</li><li>显示器：VGA</li><li>中断控制器：8259A</li><li>键盘</li><li>硬盘</li><li>时钟：内部时钟，外部时钟</li><li>网卡</li></ul></li><li>任务调度：内核进程，用户态线程</li><li>中断系统：外部中断、软中断、异常</li><li>内存管理</li><li>文件系统</li><li>系统调用</li><li>shell</li><li>网络</li></ul><h2 id="3-计算机组成概述"><a href="#3-计算机组成概述" class="headerlink" title="3.计算机组成概述"></a>3.计算机组成概述</h2><p>通常，计算机由以下几部分组成：</p><ul><li>负责计算和处理数据的 CPU</li><li>负责存储程序和数据的存储器</li><li>和外部进行数据交换的 I&#x2F;O（Input&#x2F;Output，输入输出装置）。</li></ul><p>各部分<code>通过总线连接</code>就构成了一台计算机</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.001-16862005447604.png" alt="img"></p><p>CPU在运行程序的逻辑如下：</p><ul><li><p><code>1.将磁盘上的程序加载到内存中</code></p></li><li><p><code>2.读取内存中的指令</code></p><p>首先，CPU 要把即将执行的指令从内存中读取出来。CPU 中有个 PC（Program Counter，程序计数器）寄存器，其中保存着即将执行的指令的地址。指令的读取是通过将 PC 寄存器的值输出给内存，由内存返回该值对应地址中的指令</p></li><li><p><code>3.对指令进行解码</code></p><p>然后，CPU 对读取的指令所对应的操作进行解码。指令有很多种，有进行各种运算的指令、控制下一条命令的指令、对内存和 I&#x2F;O 进行读写的指令，还有对 CPU 进行控制的指令。这些指令由 CPU 中被称为指令解码器的模块进行解码。可以用来保存地址和运算结果的寄存器称为通用寄存器（General Purpose Register）</p></li><li><p><code>4.执行指令</code></p><p>最后，CPU 对解码器确定的操作进行处理。CPU 可以从内部存储装置——寄存器或外部的内存读取数据并处理，然后将结果写回寄存器或内存。</p></li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.004.png" alt="img"></p><p>CPU 执行的指令，由代表操作种类的<code>操作码</code>和代表操作对象的<code>操作数</code>两部分组成。指令本身用特定的二进制序列来表示，这种二进制序列称为机器语言。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.005.png" alt="img"></p><blockquote><p>操作数：通常为寄存器地址、内存地址、立即数等</p><p>操作码：对应为cpu具体的操作，如加法、减法等</p></blockquote><p>根据执行的指令的特征，CPU 分为 <code>RISC</code>（Reduced Instruction Set Computer，精简指令集计算机）和 <code>CISC</code>（Complex Instruction Set Computer，复杂指令集计算机）两种</p><h3 id="3-1-内存和地址"><a href="#3-1-内存和地址" class="headerlink" title="3.1 内存和地址"></a>3.1 内存和地址</h3><p>所有能够存储数据的存储器都可称为内存，内存是用来存放运行时指令（程序）和数据的存储器。</p><p>我们一般说的电脑的内存条为DRAM，就是用来保存<code>程序运行</code>时的指令和数据。像固态硬盘、机械硬盘等存储介质也可用于存储指令和数据，但由于其访问速度实在是太慢，因此适用于计算机<code>长期保存数据和程序</code>的存储器。</p><p>内存使用地址的概念来管理存储的数据。地址表示的是数据存储的位置，如同数据的住所一样。每个数据单元都有一个地址。大多情况下数据单元是一个字节（8 位）长度。这种方式称为字节编址。不同架构的CPU有不同的编址方式。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.006.png" alt="img"></p><p>如上图，CPU可通过总线寻址找到内存空间每个数据单元，并从中取出每个数据单元存储的数据。</p><p>内存等存储器的特点是速度越快成本越高。因此通常使用“高速小容量”、“中速中等容量”到“低速大容量”等多种存储器组合的混合型架构。这种构造称为存储器层级。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.007.png" alt="img"></p><p>在存储层面，速度最快的是 CPU 中的寄存器。CPU 比内存速度快很多，由 CPU 直 接访问内存效率较低。为了提高内存访问速度，在 CPU 和内存间增加了被称为缓存的高速小容量存储器。</p><p>缓存可以暂时性地缓冲存储从内存中读取的数据。CPU 在访问内存时，如果需要的数据已经保存在缓存中，则可直接从缓存中读取，以提高访问效率。根据容量和速度的不同，缓存也分为多个层级，通常为一级缓存、二级缓存等多个级别。</p><h3 id="3-2-IO"><a href="#3-2-IO" class="headerlink" title="3.2 IO"></a>3.2 IO</h3><p>I&#x2F;O（Input&#x2F;Output）是进行数据输入输出的装置。计算机通过 I&#x2F;O 和外部实现数据交换。计算机的处理操作按照从外部读取数据、在内部处理数据、再向外部输出结果的顺序进行。以个人电脑为例，如下图所示，它从鼠标或键盘输入数据，处理器根据程序处理数据，通过显示器等向外部输出结果。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.009.png" alt="img"></p><p>访问 I&#x2F;O 的方式大致分为<code>存储器映射 I/O</code> 和<code>端口映射 I/O </code>两种。</p><ul><li><code>存储器映射 I/O</code> :存储器映射 I&#x2F;O 方式中，I&#x2F;O 也和内存一样使用地址进行管理，可以和访问内存一样的方式进行访问</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.010.png" alt="img"></p><ul><li><code>端口映射访问</code>:端口映射 I&#x2F;O 方式中，CPU 含有支持访问 I&#x2F;O 的专用指令。</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.011.png" alt="img"></p><h3 id="3-3-字节序"><a href="#3-3-字节序" class="headerlink" title="3.3 字节序"></a>3.3 字节序</h3><p>将多字节数据存储在内存中时，各字节的存储顺序称为字节序。比如，将 4 字节数据 0x12345678 放入内存时，地址 0 中放 0x12、地址 1 中放 0x34、地址 2 中放 0x56、地址 3 中放 0x78 的方式，称为大端序。相对地，地址 0 中放 0x78、地址 1 中放 0x56、地址 2 中放 0x34、地址 3 中放 0x12 的方式，称为小端序。不同CPU采用的字节序不尽相同</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.008.png" alt="img"></p><h3 id="3-4-总线"><a href="#3-4-总线" class="headerlink" title="3.4 总线"></a>3.4 总线</h3><p>总线是 CPU、内存和 I&#x2F;O 之间交换数据的共同通道。总线将一根信号线在多个模块间共享进行通信。</p><p>总线包括<code>地址总线、数据总线、控制总线、IO总线</code>，顾名思义数据线是用于数据读取、地址总线用于地址寻址、控制总线用于控制cpu行为。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.012.png" alt="img"></p><p>当计算机中的各个组件之间需要进行数据传输和控制信号传递时，总线起到了关键的作用。下面是对四种主要总线的简要介绍：</p><ol><li>地址总线（Address Bus）：<ul><li>作用：地址总线用于传输CPU或其他设备发出的内存或外设的地址信息。</li><li>功能：它决定了CPU或其他设备要访问的内存单元或外设的位置。地址总线的宽度决定了系统能够寻址的内存空间大小。例如，32位地址总线可以寻址的内存空间大小为2^32个字节（4GB）。</li></ul></li><li>数据总线（Data Bus）：<ul><li>作用：数据总线用于传输CPU或其他设备之间的数据。</li><li>功能：数据总线承载着实际的数据传输，包括指令、操作数、计算结果等。数据总线的宽度决定了一次可以传输的数据位数，例如，32位数据总线可以一次传输32位（4字节）的数据。</li></ul></li><li>控制总线（Control Bus）：<ul><li>作用：控制总线用于传输各种控制信号，包括指令控制、时序控制和状态信号等。</li><li>功能：控制总线通过不同的信号线传递各种控制信号，例如，读取（Read）和写入（Write）信号用于指示数据传输的方向，时钟信号用于同步操作，中断信号用于通知CPU有外部事件需要处理等。</li></ul></li><li>I&#x2F;O总线（I&#x2F;O Bus）：<ul><li>作用：I&#x2F;O总线用于连接CPU和外部设备之间进行输入输出操作。</li><li>功能：I&#x2F;O总线是一种专门用于输入输出的总线，它提供了一种通信通道，使得CPU能够与外部设备进行数据交换。通过I&#x2F;O总线，CPU可以发送读取（IN）和写入（OUT）指令来控制外部设备的数据读取和写入。</li></ul></li></ol><p>这四种总线相互配合，构成了计算机系统中各个组件之间的连接和通信桥梁。它们共同工作，使得CPU能够与内存和外设进行数据传输、控制信号传递和输入输出操作，实现计算机的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写STL之Vector</title>
      <link href="/2023/06/07/%E6%89%8B%E5%86%99STL-Vector/"/>
      <url>/2023/06/07/%E6%89%8B%E5%86%99STL-Vector/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码仓库：<a href="https://github.com/yanglianoo/My_STL/tree/timer">yanglianoo&#x2F;My_STL at timer (github.com)</a></p></blockquote><h2 id="1-Vector-概述"><a href="#1-Vector-概述" class="headerlink" title="1.Vector 概述"></a>1.Vector 概述</h2><p>在C++ STL（标准模板库）中，<code>vector</code> 是一个动态数组容器，它是一个模板类具有以下特性：</p><ol><li><strong>动态大小</strong>: <code>vector</code> 的大小可以根据需要动态增长或缩小。它可以自动调整内部存储空间，以适应容器中元素的数量。</li><li><strong>连续存储</strong>: <code>vector</code> 中的元素在内存中是连续存储的，这使得对元素的随机访问变得高效。</li><li><strong>快速插入和删除</strong>: 在 <code>vector</code> 的末尾插入或删除元素是高效的，时间复杂度为常数。但在中间或开头插入或删除元素的操作可能会导致元素的移动，时间复杂度为线性。</li><li><strong>随机访问</strong>: <code>vector</code> 支持通过索引进行随机访问。可以使用下标运算符 <code>[]</code> 或 <code>at()</code> 函数来访问特定位置的元素。</li><li><strong>动态调整内存</strong>: 当 <code>vector</code> 的大小超过当前分配的内存空间时，它会重新分配更大的内存块，并将现有元素移动到新的内存中。这可以确保容器始终具有足够的内存来存储元素。</li><li><strong>元素访问</strong>: 可以使用迭代器来遍历 <code>vector</code> 中的元素。可以使用 <code>begin()</code> 和 <code>end()</code> 成员函数获取指向容器开头和结尾的迭代器。</li><li><strong>容器操作</strong>: <code>vector</code> 支持许多常见的容器操作，如排序、查找、插入和删除元素。它还提供了与其他容器兼容的接口，例如迭代器、范围构造函数和算法函数。</li></ol><p><code>STL</code>库中<code>vector</code>的定义如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Allocator</span> = std::allocator&lt;T&gt;&gt; </span><br><span class="line">    <span class="keyword">class</span> vector;</span><br></pre></td></tr></table></figure><table><thead><tr><th>T</th><th>元素的类型。<code>T</code> 必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>Allocator</th><th>用于获取&#x2F;释放内存及构造&#x2F;析构内存中元素的分配器。类型必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/Allocator"><em>分配器</em> <em>(Allocator)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>成员函数</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/vector">(构造函数)</a></td><td>构造 <code>vector</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/~vector">(析构函数)</a></td><td>析构 <code>vector</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/operator%3D">operator&#x3D;</a></td><td>赋值给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/assign">assign</a></td><td>将值赋给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/get_allocator">get_allocator</a></td><td>返回相关的分配器 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/at">at</a></td><td>访问指定的元素，同时进行越界检查 (公开成员函数)</td></tr><tr><td>operator[]</td><td>访问指定的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/data">data</a></td><td>直接访问底层数组 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/reserve">reserve</a></td><td>预留存储空间 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/capacity">capacity</a></td><td>返回当前存储空间能够容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/shrink_to_fit">shrink_to_fit</a></td><td>通过释放未使用的内存减少内存的使用 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/swap">swap</a></td><td>交换内容</td></tr></tbody></table><blockquote><p>参考链接: <a href="https://zh.cppreference.com/w/cpp/container/vector">std::vector - cppreference.com</a></p></blockquote><h2 id="2-构造Vector"><a href="#2-构造Vector" class="headerlink" title="2.构造Vector"></a>2.构造Vector</h2><p>自己手写<code>vector</code>时，迭代器不是通用的<code>Allocator</code>类型，需要在<code>vector</code>内部实现一个自定义的迭代器</p><p>vector模板类定义如下，需要维护三个私有的成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;    <span class="comment">//实际数组大小</span></span><br><span class="line">    <span class="type">int</span> _capacity;<span class="comment">//最大容量</span></span><br><span class="line">    T* _elem;     <span class="comment">//数据区指针  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：模板类的实现和声明不能分离编译，因此最好将模板类的声明和实现都放在头文件中<br>参考链接：<a href="https://blog.csdn.net/u011201045/article/details/38679417">(64条消息) C++中模板类的编译过程_c++模板编译_jiazhucai的博客-CSDN博客</a></p></blockquote><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>构造函数定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>();   <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(std::initiallizer_list&lt;T&gt; init) <span class="comment">// c++11 列表初始化</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other); <span class="comment">//用另外一个vector来构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other,<span class="type">int</span> left,<span class="type">int</span> right); <span class="comment">//用另外一个vector区间构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">size_t</span> count, T&amp; value); <span class="comment">//初始化为count个 value</span></span><br></pre></td></tr></table></figure><h4 id="2-1-1-辅助函数"><a href="#2-1-1-辅助函数" class="headerlink" title="2.1.1 辅助函数"></a>2.1.1 辅助函数</h4><p>在定义构造函数具体实现时需要定义几个辅助函数:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span>; <span class="comment">//空间不足时扩容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink</span><span class="params">()</span></span>; <span class="comment">//装填因子过小时压缩</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyFrom</span> <span class="params">( T <span class="type">const</span>* A, <span class="type">int</span> left, <span class="type">int</span> right )</span></span>; <span class="comment">//复制数组区间 A[left, right]</span></span><br></pre></td></tr></table></figure><ul><li>内存扩充函数<code>expand()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_CAPACITY 3 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">expand</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_size &lt;= _capacity) <span class="keyword">return</span>;  <span class="comment">//当size 小于等于 capacity 时 不需要扩容</span></span><br><span class="line">    <span class="keyword">if</span>(_capacity &lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY; <span class="comment">//当capacity小于最小大小，更改capacity为最小大小</span></span><br><span class="line">    <span class="comment">/* 反复翻倍，直到 _capacity &gt; _size*/</span></span><br><span class="line">    <span class="keyword">while</span> (_capacity &lt; _size)</span><br><span class="line">    &#123;</span><br><span class="line">        _capacity *=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T* old_data = _data;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity &lt;&lt; <span class="number">1</span>];  <span class="comment">//capacity 增大一倍，重新 new 内存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;_size; i++)       <span class="comment">//赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = old_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] old_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内存缩小函数<code>shrink()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">shrink</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capacity &lt; DEFAULT_CAPACITY &lt;&lt; <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//不致收缩倒DEFAULT_CAPACITY以下</span></span><br><span class="line">    <span class="keyword">if</span>(_size &lt;&lt; <span class="number">2</span> &gt; _capacity) <span class="keyword">return</span>;  <span class="comment">//以 25% 为边界</span></span><br><span class="line"></span><br><span class="line">    T* old_data = _data;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = old_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] old_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>区间复制函数<code>copyFrom ( T const* A, int left, int right )</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">copyFrom</span> ( T <span class="type">const</span>* A, <span class="type">int</span> left, <span class="type">int</span> right )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _capacity = (right - left) * <span class="number">2</span>;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[_size] = A[left];</span><br><span class="line">        _size++;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-构造函数实现"><a href="#2-2-2-构造函数实现" class="headerlink" title="2.2.2 构造函数实现"></a>2.2.2 构造函数实现</h4><ul><li><code>vector()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*构造函数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>():_data(<span class="literal">nullptr</span>),_capacity(<span class="number">0</span>),_size(<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(const vector&lt;T&gt;&amp; *other*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">copyFrom</span>(other._data,<span class="number">0</span>,other._size); <span class="comment">//直接调用 copyFrom 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(std::initializer_list&lt;T&gt; *init*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* c++11 列表初始化 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(std::initializer_list&lt;T&gt; init)</span><br><span class="line">&#123;</span><br><span class="line">    _size = init.<span class="built_in">size</span>();</span><br><span class="line">    _capacity = _size * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; elem : init)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(int *count*, T&amp; *value*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(<span class="type">size_t</span> count, T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    _size = count;</span><br><span class="line">    _capacity = <span class="number">2</span> * _size;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i =<span class="number">0</span>; i&lt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-析构函数"><a href="#2-2-析构函数" class="headerlink" title="2.2 析构函数"></a>2.2 析构函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::~<span class="built_in">vector</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-赋值"><a href="#3-赋值" class="headerlink" title="3.赋值"></a>3.赋值</h2><p>实现的成员函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//成员函数</span></span><br><span class="line">    vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector&amp; other);</span><br><span class="line">    vector&amp; <span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">size_t</span> count,<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>vector&amp; operator=(const vector&amp; other)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;&amp; vector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> vector&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">copyFrom</span>(other._data,<span class="number">0</span>,other._size);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector&lt;T&gt;::operator=( std::initializer_list&lt;T&gt; *ilist* )</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;&amp; vector&lt;T&gt;::<span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = ilist.<span class="built_in">size</span>();</span><br><span class="line">    _capacity = _size * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; elem : ilist)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-元素访问"><a href="#4-元素访问" class="headerlink" title="4.元素访问"></a>4.元素访问</h2><p>元素访问的接口有如下这些：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//元素访问</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);</span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">data</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;<span class="number">0</span> || index &gt;= _size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data[_size<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* vector&lt;T&gt;::<span class="built_in">data</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h2><h3 id="5-1-迭代器使用实例"><a href="#5-1-迭代器使用实例" class="headerlink" title="5.1 迭代器使用实例"></a>5.1 迭代器使用实例</h3><p>在构建迭代器之前，先看看迭代器的用法，一般用于遍历容器中的各个元素</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 1. 使用迭代器进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1. Iterate using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 使用auto关键字进行简化</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2. Iterate using auto keyword: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 使用范围基于循环 (range-based loop)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3. Iterate using range-based loop: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 修改容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4. Modify elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        *it = *it * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 插入元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5. Insert elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> insertPos = vec.<span class="built_in">begin</span>() + <span class="number">2</span>; <span class="comment">// 在索引2的位置之后插入元素</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(insertPos, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 删除元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;6. Erase elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> erasePos = vec.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 删除索引1的元素</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(erasePos);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-迭代器类实现"><a href="#5-2-迭代器类实现" class="headerlink" title="5.2 迭代器类实现"></a>5.2 迭代器类实现</h3><p><code>iterrator</code>是一个类，在内部维护了一个指针，需要对其进行各种操作符重载，<code>iterrator</code>的具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterrator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            T * m_pointer;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Iterrator</span>():<span class="built_in">m_pointer</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">            <span class="built_in">Iterrator</span>(T * pointer) : <span class="built_in">m_pointer</span>(pointer) &#123;&#125;</span><br><span class="line">            ~<span class="built_in">Iterrator</span>() &#123;&#125;</span><br><span class="line">        <span class="comment">/* 判断两个迭代器是否相等 */</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Iterrator &amp; other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer == other.m_pointer;   </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* 迭代器赋值 */</span></span><br><span class="line">        Iterrator <span class="keyword">operator</span> = (<span class="type">const</span> Iterrator&amp; other)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer = other.m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 前缀递增*/</span></span><br><span class="line">        Iterrator &amp; <span class="keyword">operator</span> ++ ()</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer +=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 后缀递增 */</span></span><br><span class="line">        Iterrator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            ++(*<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> + (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            it.m_pointer += i;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterrator <span class="keyword">operator</span> += (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer += i;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> -= (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer -= i;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> - (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            it.m_pointer -= i;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="keyword">operator</span> - (<span class="type">const</span> Iterrator&amp; other) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer - other.m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T &amp; <span class="keyword">operator</span> * ()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T * <span class="keyword">operator</span> -&gt; ()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>记录：在对<code>Iterrator</code>前++和后++重载时，如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前缀递增*/</span></span><br><span class="line">Iterrator &amp; <span class="keyword">operator</span> ++ ()</span><br><span class="line">&#123;</span><br><span class="line">m_pointer +=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/* 后缀递增 */</span></span><br><span class="line">Iterrator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">     Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">     ++(*<span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中，后缀递增操作符(it++)可以通过接受一个额外的int参数进行区分，这是由C++语言规范所定义的。根据规范，后缀递增操作符的函数参数列表中必须有一个int类型的参数，尽管在函数体内并没有使用该参数。</p><p>这种设计是为了在语法上能够区分前缀递增和后缀递增操作。当编译器遇到<code>it++</code>表达式时，它会根据后缀递增操作符的函数参数列表中是否存在一个额外的int参数来决定使用后缀递增操作符的重载函数。</p><p>编译器会将后缀递增操作符的调用转换为对重载的后缀递增操作符函数的调用，并传递一个编译器生成的临时整数参数（通常是0）。</p><p>请注意，这个整数参数的名称在函数体内并没有使用，因为它的存在只是为了与前缀递增操作符进行区分，而不是为了实际使用。</p></blockquote><h3 id="5-3-迭代器操作函数实现"><a href="#5-3-迭代器操作函数实现" class="headerlink" title="5.3 迭代器操作函数实现"></a>5.3 迭代器操作函数实现</h3><p><code>begin</code>用于获取头指针，<code>end</code>用于获取尾指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//迭代器操作函数</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">begin</span>()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(_data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">end</span>()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(_data + _size)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要使用<code>typename</code>显示的告诉编译器<code>vector&lt;T&gt;::Iterator</code>是一个类型</p><h2 id="6-容量"><a href="#6-容量" class="headerlink" title="6.容量"></a>6.容量</h2><p>和容量相关的接口函数比较简单，实现的接口如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//容量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//判断容器是否为空</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//获取容器元素个数</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//获取容器最大存储个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> new_cap)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> vector&lt;T&gt;::<span class="built_in">empty</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _size==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">max_size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">capacity</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 重置容器大小 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">reserve</span>(<span class="type">size_t</span> new_cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capacity &gt;= new_cap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _size += new_cap;</span><br><span class="line">        <span class="built_in">expand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果 _capacity 过大则缩减*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">shrink_to_fit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shrink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-修改器"><a href="#7-修改器" class="headerlink" title="7.修改器"></a>7.修改器</h2><p>和修改容器有关的接口函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//修改器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> Iterator it ,<span class="type">const</span> T &amp; value)</span></span>;  </span><br><span class="line">    <span class="function">Iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> Iterator it ,<span class="type">int</span> n,<span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">erase</span><span class="params">(<span class="type">const</span> Iterator it)</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">erase</span><span class="params">(<span class="type">const</span> Iterator first,<span class="type">const</span> Iterator last)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector &amp; other)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>clear()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* clear操作，直接将 _size 清零*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator insert(const Iterator it ,int n,const T &amp; value)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在 it 的位置插入 n 个 T 元素*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Iterator it ,<span class="type">int</span> n,<span class="type">const</span> T &amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = it - <span class="built_in">begin</span>();</span><br><span class="line">    _size += n;</span><br><span class="line">    <span class="comment">//如果有需要，则扩容</span></span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=_size; i&gt;size;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i+n<span class="number">-1</span>] = _data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[size+i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;T&gt;::<span class="built_in">Iterator</span>(_data + size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator insert(const Iterator it ,const T &amp; value) </code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在 it 位置插入 1 个元素 value*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Iterator it ,<span class="type">const</span> T &amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    _size+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">    <span class="built_in">insert</span>(it,<span class="number">1</span>,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator erase(const Iterator it)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除 it 位置的元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Iterator it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">end</span>() - it == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _size -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = it - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = count; i &lt; _size <span class="number">-1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = _data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    _size -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator erase(const Iterator first,const Iterator last)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 区间删除 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Iterator first,<span class="type">const</span> Iterator last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( first == last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> first;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> f = first - <span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> l = last - <span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> ( l &lt; _size) <span class="comment">// [last,_szie) 顺次前移 l - f 个单元</span></span><br><span class="line">        &#123;</span><br><span class="line">            _data[f++] = _data[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        _size = f;  <span class="comment">//更新规模</span></span><br><span class="line">        <span class="built_in">shrink</span>(); <span class="comment">//若有必要则缩容</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void push_back(const T &amp; value)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在尾部插入一个元素value */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size &lt; _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[_size] = value; </span><br><span class="line">        _size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _size++;</span><br><span class="line">        <span class="built_in">expand</span>();</span><br><span class="line">        <span class="type">int</span> index = _size - <span class="number">1</span>;</span><br><span class="line">        _data[index] = value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void pop_back()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 弹出最后一个元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void resize(size_t size)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">resize</span>(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size &gt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        _size = size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i= _size; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _data[i] = <span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _size = size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = size;</span><br><span class="line">    <span class="built_in">expand</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void swap(vector &amp; other)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 两个 vector 交换*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">swap</span>(vector &amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    T * data = other._data;</span><br><span class="line">    <span class="type">int</span> size = other._size;</span><br><span class="line">    <span class="type">int</span> capacity = other._capacity;</span><br><span class="line"></span><br><span class="line">    other._data = _data;</span><br><span class="line">    other._size = _size;</span><br><span class="line">    other._capacity = _capacity;</span><br><span class="line"></span><br><span class="line">    _data = data;</span><br><span class="line">    _size = size;</span><br><span class="line">    _capacity = capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>至此，<code>vector</code> 构造完毕，未进行测试，不知道是否有<code>bug</code></p>]]></content>
      
      
      <categories>
          
          <category> 手写STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
