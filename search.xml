<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CyberRT源码分析-协程实现</title>
      <link href="/2024/10/31/CyberRT%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/10/31/CyberRT%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/440016053">x86-64寄存器和栈帧 - 知乎</a></p></li><li><p><a href="https://blog.csdn.net/Zero__two_/article/details/120781099">【详解】函数栈帧——多图（c语言）_指针与函数值传递-CSDN博客</a></p></li><li><p><a href="https://blog.csdn.net/lizhipengcsdn/article/details/131236278">CyberRt协程介绍-CSDN博客</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> 协程 </tag>
            
            <tag> X86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核启动流程分析</title>
      <link href="/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核启动流程分析"><a href="#Linux内核启动流程分析" class="headerlink" title="Linux内核启动流程分析"></a>Linux内核启动流程分析</h1><p>我在学习Linux驱动的时候总感觉蒙着一层雾，让我看不清Linux内核的核心，Linux内核有很多子系统，我觉得有必要先从<code>Linux Kernel</code>的启动去宏观的看一下各个子系统是哪个时刻被启动的，我主要以<code>ARM64</code>为例子来分析Linux 内核的启动流程。我们知道在<code>Linux</code>内核启动之前是<code>uboot</code>，<code>uboot</code>会做一些初始化工作，如初始化ddr，我使用的内核源码为迅为电子提供的<code>RK3588</code>的<code>linux SDK</code>，内核版本为<code>5.10.198</code></p><h2 id="1-内核链接文件"><a href="#1-内核链接文件" class="headerlink" title="1. 内核链接文件"></a>1. 内核链接文件</h2><p>​内核编译后生成的目标文件是ELF格式的vmlinux，vmlinux文件是各个源代码按照<code>vmlinux.lds</code>设定的规则，链接后得到的Object文件，并不是一个可执行的文件，不能在ARM平台上运行；通常会对其压缩，生成zImage或bzImage；通常内核映像以压缩格式存储，并不是一个可执行的内核；因此内核阶段需要先对内核映像自解压，他们的文件头部打包有解压缩程序</p><p>​<code>Linux</code>内核的链接文件目录在<code>arch/arm64/kernel/vmlinux.lds.S</code>，内核在编译时会根据<code>vmlinux.lds.S</code>生成<code>vmlinux.lds</code>，<code>vmlinux.lds</code>就是内核最后的链接脚本，会用于链接生成内核镜像<code>vmlinux</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//arch/arm64/kernel/vmlinux.lds.S</span><br><span class="line">/* SPDX-License-Identifier: GPL-2.0 */</span><br><span class="line">/*</span><br><span class="line"> * ld script to make ARM Linux kernel</span><br><span class="line"> * taken from the i386 version by Russell King</span><br><span class="line"> * Written by Martin Mares &lt;mj@atrey.karlin.mff.cuni.cz&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;asm-generic/vmlinux.lds.h&gt;</span><br><span class="line">#include &lt;asm/cache.h&gt;</span><br><span class="line">#include &lt;asm/kernel-pgtable.h&gt;</span><br><span class="line">#include &lt;asm/thread_info.h&gt;</span><br><span class="line">#include &lt;asm/memory.h&gt;</span><br><span class="line">#include &lt;asm/page.h&gt;</span><br><span class="line">#include &lt;asm/pgtable.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;image.h&quot;</span><br><span class="line"></span><br><span class="line">/* .exit.text needed in case of alternative patching */</span><br><span class="line">#define ARM_EXIT_KEEP(x)x</span><br><span class="line">#define ARM_EXIT_DISCARD(x)</span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_text)</span><br><span class="line"></span><br><span class="line">jiffies = jiffies_64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define HYPERVISOR_EXTABLE\</span><br><span class="line">. = ALIGN(SZ_8);\</span><br><span class="line">__start___kvm_ex_table = .;\</span><br><span class="line">*(__kvm_ex_table)\</span><br><span class="line">__stop___kvm_ex_table = .;</span><br><span class="line"></span><br><span class="line">#define HYPERVISOR_TEXT\</span><br><span class="line">/*\</span><br><span class="line"> * Align to 4 KB so that\</span><br><span class="line"> * a) the HYP vector table is at its minimum\</span><br><span class="line"> *    alignment of 2048 bytes\</span><br><span class="line"> * b) the HYP init code will not cross a page\</span><br><span class="line"> *    boundary if its size does not exceed\</span><br><span class="line"> *    4 KB (see related ASSERT() below)\</span><br><span class="line"> */\</span><br><span class="line">. = ALIGN(SZ_4K);\</span><br><span class="line">__hyp_idmap_text_start = .;\</span><br><span class="line">*(.hyp.idmap.text)\</span><br><span class="line">__hyp_idmap_text_end = .;\</span><br><span class="line">__hyp_text_start = .;\</span><br><span class="line">*(.hyp.text)\</span><br><span class="line">HYPERVISOR_EXTABLE\</span><br><span class="line">__hyp_text_end = .;</span><br><span class="line"></span><br><span class="line">#define IDMAP_TEXT\</span><br><span class="line">. = ALIGN(SZ_4K);\</span><br><span class="line">__idmap_text_start = .;\</span><br><span class="line">*(.idmap.text)\</span><br><span class="line">__idmap_text_end = .;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_HIBERNATION</span><br><span class="line">#define HIBERNATE_TEXT\</span><br><span class="line">. = ALIGN(SZ_4K);\</span><br><span class="line">__hibernate_exit_text_start = .;\</span><br><span class="line">*(.hibernate_exit.text)\</span><br><span class="line">__hibernate_exit_text_end = .;</span><br><span class="line">#else</span><br><span class="line">#define HIBERNATE_TEXT</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span><br><span class="line">#define TRAMP_TEXT\</span><br><span class="line">. = ALIGN(PAGE_SIZE);\</span><br><span class="line">__entry_tramp_text_start = .;\</span><br><span class="line">*(.entry.tramp.text)\</span><br><span class="line">. = ALIGN(PAGE_SIZE);\</span><br><span class="line">__entry_tramp_text_end = .;</span><br><span class="line">#else</span><br><span class="line">#define TRAMP_TEXT</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The size of the PE/COFF section that covers the kernel image, which</span><br><span class="line"> * runs from stext to _edata, must be a round multiple of the PE/COFF</span><br><span class="line"> * FileAlignment, which we set to its minimum value of 0x200. &#x27;stext&#x27;</span><br><span class="line"> * itself is 4 KB aligned, so padding out _edata to a 0x200 aligned</span><br><span class="line"> * boundary should be sufficient.</span><br><span class="line"> */</span><br><span class="line">PECOFF_FILE_ALIGNMENT = 0x200;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">#define PECOFF_EDATA_PADDING\</span><br><span class="line">.pecoff_edata_padding : &#123; BYTE(0); . = ALIGN(PECOFF_FILE_ALIGNMENT); &#125;</span><br><span class="line">#else</span><br><span class="line">#define PECOFF_EDATA_PADDING</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line"> * XXX: The linker does not define how output sections are</span><br><span class="line"> * assigned to input sections when there are multiple statements</span><br><span class="line"> * matching the same input section name.  There is no documented</span><br><span class="line"> * order of matching.</span><br><span class="line"> */</span><br><span class="line">/DISCARD/ : &#123;</span><br><span class="line">ARM_EXIT_DISCARD(EXIT_TEXT)</span><br><span class="line">ARM_EXIT_DISCARD(EXIT_DATA)</span><br><span class="line">EXIT_CALL</span><br><span class="line">*(.discard)</span><br><span class="line">*(.discard.*)</span><br><span class="line">*(.interp .dynamic)</span><br><span class="line">*(.dynsym .dynstr .hash .gnu.hash)</span><br><span class="line">*(.eh_frame)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = KIMAGE_VADDR + TEXT_OFFSET;</span><br><span class="line"></span><br><span class="line">.head.text : &#123;</span><br><span class="line">_text = .;</span><br><span class="line">HEAD_TEXT</span><br><span class="line">&#125;</span><br><span class="line">.text : &#123;/* Real text segment*/</span><br><span class="line">_stext = .;/* Text and read-only data*/</span><br><span class="line">__exception_text_start = .;</span><br><span class="line">*(.exception.text)</span><br><span class="line">__exception_text_end = .;</span><br><span class="line">IRQENTRY_TEXT</span><br><span class="line">SOFTIRQENTRY_TEXT</span><br><span class="line">ENTRY_TEXT</span><br><span class="line">TEXT_TEXT</span><br><span class="line">SCHED_TEXT</span><br><span class="line">CPUIDLE_TEXT</span><br><span class="line">LOCK_TEXT</span><br><span class="line">KPROBES_TEXT</span><br><span class="line">HYPERVISOR_TEXT</span><br><span class="line">IDMAP_TEXT</span><br><span class="line">HIBERNATE_TEXT</span><br><span class="line">TRAMP_TEXT</span><br><span class="line">*(.fixup)</span><br><span class="line">*(.gnu.warning)</span><br><span class="line">. = ALIGN(16);</span><br><span class="line">*(.got)/* Global offset table*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">_etext = .;/* End of text section */</span><br><span class="line"></span><br><span class="line">RO_DATA(PAGE_SIZE)/* everything from this point to     */</span><br><span class="line">EXCEPTION_TABLE(8)/* __init_begin will be marked RO NX */</span><br><span class="line">NOTES</span><br><span class="line"></span><br><span class="line">. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">__init_begin = .;</span><br><span class="line">__inittext_begin = .;</span><br><span class="line"></span><br><span class="line">INIT_TEXT_SECTION(8)</span><br><span class="line">.exit.text : &#123;</span><br><span class="line">ARM_EXIT_KEEP(EXIT_TEXT)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = ALIGN(4);</span><br><span class="line">.altinstructions : &#123;</span><br><span class="line">__alt_instructions = .;</span><br><span class="line">*(.altinstructions)</span><br><span class="line">__alt_instructions_end = .;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = ALIGN(PAGE_SIZE);</span><br><span class="line">__inittext_end = .;</span><br><span class="line">__initdata_begin = .;</span><br><span class="line"></span><br><span class="line">.init.data : &#123;</span><br><span class="line">INIT_DATA</span><br><span class="line">INIT_SETUP(16)</span><br><span class="line">INIT_CALLS</span><br><span class="line">CON_INITCALL</span><br><span class="line">SECURITY_INITCALL</span><br><span class="line">INIT_RAM_FS</span><br><span class="line">*(.init.rodata.* .init.bss)/* from the EFI stub */</span><br><span class="line">&#125;</span><br><span class="line">.exit.data : &#123;</span><br><span class="line">ARM_EXIT_KEEP(EXIT_DATA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PERCPU_SECTION(L1_CACHE_BYTES)</span><br><span class="line"></span><br><span class="line">.rela.dyn : ALIGN(8) &#123;</span><br><span class="line">*(.rela .rela*)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__rela_offset= ABSOLUTE(ADDR(.rela.dyn) - KIMAGE_VADDR);</span><br><span class="line">__rela_size= SIZEOF(.rela.dyn);</span><br><span class="line"></span><br><span class="line">. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">__initdata_end = .;</span><br><span class="line">__init_end = .;</span><br><span class="line"></span><br><span class="line">_data = .;</span><br><span class="line">_sdata = .;</span><br><span class="line">RW_DATA_SECTION(L1_CACHE_BYTES, PAGE_SIZE, THREAD_ALIGN)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Data written with the MMU off but read with the MMU on requires</span><br><span class="line"> * cache lines to be invalidated, discarding up to a Cache Writeback</span><br><span class="line"> * Granule (CWG) of data from the cache. Keep the section that</span><br><span class="line"> * requires this type of maintenance to be in its own Cache Writeback</span><br><span class="line"> * Granule (CWG) area so the cache maintenance operations don&#x27;t</span><br><span class="line"> * interfere with adjacent data.</span><br><span class="line"> */</span><br><span class="line">.mmuoff.data.write : ALIGN(SZ_2K) &#123;</span><br><span class="line">__mmuoff_data_start = .;</span><br><span class="line">*(.mmuoff.data.write)</span><br><span class="line">&#125;</span><br><span class="line">. = ALIGN(SZ_2K);</span><br><span class="line">.mmuoff.data.read : &#123;</span><br><span class="line">*(.mmuoff.data.read)</span><br><span class="line">__mmuoff_data_end = .;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PECOFF_EDATA_PADDING</span><br><span class="line">__pecoff_data_rawsize = ABSOLUTE(. - __initdata_begin);</span><br><span class="line">_edata = .;</span><br><span class="line"></span><br><span class="line">BSS_SECTION(0, 0, 0)</span><br><span class="line"></span><br><span class="line">. = ALIGN(PAGE_SIZE);</span><br><span class="line">idmap_pg_dir = .;</span><br><span class="line">. += IDMAP_DIR_SIZE;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span><br><span class="line">tramp_pg_dir = .;</span><br><span class="line">. += PAGE_SIZE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_SW_TTBR0_PAN</span><br><span class="line">reserved_ttbr0 = .;</span><br><span class="line">. += RESERVED_TTBR0_SIZE;</span><br><span class="line">#endif</span><br><span class="line">swapper_pg_dir = .;</span><br><span class="line">. += SWAPPER_DIR_SIZE;</span><br><span class="line">swapper_pg_end = .;</span><br><span class="line"></span><br><span class="line">__pecoff_data_size = ABSOLUTE(. - __initdata_begin);</span><br><span class="line">_end = .;</span><br><span class="line"></span><br><span class="line">STABS_DEBUG</span><br><span class="line"></span><br><span class="line">HEAD_SYMBOLS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The HYP init code and ID map text can&#x27;t be longer than a page each,</span><br><span class="line"> * and should not cross a page boundary.</span><br><span class="line"> */</span><br><span class="line">ASSERT(__hyp_idmap_text_end - (__hyp_idmap_text_start &amp; ~(SZ_4K - 1)) &lt;= SZ_4K,</span><br><span class="line">&quot;HYP init code too big or misaligned&quot;)</span><br><span class="line">ASSERT(__idmap_text_end - (__idmap_text_start &amp; ~(SZ_4K - 1)) &lt;= SZ_4K,</span><br><span class="line">&quot;ID map text too big or misaligned&quot;)</span><br><span class="line">#ifdef CONFIG_HIBERNATION</span><br><span class="line">ASSERT(__hibernate_exit_text_end - (__hibernate_exit_text_start &amp; ~(SZ_4K - 1))</span><br><span class="line">&lt;= SZ_4K, &quot;Hibernate exit text too big or misaligned&quot;)</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span><br><span class="line">ASSERT((__entry_tramp_text_end - __entry_tramp_text_start) == PAGE_SIZE,</span><br><span class="line">&quot;Entry trampoline text too big&quot;)</span><br><span class="line">#endif</span><br><span class="line">/*</span><br><span class="line"> * If padding is applied before .head.text, virt&lt;-&gt;phys conversions will fail.</span><br><span class="line"> */</span><br><span class="line">ASSERT(_text == (KIMAGE_VADDR + TEXT_OFFSET), &quot;HEAD is misaligned&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>在此文件的开头指定了输出的架构以及内核入口地址为<code>_text</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_text)</span><br></pre></td></tr></table></figure></li><li><p><code>_text</code>是代码段的起始地址，定义在下面的<code>SECTIONS</code>部分，可以看见<code>_text</code>即为<code>.head_text</code>段，地址为：</p><p><code>KIMAGE_VADDR + TEXT_OFFSET</code>，这两个宏定义在<code>arch/arm64/include/asm/memory.h</code>中</p><p><img src="/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20240607140937077.png" alt="image-20240607140937077"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">. = KIMAGE_VADDR + TEXT_OFFSET;</span><br><span class="line"></span><br><span class="line">.head.text : &#123;</span><br><span class="line">_text = .;</span><br><span class="line">HEAD_TEXT</span><br><span class="line">&#125;</span><br><span class="line">.text : &#123;/* Real text segment*/</span><br><span class="line">_stext = .;/* Text and read-only data*/</span><br><span class="line">__exception_text_start = .;</span><br><span class="line">*(.exception.text)</span><br><span class="line">__exception_text_end = .;</span><br><span class="line">IRQENTRY_TEXT</span><br><span class="line">SOFTIRQENTRY_TEXT</span><br><span class="line">ENTRY_TEXT</span><br><span class="line">TEXT_TEXT</span><br><span class="line">SCHED_TEXT</span><br><span class="line">CPUIDLE_TEXT</span><br><span class="line">LOCK_TEXT</span><br><span class="line">KPROBES_TEXT</span><br><span class="line">HYPERVISOR_TEXT</span><br><span class="line">IDMAP_TEXT</span><br><span class="line">HIBERNATE_TEXT</span><br><span class="line">TRAMP_TEXT</span><br><span class="line">*(.fixup)</span><br><span class="line">*(.gnu.warning)</span><br><span class="line">. = ALIGN(16);</span><br><span class="line">*(.got)/* Global offset table*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-内核启动第一阶段"><a href="#2-内核启动第一阶段" class="headerlink" title="2. 内核启动第一阶段"></a>2. 内核启动第一阶段</h2><h3 id="2-1-内核启动入口点"><a href="#2-1-内核启动入口点" class="headerlink" title="2.1 内核启动入口点"></a>2.1 内核启动入口点</h3><p>我手上有一块迅为的RK3588的板子，我们来将编译好的<code>vmlinux</code>的<code>elf</code>文件读一下看一下入口地址是多少：</p><p><img src="/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20240607141148612.png" alt="image-20240607141148612"></p><p>使用迅为提供的编译器将其反汇编，在得到的汇编文件<code>vmlinux.s</code>中查找入口地址：<code>0xffffffc008000000</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmlinux:     file format elf64-littleaarch64</span><br><span class="line">vmlinux</span><br><span class="line">architecture: aarch64, flags 0x00000150:</span><br><span class="line">HAS_SYMS, DYNAMIC, D_PAGED</span><br><span class="line">start address 0xffffffc008000000</span><br><span class="line"></span><br><span class="line">Disassembly of section .head.text:</span><br><span class="line"></span><br><span class="line">ffffffc008000000 &lt;_text&gt;:</span><br><span class="line">ffffffc008000000:91005a4d addx13, x18, #0x16</span><br><span class="line">ffffffc008000004:146c7fff bffffffc009b20000 &lt;primary_entry&gt;</span><br></pre></td></tr></table></figure><p>由上面的反汇编文件可知，<code>Linux</code>内核的第一条指令是<code>add x13, x18, #0x16</code>，对应的符号是<code>.head.text</code>，在<code>include/linux/init.h</code>中有如下定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* For assembly routines */</span><br><span class="line">#define __HEAD.section&quot;.head.text&quot;,&quot;ax&quot;</span><br><span class="line">#define __INIT.section&quot;.init.text&quot;,&quot;ax&quot;</span><br></pre></td></tr></table></figure><p>即<code>__HEAD</code>这个宏代表的就是<code>.head.text</code>这个段，所以去寻找<code>__HEAD</code>这个宏看哪里使用了，在<code>arch/arm64/kernel/head.S</code>中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Kernel startup entry point.</span><br><span class="line"> * ---------------------------</span><br><span class="line"> *</span><br><span class="line"> * The requirements are:</span><br><span class="line"> *   MMU = off, D-cache = off, I-cache = on or off,</span><br><span class="line"> *   x0 = physical address to the FDT blob.</span><br><span class="line"> *</span><br><span class="line"> * This code is mostly position independent so you call this at</span><br><span class="line"> * __pa(PAGE_OFFSET).</span><br><span class="line"> *</span><br><span class="line"> * Note that the callee-saved registers are used for storing variables</span><br><span class="line"> * that are useful before the MMU is enabled. The allocations are described</span><br><span class="line"> * in the entry routines.</span><br><span class="line"> */</span><br><span class="line">__HEAD</span><br><span class="line">_head:</span><br><span class="line">/*</span><br><span class="line"> * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span><br><span class="line"> */</span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">/*</span><br><span class="line"> * This add instruction has no meaningful effect except that</span><br><span class="line"> * its opcode forms the magic &quot;MZ&quot; signature required by UEFI.</span><br><span class="line"> */</span><br><span class="line">addx13, x18, #0x16</span><br><span class="line">bprimary_entry</span><br><span class="line">#else</span><br><span class="line">bprimary_entry// branch to kernel start, magic</span><br><span class="line">.long0// reserved</span><br><span class="line">#endif</span><br><span class="line">.quad0// Image load offset from start of RAM, little-endian</span><br><span class="line">le64sym_kernel_size_le// Effective size of kernel image, little-endian</span><br><span class="line">le64sym_kernel_flags_le// Informative flags, little-endian</span><br><span class="line">.quad0// reserved</span><br><span class="line">.quad0// reserved</span><br><span class="line">.quad0// reserved</span><br><span class="line">.asciiARM64_IMAGE_MAGIC// Magic number</span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">.longpe_header - _head// Offset to the PE header.</span><br><span class="line"></span><br><span class="line">pe_header:</span><br><span class="line">__EFI_PE_HEADER</span><br><span class="line">#else</span><br><span class="line">.long0// reserved</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这里就是内核的启动点，在上面的注释中说了<code>linux</code>内核启动之前需要关闭<code>MMU</code>以及<code>D-cache</code>，<code>I-cache</code>可以开启或者关闭，同时<code>x0</code>为<code>FDT blob</code>的物理地址</p><ul><li><code>D-cache</code>是数据缓存</li><li><code>I-cache</code>是指令缓存</li><li><code>FDT </code>是<code>uboot</code>使用的扁平设备树，flatted device tree，</li></ul><blockquote><p>数据缓存有可能缓存了bootloader的数据，如果不清除，可能导致内核访问错误的数据。而bootloader的指令与内核指令无关，所以可以不关闭指令缓存。</p></blockquote><p><code>add x13, x18, #0x16</code> 用于形成 “MZ” 签名。主要是为了满足 UEFI 固件对映像文件格式的要求，而不是为了执行任何有意义的计算。其作用是确保生成的机器码包含必要的 “MZ” 签名，使得内核映像可以被 UEFI 识别和启动。相当于一个魔数。然后执行<code>bprimary_entry</code>跳转到<code>primary_entry</code>函数执行：</p><h3 id="2-2-primary-entry函数"><a href="#2-2-primary-entry函数" class="headerlink" title="2.2 primary_entry函数"></a>2.2 primary_entry函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__INIT</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The following callee saved general purpose registers are used on the</span><br><span class="line"> * primary lowlevel boot path:</span><br><span class="line"> *</span><br><span class="line"> *  Register   Scope                      Purpose</span><br><span class="line"> *  x21        primary_entry() .. start_kernel()        FDT pointer passed at boot in x0</span><br><span class="line"> *  x23        primary_entry() .. start_kernel()        physical misalignment/KASLR offset</span><br><span class="line"> *  x28        __create_page_tables()                   callee preserved temp register</span><br><span class="line"> *  x19/x20    __primary_switch()                       callee preserved temp registers</span><br><span class="line"> *  x24        __primary_switch() .. relocate_kernel()  current RELR displacement</span><br><span class="line"> */</span><br><span class="line">SYM_CODE_START(primary_entry)</span><br><span class="line">blpreserve_boot_args</span><br><span class="line">blinit_kernel_el// w0=cpu_boot_mode</span><br><span class="line">adrpx23, __PHYS_OFFSET</span><br><span class="line">andx23, x23, MIN_KIMG_ALIGN - 1// KASLR offset, defaults to 0</span><br><span class="line">blset_cpu_boot_mode_flag</span><br><span class="line">bl__create_page_tables</span><br><span class="line">/*</span><br><span class="line"> * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span><br><span class="line"> * details.</span><br><span class="line"> * On return, the CPU will be ready for the MMU to be turned on and</span><br><span class="line"> * the TCR will have been set.</span><br><span class="line"> */</span><br><span class="line">bl__cpu_setup// initialise processor</span><br><span class="line">b__primary_switch</span><br><span class="line">SYM_CODE_END(primary_entry)</span><br></pre></td></tr></table></figure><p><code>primary_entry</code>会依次执行<code>preserve_boot_args</code>、<code>init_kernel_el</code>、<code>set_cpu_boot_mode_flag</code>、<code>__create_page_tables</code>、<code>__cpu_setup</code>、<code>__primary_switch</code></p><h4 id="2-2-1-preserve-boot-args"><a href="#2-2-1-preserve-boot-args" class="headerlink" title="2.2.1 preserve_boot_args"></a>2.2.1 preserve_boot_args</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Preserve the arguments passed by the bootloader in x0 .. x3</span><br><span class="line"> */</span><br><span class="line">SYM_CODE_START_LOCAL(preserve_boot_args)</span><br><span class="line">movx21, x0// x21=FDT，// 将dtb的地址暂存在x21寄存器，释放出x0使用</span><br><span class="line"></span><br><span class="line">adr_lx0, boot_args// 将boot_args数组的地址保存到x0中</span><br><span class="line">stpx21, x1, [x0]// 保存x21、x1的值到boot_args[0]、boot_args[1]</span><br><span class="line">stpx2, x3, [x0, #16]       // 将x2、x3的值保存到boot_args[2]、boot_args[3</span><br><span class="line"></span><br><span class="line">dmbsy// needed before dc ivac with 内存屏障</span><br><span class="line">// MMU off</span><br><span class="line"></span><br><span class="line">movx1, #0x20// 4 x 8 bytes  x1 = 32</span><br><span class="line">b__inval_dcache_area// tail call 无效化数据缓存区域</span><br><span class="line">SYM_CODE_END(preserve_boot_args)</span><br></pre></td></tr></table></figure><ul><li><p><code>boot_args</code>定义在<code>arch/arm64/setup.c</code>中，用于保存内核启动时的参数，是一个数组</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The recorded values of x0 .. x3 upon kernel entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u64 __cacheline_aligned boot_args[<span class="number">4</span>];</span><br></pre></td></tr></table></figure></li><li><p><code>stp</code> 是一个存储配对指令，将两个寄存器的值存储到连续的内存位置。</p></li></ul><h4 id="2-2-2-init-kernel-el"><a href="#2-2-2-init-kernel-el" class="headerlink" title="2.2.2 init_kernel_el"></a>2.2.2 init_kernel_el</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Starting from EL2 or EL1, configure the CPU to execute at the highest</span><br><span class="line"> * reachable EL supported by the kernel in a chosen default state. If dropping</span><br><span class="line"> * from EL2 to EL1, configure EL2 before configuring EL1.</span><br><span class="line"> *</span><br><span class="line"> * Since we cannot always rely on ERET synchronizing writes to sysregs (e.g. if</span><br><span class="line"> * SCTLR_ELx.EOS is clear), we place an ISB prior to ERET.</span><br><span class="line"> *</span><br><span class="line"> * Returns either BOOT_CPU_MODE_EL1 or BOOT_CPU_MODE_EL2 in w0 if</span><br><span class="line"> * booted in EL1 or EL2 respectively.</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START(init_kernel_el)</span><br><span class="line">mov_qx0, INIT_SCTLR_EL1_MMU_OFF  #将 INIT_SCTLR_EL1_MMU_OFF 常量加载到寄存器 x0 中</span><br><span class="line">msrsctlr_el1, x0    #将寄存器 x0 的值写入 sctlr_el1 寄存器，配置 EL1 的系统控制寄存器。</span><br><span class="line"></span><br><span class="line">mrsx0, CurrentEL    # 读取当前的异常级别（EL）到寄存器 x0 中。</span><br><span class="line">cmpx0, #CurrentEL_EL2  #比较当前 EL 是否为 EL2。</span><br><span class="line">b.eqinit_el2      #如果当前EL是EL2，则跳转到 init_el2 标签。</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(init_el1, SYM_L_LOCAL)</span><br><span class="line">isb</span><br><span class="line">mov_qx0, INIT_PSTATE_EL1 #将INIT_PSTATE_EL1常量加载到寄存器x0中，这个常量用于初始化 PSTATE 寄存器。</span><br><span class="line">msrspsr_el1, x0#将寄存器x0的值写入spsr_el1寄存器，配置EL1的Saved Program Status Register。</span><br><span class="line">msrelr_el1, lr #将链接寄存器（lr）的值写入 elr_el1 寄存器，配置 EL1 的 Exception Link Register。</span><br><span class="line">movw0, #BOOT_CPU_MODE_EL1 #将 BOOT_CPU_MODE_EL1 常量加载到寄存器 w0 中，表示当前的 CPU 模式为 EL1。</span><br><span class="line">eret</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(init_el2, SYM_L_LOCAL)</span><br><span class="line">mov_qx0, HCR_HOST_NVHE_FLAGS #将 HCR_HOST_NVHE_FLAGS 常量加载到寄存器 x0 中，用于配置 EL2 的 Hypervisor Configuration Register。</span><br><span class="line">msrhcr_el2, x0 #将寄存器 x0 的值写入 hcr_el2 寄存器。</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">init_el2_state</span><br><span class="line"></span><br><span class="line">/* Hypervisor stub */</span><br><span class="line">adr_lx0, __hyp_stub_vectors #使用 adr_l 宏将 __hyp_stub_vectors 的地址加载到寄存器 x0 中。__hyp_stub_vectors 是 EL2 的异常向量表地址。</span><br><span class="line">msrvbar_el2, x0 #将寄存器 x0 的值写入 vbar_el2 寄存器，设置 EL2 的向量基址寄存器。</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">msrelr_el2, lr #将链接寄存器（lr）的值写入 elr_el2 寄存器，配置 EL2 的 Exception Link Register。</span><br><span class="line">movw0, #BOOT_CPU_MODE_EL2  #将 BOOT_CPU_MODE_EL2 常量加载到寄存器 w0 中，表示当前的 CPU 模式为 EL2。</span><br><span class="line">eret</span><br><span class="line">SYM_FUNC_END(init_kernel_el)</span><br><span class="line"></span><br><span class="line">//arch/arm64/include/asm/virt.h</span><br><span class="line">#define BOOT_CPU_MODE_EL1(0xe11)</span><br><span class="line">#define BOOT_CPU_MODE_EL2(0xe12)</span><br></pre></td></tr></table></figure><p>这段代码实现了在不同异常级别（EL2 或 EL1）下对处理器进行初始化，并根据当前的启动级别设置相应的寄存器和状态，以便内核能够正确执行。主要步骤包括：</p><ol><li><strong>配置 EL1 的系统控制寄存器</strong>。</li><li><strong>检查当前异常级别</strong>。</li><li><strong>如果是 EL1</strong><ul><li>配置 PSTATE 和异常链接寄存器。</li><li>切换到 EL1 并继续执行。</li></ul></li><li><strong>如果是 EL2</strong><ul><li>配置 Hypervisor Configuration Register。</li><li>进一步初始化 EL2 状态。</li><li>设置异常向量基址。</li><li>切换到 EL2 并继续执行</li></ul></li></ol><h4 id="2-2-3-set-cpu-boot-mode-flag"><a href="#2-2-3-set-cpu-boot-mode-flag" class="headerlink" title="2.2.3 set_cpu_boot_mode_flag"></a>2.2.3 set_cpu_boot_mode_flag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Sets the __boot_cpu_mode flag depending on the CPU boot mode passed</span><br><span class="line"> * in w0. See arch/arm64/include/asm/virt.h for more info.</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(set_cpu_boot_mode_flag)</span><br><span class="line">adr_lx1, __boot_cpu_mode #将 __boot_cpu_mode 的地址加载到寄存器 x1 中</span><br><span class="line">cmpw0, #BOOT_CPU_MODE_EL2  #如果为不为EL2则跳转到标签1处</span><br><span class="line">b.ne1f</span><br><span class="line">addx1, x1, #4  #如果 w0 中的值等于 BOOT_CPU_MODE_EL2，则将 x1（即 __boot_cpu_mode 的地址）加上 4，以指向下一个 4 字节对齐的位置。</span><br><span class="line">1:strw0, [x1]// 将寄存器 w0 的值存储到内存地址 x1 指向的位置</span><br><span class="line">dmbsy</span><br><span class="line">dcivac, x1// Invalidate potentially stale cache line</span><br><span class="line">ret</span><br><span class="line">SYM_FUNC_END(set_cpu_boot_mode_flag)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * We need to find out the CPU boot mode long after boot, so we need to</span><br><span class="line"> * store it in a writable variable.</span><br><span class="line"> *</span><br><span class="line"> * This is not in .bss, because we set it sufficiently early that the boot-time</span><br><span class="line"> * zeroing of .bss would clobber it.</span><br><span class="line"> */</span><br><span class="line">SYM_DATA_START(__boot_cpu_mode)</span><br><span class="line">.longBOOT_CPU_MODE_EL2</span><br><span class="line">.longBOOT_CPU_MODE_EL1</span><br><span class="line">SYM_DATA_END(__boot_cpu_mode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//arch/arm64/include/asm/virt.h</span><br><span class="line">#define BOOT_CPU_MODE_EL1(0xe11)</span><br><span class="line">#define BOOT_CPU_MODE_EL2(0xe12)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>w0</code>寄存器保存了cpu的启动模式</li><li><code>__boot_cpu_mode</code>是一个<code>int64</code>的全局变量保存cpu的启动模式，前面四个字节的值为<code>0xe11</code>，后面四个字节的值为<code>0xe12</code></li></ul><h4 id="2-2-4-create-page-tables"><a href="#2-2-4-create-page-tables" class="headerlink" title="2.2.4 __create_page_tables"></a>2.2.4 __create_page_tables</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Setup the initial page tables. We only setup the barest amount which is</span><br><span class="line"> * required to get the kernel running. The following sections are required:</span><br><span class="line"> *   - identity mapping to enable the MMU (low address, TTBR0)</span><br><span class="line"> *   - first few MB of the kernel linear mapping to jump to once the MMU has</span><br><span class="line"> *     been enabled</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(__create_page_tables)</span><br><span class="line">movx28, lr</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Invalidate the init page tables to avoid potential dirty cache lines</span><br><span class="line"> * being evicted. Other page tables are allocated in rodata as part of</span><br><span class="line"> * the kernel image, and thus are clean to the PoC per the boot</span><br><span class="line"> * protocol.</span><br><span class="line"> */</span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">adrpx1, init_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Clear the init page tables.</span><br><span class="line"> */</span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">adrpx1, init_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">1:stpxzr, xzr, [x0], #16</span><br><span class="line">stpxzr, xzr, [x0], #16</span><br><span class="line">stpxzr, xzr, [x0], #16</span><br><span class="line">stpxzr, xzr, [x0], #16</span><br><span class="line">subsx1, x1, #64</span><br><span class="line">b.ne1b</span><br><span class="line"></span><br><span class="line">movx7, SWAPPER_MM_MMUFLAGS</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Create the identity mapping.</span><br><span class="line"> */</span><br><span class="line">adrpx0, idmap_pg_dir</span><br><span class="line">adrpx3, __idmap_text_start// __pa(__idmap_text_start)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_VA_BITS_52</span><br><span class="line">mrs_sx6, SYS_ID_AA64MMFR2_EL1</span><br><span class="line">andx6, x6, #(0xf &lt;&lt; ID_AA64MMFR2_LVA_SHIFT)</span><br><span class="line">movx5, #52</span><br><span class="line">cbnzx6, 1f</span><br><span class="line">#endif</span><br><span class="line">movx5, #VA_BITS_MIN</span><br><span class="line">1:</span><br><span class="line">adr_lx6, vabits_actual</span><br><span class="line">strx5, [x6]</span><br><span class="line">dmbsy</span><br><span class="line">dcivac, x6// Invalidate potentially stale cache line</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * VA_BITS may be too small to allow for an ID mapping to be created</span><br><span class="line"> * that covers system RAM if that is located sufficiently high in the</span><br><span class="line"> * physical address space. So for the ID map, use an extended virtual</span><br><span class="line"> * range in that case, and configure an additional translation level</span><br><span class="line"> * if needed.</span><br><span class="line"> *</span><br><span class="line"> * Calculate the maximum allowed value for TCR_EL1.T0SZ so that the</span><br><span class="line"> * entire ID map region can be mapped. As T0SZ == (64 - #bits used),</span><br><span class="line"> * this number conveniently equals the number of leading zeroes in</span><br><span class="line"> * the physical address of __idmap_text_end.</span><br><span class="line"> */</span><br><span class="line">adrpx5, __idmap_text_end</span><br><span class="line">clzx5, x5</span><br><span class="line">cmpx5, TCR_T0SZ(VA_BITS_MIN) // default T0SZ small enough?</span><br><span class="line">b.ge1f// .. then skip VA range extension</span><br><span class="line"></span><br><span class="line">adr_lx6, idmap_t0sz</span><br><span class="line">strx5, [x6]</span><br><span class="line">dmbsy</span><br><span class="line">dcivac, x6// Invalidate potentially stale cache line</span><br><span class="line"></span><br><span class="line">#if (VA_BITS &lt; 48)</span><br><span class="line">#define EXTRA_SHIFT(PGDIR_SHIFT + PAGE_SHIFT - 3)</span><br><span class="line">#define EXTRA_PTRS(1 &lt;&lt; (PHYS_MASK_SHIFT - EXTRA_SHIFT))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * If VA_BITS &lt; 48, we have to configure an additional table level.</span><br><span class="line"> * First, we have to verify our assumption that the current value of</span><br><span class="line"> * VA_BITS was chosen such that all translation levels are fully</span><br><span class="line"> * utilised, and that lowering T0SZ will always result in an additional</span><br><span class="line"> * translation level to be configured.</span><br><span class="line"> */</span><br><span class="line">#if VA_BITS != EXTRA_SHIFT</span><br><span class="line">#error &quot;Mismatch between VA_BITS and page size/number of translation levels&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">movx4, EXTRA_PTRS</span><br><span class="line">create_table_entry x0, x3, EXTRA_SHIFT, x4, x5, x6</span><br><span class="line">#else</span><br><span class="line">/*</span><br><span class="line"> * If VA_BITS == 48, we don&#x27;t have to configure an additional</span><br><span class="line"> * translation level, but the top-level table has more entries.</span><br><span class="line"> */</span><br><span class="line">movx4, #1 &lt;&lt; (PHYS_MASK_SHIFT - PGDIR_SHIFT)</span><br><span class="line">str_lx4, idmap_ptrs_per_pgd, x5</span><br><span class="line">#endif</span><br><span class="line">1:</span><br><span class="line">ldr_lx4, idmap_ptrs_per_pgd</span><br><span class="line">movx5, x3// __pa(__idmap_text_start)</span><br><span class="line">adr_lx6, __idmap_text_end// __pa(__idmap_text_end)</span><br><span class="line"></span><br><span class="line">map_memory x0, x1, x3, x6, x7, x3, x4, x10, x11, x12, x13, x14</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Map the kernel image (starting with PHYS_OFFSET).</span><br><span class="line"> */</span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">mov_qx5, KIMAGE_VADDR// compile time __va(_text)</span><br><span class="line">addx5, x5, x23// add KASLR displacement</span><br><span class="line">movx4, PTRS_PER_PGD</span><br><span class="line">adrpx6, _end// runtime __pa(_end)</span><br><span class="line">adrpx3, _text// runtime __pa(_text)</span><br><span class="line">subx6, x6, x3// _end - _text</span><br><span class="line">addx6, x6, x5// runtime __va(_end)</span><br><span class="line"></span><br><span class="line">map_memory x0, x1, x5, x6, x7, x3, x4, x10, x11, x12, x13, x14</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Since the page tables have been populated with non-cacheable</span><br><span class="line"> * accesses (MMU disabled), invalidate those tables again to</span><br><span class="line"> * remove any speculatively loaded cache lines.</span><br><span class="line"> */</span><br><span class="line">dmbsy</span><br><span class="line"></span><br><span class="line">adrpx0, idmap_pg_dir</span><br><span class="line">adrpx1, idmap_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">adrpx1, init_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line">retx28</span><br><span class="line">SYM_FUNC_END(__create_page_tables)</span><br></pre></td></tr></table></figure><p>页表的映射比较复杂，后面再分析，主要是的功能时缓存无效化、页表清空、虚拟地址配置，然后把内核进行了映射。</p><h4 id="2-2-5-cpu-setup"><a href="#2-2-5-cpu-setup" class="headerlink" title="2.2.5 __cpu_setup"></a>2.2.5 __cpu_setup</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//arch/arm64/mm/proc.S</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *__cpu_setup</span><br><span class="line"> *</span><br><span class="line"> *Initialise the processor for turning the MMU on.</span><br><span class="line"> *</span><br><span class="line"> * Output:</span><br><span class="line"> *Return in x0 the value of the SCTLR_EL1 register.</span><br><span class="line"> */</span><br><span class="line">.pushsection &quot;.idmap.text&quot;, &quot;awx&quot;</span><br><span class="line">SYM_FUNC_START(__cpu_setup)</span><br><span class="line">tlbivmalle1// 通过 tlbi 指令无效化本地 TLB,刷新tlb，用于后续映射</span><br><span class="line">dsbnsh</span><br><span class="line"></span><br><span class="line">movx1, #3 &lt;&lt; 20</span><br><span class="line">msrcpacr_el1, x1// Enable FP/ASIMD</span><br><span class="line">movx1, #1 &lt;&lt; 12// Reset mdscr_el1 and disable</span><br><span class="line">msrmdscr_el1, x1// access to the DCC from EL0</span><br><span class="line">isb// Unmask debug exceptions now,</span><br><span class="line">enable_dbg// since this is per-cpu</span><br><span class="line">reset_pmuserenr_el0 x1// Disable PMU access from EL0</span><br><span class="line">reset_amuserenr_el0 x1// Disable AMU access from EL0</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Memory region attributes</span><br><span class="line"> */</span><br><span class="line">mov_qx5, MAIR_EL1_SET #内存属性配置值写入 MAIR_EL1 寄存器，设置内存区域的属性</span><br><span class="line">msrmair_el1, x5</span><br><span class="line">/*</span><br><span class="line"> * Set/prepare TCR and TTBR. TCR_EL1.T1SZ gets further</span><br><span class="line"> * adjusted if the kernel is compiled with 52bit VA support.</span><br><span class="line"> */</span><br><span class="line">mov_qx10, TCR_TxSZ(VA_BITS) | TCR_CACHE_FLAGS | TCR_SMP_FLAGS | \</span><br><span class="line">TCR_TG_FLAGS | TCR_KASLR_FLAGS | TCR_ASID16 | \</span><br><span class="line">TCR_TBI0 | TCR_A1 | TCR_KASAN_SW_FLAGS | TCR_MTE_FLAGS</span><br><span class="line"></span><br><span class="line">tcr_clear_errata_bits x10, x9, x5</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_VA_BITS_52</span><br><span class="line">ldr_lx9, vabits_actual</span><br><span class="line">subx9, xzr, x9</span><br><span class="line">addx9, x9, #64</span><br><span class="line">tcr_set_t1szx10, x9</span><br><span class="line">#else</span><br><span class="line">ldr_lx9, idmap_t0sz</span><br><span class="line">#endif</span><br><span class="line">tcr_set_t0szx10, x9</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set the IPS bits in TCR_EL1.</span><br><span class="line"> */</span><br><span class="line">tcr_compute_pa_size x10, #TCR_IPS_SHIFT, x5, x6</span><br><span class="line">#ifdef CONFIG_ARM64_HW_AFDBM</span><br><span class="line">/*</span><br><span class="line"> * Enable hardware update of the Access Flags bit.</span><br><span class="line"> * Hardware dirty bit management is enabled later,</span><br><span class="line"> * via capabilities.</span><br><span class="line"> */</span><br><span class="line">mrsx9, ID_AA64MMFR1_EL1</span><br><span class="line">andx9, x9, #0xf</span><br><span class="line">cbzx9, 1f</span><br><span class="line">orrx10, x10, #TCR_HA// hardware Access flag update</span><br><span class="line">1:</span><br><span class="line">#endif/* CONFIG_ARM64_HW_AFDBM */</span><br><span class="line">msrtcr_el1, x10</span><br><span class="line">/*</span><br><span class="line"> * Prepare SCTLR</span><br><span class="line"> */</span><br><span class="line">mov_qx0, INIT_SCTLR_EL1_MMU_ON</span><br><span class="line">ret// return to head.S</span><br><span class="line">SYM_FUNC_END(__cpu_setup)</span><br></pre></td></tr></table></figure><p><code>__cpu_setup</code>定义在<code>arch/arm64/mm/proc.S</code>中，这段代码通过一系列步骤初始化处理器，以便安全地开启内存管理单元（MMU）。主要步骤包括：</p><ol><li>无效化本地 TLB</li><li>启用浮点和 SIMD 单元</li><li>设置调试寄存器</li><li>配置内存属性寄存器</li><li>配置翻译控制寄存器和基址寄存器</li><li>设置物理地址大小和硬件访问标志</li><li>准备系统控制寄存器并返回</li></ol><p>这些步骤确保处理器在启用 MMU 时能正确处理内存访问和管理</p><h4 id="2-2-6-primary-switch"><a href="#2-2-6-primary-switch" class="headerlink" title="2.2.6 __primary_switch"></a>2.2.6 __primary_switch</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SYM_FUNC_START_LOCAL(__primary_switch)</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">movx19, x0// preserve new SCTLR_EL1 value</span><br><span class="line">mrsx20, sctlr_el1// preserve old SCTLR_EL1 value</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">adrpx1, init_pg_dir</span><br><span class="line">bl__enable_mmu</span><br><span class="line">#ifdef CONFIG_RELOCATABLE</span><br><span class="line">#ifdef CONFIG_RELR</span><br><span class="line">movx24, #0// no RELR displacement yet</span><br><span class="line">#endif</span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">blrx8</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * If we return here, we have a KASLR displacement in x23 which we need</span><br><span class="line"> * to take into account by discarding the current kernel mapping and</span><br><span class="line"> * creating a new one.</span><br><span class="line"> */</span><br><span class="line">pre_disable_mmu_workaround</span><br><span class="line">msrsctlr_el1, x20// disable the MMU</span><br><span class="line">isb</span><br><span class="line">bl__create_page_tables// recreate kernel mapping</span><br><span class="line"></span><br><span class="line">tlbivmalle1// Remove any stale TLB entries</span><br><span class="line">dsbnsh</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">set_sctlr_el1x19// re-enable the MMU</span><br><span class="line"></span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">brx8</span><br><span class="line">SYM_FUNC_END(__primary_switch)</span><br></pre></td></tr></table></figure><p>这段代码主要是用于内核映射的重定位，如果内核地址需要重定位则需要查询页表进行重新映射，然后在最后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">brx8</span><br></pre></td></tr></table></figure><p>跳转到<code>__primary_switched</code>函数继续执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following fragment of code is executed with the MMU enabled.</span><br><span class="line"> *</span><br><span class="line"> *   x0 = __PHYS_OFFSET</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(__primary_switched)</span><br><span class="line">adrpx4, init_thread_union</span><br><span class="line">addsp, x4, #THREAD_SIZE</span><br><span class="line">adr_lx5, init_task</span><br><span class="line">msrsp_el0, x5// Save thread_info</span><br><span class="line"></span><br><span class="line">adr_lx8, vectors// load VBAR_EL1 with virtual</span><br><span class="line">msrvbar_el1, x8// vector table address</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">stpxzr, x30, [sp, #-16]!</span><br><span class="line">movx29, sp</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SHADOW_CALL_STACK</span><br><span class="line">adr_lscs_sp, init_shadow_call_stack// Set shadow call stack</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">str_lx21, __fdt_pointer, x5// Save FDT pointer</span><br><span class="line"></span><br><span class="line">ldr_lx4, kimage_vaddr// Save the offset between</span><br><span class="line">subx4, x4, x0// the kernel virtual and</span><br><span class="line">str_lx4, kimage_voffset, x5// physical mappings</span><br><span class="line"></span><br><span class="line">// Clear BSS</span><br><span class="line">adr_lx0, __bss_start</span><br><span class="line">movx1, xzr</span><br><span class="line">adr_lx2, __bss_stop</span><br><span class="line">subx2, x2, x0</span><br><span class="line">bl__pi_memset</span><br><span class="line">dsbishst// Make zero page visible to PTW</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)</span><br><span class="line">blkasan_early_init</span><br><span class="line">#endif</span><br><span class="line">movx0, x21// pass FDT address in x0</span><br><span class="line">blearly_fdt_map// Try mapping the FDT early</span><br><span class="line">blinit_feature_override// Parse cpu feature overrides</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">tstx23, ~(MIN_KIMG_ALIGN - 1)// already running randomized?</span><br><span class="line">b.ne0f</span><br><span class="line">blkaslr_early_init// parse FDT for KASLR options</span><br><span class="line">cbzx0, 0f// KASLR disabled? just proceed</span><br><span class="line">orrx23, x23, x0// record KASLR offset</span><br><span class="line">ldpx29, x30, [sp], #16// we must enable KASLR, return</span><br><span class="line">ret// to __primary_switch()</span><br><span class="line">0:</span><br><span class="line">#endif</span><br><span class="line">blswitch_to_vhe// Prefer VHE if possible</span><br><span class="line">addsp, sp, #16</span><br><span class="line">movx29, #0</span><br><span class="line">movx30, #0</span><br><span class="line">bstart_kernel</span><br><span class="line">SYM_FUNC_END(__primary_switched)</span><br></pre></td></tr></table></figure><p>此函数在启用 MMU 后执行，负责初始化各种系统寄存器和数据结构，清空 BSS 段，处理设备树和特性覆盖，并根据需要处理内核地址空间布局随机化（KASLR）。最后，它跳转到 <code>start_kernel</code> 函数，开始内核的主要启动过程。</p><h2 id="3-内核启动第二阶段"><a href="#3-内核启动第二阶段" class="headerlink" title="3. 内核启动第二阶段"></a>3. 内核启动第二阶段</h2><p>Linux内核启动的第二阶段也就是常说的C语言阶段，从start_kernel()函数开始；start_kernel()函数是所有Linux平台进入系统内核初始化后的入口函数；主要完成剩余的与硬件平台相关的初始化工作，这些初始化操作，有的是公共的，有的是需要配置才会执行的；内核工作需要的模块的初始化依次被调用，如：内存管理、调度系统、异常处理等；</p><h3 id="3-1-start-kernel"><a href="#3-1-start-kernel" class="headerlink" title="3.1 start_kernel"></a>3.1 start_kernel</h3><p>start_kernel()函数在init&#x2F;main.c文件中，主要完成Linux子系统的初始化工作；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">casmlinkage __visible <span class="type">void</span> __init __no_sanitize_address <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *command_line;</span><br><span class="line"><span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">smp_setup_processor_id();</span><br><span class="line">debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">cgroup_init_early();</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line">early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts are still disabled. Do necessary setups, then</span></span><br><span class="line"><span class="comment"> * enable them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">boot_cpu_init();</span><br><span class="line">page_address_init();</span><br><span class="line">pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);</span><br><span class="line">early_security_init();</span><br><span class="line">setup_arch(&amp;command_line);</span><br><span class="line">setup_boot_config(command_line);</span><br><span class="line">setup_command_line(command_line);</span><br><span class="line">setup_nr_cpu_ids();</span><br><span class="line">setup_per_cpu_areas();</span><br><span class="line">smp_prepare_boot_cpu();<span class="comment">/* arch-specific boot-cpu hooks */</span></span><br><span class="line">boot_cpu_hotplug_init();</span><br><span class="line"></span><br><span class="line">build_all_zonelists(<span class="literal">NULL</span>);</span><br><span class="line">page_alloc_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_ROCKCHIP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *s = saved_command_line;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *e = &amp;saved_command_line[<span class="built_in">strlen</span>(saved_command_line)];</span><br><span class="line"><span class="type">int</span> n =</span><br><span class="line">    pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, saved_command_line);</span><br><span class="line">n -= <span class="built_in">strlen</span>(<span class="string">&quot;Kernel command line: &quot;</span>);</span><br><span class="line">s += n;</span><br><span class="line"><span class="comment">/* command line maybe too long to print one time */</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; s &lt; e) &#123;</span><br><span class="line">n = pr_cont(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">s += n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, saved_command_line);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* parameters may set static keys */</span></span><br><span class="line">jump_label_init();</span><br><span class="line">parse_early_param();</span><br><span class="line">after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">  static_command_line, __start___param,</span><br><span class="line">  __stop___param - __start___param,</span><br><span class="line">  <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, &amp;unknown_bootoption);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">parse_args(<span class="string">&quot;Setting init args&quot;</span>, after_dashes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">   <span class="literal">NULL</span>, set_init_arg);</span><br><span class="line"><span class="keyword">if</span> (extra_init_args)</span><br><span class="line">parse_args(<span class="string">&quot;Setting extra init args&quot;</span>, extra_init_args,</span><br><span class="line">   <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, set_init_arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment"> * kmem_cache_init()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup_log_buf(<span class="number">0</span>);</span><br><span class="line">vfs_caches_init_early();</span><br><span class="line">sort_main_extable();</span><br><span class="line">trap_init();</span><br><span class="line">mm_init();</span><br><span class="line">poking_init();</span><br><span class="line">ftrace_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* trace_printk can be enabled here */</span></span><br><span class="line">early_trace_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the scheduler prior starting any interrupts (such as the</span></span><br><span class="line"><span class="comment"> * timer interrupt). Full topology setup happens at smp_init()</span></span><br><span class="line"><span class="comment"> * time - but meanwhile we still have a functioning scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sched_init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN(!irqs_disabled(),</span><br><span class="line"> <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line">local_irq_disable();</span><br><span class="line">radix_tree_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up housekeeping before setting up workqueues to allow the unbound</span></span><br><span class="line"><span class="comment"> * workqueue to take non-housekeeping into account.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">housekeeping_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allow workqueue creation and work item queueing/cancelling</span></span><br><span class="line"><span class="comment"> * early.  Work item execution depends on kthreads and starts after</span></span><br><span class="line"><span class="comment"> * workqueue_init().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">workqueue_init_early();</span><br><span class="line"></span><br><span class="line">rcu_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Trace events are available after this */</span></span><br><span class="line">trace_init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (initcall_debug)</span><br><span class="line">initcall_debug_enable();</span><br><span class="line"></span><br><span class="line">context_tracking_init();</span><br><span class="line"><span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">early_irq_init();</span><br><span class="line">init_IRQ();</span><br><span class="line">tick_init();</span><br><span class="line">rcu_init_nohz();</span><br><span class="line">init_timers();</span><br><span class="line">hrtimers_init();</span><br><span class="line">softirq_init();</span><br><span class="line">timekeeping_init();</span><br><span class="line">kfence_init();</span><br><span class="line">time_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For best initial stack canary entropy, prepare it after:</span></span><br><span class="line"><span class="comment"> * - setup_arch() for any UEFI RNG entropy and boot cmdline access</span></span><br><span class="line"><span class="comment"> * - timekeeping_init() for ktime entropy used in random_init()</span></span><br><span class="line"><span class="comment"> * - time_init() for making random_get_entropy() work on some platforms</span></span><br><span class="line"><span class="comment"> * - random_init() to initialize the RNG from from early entropy sources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">random_init(command_line);</span><br><span class="line">boot_init_stack_canary();</span><br><span class="line"></span><br><span class="line">perf_event_init();</span><br><span class="line">profile_init();</span><br><span class="line">call_function_init();</span><br><span class="line">WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line">kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HACK ALERT! This is early. We&#x27;re enabling the console before</span></span><br><span class="line"><span class="comment"> * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span></span><br><span class="line"><span class="comment"> * this. But we do want output early, in case something goes wrong.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">console_init();</span><br><span class="line"><span class="keyword">if</span> (panic_later)</span><br><span class="line">panic(<span class="string">&quot;Too many boot %s vars at `%s&#x27;&quot;</span>, panic_later,</span><br><span class="line">      panic_param);</span><br><span class="line"></span><br><span class="line">lockdep_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Need to run this when irqs are enabled, because it wants</span></span><br><span class="line"><span class="comment"> * to self-test [hard/soft]-irqs on/off lock inversion bugs</span></span><br><span class="line"><span class="comment"> * too:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">locking_selftest();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line"><span class="keyword">if</span> (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">pr_crit(<span class="string">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;</span>,</span><br><span class="line">    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)),</span><br><span class="line">    min_low_pfn);</span><br><span class="line">initrd_start = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">setup_per_cpu_pageset();</span><br><span class="line">numa_policy_init();</span><br><span class="line">acpi_early_init();</span><br><span class="line"><span class="keyword">if</span> (late_time_init)</span><br><span class="line">late_time_init();</span><br><span class="line">sched_clock_init();</span><br><span class="line">calibrate_delay();</span><br><span class="line"></span><br><span class="line">arch_cpu_finalize_init();</span><br><span class="line"></span><br><span class="line">pid_idr_init();</span><br><span class="line">anon_vma_init();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line"><span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">efi_enter_virtual_mode();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">thread_stack_cache_init();</span><br><span class="line">cred_init();</span><br><span class="line">fork_init();</span><br><span class="line">proc_caches_init();</span><br><span class="line">uts_ns_init();</span><br><span class="line">buffer_init();</span><br><span class="line">key_init();</span><br><span class="line">security_init();</span><br><span class="line">dbg_late_init();</span><br><span class="line">vfs_caches_init();</span><br><span class="line">pagecache_init();</span><br><span class="line">signals_init();</span><br><span class="line">seq_file_init();</span><br><span class="line">proc_root_init();</span><br><span class="line">nsfs_init();</span><br><span class="line">cpuset_init();</span><br><span class="line">cgroup_init();</span><br><span class="line">taskstats_init_early();</span><br><span class="line">delayacct_init();</span><br><span class="line"></span><br><span class="line">acpi_subsystem_init();</span><br><span class="line">arch_post_acpi_subsys_init();</span><br><span class="line">sfi_init_late();</span><br><span class="line">kcsan_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">arch_call_rest_init();</span><br><span class="line"></span><br><span class="line">prevent_tail_call_optimization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见依次调用了很多的初始化函数</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://mshrimp.github.io/2020/04/19/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EARM64/">Linux内核启动流程-基于ARM64 | Mshrimp blog</a></li><li><a href="https://b2qtatgfkp.feishu.cn/docx/CttXdvBEuomVmmxQcw5cqh5jnJg">05 Linux 内核 - 飞书云文档 (feishu.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> ARM64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核中同步机制的底层实现</title>
      <link href="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核同步机制剖析"><a href="#Linux内核同步机制剖析" class="headerlink" title="Linux内核同步机制剖析"></a>Linux内核同步机制剖析</h1><p>在Linux内核中提供了四种处理并发和竞争的方法，分别是原子操作、自旋锁、信号量、互斥量，事先说明下我使用的<code>linux</code>内核为版本为<code>4.19.232</code></p><h2 id="1-原子变量"><a href="#1-原子变量" class="headerlink" title="1. 原子变量"></a>1. 原子变量</h2><p>在了解原子变量在linux内核中是如何实现之前，建议先了解以下<code>SMP</code>系统和<code>UP</code>系统的不同，然后学习以下<code>cache</code>一致性相关知识，这里给出一个参考链接</p><blockquote><p><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#cpu-cache-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">2.4 CPU 缓存一致性 | 小林coding (xiaolincoding.com)</a></p></blockquote><p>原子操作又可以进一步细分为“整型原子操作”和“位原子操作”，这里首先对<strong>整型原子操作</strong>进行讲解。在 Linux 内核中使用 <code>atomic_t</code> 和<code> atomic64_t</code> 结构体分别来完成 32 位系统和 64 位系统的整形数据原子操作，两个结构体定义在内核源码<code>/include/linux/types.h</code>文件中，具体定义如下：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508114202431.png" alt="image-20240508114202431"></p><p>对整型原子变量的操作有以下一些函数，定义在内核源码的<code>/include/linux/atomic.h</code>中，</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>ATOMIC_INIT(int i)</code></td><td>定义原子变量的时候对其初始化，赋值为 i</td></tr><tr><td><code>int atomic_read(atomic_t *v)</code></td><td>读取 v 的值，并且返回。</td></tr><tr><td><code>void atomic_set(atomic_t *v, int i)</code></td><td>向原子变量 v 写入 i 值。</td></tr><tr><td><code>void atomic_add(int i, atomic_t *v)</code></td><td>原子变量 v 加上 i 值。</td></tr><tr><td><code>void atomic_sub(int i, atomic_t *v)</code></td><td>原子变量 v 减去 i 值。</td></tr><tr><td><code>void atomic_inc(atomic_t *v)</code></td><td>原子变量 v 加 1</td></tr><tr><td><code>void atomic_dec(atomic_t *v)</code></td><td>原子变量 v 减 1</td></tr><tr><td><code>int atomic_dec_return(atomic_t *v)</code></td><td>原子变量 v 减 1，并返回 v 的值。</td></tr><tr><td><code>int atomic_inc_return(atomic_t *v)</code></td><td>原子变量 v 加 1，并返回 v 的值。</td></tr><tr><td><code>int atomic_sub_and_test(int i, atomic_t *v)</code></td><td>原子变量 v 减 i，如果结果为 0 就返回真，否则返回假</td></tr><tr><td><code>int atomic_dec_and_test(atomic_t *v)</code></td><td>原子变量 v 减 1，如果结果为 0 就返回真，否则返回假</td></tr><tr><td><code>int atomic_inc_and_test(atomic_t *v)</code></td><td>原子变量 v 加 1，如果结果为 0 就返回真，否则返回假</td></tr><tr><td><code>int atomic_add_negative(int i, atomic_t *v)</code></td><td>原子变量 v 加 i，如果结果为负就返回真，否则返回假</td></tr></tbody></table><p>对原子位操作的函数有如下，和原子整形变量不同，原子位操作没有 <code>atomic_t </code>的数据结构，原子位操作是直接对内存进行操作</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>void set_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位置 1</td></tr><tr><td><code>void clear_bit(int nr,void *p)</code></td><td>将 p 地址的第 nr 位清零</td></tr><tr><td><code>void change_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位进行翻转</td></tr><tr><td><code>int test_bit(int nr, void *p)</code></td><td>获取 p 地址的第 nr 位的值</td></tr><tr><td><code>int test_and_set_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值</td></tr><tr><td><code>int test_and_clear_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位清零，并且返回 nr 位原来的值</td></tr><tr><td><code>int test_and_change_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值</td></tr></tbody></table><p>我们以原子变量加操作的源码来分析，原子变量的操作在不同体系架构下是不同的，假设我现在定义一个原子变量，然后对其执行加操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> v = ATOMIC_INIT(<span class="number">1</span>);<span class="comment">//初始化原子类型变量 v,并设置为 1</span></span><br><span class="line"><span class="type">atomic_inc</span>(v);   <span class="comment">//将原子变量+1</span></span><br></pre></td></tr></table></figure><p><code>atomic_inc</code>这个宏定义在<code>linux/atomic.h</code>中：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508223825378.png" alt="image-20240508223825378"></p><p>可以看见<code>atomic_inc</code>实际上会去调用<code>atomic_add</code>来使得原子变量加一，<code>atomic_add</code>是一个和体系架构相关的宏函数，我们以<code>x86</code>平台和<code>arm</code>平台为例子，对于<code>linux/atomic.h</code>这个文件无论哪种架构都会去包含<code>\#include &lt;asm/atomic.h&gt;</code>这个头文件，不同的架构这个头文件内容是不一样的。</p><h3 id="1-1-X86平台原子操作的底层实现"><a href="#1-1-X86平台原子操作的底层实现" class="headerlink" title="1.1 X86平台原子操作的底层实现"></a>1.1 X86平台原子操作的底层实现</h3><p>我们首先来分析<code>x86</code>架构，<code>&lt;asm/atomic.h&gt;</code>这个头文件位于<code>arch/x86/include/asm/atomic.h</code>，在这个文件的最底部包含了一个头文件：<code>&lt;asm-generic/atomic-instrumented.h&gt;</code></p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508225051741.png" alt="image-20240508225051741"></p><p>在<code>&lt;asm-generic/atomic-instrumented.h&gt;</code>中定义了和<code>x86</code>架构下原子变量操作的函数</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508225142115.png" alt="image-20240508225142115"></p><p>例如<code>atomic_add</code>会去调用<code>arch_atomic_add</code>，而<code>arch_atomic_add</code>就定义在<code>arch/x86/include/asm/atomic.h</code>中：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508225332327.png" alt="image-20240508225332327"></p><p><code>arch_atomic_add</code>这个函数内部做的操作就是原子变量加一，它是如何做的呢，先来看<code>LOCK_PREFIX</code>这个宏，定义在<code>arch/x86/include/asm/alternative-asm.h</code>中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">.macro LOCK_PREFIX</span><br><span class="line"><span class="number">672</span>:lock</span><br><span class="line">.pushsection .smp_locks,<span class="string">&quot;a&quot;</span></span><br><span class="line">.balign <span class="number">4</span></span><br><span class="line">.<span class="type">long</span> <span class="number">672b</span> - .</span><br><span class="line">.popsection</span><br><span class="line">.endm</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">.macro LOCK_PREFIX</span><br><span class="line">.endm</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看见只有在<code>SMP</code>系统下此宏才会被定义，在<code>SMP</code>系统下涉及到多核之间的<code>cache</code>数据同步与竞争关系，此时才会去定义这个宏，在不是<code>SMP</code>的系统下此宏为空，即单核情况下，这个宏为空，在单核情况下，上面的<code>arch_atomic_add</code>函数就变成了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;addl %1,%0&quot;</span></span></span><br><span class="line"><span class="params">     : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span><br><span class="line"><span class="params">     : <span class="string">&quot;ir&quot;</span> (i) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>addl</code>指令用于执行32位整数加法操作，<code>%1</code>代表i这个参数，<code>%0</code>代表<code>v-&gt;vounter</code>这个参数，<code>addl</code>指令有三个步骤</p><ul><li><strong>取值</strong>：汇编指令首先从 <code>%1</code>（即 <code>i</code>）获取一个整数值。</li><li><strong>加法运算</strong>：将从 <code>%1</code> 取得的值加到 <code>%0</code>（即 <code>v-&gt;counter</code> 内存位置的当前值）上。</li><li><strong>存储结果</strong>：将加法的结果写回 <code>%0</code>，也就是更新 <code>v-&gt;counter</code> 的值。</li></ul></li><li><p>而这三个步骤在单核情况下就是一条<code>addl</code>指令，在单核情况下是原子的，<code>addl</code>在执行时不会被打断</p></li></ul><p>在<code>SMP</code>系统下，由于每个核心都有自己的<code>cache</code>，因此通过锁总线的方式来保证<code>addl</code>指令在多核情况下对同一块内存的操作是一个cpu独占的，在读写完成后再通过<code>cache</code>一致性协议同步，上面这个<code>LOCK_PREFIX</code>宏定义了一些前缀，具体什么意思可以参照下面这个博客，总之就是使用<code>lock</code>指令进行了锁总线的操作，从而实现<code>addl</code>指令在多核情况下的原子性</p><blockquote><p><a href="https://blog.csdn.net/ture010love/article/details/7663008">Linux 内核 LOCK_PREFIX 的含义-CSDN博客</a></p></blockquote><h3 id="1-2-ARM架构的原子操作底层实现"><a href="#1-2-ARM架构的原子操作底层实现" class="headerlink" title="1.2 ARM架构的原子操作底层实现"></a>1.2 ARM架构的原子操作底层实现</h3><p><code>arm</code>架构会有一些不同，<code>ARMv3</code>至<code>ARMv7</code>支持32位寻址空间。<code>ARMv8-A</code>开始支持64位寻址空间，32位的<code>arm</code>架构和64位的<code>arm</code>架构在实现原子操作时是存在一些指令上的不同的。在<code>ARMv8.1</code>之前，为实现原子操作采用的方法主要是<code>LL/SC(Load-Link/Store-Conditional)</code>。ARMv7中实现<code>LL/SC</code>的指令是<code>LDREX/STREX</code>，其实就是比基础的<code>LDR</code>和<code>STR</code>指令多了一个”EX”，”EX”表示exclusive（独占）。具体说来就是，当用<code>LDREX</code>指令从内存某个地址取出数据放到寄存器后，一个硬件的<code>monitor</code>会将此地址标记为<code>exclusive</code>。</p><h4 id="1-2-1-ARM32原子操作"><a href="#1-2-1-ARM32原子操作" class="headerlink" title="1.2.1 ARM32原子操作"></a>1.2.1 ARM32原子操作</h4><p>我们先来看<code>ARMV7</code>是如何做的，还是以<code>atomic_add</code>这个宏为例子，<code>ARMV7</code>及以前的代码是放在<code>arch/arm</code>目录下，我们去<code>arch/arm/include/asm/atomic.h</code>中查找：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509135911099.png" alt="image-20240509135911099"></p><p>在此文件中首先定义了一个宏<code>__LINUX_ARM_ARCH__</code>如果<code>ARM</code>的架构版本大于等于6则说明是支持SMP系统的，如果<code>ARM</code>架构的版本小于<code>ARMV7</code>说明是不支持SMP系统的，多核情况下支持锁内存这样的指令，而单核情况下是不支持的，因此原子操作实际上是通过关闭中断来实现的</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509140147787.png" alt="image-20240509140147787"></p><p>在此文件的下半部分定义了一些宏：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509140456071.png" alt="image-20240509140456071"></p><p><code>ATOMIC_OPS</code>这个宏展开后会去依次调用<code>ATOMIC_OP</code>，<code>ATOMIC_OP_RETURN</code>，<code>ATOMIC_FETCH_OP</code>，在上面的代码中调用了<code>ATOMIC_OPS(add, +=, add)</code>，就相当于：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ATOMIC_OP(add, += , add)</span><br><span class="line">ATOMIC_OP(add, += , add)</span><br><span class="line">ATOMIC_FETCH_OP(op, c_op, asm_op)</span><br></pre></td></tr></table></figure><p>这三个宏都是在上面定义的，以SMP系统下的<code>ATOMIC_OP</code>为例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ARMv6 UP and SMP safe atomic ops.  We use load exclusive and</span></span><br><span class="line"><span class="comment"> * store exclusive to ensure that these are atomic.  We may loop</span></span><br><span class="line"><span class="comment"> * to ensure that the update happens.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, c_op, asm_op)\</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">unsigned long tmp;\</span></span><br><span class="line"><span class="meta">int result;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">prefetchw(&amp;v-&gt;counter);\</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;@ atomic_&quot;</span> #op <span class="string">&quot;\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;1:ldrex%0, [%3]\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;&quot;</span> #asm_op <span class="string">&quot;%0, %0, %4\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;strex%1, %0, [%3]\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;teq%1, #0\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bne1b&quot;</span>\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;=&amp;r&quot;</span> (result), <span class="string">&quot;=&amp;r&quot;</span> (tmp), <span class="string">&quot;+Qo&quot;</span> (v-&gt;counter)\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;r&quot;</span> (&amp;v-&gt;counter), <span class="string">&quot;Ir&quot;</span> (i)\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;cc&quot;</span>);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>展开后这个宏函数的名字就变成了，可以看见就是我们需要的<code>atomic_add</code>函数，其余的宏展开后同理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp;\</span><br><span class="line"><span class="type">int</span> result;\</span><br><span class="line">\</span><br><span class="line">prefetchw(&amp;v-&gt;counter);\</span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;@ atomic_add&quot;</span>\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">1</span>:ldrex%<span class="number">0</span>, [%<span class="number">3</span>]\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>add%<span class="number">0</span>, %<span class="number">0</span>, %<span class="number">4</span>\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>strex%<span class="number">1</span>, %<span class="number">0</span>, [%<span class="number">3</span>]\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>teq%<span class="number">1</span>, #<span class="number">0</span>\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>bne<span class="number">1b</span><span class="string">&quot;\</span></span><br><span class="line"><span class="string">: &quot;</span>=&amp;r<span class="string">&quot; (result), &quot;</span>=&amp;r<span class="string">&quot; (tmp), &quot;</span>+Qo<span class="string">&quot; (v-&gt;counter)\</span></span><br><span class="line"><span class="string">: &quot;</span>r<span class="string">&quot; (&amp;v-&gt;counter), &quot;</span>Ir<span class="string">&quot; (i)\</span></span><br><span class="line"><span class="string">: &quot;</span>cc<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>unsigned long tmp;</code> 和 <code>int result;</code> 定义了两个变量，分别用于存储临时数据和操作结果。</p></li><li><p><code>prefetchw(&amp;v-&gt;counter);</code> 用于预取 <code>v-&gt;counter</code> 的写操作，这可能帮助提高性能。</p></li><li><p>定义了一个内联汇编块，用于实现原子操作。</p><ul><li><code>&quot;@ atomic_&quot; #op &quot;\n&quot;</code> 是一个注释，标识了操作类型。</li><li><code>&quot;ldrex %0, [%3]\n&quot;</code> 使用 <code>ldrex</code> 指令加载 <code>v-&gt;counter</code> 的值到 <code>result</code>，这是一个独占读取。</li><li><code>&quot;#asm_op %0, %0, %4\n&quot;</code> 执行指定的操作，如 <code>add</code>，结果存回 <code>result</code>。</li><li><code>&quot;strex %1, %0, [%3]\n&quot;</code> 使用 <code>strex</code> 尝试将 <code>result</code> 的新值存回 <code>v-&gt;counter</code>。如果在此期间 <code>v-&gt;counter</code> 被其他处理器修改过，则 <code>strex</code> 返回非零值。</li><li><code>&quot;teq %1, #0\n&quot;</code> 测试 <code>strex</code> 的结果是否为 0（表示成功）。</li><li><code>&quot;bne 1b&quot;</code> 如果 <code>strex</code> 失败（<code>tmp</code> 不为 0），则跳回标签 <code>1</code> 重新执行。</li></ul></li><li><p><code>&quot;+Qo&quot; (v-&gt;counter)</code> 表示 <code>v-&gt;counter</code> 是一个输入输出操作数（既被读也被写）。</p></li><li><p><code>&quot;r&quot; (&amp;v-&gt;counter)</code> 和 <code>&quot;Ir&quot; (i)</code> 分别传入 <code>v-&gt;counter</code> 的地址和整数 <code>i</code> 作为输入。</p></li><li><p><code>&quot;cc&quot;</code> 表示这段代码会修改条件寄存器。</p></li></ul><p>这段汇编代码的逻辑如下图所示：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/barriers-12a.png" alt="barriers-12a"></p><p>假设CPU A先进行load操作，并标记了变量v所在的内存地址为exclusive，在CPU A进行下一步的store操作之前，CPU B也进行了对变量v的load操作，那么这个内存地址的exclusive就成了CPU B标记的了。之后CPU A使用STREX进行store操作，它会测试store的目标地址的exclusive是不是自己标记的（是否为自己独占），结果不是，那么store失败。接下来CPU B也执行STREX，因为exclusive是自己标记的，所以可以store成功，exclusive标记也同步失效。此时CPU A会再次尝试一轮LL&#x2F;SC的操作，直到store成功。</p><p>而对于非SMP系统即单核系统：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, c_op, asm_op)\</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">unsigned long flags;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">raw_local_irq_save(flags);\</span></span><br><span class="line"><span class="meta">v-&gt;counter c_op i;\</span></span><br><span class="line"><span class="meta">raw_local_irq_restore(flags);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>可以看见直接使用开关中断的方式来实现</li></ul><h4 id="1-2-2-ARM64原子操作"><a href="#1-2-2-ARM64原子操作" class="headerlink" title="1.2.2 ARM64原子操作"></a>1.2.2 ARM64原子操作</h4><p><code>ARM64</code>原子操作相关的代码定义在<code>arch/arm64/include/atomic.h</code>，在此文件的开头有一个包含头文件的操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM64_LSE_ATOMICS) &amp;&amp; defined(CONFIG_AS_LSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/atomic_lse.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/atomic_ll_sc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>CONFIG_ARM64_LSE_ATOMICS</code>这个宏是在 ARMv8.1 架构中引入的一组增强的原子操作（LSE，Large System Extensions），这些操作提供了更高效的原子指令支持。</li><li><code>CONFIG_AS_LSE</code> 可能表示汇编器支持 <code>LSE</code> 指令集。</li><li>因此如果是<code>ARMv8.1</code>架构以后的使用的是<code>&lt;asm/atomic_lse.h&gt;</code>这个头文件，<code>ARMv8.1</code>以前大于<code>ARMV7</code>的使用的是<code>&lt;asm/atomic_ll_sc.h&gt;</code>头文件</li></ul><p>我们先来看<code>&lt;asm/atomic_ll_sc.h&gt;</code>文件即不支持<code>LSE</code>的原子操作是如何实现的：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509142531497.png" alt="image-20240509142531497"></p><p>和<code>ARMV7</code>一样调用<code>ATOMIC_OPS(and, and, )</code>，</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509142631493.png" alt="image-20240509142631493"></p><p>展开后变成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, asm_op, constraint)\</span></span><br><span class="line"><span class="meta">__LL_SC_INLINE void\</span></span><br><span class="line"><span class="meta">__LL_SC_PREFIX(atomic_add(int i, atomic_t *v))\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">unsigned long tmp;\</span></span><br><span class="line"><span class="meta">int result;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">asm volatile(<span class="string">&quot;// atomic_add &quot;</span>\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>prfmpstl1strm, %2\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>1:ldxr%w0, %2\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>add%w0, %w0, %w3\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>stxr%w1, %w0, %2\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>cbnz%w1, 1b<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">: &quot;</span>=&amp;r<span class="string">&quot; (result), &quot;</span>=&amp;r<span class="string">&quot; (tmp), &quot;</span>+Q<span class="string">&quot; (v-&gt;counter)\</span></span></span><br><span class="line"><span class="string"><span class="meta">: #constraint &quot;</span>r<span class="string">&quot; (i));\</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;\</span></span></span><br><span class="line"><span class="string"><span class="meta">__LL_SC_EXPORT(atomic_##op);</span></span></span><br></pre></td></tr></table></figure><ul><li><p><code>ldxr</code>和<code>ldrex</code>都是实现原子操作的 Load-Exclusive 指令，但它们适用于不同的 ARM 架构版本。</p></li><li><p>汇编指令详细执行原子操作：</p><ul><li><code>prfm pstl1strm, %2</code>：预取指令，为存储预取数据到一级流式存储器。</li><li><code>ldxr %w0, %2</code>：使用 Load-Exclusive 指令从 <code>v-&gt;counter</code> 加载数据到寄存器 <code>%w0</code>。</li><li><code>#asm_op %w0, %w0, %w3</code>：执行如加法、减法等操作，结果存回 <code>%w0</code>。</li><li><code>stxr %w1, %w0, %2</code>：使用 Store-Exclusive 指令尝试将 <code>%w0</code> 的值存回 <code>v-&gt;counter</code>。</li><li><code>cbnz %w1, 1b</code>：如果 <code>stxr</code> 指示存储失败（寄存器 <code>%w1</code> 不为零），则跳回标签 <code>1</code> 重新尝试。</li></ul></li><li><p>寄存器 <code>result</code> 和 <code>tmp</code> 分别用于存储操作的结果和临时数据。</p></li><li><p>约束 <code>&quot;+Q&quot; (v-&gt;counter)</code> 表示 <code>v-&gt;counter</code> 是一个读写操作数。</p></li><li><p><code>#constraint &quot;r&quot; (i)</code> 表示输入 <code>i</code> 作为寄存器输入，具体的约束由宏的调用者提供。</p></li></ul><p>对于<code>ARMv8.1 </code>架构及以后支持<code>LSE</code>指令集的原子操作实现需要去查看<code>&lt;asm/atomic_lse.h&gt;</code>，在上面的原子实现中，如果<code>stxr</code>指令失败会导致重试，重试一次还好，如果CPU之间竞争比较激烈，可能导致重试的次数较多，所以从2014年的ARMv8.1开始，ARM推出了用于原子操作的LSE(Large System Extension)指令集扩展，新增的指令包括CAS, SWP和LD<OP>, ST<OP>等，其中<OP>可以是ADD, CLR, EOR, SET等。</OP></OP></OP></p><p>来看看代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LL_SC_ATOMIC(op)__LL_SC_CALL(atomic_##op)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, asm_op)\</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">register int w0 asm (<span class="string">&quot;w0&quot;</span>) = i;\</span></span><br><span class="line"><span class="meta">register atomic_t *x1 asm (<span class="string">&quot;x1&quot;</span>) = v;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">asm volatile(\</span></span><br><span class="line"><span class="meta">__LSE_PREAMBLE\</span></span><br><span class="line"><span class="meta">ARM64_LSE_ATOMIC_INSN(__LL_SC_ATOMIC(op),\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;&quot;</span> #asm_op <span class="string">&quot;%w[i], %[v]\n&quot;</span>)\</span></span><br><span class="line"><span class="meta">: [i] <span class="string">&quot;+r&quot;</span> (w0), [v] <span class="string">&quot;+Q&quot;</span> (v-&gt;counter)\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;r&quot;</span> (x1)\</span></span><br><span class="line"><span class="meta">: __LL_SC_CLOBBERS);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line">ATOMIC_OP(andnot, stclr)</span><br><span class="line">ATOMIC_OP(or, stset)</span><br><span class="line">ATOMIC_OP(xor, steor)</span><br><span class="line">ATOMIC_OP(add, stadd)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>展开后为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define __LL_SC_ATOMIC(op)__LL_SC_CALL(atomic_##op)</span><br><span class="line">#define ATOMIC_OP(op, asm_op)\</span><br><span class="line">static inline void atomic_add(int i, atomic_t *v)\</span><br><span class="line">&#123;\</span><br><span class="line">register int w0 asm (&quot;w0&quot;) = i;\</span><br><span class="line">register atomic_t *x1 asm (&quot;x1&quot;) = v;\</span><br><span class="line">\</span><br><span class="line">asm volatile(\</span><br><span class="line">__LSE_PREAMBLE\</span><br><span class="line">ARM64_LSE_ATOMIC_INSN(__LL_SC_ATOMIC(add),\</span><br><span class="line">&quot;&quot; stdadd&quot;%w[i], %[v]\n&quot;)\</span><br><span class="line">: [i] &quot;+r&quot; (w0), [v] &quot;+Q&quot; (v-&gt;counter)\</span><br><span class="line">: &quot;r&quot; (x1)\</span><br><span class="line">: __LL_SC_CLOBBERS);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ATOMIC_OP(andnot, stclr)</span><br><span class="line">ATOMIC_OP(or, stset)</span><br><span class="line">ATOMIC_OP(xor, steor)</span><br><span class="line">ATOMIC_OP(add, stadd)</span><br></pre></td></tr></table></figure><p>寄存器绑定：</p><ul><li>变量 <code>w0</code> 和 <code>x1</code> 分别绑定到 ARM64 寄存器 <code>w0</code> 和 <code>x1</code>。<code>w0</code> 是用来存储整数 <code>i</code>，而 <code>x1</code> 是用来存储指针 <code>v</code> 的地址。</li><li>使用 <code>asm</code> 关键字显式指定使用哪个寄存器，这有助于在内联汇编代码中直接引用这些寄存器。</li></ul><p>内联汇编：</p><ul><li><code>&quot; &quot; #asm_op &quot; %w[i], %[v]\n&quot;</code>：这是实际执行的原子操作指令，<code>#asm_op</code> 将被替换为传入的汇编操作符，如 <code>stadd</code>。</li><li>输出列表 (<code>[i] &quot;+r&quot; (w0), [v] &quot;+Q&quot; (v-&gt;counter)</code>)：定义了内联汇编修改的变量。<code>+r</code> 表示变量既是输入又是输出，<code>+Q</code> 表示内存操作数，也是读写的。</li><li>输入列表 (<code>&quot;r&quot; (x1)</code>)：提供给汇编的输入。</li><li>被破坏列表 (<code>__LL_SC_CLOBBERS</code>)：可能是一组被这段内联汇编修改的其他寄存器，以确保调用者能够保存和恢复这些寄存器的状态。</li></ul><p>直接一条指令实现了原子操作，类似于x86的lock指令</p><h2 id="2-自旋锁"><a href="#2-自旋锁" class="headerlink" title="2.自旋锁"></a>2.自旋锁</h2><p>自旋锁（spin lock）是一种非阻塞锁，也就是说，如果某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗 CPU 的时间，不停的试图获取锁。</p><p>内核中以 <code>spinlock_t </code>结构体来表示自旋锁，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock_types.h” 文件中，如下所示</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u8 __padding[LOCK_PADSIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line"><span class="type">arch_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> magic, owner_cpu;</span><br><span class="line"><span class="type">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure><ul><li><code>spinlock_t</code>这个结构体实际使用的是<code>raw_spinlock_t</code></li><li><code>raw_spinlock_t</code>内部使用的是<code>arch_spinlock_t</code>，一看就是一个和体系结构相关的自旋锁</li></ul><p>自旋锁相关 <code>API</code> 函数定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中，部分 API 函数如下所示</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>DEFINE_SPINLOCK(spinlock_t lock)</td><td>定义并初始化自旋锁</td></tr><tr><td>int spin_lock_init(spinlock_t *lock)</td><td>初始化自旋锁</td></tr><tr><td>void spin_lock(spinlock_t *lock)</td><td>获取指定的自旋锁，也叫做加锁</td></tr><tr><td>void spin_unlock(spinlock_t *lock)</td><td>释放指定的自旋锁</td></tr><tr><td>int spin_trylock(spinlock_t *lock)</td><td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td></tr><tr><td>int spin_is_locked(spinlock_t *lock)</td><td>检查指定的自旋锁是否被获取，如果没有被获取就返回非 0，否则返回0</td></tr></tbody></table><p>自旋锁的使用步骤：</p><ul><li><p>在访问临界资源的时候先申请自旋锁</p></li><li><p>获取到自旋锁之后就进入临界区，获取不到自旋锁就“原地等待”。</p></li><li><p>退出临界区的时候要释放自旋锁。</p></li></ul><p>我们要去分析自旋锁的代码实际上就是要去看<code>arch_spinlock_t</code>的相关操作，回到“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock_types.h”的最上面即<code>raw_spinlock_t</code>定义的地方<br><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240510171732998.png" alt="image-20240510171732998"></p><ul><li>如果是<code>SMP</code>系统使用的是<code>&lt;asm/spinlock_types.h&gt;</code>，否则使用的是<code>&lt;linux/spinlock_types_up.h&gt;</code></li></ul><p>到这里就到了自旋锁的分水岭，单核情况和多核情况自旋锁是完全不同的，这里先引入一个概念，关于抢占式内核与非抢占式内核：</p><ul><li><p>在非抢占式内核中，如果一个进程在内核态运行，其只有在以下两种情况会被切换：</p><ol><li>其运行完成（返回用户空间）</li><li>主动让出cpu（即主动调用schedule或内核中的任务阻塞——这同样也会导致调用schedule）</li></ol></li><li><p>在抢占式内核中，如果一个进程在内核态运行，其只有在以下四种情况会被切换：</p></li></ul><ol><li>其运行完成（返回用户空间）</li><li>主动让出cpu（即主动调用schedule或内核中的任务阻塞——这同样也会导致调用schedule）</li><li>当从中断处理程序正在执行，且返回内核空间之前（此时可抢占标志premptcount须为0）</li><li>当内核代码再一次具有可抢占性的时候，如解锁及使能软中断等。</li></ol><p><code>linux</code>内核是一个可抢占的内核， 在单cpu，可抢占内核中，自旋锁实现为“禁止内核抢占”，并不实现“自旋”。禁止内核抢占只是关闭“可抢占标志”，而不是禁止进程切换。显式使用schedule或进程阻塞（此也会导致调用schedule）时，还是会发生进程调度的。这也符合自旋锁的作用，加上自旋锁的线程是不会被阻塞的，禁止抢占会防止线程从运行态被切换。在多cpu，可抢占内核中，自旋锁实现为“禁止内核抢占” + “自旋”。</p><h3 id="2-1-单核情况下自旋锁的实现"><a href="#2-1-单核情况下自旋锁的实现" class="headerlink" title="2.1 单核情况下自旋锁的实现"></a>2.1 单核情况下自旋锁的实现</h3><p>有了上面的概念我们再来看单核情况下自旋锁的实现，上面说到我们需要去<code>&lt;linux/spinlock_types_up.h&gt;</code>寻找<code>arch_spinlock_t</code>的定义：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240518113330340.png" alt="image-20240518113330340"></p><p>可以看见是一个空的结构体，然后我们来看加锁函数<code>spin_lock</code>，定义在<code>include/linux/spinlock.h</code>中，此函数会去掉用<code>raw_spin_lock</code>的宏，这个宏也在此头文件中，然后会去调用<code>_raw_spin_lock</code>，此宏定义在<code>include/linux/spinlock_api_up.h</code>中，它会去调用<code>__LOCK</code>宏，<code>__LOCK</code>会调用<code>___LOCK</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/spinlock_api_up.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock)__LOCK(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___LOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; __acquire(lock); (void)(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; preempt_disable(); ___LOCK(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/compiler_types.h</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __acquire(x) (void)0</span></span><br></pre></td></tr></table></figure><ul><li>可以看见先做了<code>preempt_disable();</code>操作，用于禁止抢占</li><li>然后执行<code>__acquire(lock);</code>，可以看见就是将<code>lock</code>置为0，然后<code>(void)(lock);</code>置为空</li><li>所以在单核情况下自旋锁除了关闭内核抢占，什么都没做</li></ul><p>对于锁的释放<code>spin_unlock</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_unlock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_unlock(lock)_raw_spin_unlock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/spinlock_api_up.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_unlock(lock)__UNLOCK(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UNLOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; preempt_enable(); ___UNLOCK(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___UNLOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; (void)(lock); &#125; while (0)</span></span><br></pre></td></tr></table></figure><ul><li>调用<code> preempt_enable();</code>重新开启cpu的内核抢占</li></ul><h3 id="2-2-多核情况下自旋锁的实现"><a href="#2-2-多核情况下自旋锁的实现" class="headerlink" title="2.2 多核情况下自旋锁的实现"></a>2.2 多核情况下自旋锁的实现</h3><p>在多核情况下<code>arch_spinlock_t</code>的需要包含<code>&lt;asm/spinlock_types.h&gt;</code>中，这是一个和体系架构相关的头文件，在<code>x86</code>、<code>ARM32</code>、<code>ARM64</code>下的实现是不一样的，</p><h4 id="2-2-1-ARM32"><a href="#2-2-1-ARM32" class="headerlink" title="2.2.1 ARM32"></a>2.2.1 ARM32</h4><p>首先来看<code>ARM32</code>的实现，用到的头文件为“内核源码&#x2F;arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;spinlock_types.h”</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TICKET_SHIFT16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">u32 slock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">raw_tickets</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARMEB__</span></span><br><span class="line">u16 next;</span><br><span class="line">u16 owner;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">u16 owner;</span><br><span class="line">u16 next;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; tickets;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="type">arch_spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED&#123; &#123; 0 &#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>arch_spinlock_t</code>结构体内部是一个联合体，简单来说就是存放一个<code>u32</code>类型的数据，把一个<code>u32</code>拆分成两个<code>u16</code>，分别为<code>next</code>和 <code>owner</code></p><ul><li><code>owner</code>表示持有这个数字的线程可以获取自旋锁</li><li><code>next</code>表示如果后续再有线程请求获取这个自旋锁，就为此线程分配这个数字</li></ul></li><li><p><code>__ARMEB__</code>这个宏是标识大端和小端的</p></li><li><p><code>next</code>和<code>owner</code>设计的原因是为了保证<code>spinlock</code>的公平性，先申请持有锁的线程先拿到锁，举个例子</p><p>1.刚开始<code>owner=next=0</code>;<br>2.第一个thread获取<code>spinlock</code>，可获取成功，此时<code>owner=0,next=0</code><br>3.第二个thread获取spinlock,如果第一个thread 还没有释放spinlock，则next++,next变为1;</p><p>4.第三个thread获取spinlock,如果第一个thread 还没有释放spinlock，则next++,next变为2;</p><p>5.此时第一个thread释放spinlock，则执行<code>owner++,owner=1;</code></p><p>6.虽然此时第二个thread和第三个thread都在等待spinlock,但是因为第二个thread的next&#x3D;owner,所以第二个thread可以获取到spinlock，第三个thread则继续等待。</p><p>这样保证了spinlock的唤醒机制是先到先唤醒，后到后唤醒保证了公平性。</p></li></ul><p>基于上面的设计我们来看一下加锁操作，在<code>内核源码/include/linux/spinlock.h</code>中：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240519123433508.png" alt="image-20240519123433508"></p><p>初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spin_lock_init(_lock)\</span></span><br><span class="line"><span class="meta">do &#123;\</span></span><br><span class="line"><span class="meta">spinlock_check(_lock);\</span></span><br><span class="line"><span class="meta">raw_spin_lock_init(&amp;(_lock)-&gt;rlock);\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> raw_spin_lock_init(lock)\</span></span><br><span class="line"><span class="meta">do &#123; *(lock) = __RAW_SPIN_LOCK_UNLOCKED(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  include/linux/spinlock_types.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RAW_SPIN_LOCK_INITIALIZER(lockname)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,\</span></span><br><span class="line"><span class="meta">SPIN_DEBUG_INIT(lockname)\</span></span><br><span class="line"><span class="meta">SPIN_DEP_MAP_INIT(lockname) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RAW_SPIN_LOCK_UNLOCKED(lockname)\</span></span><br><span class="line"><span class="meta">(raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER(lockname)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  arch/arm/include/asm/spinlock_types.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED&#123; &#123; 0 &#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>可以看见初始化锁最后会调用到<code>arch/arm/include/asm/spinlock_types.h</code>文件中的<code>__ARCH_SPIN_LOCK_UNLOCKED</code>来将自旋锁中的<code>.raw_lock</code>成员初始化为0，在上面的自旋锁的定义中<code>arch_spinlock_t raw_lock;</code>最后实际上就是将<code>arch_spinlock_t</code>结构体中的<code>u32</code>变成了0，即初始化时<code>next=0 , owner=0</code></li></ul><p>加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include\linux\spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock) __raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">acquires</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">__acquire(lock);</span><br><span class="line">arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  arch/arm/include/asm/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_spin_lock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line">u32 newval;</span><br><span class="line"><span class="type">arch_spinlock_t</span> lockval;</span><br><span class="line"></span><br><span class="line">prefetchw(&amp;lock-&gt;slock);</span><br><span class="line">__asm__ __volatile__(</span><br><span class="line"><span class="string">&quot;1:ldrex%0, [%3]\n&quot;</span></span><br><span class="line"><span class="string">&quot;add%1, %0, %4\n&quot;</span></span><br><span class="line"><span class="string">&quot;strex%2, %1, [%3]\n&quot;</span></span><br><span class="line"><span class="string">&quot;teq%2, #0\n&quot;</span></span><br><span class="line"><span class="string">&quot;bne1b&quot;</span></span><br><span class="line">: <span class="string">&quot;=&amp;r&quot;</span> (lockval), <span class="string">&quot;=&amp;r&quot;</span> (newval), <span class="string">&quot;=&amp;r&quot;</span> (tmp)</span><br><span class="line">: <span class="string">&quot;r&quot;</span> (&amp;lock-&gt;slock), <span class="string">&quot;I&quot;</span> (<span class="number">1</span> &lt;&lt; TICKET_SHIFT)</span><br><span class="line">: <span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (lockval.tickets.next != lockval.tickets.owner) &#123;</span><br><span class="line">wfe();</span><br><span class="line">lockval.tickets.owner = READ_ONCE(lock-&gt;tickets.owner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smp_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>spin_lock</code>加锁，对于<code>ARM32</code>最终会调用到<code>arch_spin_lock</code></p></li><li><p><code>ldrex %0, [%3]</code>：将 <code>[lock-&gt;slock]</code> 的值加载到 <code>lockval</code> 中，并设置一个独占标志。就是加载锁的那个<code>u32</code>的值到<code>lockval</code>中。存储一个锁的值的本地副本<code>lockval</code></p></li><li><p><code>add %1, %0, %4</code>：将 <code>lockval</code> 和 <code>1 &lt;&lt; TICKET_SHIFT</code> 相加，结果存储在 <code>newval</code> 中。<code>TICKET_SHIFT</code>的值为<code>16</code>，即将高16位加一，那么<code>newval</code>的<code>next</code>就加一了</p></li><li><p><code>strex %2, %1, [%3]</code>：将 <code>newval</code> 写入到 <code>[lock-&gt;slock]</code> 中，如果成功（即 <code>tmp</code> 为 0），则表示锁获取成功，否则重试。</p></li><li><p>执行完毕上面的操作后就是将锁的<code>u32</code>的值的<code>next</code>加一了，然后保存了一个本地的副本值，<code>lockval</code>的<code>next</code>值是上一次未加一的值</p></li><li><p>然后下面有个<code>while</code>循环会去判断<code>lockval</code>的<code>owner</code>值和<code>next</code>值是否相等，如果不等，则去加载最新的<code>lock</code>的<code>owner</code>的值，上面提到如果有线程释放锁了，会去将<code>lock</code>的<code>owner</code>值加一，因此如果最新的<code>owner</code>值和本地线程维护的<code>next</code>值相等了就说明本地线程可以不用循环等待了</p></li><li><p>在循环内部会调用一个<code>wfe()</code>函数，这个函数是用于使当前的cpu处于低功耗状态，如果说其他核心上的线程还在持有锁并没有释放，我们可以让当前线程不用一直自旋，直接使其进入低功耗状态，当锁释放时再唤醒</p></li></ul><p>解锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_unlock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_unlock(lock)_raw_spin_unlock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include\linux\spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_unlock(lock) __raw_spin_unlock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_unlock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">spin_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">do_raw_spin_unlock(lock);</span><br><span class="line">preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_unlock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">releases</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">arch_spin_unlock(&amp;lock-&gt;raw_lock);</span><br><span class="line">__release(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  arch/arm/include/asm/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_spin_unlock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">smp_mb();</span><br><span class="line">lock-&gt;tickets.owner++;</span><br><span class="line">dsb_sev();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可以看见解锁操作就是将<code>owner</code>的值加一</li><li>然后唤醒，上面提到其余没有拿到锁的线程会自旋然后进入低功耗状态，调用<code>dsb_sev();</code>就可以唤醒cpu，因为此时<code>owner</code>的值加一了</li></ul><h4 id="2-2-2-ARM64和X86"><a href="#2-2-2-ARM64和X86" class="headerlink" title="2.2.2 ARM64和X86"></a>2.2.2 ARM64和X86</h4><p>在<code>ARM64</code>和<code>x86</code>平台下，先要去找<code>arch_spinlock_t</code>的定义，去<code>arch/arm64/include/asm/spinlock_types.h</code>中寻找：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240519134302875.png" alt="image-20240519134302875"></p><p>可以看见会去包含：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/qspinlock_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/qrwlock_types.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>进入<code>/include/asm-generic/qspinlock_types.h</code>，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qspinlock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">atomic_t</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By using the whole 2nd least significant byte for the</span></span><br><span class="line"><span class="comment"> * pending bit, we can allow better optimization of the lock</span></span><br><span class="line"><span class="comment"> * acquisition for the pending bit holder.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LITTLE_ENDIAN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u8locked;</span><br><span class="line">u8pending;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u16locked_pending;</span><br><span class="line">u16tail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u16tail;</span><br><span class="line">u16locked_pending;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u8reserved[<span class="number">2</span>];</span><br><span class="line">u8pending;</span><br><span class="line">u8locked;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="type">arch_spinlock_t</span>;</span><br></pre></td></tr></table></figure><p>在这里定义了<code>arch_spinlock_t</code>，<code>__LITTLE_ENDIAN</code>用于判断大端和小端，可以看见使用了一个32位的原子变量</p><p>来看加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include\linux\spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock) __raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">acquires</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">__acquire(lock);</span><br><span class="line">arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include\asm-generic\qspinlock.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_spin_lock(l)queued_spin_lock(l)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">queued_spin_lock</span><span class="params">(<span class="keyword">struct</span> qspinlock *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 val;</span><br><span class="line"></span><br><span class="line">val = atomic_cmpxchg_acquire(&amp;lock-&gt;val, <span class="number">0</span>, _Q_LOCKED_VAL);</span><br><span class="line"><span class="keyword">if</span> (likely(val == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">queued_spin_lock_slowpath(lock, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现十分复杂，后续再分析……</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * queued_spin_lock_slowpath - acquire the queued spinlock</span></span><br><span class="line"><span class="comment"> * @lock: Pointer to queued spinlock structure</span></span><br><span class="line"><span class="comment"> * @val: Current value of the queued spinlock 32-bit word</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (queue tail, pending bit, lock value)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              fast     :    slow                                  :    unlock</span></span><br><span class="line"><span class="comment"> *                       :                                          :</span></span><br><span class="line"><span class="comment"> * uncontended  (0,0,0) -:--&gt; (0,0,1) ------------------------------:--&gt; (*,*,0)</span></span><br><span class="line"><span class="comment"> *                       :       | ^--------.------.             /  :</span></span><br><span class="line"><span class="comment"> *                       :       v           \      \            |  :</span></span><br><span class="line"><span class="comment"> * pending               :    (0,1,1) +--&gt; (0,1,0)   \           |  :</span></span><br><span class="line"><span class="comment"> *                       :       | ^--&#x27;              |           |  :</span></span><br><span class="line"><span class="comment"> *                       :       v                   |           |  :</span></span><br><span class="line"><span class="comment"> * uncontended           :    (n,x,y) +--&gt; (n,0,0) --&#x27;           |  :</span></span><br><span class="line"><span class="comment"> *   queue               :       | ^--&#x27;                          |  :</span></span><br><span class="line"><span class="comment"> *                       :       v                               |  :</span></span><br><span class="line"><span class="comment"> * contended             :    (*,x,y) +--&gt; (*,0,0) ---&gt; (*,0,1) -&#x27;  :</span></span><br><span class="line"><span class="comment"> *   queue               :         ^--&#x27;                             :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queued_spin_lock_slowpath</span><span class="params">(<span class="keyword">struct</span> qspinlock *lock, u32 val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mcs_spinlock</span> *<span class="title">prev</span>, *<span class="title">next</span>, *<span class="title">node</span>;</span></span><br><span class="line">u32 old, tail;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">BUILD_BUG_ON(CONFIG_NR_CPUS &gt;= (<span class="number">1U</span> &lt;&lt; _Q_TAIL_CPU_BITS));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pv_enabled())</span><br><span class="line"><span class="keyword">goto</span> pv_queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (virt_spin_lock(lock))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait for in-progress pending-&gt;locked hand-overs with a bounded</span></span><br><span class="line"><span class="comment"> * number of spins so that we guarantee forward progress.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,1,0 -&gt; 0,0,1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (val == _Q_PENDING_VAL) &#123;</span><br><span class="line"><span class="type">int</span> cnt = _Q_PENDING_LOOPS;</span><br><span class="line">val = atomic_cond_read_relaxed(&amp;lock-&gt;val,</span><br><span class="line">       (VAL != _Q_PENDING_VAL) || !cnt--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we observe any contention; queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (val &amp; ~_Q_LOCKED_MASK)</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * trylock || pending</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,0,0 -&gt; 0,0,1 ; trylock</span></span><br><span class="line"><span class="comment"> * 0,0,1 -&gt; 0,1,1 ; pending</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">val = queued_fetch_set_pending_acquire(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we observe any contention; undo and queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(val &amp; ~_Q_LOCKED_MASK)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(val &amp; _Q_PENDING_MASK))</span><br><span class="line">clear_pending(lock);</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We&#x27;re pending, wait for the owner to go away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,1,1 -&gt; 0,1,0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this wait loop must be a load-acquire such that we match the</span></span><br><span class="line"><span class="comment"> * store-release that clears the locked bit and create lock</span></span><br><span class="line"><span class="comment"> * sequentiality; this is because not all</span></span><br><span class="line"><span class="comment"> * clear_pending_set_locked() implementations imply full</span></span><br><span class="line"><span class="comment"> * barriers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (val &amp; _Q_LOCKED_MASK)</span><br><span class="line">atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_MASK));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * take ownership and clear the pending bit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,1,0 -&gt; 0,0,1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clear_pending_set_locked(lock);</span><br><span class="line">qstat_inc(qstat_lock_pending, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * End of pending bit optimistic spinning and beginning of MCS</span></span><br><span class="line"><span class="comment"> * queuing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">queue</span>:</span><br><span class="line">qstat_inc(qstat_lock_slowpath, <span class="literal">true</span>);</span><br><span class="line">pv_queue:</span><br><span class="line">node = this_cpu_ptr(&amp;mcs_nodes[<span class="number">0</span>]);</span><br><span class="line">idx = node-&gt;count++;</span><br><span class="line">tail = encode_tail(smp_processor_id(), idx);</span><br><span class="line"></span><br><span class="line">node += idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure that we increment the head node-&gt;count before initialising</span></span><br><span class="line"><span class="comment"> * the actual node. If the compiler is kind enough to reorder these</span></span><br><span class="line"><span class="comment"> * stores, then an IRQ could overwrite our assignments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">barrier();</span><br><span class="line"></span><br><span class="line">node-&gt;locked = <span class="number">0</span>;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">pv_init_node(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We touched a (possibly) cold cacheline in the per-cpu queue node;</span></span><br><span class="line"><span class="comment"> * attempt the trylock once more in the hope someone let go while we</span></span><br><span class="line"><span class="comment"> * weren&#x27;t watching.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (queued_spin_trylock(lock))</span><br><span class="line"><span class="keyword">goto</span> release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure that the initialisation of @node is complete before we</span></span><br><span class="line"><span class="comment"> * publish the updated tail via xchg_tail() and potentially link</span></span><br><span class="line"><span class="comment"> * @node into the waitqueue via WRITE_ONCE(prev-&gt;next, node) below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">smp_wmb();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Publish the updated tail.</span></span><br><span class="line"><span class="comment"> * We have already touched the queueing cacheline; don&#x27;t bother with</span></span><br><span class="line"><span class="comment"> * pending stuff.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * p,*,* -&gt; n,*,*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">old = xchg_tail(lock, tail);</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * if there was a previous node; link it and wait until reaching the</span></span><br><span class="line"><span class="comment"> * head of the waitqueue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (old &amp; _Q_TAIL_MASK) &#123;</span><br><span class="line">prev = decode_tail(old);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Link @node into the waitqueue. */</span></span><br><span class="line">WRITE_ONCE(prev-&gt;next, node);</span><br><span class="line"></span><br><span class="line">pv_wait_node(node, prev);</span><br><span class="line">arch_mcs_spin_lock_contended(&amp;node-&gt;locked);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While waiting for the MCS lock, the next pointer may have</span></span><br><span class="line"><span class="comment"> * been set by another lock waiter. We optimistically load</span></span><br><span class="line"><span class="comment"> * the next pointer &amp; prefetch the cacheline for writing</span></span><br><span class="line"><span class="comment"> * to reduce latency in the upcoming MCS unlock operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">next = READ_ONCE(node-&gt;next);</span><br><span class="line"><span class="keyword">if</span> (next)</span><br><span class="line">prefetchw(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * we&#x27;re at the head of the waitqueue, wait for the owner &amp; pending to</span></span><br><span class="line"><span class="comment"> * go away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * *,x,y -&gt; *,0,0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this wait loop must use a load-acquire such that we match the</span></span><br><span class="line"><span class="comment"> * store-release that clears the locked bit and create lock</span></span><br><span class="line"><span class="comment"> * sequentiality; this is because the set_locked() function below</span></span><br><span class="line"><span class="comment"> * does not imply a full barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The PV pv_wait_head_or_lock function, if active, will acquire</span></span><br><span class="line"><span class="comment"> * the lock and return a non-zero value. So we have to skip the</span></span><br><span class="line"><span class="comment"> * atomic_cond_read_acquire() call. As the next PV queue head hasn&#x27;t</span></span><br><span class="line"><span class="comment"> * been designated yet, there is no way for the locked value to become</span></span><br><span class="line"><span class="comment"> * _Q_SLOW_VAL. So both the set_locked() and the</span></span><br><span class="line"><span class="comment"> * atomic_cmpxchg_relaxed() calls will be safe.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If PV isn&#x27;t active, 0 will be returned instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((val = pv_wait_head_or_lock(lock, node)))</span><br><span class="line"><span class="keyword">goto</span> locked;</span><br><span class="line"></span><br><span class="line">val = atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_PENDING_MASK));</span><br><span class="line"></span><br><span class="line">locked:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * claim the lock:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * n,0,0 -&gt; 0,0,1 : lock, uncontended</span></span><br><span class="line"><span class="comment"> * *,*,0 -&gt; *,*,1 : lock, contended</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the queue head is the only one in the queue (lock value == tail)</span></span><br><span class="line"><span class="comment"> * and nobody is pending, clear the tail code and grab the lock.</span></span><br><span class="line"><span class="comment"> * Otherwise, we only need to grab the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In the PV case we might already have _Q_LOCKED_VAL set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The atomic_cond_read_acquire() call above has provided the</span></span><br><span class="line"><span class="comment"> * necessary acquire semantics required for locking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (((val &amp; _Q_TAIL_MASK) == tail) &amp;&amp;</span><br><span class="line">    atomic_try_cmpxchg_relaxed(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL))</span><br><span class="line"><span class="keyword">goto</span> release; <span class="comment">/* No contention */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Either somebody is queued behind us or _Q_PENDING_VAL is set */</span></span><br><span class="line">set_locked(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * contended path; wait for next if not observed yet, release.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!next)</span><br><span class="line">next = smp_cond_load_relaxed(&amp;node-&gt;next, (VAL));</span><br><span class="line"></span><br><span class="line">arch_mcs_spin_unlock_contended(&amp;next-&gt;locked);</span><br><span class="line">pv_kick_node(lock, next);</span><br><span class="line"></span><br><span class="line">release:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * release the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__this_cpu_dec(mcs_nodes[<span class="number">0</span>].count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h2><p><code>Linux</code> 内核使用 <code>semaphore</code> 结构体来表示信号量，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;semaphore.h”文件内</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Please don&#x27;t access any members of this structure directly */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line"><span class="type">raw_spinlock_t</span>lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与信号量相关的 API 函数同样定义在 semaphore.h 文件内，部分常用 API 函数如下所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_SEAMPHORE(name)</code></td><td>定义信号量，并且设置信号量的值为 1。</td></tr><tr><td><code>void sema_init(struct semaphore *sem, int val)</code></td><td>初始化信号量 sem，设置信号量值为 val。</td></tr><tr><td><code>void down(struct semaphore *sem)</code></td><td>获取信号量，不能被中断打断，如 ctrl+c</td></tr><tr><td><code>int down_interruptible(struct semaphore *sem)</code></td><td>获取信号量，可以被中断打断，如 ctrl+c</td></tr><tr><td><code>void up(struct semaphore *sem)</code></td><td>释放信号量</td></tr><tr><td><code>int down_trylock(struct semaphore *sem);</code></td><td>尝试获取信号量，如果能获取到信号量就获取，并且返回 0</td></tr></tbody></table><p>在<code>semaphore</code> 结构体的定义中，包含一个自旋锁，一个计数的<code>count</code>值，一个双向链表</p><p>先来看定义信号量的宏以及初始化函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/semaphore.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SEMAPHORE_INITIALIZER(name, n)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">.lock= __RAW_SPIN_LOCK_UNLOCKED((name).lock),\</span></span><br><span class="line"><span class="meta">.count= n,\</span></span><br><span class="line"><span class="meta">.wait_list= LIST_HEAD_INIT((name).wait_list),\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SEMAPHORE(name)\</span></span><br><span class="line"><span class="meta">struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">*sem = (<span class="keyword">struct</span> semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">&quot;semaphore-&gt;lock&quot;</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化了自旋锁</li><li>然后初始化了<code>count</code>值</li><li>初始化了双向链表，这个链表用于挂载阻塞在此信号量上的线程的结构体指针</li></ul><p>加锁函数即<code>down</code>函数，获取一个锁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/semaphore.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">sem-&gt;count--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__down(sem);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __down(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __sched __down_common(<span class="keyword">struct</span> semaphore *sem, <span class="type">long</span> state,</span><br><span class="line"><span class="type">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"></span><br><span class="line">list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list);</span><br><span class="line">waiter.task = current;</span><br><span class="line">waiter.up = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (signal_pending_state(state, current))</span><br><span class="line"><span class="keyword">goto</span> interrupted;</span><br><span class="line"><span class="keyword">if</span> (unlikely(timeout &lt;= <span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> timed_out;</span><br><span class="line">__set_current_state(state);</span><br><span class="line">raw_spin_unlock_irq(&amp;sem-&gt;lock);</span><br><span class="line">timeout = schedule_timeout(timeout);</span><br><span class="line">raw_spin_lock_irq(&amp;sem-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (waiter.up)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> timed_out:</span><br><span class="line">list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line"> interrupted:</span><br><span class="line">list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>raw_spin_lock_irqsave</code>加锁</p></li><li><p>如果<code>count</code>的值大于0，则将信号量的<code>count</code>值减一，如果<code>count</code>的值小于等于0，则会去执行<code>__down</code>函数，最终会去调用到<code>__down_common</code>函数，传入的参数为<code>TASK_UNINTERRUPTIBLE</code>和<code>MAX_SCHEDULE_TIMEOUT</code></p><ul><li><code>TASK_UNINTERRUPTIBLE</code>：线程已经进入睡眠状态，且不可被打断</li><li><code>MAX_SCHEDULE_TIMEOUT</code>：线程调度超时时间</li></ul></li><li><p>如果进入了<code>__down_common</code>函数就说明当前的线程拿不到信号量，那么当前线程应该干嘛呢，肯定不能傻傻的干等，因此当前线程会休眠，当持有信号量的线程释放信号量后再通知阻塞在此信号量的线程从而将其唤醒去执行，<code>__down_common</code>函数就是在做这一件事情</p><ul><li><p>首先定了一个<code>semaphore_waiter</code>，包含一个链表节点和一个<code>task_struct</code>，<code>task_struct</code>可用于代表当前线程，<code>current</code>就代表了当前线程的<code>task_struct</code>的指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="type">bool</span> up;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">waiter.task = current;</span><br><span class="line">waiter.up = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后调用<code>list_add_tail(&amp;waiter.list, &amp;*sem*-&gt;wait_list);</code>将这个<code>semaphore_waiter</code>挂载在信号量的<code>wait_list</code>链表上，因此当持有信号量的线程释放后就可以通过这个等待链表去唤醒其他阻塞的线程，唤醒其实就是将这个<code>bool</code>的<code>up</code>值置为<code>true</code></p></li><li><p>在<code>for</code>循环内部，会先去调用<code>signal_pending_state</code>去检测线程在当前状态下是否有信号需要处理，我们出入的进程状态为<code>TASK_UNINTERRUPTIBLE</code>，即在此状态下有信号需要处理也需要返回。</p></li><li><p>然后由于传入的<code>MAX_SCHEDULE_TIMEOUT</code>是一个很大的值，因此<code>timed_out</code>应该也是不会超时的</p></li><li><p>调用<code>__set_current_state</code>来设置当前线程的状态</p></li><li><p><code>raw_spin_unlock_irq</code>解锁，这里为什么要先解锁呢，那是因为下面执行的<code>schedule_timeout</code>会导致当前的线程睡眠，而自旋锁保护的临界资源是不允许睡眠的，<code>schedule_timeout</code>是去执行调度切换当前线程，再次切换回来后会去执行<code>raw_spin_lock_irq</code>加锁操作，然后去判断<code>waiter.up</code>是否为<code>true</code>如果为<code>true</code>说明当前线程被唤醒否则继续执行<code>for</code>循环一直等</p></li></ul></li><li><p>调用<code>raw_spin_unlock_irqrestore</code>开锁</p></li></ul><p>解锁操作，即<code>up</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/semaphore.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list)))</span><br><span class="line">sem-&gt;count++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__up(sem);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __up(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> =</span> list_first_entry(&amp;sem-&gt;wait_list,</span><br><span class="line"><span class="keyword">struct</span> semaphore_waiter, <span class="built_in">list</span>);</span><br><span class="line">list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">waiter-&gt;up = <span class="literal">true</span>;</span><br><span class="line">wake_up_process(waiter-&gt;task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先判断信号量的等待链表是否为空，如果等待的线程为空则直接将<code>count</code>值加一</li><li>不为空去执行<code>__up</code>函数，可以看见在此函数内部就是从等待链表上先取出一个等待的线程，然后从等待链表中删除，将此线程的<code>up </code>置为<code>true</code>，最后去唤醒此线程</li></ul><p>最后说一下这里的加锁操作我们使用的是<code>raw_spin_lock_irqsave</code>，它和我们上面讲自旋锁使用的<code>spin_unlock</code>的区别就在于加了<code>irq</code>的会去禁用本地中断，我们以多核系统为例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock_irq(lock)_raw_spin_lock_irq(lock)</span></span><br><span class="line"><span class="comment">// spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock_irq(lock) __raw_spin_lock_irq(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock_irq(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">local_irq_disable();</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">acquires</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">__acquire(lock);</span><br><span class="line">arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看见只是在<code>__raw_spin_lock_irq</code>中会去调用<code>local_irq_disable();</code>禁止本地中断，然后最后会去调用<code>arch_spin_lock</code>加锁</li><li>在使用<code>spin_lock</code>时要明确知道该锁不会在中断处理程序中使用,如果在中断处理程序中也使用了&#96;&#96;spin_lock<code>就会导致死锁，在任何情况下使用</code>spin_lock_irq&#96;都是安全的。因为它既禁止本地中断，又禁止内核抢占。</li></ul><h2 id="4-互斥锁"><a href="#4-互斥锁" class="headerlink" title="4. 互斥锁"></a>4. 互斥锁</h2><p>内核中以<code>mutex</code>结构体来表示互斥体，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;mutex.h”文件中，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line"><span class="type">atomic_long_t</span>owner;</span><br><span class="line"><span class="type">spinlock_t</span>wait_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line"><span class="type">void</span>*magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span><span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>可以看见互斥锁的实现其实和信号量类似，不同的是互斥锁在任何时刻只会有一个线程可以持有锁，而信号量可以多个，在互斥锁的内部同样有一个挂载等待线程的链表<code>wait_list</code>，以及一个原子变量<code>owner</code></li><li>包含一个互斥锁用于加锁操作</li></ul><p>一些和互斥体相关的 API 函数也定义在 <code>mutex.h</code> 文件中，常用 API 函数如下所示</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_MUTEX(name)</code></td><td>定义并初始化一个 mutex 变量。</td></tr><tr><td><code>void mutex_init(mutex *lock)</code></td><td>初始化 mutex。</td></tr><tr><td><code>void mutex_lock(struct mutex *lock)</code></td><td>获取 mutex，也就是给 mutex 上锁。</td></tr><tr><td><code>void mutex_unlock(struct mutex *lock)</code></td><td>释放 mutex，也就给 mutex 解锁。</td></tr><tr><td><code>int mutex_is_locked(struct mutex *lock)</code></td><td>判断 mutex 是否被获取，如果是的话就返回1，否则返回0</td></tr></tbody></table><p>初始化和加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/mutex.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">&#123; .owner = ATOMIC_LONG_INIT(0) \</span></span><br><span class="line"><span class="meta">, .wait_lock = __SPIN_LOCK_UNLOCKED(lockname.wait_lock) \</span></span><br><span class="line"><span class="meta">, .wait_list = LIST_HEAD_INIT(lockname.wait_list) \</span></span><br><span class="line"><span class="meta">__DEBUG_MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">__DEP_MAP_MUTEX_INITIALIZER(lockname) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_MUTEX(mutexname) \</span></span><br><span class="line"><span class="meta">struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mutex_init(mutex)\</span></span><br><span class="line"><span class="meta">do &#123;\</span></span><br><span class="line"><span class="meta">static struct lock_class_key __key;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">__mutex_init((mutex), #mutex, &amp;__key);\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line"><span class="type">void</span> __mutex_init(<span class="keyword">struct</span> mutex *lock, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">atomic_long_set(&amp;lock-&gt;owner, <span class="number">0</span>);</span><br><span class="line">spin_lock_init(&amp;lock-&gt;wait_lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;lock-&gt;wait_list);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">osq_lock_init(&amp;lock-&gt;osq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">debug_mutex_init(lock, name, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DEFINE_MUTEX</code>宏会去调用<code>__MUTEX_INITIALIZER</code>来定义和初始化一个互斥锁，将互斥锁的<code>owner</code>赋值为0，初始化互斥锁和等待链表</li><li><code>mutex_init</code>宏会去调用<code>__mutex_init</code>，同样内部会先将<code>owner</code>的值设置为0，初始化互斥锁，初始化等待链表</li></ul><p>加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_lock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!__mutex_trylock_fast(lock))</span><br><span class="line">__mutex_lock_slowpath(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span> __mutex_trylock_fast(<span class="keyword">struct</span> mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> curr = (<span class="type">unsigned</span> <span class="type">long</span>)current;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> zero = <span class="number">0UL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (atomic_long_try_cmpxchg_acquire(&amp;lock-&gt;owner, &amp;zero, curr))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched</span><br><span class="line">__mutex_lock_slowpath(<span class="keyword">struct</span> mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">__mutex_lock(lock, TASK_UNINTERRUPTIBLE, <span class="number">0</span>, <span class="literal">NULL</span>, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __sched</span><br><span class="line">__mutex_lock(<span class="keyword">struct</span> mutex *lock, <span class="type">long</span> state, <span class="type">unsigned</span> <span class="type">int</span> subclass,</span><br><span class="line">     <span class="keyword">struct</span> lockdep_map *nest_lock, <span class="type">unsigned</span> <span class="type">long</span> ip)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __mutex_lock_common(lock, state, subclass, nest_lock, ip, <span class="literal">NULL</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>might_sleep();</code>不用管，如果没有调试的需要(没有定义CONFIG_DEBUG_ATOMIC_SLEEP)，这个宏&#x2F;函数什么事情都不，might_sleep就是一个空函数，所以平常看code的时候可以忽略。内核只是用它来提醒开发人员，调用该函数的函数可能会sleep。</p></li><li><p>然后调用<code>__mutex_trylock_fast(*lock*)</code>去快速加锁</p><p>fast 部分的代码相对比较简单，主要是两步：</p><ul><li>获取当前进程的<code> task_stuct</code> 指针，<code>current</code>是当前线程的<code>tcb</code>指针</li><li>调用 <code>atomic_long_cmpxchg_acquire</code> 函数尝试更新<code> lock-&gt;owner</code>,这个函数是一个原子操作函数，因为 <code>lock-&gt;owner</code> 是全局变量，所以这里需要用到原子操作。这个接口的定义为：将 p1 (第一个参数)和 p2 作比较，如果相等，则 p1&#x3D;p3，返回 p2，否则不执行赋值，直接返回 p1，类似于c++的CAS操作</li></ul><p>当 <code>lock-&gt;owner</code> 为 0 时，表示既没有其它进程获取锁也没有等待者,就可以直接获取到锁并返回。否则就代表有其他线程持有锁。此时就需要加上慢锁了</p></li><li><p><code>__mutex_lock_slowpath</code>会去调用<code>__mutex_lock</code>，然后调用<code>__mutex_lock_common</code>，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock a mutex (possibly interruptible), slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> __sched</span><br><span class="line">__mutex_lock_common(<span class="keyword">struct</span> mutex *lock, <span class="type">long</span> state, <span class="type">unsigned</span> <span class="type">int</span> subclass,</span><br><span class="line">    <span class="keyword">struct</span> lockdep_map *nest_lock, <span class="type">unsigned</span> <span class="type">long</span> ip,</span><br><span class="line">    <span class="keyword">struct</span> ww_acquire_ctx *ww_ctx, <span class="type">const</span> <span class="type">bool</span> use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ww_mutex</span> *<span class="title">ww</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx)</span><br><span class="line">ww_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line">ww = container_of(lock, <span class="keyword">struct</span> ww_mutex, base);</span><br><span class="line"><span class="keyword">if</span> (ww_ctx) &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(ww_ctx == READ_ONCE(ww-&gt;ctx)))</span><br><span class="line"><span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the wounded flag after a kill. No other process can</span></span><br><span class="line"><span class="comment"> * race and wound us here since they can&#x27;t have a valid owner</span></span><br><span class="line"><span class="comment"> * pointer if we don&#x27;t have any locks held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ww_ctx-&gt;acquired == <span class="number">0</span>)</span><br><span class="line">ww_ctx-&gt;wounded = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preempt_disable();</span><br><span class="line">mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    mutex_optimistic_spin(lock, ww_ctx, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="comment">/* got the lock, yay! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">ww_mutex_set_context_fastpath(ww, ww_ctx);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After waiting to acquire the wait_lock, try again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> skip_wait;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx) &#123;</span><br><span class="line"><span class="comment">/* add waiting tasks to the end of the waitqueue (FIFO): */</span></span><br><span class="line">__mutex_add_waiter(lock, &amp;waiter, &amp;lock-&gt;wait_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">waiter.ww_ctx = MUTEX_POISON_WW_CTX;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add in stamp order, waking up waiters that must kill</span></span><br><span class="line"><span class="comment"> * themselves.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = __ww_mutex_add_waiter(&amp;waiter, lock, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_early_kill;</span><br><span class="line"></span><br><span class="line">waiter.ww_ctx = ww_ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waiter.task = current;</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">bool</span> first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Once we hold wait_lock, we&#x27;re serialized against</span></span><br><span class="line"><span class="comment"> * mutex_unlock() handing the lock off to us, do a trylock</span></span><br><span class="line"><span class="comment"> * before testing the error conditions to make sure we pick up</span></span><br><span class="line"><span class="comment"> * the handoff.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock))</span><br><span class="line"><span class="keyword">goto</span> acquired;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check for signals and kill conditions while holding</span></span><br><span class="line"><span class="comment"> * wait_lock. This ensures the lock cancellation is ordered</span></span><br><span class="line"><span class="comment"> * against mutex_unlock() and wake-ups do not go missing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal_pending_state(state, current))) &#123;</span><br><span class="line">ret = -EINTR;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx) &#123;</span><br><span class="line">ret = __ww_mutex_check_kill(lock, &amp;waiter, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line"></span><br><span class="line">first = __mutex_waiter_is_first(lock, &amp;waiter);</span><br><span class="line"><span class="keyword">if</span> (first)</span><br><span class="line">__mutex_set_flag(lock, MUTEX_FLAG_HANDOFF);</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Here we order against unlock; we must either see it change</span></span><br><span class="line"><span class="comment"> * state back to RUNNING and fall through the next schedule(),</span></span><br><span class="line"><span class="comment"> * or we must see its unlock and acquire.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    (first &amp;&amp; mutex_optimistic_spin(lock, ww_ctx, &amp;waiter)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">&#125;</span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">acquired:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wound-Wait; we stole the lock (!first_waiter), check the</span></span><br><span class="line"><span class="comment"> * waiters as anyone might want to wound us.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ww_ctx-&gt;is_wait_die &amp;&amp;</span><br><span class="line">    !__mutex_waiter_is_first(lock, &amp;waiter))</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__mutex_remove_waiter(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line"></span><br><span class="line">skip_wait:</span><br><span class="line"><span class="comment">/* got the lock - cleanup and rejoice! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">ww_mutex_lock_acquired(ww, ww_ctx);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">__mutex_remove_waiter(lock, &amp;waiter);</span><br><span class="line">err_early_kill:</span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于此函数的分析请参考如下博文，后续有时间再去看代码</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/364130923">linux同步机制 - mutex lock - 知乎 (zhihu.com)</a></p></blockquote></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://blog.csdn.net/weixin_42135087/article/details/123165545">02-Linux Kernel(armv8-aarch64)的原子操作的底层实现</a></li><li><a href="https://www.zhihu.com/tardis/zm/art/89299392?source_id=1005">读写一气呵成 - Linux中的原子操作 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/weixin_42135087/article/details/123165545">02-Linux Kernel(armv8-aarch64)的原子操作的底层实现_在aarch64多核体系结构中,以下哪一条汇编指令可以用于进行原子操作-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/115748853">Linux 单&#x2F;多处理器下的内核同步与实现—自旋锁 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/wh_19910525/article/details/11536279">Linux内核spin_lock、spin_lock_irq 和 spin_lock_irqsave 分析-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 原子变量 </tag>
            
            <tag> 自旋锁 </tag>
            
            <tag> 信号量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用原始套接字剖析TCP</title>
      <link href="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/"/>
      <url>/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络分层"><a href="#1-网络分层" class="headerlink" title="1. 网络分层"></a>1. 网络分层</h2><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/ARP%E5%8D%8F%E8%AE%AE.png" alt="ARP协议"></p><ul><li><p>按照OSI分层的话从上到下分为7层：物理层、链路层、网络层、传输层、会话层、表示层、应用层</p></li><li><p>一般来说会话层、表示层、应用层 统一称为 应用层</p></li><li><p>每张网卡都有一个唯一确定的地址，被称为<code>MAC</code>地址，通过这个全球唯一的<code>MAC</code>地址，就能标识不同的网络设备，<code>MAC</code>地址是一个<code>48bit</code>的值</p></li></ul><h2 id="2-Ethernet-封包格式"><a href="#2-Ethernet-封包格式" class="headerlink" title="2. Ethernet 封包格式"></a>2. Ethernet 封包格式</h2><h3 id="2-1-以太网封包格式"><a href="#2-1-以太网封包格式" class="headerlink" title="2.1 以太网封包格式"></a>2.1 以太网封包格式</h3><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/v2-d69f6122a8ec686cbf573d96d66b078c_r.jpg" alt="img" style="zoom:150%;"><table><thead><tr><th>字段</th><th>字段长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>前导码（preamble）</td><td>7</td><td>0和1交替变换的码流</td></tr><tr><td>帧开始符（SFD）</td><td>1</td><td>帧起始符</td></tr><tr><td>目的地址（DA）</td><td>6</td><td>目的设备的MAC物理地址</td></tr><tr><td>源地址（SA）</td><td>6</td><td>发送设备的MAC物理地址</td></tr><tr><td>长度&#x2F;类型（Length&#x2F;Type）</td><td>2</td><td>帧数据字段长度&#x2F;帧协议类型</td></tr><tr><td>数据及填充（data and pad）</td><td>46~1500</td><td>帧数据字段</td></tr><tr><td>帧校验序列（FCS）</td><td>4</td><td>数据校验字段</td></tr></tbody></table><ul><li><p>以太网帧大小必须在64-1518字节（不包含前导码和定界符），即包括目的地址（6B）、源地址（6B）、类型（2B）、数据、FCS（4B）在内，其中数据段大小在46~1500字节之间。</p></li><li><p>以太网的前导码是一串交替的0和1，用于在网络流中区分一帧帧数据，前导码的最后一个字节是帧开始定界符</p></li></ul><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221170858451.png" alt="image-20240221170858451" style="zoom: 67%;"><h3 id="2-2-IP协议封包格式"><a href="#2-2-IP协议封包格式" class="headerlink" title="2.2 IP协议封包格式"></a>2.2 IP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/IP.png" alt="IP"></p><h3 id="2-2-ARP协议封包格式"><a href="#2-2-ARP协议封包格式" class="headerlink" title="2.2 ARP协议封包格式"></a>2.2 ARP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/ARP.png" alt="ARP"></p><h3 id="2-3-TCP协议封包格式"><a href="#2-3-TCP协议封包格式" class="headerlink" title="2.3 TCP协议封包格式"></a>2.3 TCP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/tcp-170852003743213.png" alt="tcp"></p><p>在Tcp协议中，比较重要的字段有：</p><ul><li><p>源端口：表示发送端端口号，字段长 16 位，2个字节</p></li><li><p>目的端口：表示接收端端口号，字段长 16 位，2个字节</p></li><li><p>序列号（sequence number）：字段长 32 位，占4个字节，序列号的范围为 [0，4284967296]。</p><ul><li>由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号</li><li>首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号，这是随机生成的。</li><li>序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0</li></ul></li><li><p>确认序号（acknowledgement number）：占32位（4字节），表示收到的下一个报文段的第一个数据字节的序号，如果确认序号为N，序号为S，则表明到序号N-S为止的所有数据字节都已经被正确地接收到了。</p></li><li><p>8个标志位（Flag）:</p><ul><li>CWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</li><li>ECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1.；</li><li>URG：该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</li><li>ACK：该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</li><li>PSH：该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</li><li>SYN：用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</li><li>FIN：该位设为 1，表示今后不再有数据发送，希望断开连接。</li></ul></li><li><p>窗口尺寸：该字段长 16 位，表示从确认序号所指位置开始能够接收的数据大小，TCP 不允许发送超过该窗口大小的数据。</p></li></ul><h3 id="2-4-UDP协议封包格式"><a href="#2-4-UDP协议封包格式" class="headerlink" title="2.4 UDP协议封包格式"></a>2.4 UDP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/udp-170852008999615.png" alt="udp"></p><h2 id="2-套接字通信"><a href="#2-套接字通信" class="headerlink" title="2.套接字通信"></a>2.套接字通信</h2><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/%E5%9B%BE%E7%89%87.png" alt="图片" style="zoom: 80%;"><ul><li>在Linux的套接字编程中分为标准套接字和原始套接字，而标准套接字又分为流式套接字和数据报套接字<ul><li>流式套接字：TCP</li><li>数据报套接字：UDP</li></ul></li></ul><h3 id="2-1-UDP编程"><a href="#2-1-UDP编程" class="headerlink" title="2.1 UDP编程"></a>2.1 UDP编程</h3><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/udp.png" alt="udp" style="zoom:80%;"><ul><li><code>sendto</code>函数是非阻塞的，<code>recvfrom</code>函数是阻塞的</li></ul><p><strong>udp客户端的实现:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//udp客户端的实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons inet_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;ip&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd; <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span> <span class="comment">//服务器网络信息结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：创建套接字</span></span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端自己指定自己的ip地址和端口号，一般不需要，系统会自动分配</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    clientaddr.sin_addr.s_addr = inet_addr(argv[<span class="number">3</span>]); <span class="comment">//客户端的ip地址</span></span><br><span class="line">    clientaddr.sin_port = htons(atoi(argv[<span class="number">4</span>])); <span class="comment">//客户端的端口号</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：填充服务器网络信息结构体</span></span><br><span class="line">    <span class="comment">//inet_addr：将点分十进制字符串ip地址转化为整形数据</span></span><br><span class="line">    <span class="comment">//htons：将主机字节序转化为网络字节序</span></span><br><span class="line">    <span class="comment">//atoi：将数字型字符串转化为整形数据</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：进行通信</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sendto(sockfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to sendto&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> text[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, text, <span class="keyword">sizeof</span>(text), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;from server: %s\n&quot;</span>, text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第四步：关闭文件描述符</span></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>udp服务器的实现:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//udp服务器的实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons inet_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;ip&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd; <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span> <span class="comment">//服务器网络信息结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：创建套接字</span></span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：填充服务器网络信息结构体</span></span><br><span class="line">    <span class="comment">//inet_addr：将点分十进制字符串ip地址转化为整形数据</span></span><br><span class="line">    <span class="comment">//htons：将主机字节序转化为网络字节序</span></span><br><span class="line">    <span class="comment">//atoi：将数字型字符串转化为整形数据</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：将套接字与服务器网络信息结构体绑定</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第四步：进行通信</span></span><br><span class="line">        <span class="type">char</span> text[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, text, <span class="keyword">sizeof</span>(text), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s - %d]: %s\n&quot;</span>, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port), text);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">strcat</span>(text, <span class="string">&quot; *_*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sendto(sockfd, text, <span class="keyword">sizeof</span>(text), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to sendto&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：关闭文件描述符</span></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-TCP编程"><a href="#2-2-TCP编程" class="headerlink" title="2.2 TCP编程"></a>2.2 TCP编程</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/tcp.png" alt="tcp"></p><h2 id="3-ARP协议分析"><a href="#3-ARP协议分析" class="headerlink" title="3. ARP协议分析"></a>3. ARP协议分析</h2><p><code>ARP</code>协议是链路层的协议，用于拿到目标<code>IP</code>主机的<code>MAC</code>地址，例如假设我现在主机<code>A(192.168.1.1)</code> 向 <code>B(192.168.1.2)</code> 发送一个数据包，那么<code>A</code>必须知道<code>B</code>主机的<code>ip</code>，<code>port</code>，使用的协议(<code>TCP/UDP</code>，此外还需要<code>MAC</code>地址，在第一次发送时<code>A</code>并不知道<code>B</code>的<code>MAC</code>地址，因此需要先拿到<code>B</code>的<code>MAC</code>地址，这就需要使用到<code>ARP</code>协议</p><p>ARP（Address Resolution Protocol，地址解析协议）</p><ul><li><p>1、是 TCP&#x2F;IP 协议族中的一个</p></li><li><p>2、主要用于查询指定 ip 所对应的的 MAC</p></li><li><p>3、请求方使用广播来发送请求</p></li><li><p>4、应答方使用单播来回送数据</p></li><li><p>5、为了在发送数据的时候提高效率在计算中会有一个 ARP 缓存表，用来暂时存放 ip 所对应的 MAC，在 linux中使用 ARP 即可查看,在 xp 中使用 ARP -a</p></li></ul><p>考虑如下的局域网通信流程，各个主机通过交换机相连接</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221151031897.png" alt="image-20240221151031897"></p><p>先说一下交换机的功能：</p><ul><li>交换机中有一个缓存表，这个表中保存了每一端口相连设备的MAC地址，将端口和MAC地址相互对应好保存在这个缓存表中</li><li>当一个设备向另外一个设备发送数据时，发送的数据先到达交换机，交换机会根据发送数据包中的目标主机的MAC地址去缓存表中索引目标设备的端口，然后将数据转发给此端口</li><li>交换机一般工作在数据链路层</li></ul><p>ARP获取目标MAC的流程：</p><ul><li><p>主机A不知道B的MAC地址，那么主机A会先发送一个ARP广播，交换机第一次收到ARP广播时，会把ARP广播数据包转发给所有连接上的端口（除来源端口）；此时也会根据A发送的ARP数据去拿到A的MAC地址，将A插入的端口何其MAC地址对应起来保存到交换机自己的缓存表中</p></li><li><p>这样所有的主机拿到这个ARP广播后，会比对IP地址，判断A主机是否想要自己的MAC地址，此时B主机比对后发现是，就会将自己的MAC地址写入到回复的ARP数据包中，并以单播的形式先发送给交换机，然后交换机再转发给对应的主机。</p></li><li><p>为了避免下次A主机向B主机发送数据时还要再次去发送ARP数据包去向B主机获取它的MAC地址，因此在第一次获取到B的MAC地址后会将它放在一张表中存起来，这张表用来暂时存放 ip 所对应的 MAC，在 linux中使用 ARP 即可查看,在 xp 中使用 ARP -a</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221152640111.png" alt="image-20240221152640111"></p></li></ul><p>现在假设各主机之间通过路由器相连：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221161712911.png" alt="image-20240221161712911"></p><p>先说一下路由器的功能：</p><ul><li><p>交换机用于实现同网段之间设备的通信，路由器用于不同网段之间的设备的通信，路由器工作在网络层</p></li><li><p>路由器中存在两个网卡，一个用于内部局域网通信，一个用于和另外一个路由器建立连接</p></li><li><p>假设A主机想要向D主机发送数据，由于此时不在同一网段中，因此A主机会将数据包先发送给路由器，由路由器进行转发。而A主机是如何知道谁是路由器呢，这就到了默认网关出场了，每台主机在配置网络的时候需要将默认网关配置成连接的路由器的IP地址，比如A主机的默认网关地址就是<code>192.168.1.1</code>，D主机的默认网关地址就是<code>192.168.3.1</code></p></li><li><p>现在A发送的数据包到达了路由器，A想要向<code>192.168.3.0</code>这个网段发送数据，此时路由器会进行判断说将这个数据包转发到和他连接的哪一个路由器，因此需要去查表，这个表就叫做路由表，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Network: 192.168.3.0</span><br><span class="line">Mask: 255.255.255.0</span><br><span class="line">Next Hop: 192.168.2.3</span><br></pre></td></tr></table></figure><p>对于路由器1来说，路由表就如上，意味着如果路由器1要向<code>192.168.3.0</code>这个网段发送数据，那么它的下一跳的路由器的地址为<code>192.168.2.3</code>，可以看见<code>192.168.2.3</code>就代表了路由器2，而通过路由器2就能访问到D主机了</p></li></ul><h2 id="4-使用原始套接字进行网络数据分析"><a href="#4-使用原始套接字进行网络数据分析" class="headerlink" title="4. 使用原始套接字进行网络数据分析"></a>4. 使用原始套接字进行网络数据分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ether.h&gt;</span> <span class="comment">//ETH_P_ALL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERRLOG(errmsg) do&#123;\</span></span><br><span class="line"><span class="meta">                            perror(errmsg);\</span></span><br><span class="line"><span class="meta">                            exit(1);\</span></span><br><span class="line"><span class="meta">                        &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建原始套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;sockfd = %d\n&quot;, sockfd);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收数据并分析</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> msg[<span class="number">1600</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//recvfrom recv read 都可以使用</span></span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, msg, <span class="keyword">sizeof</span>(msg), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析接收到的数据包</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> type;</span><br><span class="line">        <span class="built_in">sprintf</span>(dst_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">0</span>], msg[<span class="number">1</span>], msg[<span class="number">2</span>], msg[<span class="number">3</span>], msg[<span class="number">4</span>], msg[<span class="number">5</span>]);</span><br><span class="line">        <span class="built_in">sprintf</span>(src_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">6</span>], msg[<span class="number">7</span>], msg[<span class="number">8</span>], msg[<span class="number">9</span>], msg[<span class="number">10</span>], msg[<span class="number">11</span>]);</span><br><span class="line">        type = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">12</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;源mac：%s --&gt; 目的mac：%s\n&quot;</span>, src_mac, dst_mac);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;type = %#x\n&quot;</span>, type);</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0x0800</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip数据报\n&quot;</span>);</span><br><span class="line">            <span class="comment">//头部长度、总长度</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_head_len;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> ip_len;</span><br><span class="line">            ((*(<span class="type">unsigned</span> <span class="type">char</span> *)(msg + <span class="number">14</span>)) &amp; <span class="number">0x0f</span>) * <span class="number">4</span>;</span><br><span class="line">            ip_len = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">16</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip头部：%d, ip数据报总长度: %d\n&quot;</span>, ip_head_len, ip_len);</span><br><span class="line">            <span class="comment">//目的ip地址、源IP地址</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> dst_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> src_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(src_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">26</span>], msg[<span class="number">27</span>], msg[<span class="number">28</span>], msg[<span class="number">29</span>]);</span><br><span class="line">            <span class="built_in">sprintf</span>(dst_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">30</span>], msg[<span class="number">31</span>], msg[<span class="number">32</span>], msg[<span class="number">33</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;源ip地址：%s --&gt; 目的ip地址：%s\n&quot;</span>, src_ip, dst_ip);</span><br><span class="line">            <span class="comment">//协议类型</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_type;</span><br><span class="line">            ip_type = *(msg + <span class="number">23</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip_type = %d\n&quot;</span>, ip_type);</span><br><span class="line">            <span class="comment">//icmp、igmp、tcp、udp</span></span><br><span class="line">            <span class="keyword">if</span>(ip_type == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;icmp报文\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;igmp报文\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;tcp报文\n&quot;</span>);</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> src_port;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> dst_port;</span><br><span class="line">                src_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">34</span>));</span><br><span class="line">                dst_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">36</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;源端口号：%d --&gt; 目的端口号: %d\n&quot;</span>, src_port, dst_port);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">17</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;udp报文\n&quot;</span>);</span><br><span class="line">                <span class="comment">//目的端口号、源端口号</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> src_port;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> dst_port;</span><br><span class="line">                src_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">34</span>));</span><br><span class="line">                dst_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">36</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;源端口号：%d --&gt; 目的端口号: %d\n&quot;</span>, src_port, dst_port);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">0x0806</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;arp数据报\n&quot;</span>);</span><br><span class="line">            <span class="comment">//源ip地址</span></span><br><span class="line">            <span class="comment">//目的ip地址</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> dst_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> src_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(src_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">28</span>], msg[<span class="number">29</span>], msg[<span class="number">30</span>], msg[<span class="number">31</span>]);</span><br><span class="line">            <span class="built_in">sprintf</span>(dst_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">38</span>], msg[<span class="number">39</span>], msg[<span class="number">40</span>], msg[<span class="number">41</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;源ip地址：%s --&gt; 目的ip地址：%s\n&quot;</span>, src_ip, dst_ip);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">0x8035</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rarp数据报\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码运行结果如下，在<code>root</code>模式下运行：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221210039770.png" alt="image-20240221210039770"></p><h2 id="5-使用原始套接字剖析TCP协议"><a href="#5-使用原始套接字剖析TCP协议" class="headerlink" title="5. 使用原始套接字剖析TCP协议"></a>5. 使用原始套接字剖析TCP协议</h2><p>为了更好的理解TCP协议中的三次握手与四次挥手，我们使用原始套接字来抓取一下TCP数据报，逐步分析每次握手和挥手之间的TCP数据报的变化：</p><p>我现在有两台主机，主机之间通过路由器连接：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240222155851459.png" alt="image-20240222155851459"></p><ul><li>A作为客户端，IP为：192.168.3.9，端口为系统默认分配，我们将会在A主机上运行一个客户端程序使用TCP去连接B主机</li><li>B作为服务器，IP为：192.168.3.31，端口设置为<code>10000</code>，我们会在B主机上运行一个服务器程序使用TCP去监听TCP连接</li><li>额外在A主机上运行一个网络抓包程序，用来抓取A主机发送给B主机和B主机发送给A主机的TCP数据报</li></ul><p><strong>服务器代码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [ip] [port]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：创建套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：将套接字与服务器网络信息结构体绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line">    <span class="comment">//配置本地服务器的Ip和端口号</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, addrlen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：将套接字设置为被动监听状态</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd, <span class="number">10</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：阻塞等待客户端的链接请求</span></span><br><span class="line">    <span class="type">int</span> acceptfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>((acceptfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;addrlen)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印连接的客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip:%s, port:%d\n&quot;</span>, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：进行通信</span></span><br><span class="line">    <span class="comment">//tcp服务器与客户端通信时，需要使用accept函数的返回值</span></span><br><span class="line">    <span class="type">char</span> buf[N] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(recv(acceptfd, buf, N, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to recv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;from client: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(buf, <span class="string">&quot; *_*&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(send(acceptfd, buf, N, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to send&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字文件描述符</span></span><br><span class="line">    close(acceptfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [ip] [port]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;FAIL to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen =<span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line"></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr ,addrlen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[N] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    fgets(buf , N ,<span class="built_in">stdin</span>);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sockfd , buf , N , <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;faild to send&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> text[N] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(recv(sockfd , text, N , <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to recv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;from server: %s\n&quot;</span>, text);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>网络抓包代码</strong>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ether.h&gt;</span> <span class="comment">//ETH_P_ALL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERRLOG(errmsg) do&#123;\</span></span><br><span class="line"><span class="meta">                            perror(errmsg);\</span></span><br><span class="line"><span class="meta">                            exit(1);\</span></span><br><span class="line"><span class="meta">                        &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建原始套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收数据并分析</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> msg[<span class="number">1600</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//recvfrom recv read 都可以使用</span></span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, msg, <span class="keyword">sizeof</span>(msg), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析接收到的数据包</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> type;</span><br><span class="line">        <span class="built_in">sprintf</span>(dst_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">0</span>], msg[<span class="number">1</span>], msg[<span class="number">2</span>], msg[<span class="number">3</span>], msg[<span class="number">4</span>], msg[<span class="number">5</span>]);</span><br><span class="line">        <span class="built_in">sprintf</span>(src_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">6</span>], msg[<span class="number">7</span>], msg[<span class="number">8</span>], msg[<span class="number">9</span>], msg[<span class="number">10</span>], msg[<span class="number">11</span>]);</span><br><span class="line">        type = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">12</span>));</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0x0800</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//头部长度、总长度</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_head_len;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> ip_len;</span><br><span class="line">            ((*(<span class="type">unsigned</span> <span class="type">char</span> *)(msg + <span class="number">14</span>)) &amp; <span class="number">0x0f</span>) * <span class="number">4</span>;</span><br><span class="line">            ip_len = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">16</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//目的ip地址、源IP地址</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> dst_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> src_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(src_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">26</span>], msg[<span class="number">27</span>], msg[<span class="number">28</span>], msg[<span class="number">29</span>]);</span><br><span class="line">            <span class="built_in">sprintf</span>(dst_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">30</span>], msg[<span class="number">31</span>], msg[<span class="number">32</span>], msg[<span class="number">33</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//协议类型</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_type;</span><br><span class="line">            ip_type = *(msg + <span class="number">23</span>);</span><br><span class="line">            <span class="keyword">if</span>(ip_type == <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> src_port;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> dst_port;</span><br><span class="line">                src_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">34</span>));</span><br><span class="line">                dst_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">36</span>));</span><br><span class="line">                <span class="keyword">if</span>(dst_port == <span class="number">10000</span> || src_port==<span class="number">10000</span>)&#123;</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">char</span> flag = msg[<span class="number">47</span>] &amp; <span class="number">0x3f</span>;</span><br><span class="line">                    <span class="type">int</span> ACK = flag &gt;&gt; <span class="number">4</span> &amp; <span class="number">0x1</span>; </span><br><span class="line">                    <span class="type">int</span> SYN = flag &gt;&gt; <span class="number">1</span> &amp; <span class="number">0x1</span>;</span><br><span class="line">                    <span class="type">int</span> FIN = flag &amp; <span class="number">0x1</span>;</span><br><span class="line">                    <span class="type">uint32_t</span> seq = ntohl(*(<span class="type">uint32_t</span> *)(msg + <span class="number">38</span>));</span><br><span class="line">                    <span class="type">uint32_t</span> actual_seq = ntohl(*(<span class="type">uint32_t</span> *)(msg + <span class="number">42</span>));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;----------------tcp报文----------------\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;源端口号：%d --&gt; 目的端口号: %d\n&quot;</span>, src_port, dst_port);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;源ip地址：%s --&gt; 目的ip地址：%s\n&quot;</span>, src_ip, dst_ip);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ip头部：%d, ip数据报总长度: %d\n&quot;</span>, ip_head_len, ip_len);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ACK: %d SYN: %d SEQ: %u ASEQ: %u FIN: %d\n &quot;</span>,ACK,SYN,seq ,actual_seq,FIN);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于A主机来说，我们抓取目标为目标端口为<code>10000</code>或者发送端口为<code>10000</code>的TCP数据报，其他的全部舍弃，目标端口为<code>10000</code>的TCP数据报是A发送给B的，发送端口为<code>10000</code>的是B主机发送给A的</p><p>先启动服务器程序，再启动客户端程序，三次握手的结果如下，</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240222195612633.png" alt="image-20240222195612633"></p><p>很清晰的说明了三次握手的过程：上图中的<code>ASEQ</code>就是<code>ack</code>确认序号</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240222195914907.png" alt="image-20240222195914907"></p><ul><li><p>在理解三次握手，四次挥手之前，我们先理解两个很重要的概念：</p><p>在下面这张图中代表了一帧TCP数据包</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/tcp-170852003743213.png" alt="tcp"></p><ul><li><code>seq,序列号</code>：代表了发送的数据字节数，在一帧TCP数据包中发送的每一个字节都会计数；这里的数据指的是上图中给哪个进程中的数据，不包含TCP头中的字节，在我们进行握手或者挥手时，发送的字节数据数为0，因此<code>seq</code>理论上是不会增加的，但是由于我们在握手和挥手的过程中<code>FIN</code>、<code>SYN</code>状态码是会发生改变的，因此TCP协议规定这两个状态码发生改变时就当多了一字节的数据，因此<code>seq+1</code>;<code>seq</code>代表的本机发送的字节数，<code>seq</code>的增加与否只与本机发送的数据有关，和接收到的数据无关</li><li><code>ack，确认序列号</code>：这个<code>ack</code>和状态码中全部大写的<code>ACK</code>不一样，这里代表确认号，确认号只与接收到的数据的字节数有关，如果对方发送的TCP数据包中有数据，则这个<code>ack</code>的值等于上次<code>ack</code>的值加上收到的数据的字节数，同样如果接收到的数据包的<code>FIN</code>、<code>SYN</code>状态码发生了改变<code>ack</code>会相应的加一，</li></ul></li><li><p>第一次握手：</p><ul><li>客户端请求建立连接，将<code>SYN</code>置为<code>1</code>，<code>ACK</code>为<code>0</code>，然后随机生成一个<code>seq=1490486468</code>，<code>ack=0</code></li></ul></li><li><p>第二次握手：服务器给客户端回复数据</p><ul><li>服务器在收到客户端发送的第一次握手信息后，会先检查<code>SYN</code>是否为<code>1</code>，如果为<code>1</code>，将<code>ACK=1</code>，向客户端请求建立连接，因此<code>SYN=1</code>，然后随机生成一个<code>seq=4013990024</code>，将收到的<code>seq+1</code>放在<code>ack</code>中，此时<code>ack=1490486469</code>，然后打包发给客户端</li><li>客户端检测服务器发送来的请求信息，先判断<code>ACK</code>和<code>SYN</code>是否等于1，<code>ACK=1</code>代表服务器同意了客户端的连接请求，<code>SYN=1</code>代表服务器想要同客户端建立连接。此时对于客户端来说由于上次的<code>seq=1490486468</code>，然后上次发送了<code>SYN</code>，上面提到<code>SYN</code>代表发送了一个字节，因此下次发送的序列号为<code>seq = 1490486468 + 1 = 1490486469</code>，</li></ul></li><li><p>第三次握手：客户端发送数据给服务器</p><ul><li>客户端将<code>ACK</code>标志位置为1，代表同意了服务器的连接请求，服务器发送过来的数据的<code>seq = 4013990024</code>，同样由于服务器改变了<code>SYN</code>状态码，代表发送了一个字节过来，因此客户端发送给服务器的确认码为<code>ack 4013990024+1=4013990025</code></li><li>服务器端查看ACK对应的标志位是否为1, 如果是1代表, 客户端同意了服务器的连接请求，然后校验确认序号是否等于生成的随意序号+1，然后拿到客户端的发送序号</li></ul></li></ul><p>三次握手完成之后，客户端和服务器都变成了同一种状态，这种状态叫：ESTABLISHED，表示双向连接已经建立， 可以通信了。在通过过程中，正常的通信状态就是 ESTABLISHED。在我们的程序中，客户端会先向服务器写入数据，服务器拿到数据后会回复客户端确认收到数据，然后再向客户端发送数据，发送完毕后，就直接关闭连接</p><p>观察数据发送和四次挥手我们使用<code>Wireshark</code>抓包来看一下：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223111923750.png" alt="image-20240223111923750"></p><ul><li>前三帧数据就是三次握手的过程，然后客户端向服务器发送了数据，看第四帧的数据，发送的数据的长度为<code>128</code>，此时客户端的<code>seq = 1 ， ack = 1</code>，然后服务器接收到了数据，此时服务器接收到了发送来的<code>128</code>字节数据，</li><li><code>TCP</code>协议规定接收方在接收到数据后，需要应答发送方，发送发如果一直没收到接收方的应答，则代表此次发送数据出现了丢包，那发送方会重发数据，因此在第四帧客户端向无服务发送数据后，需要应答客户端，即第五帧数据，回复的确认号<code>ack = 128 + 1 =129</code>，发送方根据这个确认号就知道接收方成功接收到数据了</li></ul><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223115646850.png" alt="image-20240223115646850"></p><ul><li>然后第六帧数据，服务器向客户端发送数据，数据长度为128，发送给客户端后理论上客户端应该回复一帧说我已经收到了的数据包，但是由于服务器在发送完毕这128字节数据后立马执行了<code>close</code>操作去断开连接，导致了一些很奇怪的操作，因此好像看着并没有回复此帧</li></ul><p>接下来看四次挥手的过程：</p><ul><li><p>服务器和客户端都可以主动发起断开连接，在我们的代码中是服务器发起的断开连接</p></li><li><p>第一次挥手：服务器会将<code>FIN</code>置为1，然后发送给客户端去告诉客户端我想要断开连接了  </p></li><li><p>第二次挥手：客户端发现了服务器此次请求，因此<code>FIN</code>的改变占用一个字节因此回复的<code>ack = 129 + 1 = 130</code>，然后发送给服务器，服务器得到此数据包检查确认序号知道客户端同意了断开连接，进入等待</p></li><li><p>第三次挥手：客户端将<code>FIN</code>置为1去发送给服务器告诉服务器它想要断开连接</p></li><li><p>第四次挥手：服务器检查客户端发送的<code>FIN</code>的值，然后同意客户端断开连接，此时是服务器第二次发送数据因此<code>seq = 129 + 1 =130</code>，客户端的发送序号为<code>129</code>，然后客户端将<code>FIN</code>置为了1，因此此时<code>ack = 129 + 1 =130</code></p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223121923843.png" alt="image-20240223121923843"></p></li><li><p>根据<code>Wireshark</code>的抓包结果显示，最后四帧明显是四次挥手的过程，但实际上不然，我们看见似乎是少了一帧数据，三次握手三帧，客户端发送 + 服务器应答 2帧，服务器发送+客户端应答 2 帧，四次挥手四帧，总共应该是11帧，但实际上只有10帧</p></li><li><p>理论上第8帧中客户端执行第2次挥手时回复的<code>ack</code>应该是130才对，但是确回复的<code>ack</code>是<code>129 = 128 +1</code>，因此我们可以猜测第九帧实际上是用于回复上次服务器发送来的<code>128</code>自己的数据，而不是四次挥手中的第二次挥手，而客户端将第二次挥手和第三次挥手合并成了一帧数据发送，即第9帧。</p></li><li><p>这是由什么原因引起的，问题在于服务器在第6帧向客户端发送数据后，立刻执行了<code>close</code>操作，去发起断开连接，即第7帧，客户端先收到了这两帧数据，因此客户端先回复服务器收到了数据，然后再去应答断开连接的请求</p></li><li><p>我们修改一下服务器的代码，在<code>close</code>之前添加一个延时操作，再使用<code>Wireshark</code>，抓包</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223120541936.png" alt="image-20240223120541936"></p></li></ul><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223123938843.png" alt="image-20240223123938843"></p><ul><li>可以看见此时就有11帧数据了，此时是由客户端先发起的断开连接请求，因此服务器再向客户端发送数据后没有立即执行断开连接操作，因此客户端有时间去先执行应答，然后去向服务器申请断开连接</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/UDP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-对象池</title>
      <link href="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-FOR-EACH-宏实现"><a href="#1-FOR-EACH-宏实现" class="headerlink" title="1. FOR_EACH 宏实现"></a>1. FOR_EACH 宏实现</h2><p>代码目录：<code>cyber/base/for_each.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasLess, <span class="keyword">operator</span>&lt;)  <span class="comment">// NOLINT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">End</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;HasLess&lt;Value&gt;::value &amp;&amp; HasLess&lt;End&gt;::value,</span><br><span class="line">                        <span class="type">bool</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">LessThan</span><span class="params">(<span class="type">const</span> Value&amp; val, <span class="type">const</span> End&amp; end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &lt; end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">End</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasLess&lt;Value&gt;::value || !HasLess&lt;End&gt;::value,</span><br><span class="line">                        <span class="type">bool</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">LessThan</span><span class="params">(<span class="type">const</span> Value&amp; val, <span class="type">const</span> End&amp; end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val != end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR_EACH(i, begin, end)           \</span></span><br><span class="line"><span class="meta">  for (auto i = (true ? (begin) : (end)); \</span></span><br><span class="line"><span class="meta">       apollo::cyber::base::LessThan(i, (end)); ++i)</span></span><br></pre></td></tr></table></figure><p>我们先看看这个宏的用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, <span class="number">100</span>) &#123; vec.<span class="built_in">push_back</span>(i); &#125;</span><br><span class="line"><span class="built_in">FOR_EACH</span>(it, vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()) &#123; std::cout&lt;&lt;*it&lt;&lt;std::endl; &#125;</span><br></pre></td></tr></table></figure><p>简单来说就是用于对不同类型的数据进行遍历操作：</p><p><code>DEFINE_TYPE_TRAIT(HasLess, operator&lt;) </code>这个<code>trait</code>操作是保证传进来的<code>begin</code>和<code>end</code>类型重载了<code>&lt;</code>，</p><p><code>for</code>循环里会去调用<code>LessThan</code>函数，<code>LessThan</code>函数的两个模板参数就是<code>begin</code>所代表的类型和<code>End</code>所代表的类型。</p><p>当<code>HasLess&lt;Value&gt;::value &amp;&amp; HasLess&lt;End&gt;::value</code>满足时，才会走第一个模板函数，将会对<code>val</code>和<code>end</code>的值进行比较，函数返回值为<code>bool</code>类型，</p><p>当<code>Value</code>或者<code>End</code>其中任意一个类型不具有<code>&lt;</code>的重载则会走第二个模板函数，函数内部会对这两个值进行判断是否是相等</p><p>如果用户在使用时提供的类型既不支持 <code>&lt;</code> 运算符，也不支持 <code>!=</code> 运算符，那么在编译时将会导致错误。</p><h2 id="2-对象池的实现"><a href="#2-对象池的实现" class="headerlink" title="2. 对象池的实现"></a>2. 对象池的实现</h2><p>源码目录：<code>cyber/base/object_pool.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPool</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;ObjectPool&lt;T&gt;&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> InitFunc = std::function&lt;<span class="built_in">void</span>(T *)&gt;;</span><br><span class="line">  <span class="keyword">using</span> ObjectPoolPtr = std::shared_ptr&lt;ObjectPool&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ObjectPool</span><span class="params">(<span class="type">uint32_t</span> num_objects, Args &amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ObjectPool</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 拿到一个对象*/</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">GetObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T object;</span><br><span class="line">    Node *next;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/*禁用拷贝构造*/</span></span><br><span class="line">  <span class="built_in">ObjectPool</span>(ObjectPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ObjectPool &amp;<span class="keyword">operator</span>=(ObjectPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReleaseObject</span><span class="params">(T *)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> num_objects_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> *object_arena_ = <span class="literal">nullptr</span>;</span><br><span class="line">  Node *free_head_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">f</span>(obj);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::~<span class="built_in">ObjectPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">    <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object_arena_ + i * size)-&gt;object.~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(object_arena_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ObjectPool&lt;T&gt;::<span class="built_in">ReleaseObject</span>(T *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(object == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object)-&gt;next = free_head_;</span><br><span class="line">  free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ObjectPool&lt;T&gt;::<span class="built_in">GetObject</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(free_head_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> self = <span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">auto</span> obj =</span><br><span class="line">      std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="built_in">reinterpret_cast</span>&lt;T *&gt;(free_head_),</span><br><span class="line">                         [self](T *object) &#123; self-&gt;<span class="built_in">ReleaseObject</span>(object); &#125;);</span><br><span class="line">  free_head_ = free_head_-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">f</span>(obj);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::~<span class="built_in">ObjectPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">    <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object_arena_ + i * size)-&gt;object.~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(object_arena_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ObjectPool&lt;T&gt;::<span class="built_in">ReleaseObject</span>(T *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(object == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object)-&gt;next = free_head_;</span><br><span class="line">  free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ObjectPool&lt;T&gt;::<span class="built_in">GetObject</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(free_head_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> self = <span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">auto</span> obj =</span><br><span class="line">      std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="built_in">reinterpret_cast</span>&lt;T *&gt;(free_head_),</span><br><span class="line">                         [self](T *object) &#123; self-&gt;<span class="built_in">ReleaseObject</span>(object); &#125;);</span><br><span class="line">  free_head_ = free_head_-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向对象池中传递目标的类型和构建目标的参数，用<code>T</code>和<code> ... Args</code>来进行传递，在构造函数内部首先计算了一个<code>Node</code>的大小，然后分配<code>num_objects</code>个<code>node</code>大小的内存作为目标池来管理，根据这个<code>node</code>的定义我们可以知道对象池管理对象时是以链表的方式将各个链表链接起来的，再分配完毕内存后，通过<code>FOR_EACH</code>来在指定的地址处创建对象，然后让创建的这个对象的指针指向<code>free_head_</code></p><p>还有另外一个构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">f</span>(obj);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造和上一个的区别在于多了一个参数<code>InitFunc f</code>，允许在构造对象池的时候提供一个操作对象的函数，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> InitFunc = std::function&lt;<span class="built_in">void</span>(T *)&gt;;</span><br></pre></td></tr></table></figure><p><code>InitFunc</code>是一个可调用对象，此对象的返回值是<code>void</code>，需要的参数是<code>T *</code>类型，所以在构造对象池的时候使用<code>f(obj);</code>来操作了对象</p><p><img src="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/image-20231202110144511.png" alt="image-20231202110144511"></p><p>接着来看看释放一个对象的操作，释放对象就是将一个对象重新放入对象池中：然后更新<code>free_head</code>的值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ObjectPool&lt;T&gt;::<span class="built_in">ReleaseObject</span>(T *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(object == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object)-&gt;next = free_head_;</span><br><span class="line">  free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/image-20231202111140335.png" alt="image-20231202111140335"></p><p>最后是拿到一个对象的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ObjectPool&lt;T&gt;::<span class="built_in">GetObject</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(free_head_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> self = <span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">auto</span> obj =</span><br><span class="line">      std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="built_in">reinterpret_cast</span>&lt;T *&gt;(free_head_),</span><br><span class="line">                         [self](T *object) &#123; self-&gt;<span class="built_in">ReleaseObject</span>(object); &#125;);</span><br><span class="line">  free_head_ = free_head_-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过<code>std::shared_ptr&lt;T&gt; ptr(pointer, deleter);</code>来得到这个<code>obj</code>，第二个参数即是智能指针管理的这个对象的引用计数归零时将要执行的操作，这里就是说当<code>obj</code>的引用计数归零时，让此对象重新返回对象池，所以传入的可调用对象的形式是一个lamada函数：<code> [self](T *object) &#123; self-&gt;ReleaseObject(object); &#125;</code>，然后更新<code>free_head_</code></p><p>所以从对象池中拿对象从<code>arena</code>的高地址处<code>free_head_</code>开始拿，释放也是如此，将一个对象插入到<code>free_head_</code>之后，然后更新<code>free_head_</code></p><p>最后是析构函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::~<span class="built_in">ObjectPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">    <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object_arena_ + i * size)-&gt;object.~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(object_arena_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历调用对象的自己析构函数，然后释放<code>arena</code>这块内存</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/sinat_31608641/article/details/120692775">__builtin_expect函数-CSDN博客</a></li><li><a href="https://www.cnblogs.com/-citywall123/p/12726552.html">C++对象池的实现和原理 - 知道了呀~ - 博客园 (cnblogs.com)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 对象池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-无锁哈希表</title>
      <link href="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h2><p>源码目录：<code>cyber/base/atomic_hash_map.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief A implementation of lock-free fixed size hash map</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @tparam K Type of key, must be integral</span></span><br><span class="line"><span class="comment"> * @tparam V Type of value</span></span><br><span class="line"><span class="comment"> * @tparam 128 Size of hash table</span></span><br><span class="line"><span class="comment"> * @tparam 0 Type traits, use for checking types of key &amp; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, std::<span class="type">size_t</span> TableSize = <span class="number">128</span>,</span><br><span class="line">          <span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;K&gt;::value &amp;&amp;</span><br><span class="line">                                      (TableSize &amp; (TableSize - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                                  <span class="type">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> AtomicHashMap &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>() : <span class="built_in">capacity_</span>(TableSize), <span class="built_in">mode_num_</span>(capacity_ - <span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  AtomicHashMap &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Has</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Get</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V *value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    V *val = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">bool</span> res = table_[index].<span class="built_in">Get</span>(key, &amp;val);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      *value = *val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, V &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, std::forward&lt;V&gt;(value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="built_in">Entry</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entry</span><span class="params">(K key)</span> : key(key) &#123;</span></span><br><span class="line">      value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(), std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entry</span>(K key, <span class="type">const</span> V &amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">      value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(value), std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entry</span>(K key, V &amp;&amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">      value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(std::forward&lt;V&gt;(value)), std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entry</span>() &#123; <span class="keyword">delete</span> value_ptr.<span class="built_in">load</span>(std::memory_order_acquire); &#125;</span><br><span class="line"></span><br><span class="line">    K key = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;V *&gt; value_ptr = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    std::atomic&lt;Entry *&gt; next = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Bucket</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bucket</span>() : <span class="built_in">head_</span>(<span class="keyword">new</span> <span class="built_in">Entry</span>()) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Bucket</span>() &#123;</span><br><span class="line">      Entry *ite = head_;</span><br><span class="line">      <span class="keyword">while</span> (ite) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = ite-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">delete</span> ite;</span><br><span class="line">        ite = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">      Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;key &lt; key) &#123;</span><br><span class="line">          m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> target-&gt;key == key;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(K key, Entry **prev_ptr, Entry **target_ptr)</span> </span>&#123;</span><br><span class="line">      Entry *prev = head_;</span><br><span class="line">      Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;key == key) &#123;</span><br><span class="line">          *prev_ptr = prev;</span><br><span class="line">          *target_ptr = target;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;key &gt; key) &#123;</span><br><span class="line">          *prev_ptr = prev;</span><br><span class="line">          *target_ptr = target;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prev = target;</span><br><span class="line">          m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      *prev_ptr = prev;</span><br><span class="line">      *target_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">      V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">          <span class="comment">// key exists, update value</span></span><br><span class="line">          <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">            new_value = <span class="keyword">new</span> <span class="built_in">V</span>(value);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                  old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">                  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">            <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_entry;</span><br><span class="line">              new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">            new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key, value);</span><br><span class="line">          &#125;</span><br><span class="line">          new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">          <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                                 std::memory_order_acq_rel,</span><br><span class="line">                                                 std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// Insert success</span></span><br><span class="line">            <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_value;</span><br><span class="line">              new_value = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key, V &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">      V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">          <span class="comment">// key exists, update value</span></span><br><span class="line">          <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">            new_value = <span class="keyword">new</span> <span class="built_in">V</span>(std::forward&lt;V&gt;(value));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                  old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">                  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">            <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_entry;</span><br><span class="line">              new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">            new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key, value);</span><br><span class="line">          &#125;</span><br><span class="line">          new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">          <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                                 std::memory_order_acq_rel,</span><br><span class="line">                                                 std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// Insert success</span></span><br><span class="line">            <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_value;</span><br><span class="line">              new_value = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">      V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">          <span class="comment">// key exists, update value</span></span><br><span class="line">          <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">            new_value = <span class="keyword">new</span> <span class="built_in">V</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                  old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">                  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">            <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_entry;</span><br><span class="line">              new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">            new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key);</span><br><span class="line">          &#125;</span><br><span class="line">          new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">          <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                                 std::memory_order_acq_rel,</span><br><span class="line">                                                 std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// Insert success</span></span><br><span class="line">            <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_value;</span><br><span class="line">              new_value = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">        *value = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry *head_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Bucket table_[TableSize];</span><br><span class="line">  <span class="type">uint64_t</span> capacity_;</span><br><span class="line">  <span class="type">uint64_t</span> mode_num_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-无锁哈希表的实现"><a href="#2-无锁哈希表的实现" class="headerlink" title="2. 无锁哈希表的实现"></a>2. 无锁哈希表的实现</h2><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在存储器存储位置的数据结构。 也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。 这个映射函数称做散列函数，存放记录的数组称做散列表。</p><p>给定一个键值<code>K</code>，通过一个函数计算出了这个<code>K</code>在内存中对应值的存储位置，那个这个函数就被称为哈希函数：</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/20210517094111543.png" alt="关键字和存储地址之间的对应关系"></p><p>这里举个例子：</p><p>假如我们一共有 50 人参加学校的数学竞赛，然后我们为每个学生分配一个编号，依次是 1 到 50.</p><p>如果我们想要快速知道编号对应学生的信息，我们就可以用一个数组来存放学生的信息，编号为 1 的放到数组下标为 1 的位置，编号为 2 的放到数组下标为 2 的位置，依次类推。</p><p>现在如果我们想知道编号为 20 的学生的信息，我们只需要把数组下标为 20 的元素取出来就可以了，时间复杂度为 O(1)，是不是效率非常高呢。</p><p>但是这些学生肯定来自不同的年级和班级，为了包含更详细的信息，我们在原来编号前边加上年级和班级的信息，比如 030211 ，03 表示年级，02 表示班级，11 原来的编号，这样我们该怎么存储学生的信息，才能够像原来一样使用下标快速查找学生的信息呢？</p><p>思路还是和原来一样，我们通过编号作为下标来储存，但是现在编号多出了年级和班级的信息怎么办呢，我们只需要截取编号的后两位作为数组下标来储存就可以了。</p><p>这个过程就是典型的散列思想。其中，参赛学生的编号我们称之为键(key)，我们用它来标识一个学生。然后我们通过一个方法（比如上边的截取编号最后两位数字）把编号转变为数组下标，这个方法叫做散列函数（哈希函数），通过散列函数得到的值叫做散列值（哈希值）</p><p>我们自己在设计散列函数的函数时应该遵循什么规则呢？</p><ol><li>得到的散列值是一个非负整数</li><li>两个相同的键，通过散列函数计算出的散列值也相同</li><li>两个不同的键，计算出的散列值不同</li></ol><p>虽然我们在设计的时候要求满足以上三条要求，但对于第三点很难保证所有不同的建都被计算出不同的散列值。有可能不同的建会计算出相同的值，这叫做哈希冲突。为了解决这个冲突，可以将散列函数计算得到相同值得<code>key</code>放到同一个链表中，这也是<code>CyberRt</code>中散列表的做法：</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130123005161.png" alt="image-20231130123005161"></p><p>因此散列表就是一个数组，只不过数组中的每个元素都是一个链表，这个链表我们称为一个<code>Bucket</code>，就是一个篮子。<code>Bucket</code>中链表的节点我们用<code>Entry</code>来进行描述。</p><p>我们先来看<code>Entry</code>的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">  <span class="built_in">Entry</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Entry</span><span class="params">(K key)</span> : key(key) &#123;</span></span><br><span class="line">    value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(), std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Entry</span>(K key, <span class="type">const</span> V &amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">    value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(value), std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Entry</span>(K key, V &amp;&amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">    value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(std::forward&lt;V&gt;(value)), std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Entry</span>() &#123; <span class="keyword">delete</span> value_ptr.<span class="built_in">load</span>(std::memory_order_acquire); &#125;</span><br><span class="line"></span><br><span class="line">  K key = <span class="number">0</span>;</span><br><span class="line">  std::atomic&lt;V *&gt; value_ptr = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  std::atomic&lt;Entry *&gt; next = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个<code>Entry</code>存储了一个数据指针和指向下一个<code>Entry</code>的指针，他们都是原子变量，在这份源码中，定义说这个键的类型必须为整形，因此<code>K key = 0</code>，里面提供了四个构造函数。</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130125814591.png" alt="image-20231130125814591"></p><p>然后是<code>Bucket</code>的定义：<code>Bucket</code>是一个链表，对链表中的每一个节点的操作都是原子的。</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130135128856.png" alt="image-20231130135128856"></p><p>在散列表中放入键值后，散列表就长下面这样子了：哈希值相同的键放在同一个<code>Bucket</code>里，同一个<code>Bucket</code>中键的排列依次往下接就行</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130140811197.png" alt="image-20231130140811197"></p><ul><li><p>在<code>Bucket</code>中查找<code>key</code>：根据<code>key</code>挨个对<code>Entry</code>中的<code>key</code>值进行比较，如果找到了就返回<code>true</code>，没找到就返回<code>false</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">  Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;key &lt; key) &#123;</span><br><span class="line">      m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target-&gt;key == key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Bucket</code>中查找<code>key</code>对应的那个<code>Entry</code>：从头节点开始遍历，只要<code>m_target</code>不是<code>null_ptr</code>，循环就会继续执行，如果有对应的<code>key</code>值，将通过<code>prev_ptr</code>和<code>target_ptr</code>参数返回查找结果。<code>prev_ptr</code>和<code>target_ptr</code>都是二级指针，都指向了一个<code>Entry*</code>。如果<code>target</code>指向的那个<code>Entry</code>中的<code>key</code>值大于传入的这个<code>key</code>值，同时又不相等，说明这个<code>key</code>值的大小位于<code>prev</code>和<code>target</code>之间，从这里我们可以猜测，拥有相同哈希值的<code>key</code>在同一个<code>Bucket</code>中的排列是按照从小到大的顺序排的</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130144538014.png" alt="image-20231130144538014"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(K key, Entry **prev_ptr, Entry **target_ptr)</span> </span>&#123;</span><br><span class="line">  Entry *prev = head_;</span><br><span class="line">  Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;key == key) &#123;</span><br><span class="line">      *prev_ptr = prev;</span><br><span class="line">      *target_ptr = target;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;key &gt; key) &#123;</span><br><span class="line">      *prev_ptr = prev;</span><br><span class="line">      *target_ptr = target;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev = target;</span><br><span class="line">      m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *prev_ptr = prev;</span><br><span class="line">  *target_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Bucket</code>中根据键值插入对应的<code>value</code>:首先调用上面的<code>find</code>函数去查找<code>Bucket</code>中是否存在<code>key</code>，如果存在则新建一个<code>value</code>，然后通过cas操作去修改此<code>Entry</code>中的<code>value</code>值。如果在<code>Bucket</code>中没有找到这个<code>key</code>，说明需要新建一个<code>Entry</code>，需要将这个<code>new_entry</code>插入到<code>prev</code>和<code>target</code>之间，这里也是原子操作。其余两个插入函数同理，只是入参不一样。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">  Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">  Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">  Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">  V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">      <span class="comment">// key exists, update value</span></span><br><span class="line">      <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">        new_value = <span class="keyword">new</span> <span class="built_in">V</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">              old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">              std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">        <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">          <span class="keyword">delete</span> new_entry;</span><br><span class="line">          new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">        new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">      new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">      <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                             std::memory_order_acq_rel,</span><br><span class="line">                                             std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">// Insert success</span></span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">          <span class="keyword">delete</span> new_value;</span><br><span class="line">          new_value = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后是根据<code>key</code>值拿到<code>value</code>的函数，也是通过<code>Find</code>函数去找，如果找到了则赋值，没找到就返回<code>false</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">  Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">  Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">    *value = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>有了<code>Entry</code>和<code>Bucket</code>之后我们来看一下<code>AtomicHashMap</code>的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, std::<span class="type">size_t</span> TableSize = <span class="number">128</span>,</span><br><span class="line">          <span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;K&gt;::value &amp;&amp;</span><br><span class="line">                                      (TableSize &amp; (TableSize - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                                  <span class="type">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> AtomicHashMap &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>() : <span class="built_in">capacity_</span>(TableSize), <span class="built_in">mode_num_</span>(capacity_ - <span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  AtomicHashMap &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Has</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Get</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V *value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    V *val = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">bool</span> res = table_[index].<span class="built_in">Get</span>(key, &amp;val);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      *value = *val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, V &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, std::forward&lt;V&gt;(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  Bucket table_[TableSize];</span><br><span class="line">  <span class="type">uint64_t</span> capacity_;</span><br><span class="line">  <span class="type">uint64_t</span> mode_num_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先模板操作就很有意思:</p><ul><li><code>&lt;typename K, typename V, std::size_t TableSize = 128, ...&gt;</code>: 定义模板的参数列表。<code>K</code> 和 <code>V</code> 是模板的键和值类型，<code>TableSize</code> 是哈希表的大小，默认为 128。</li><li><code>typename std::enable_if&lt;...&gt;::type = 0</code>: 使用 <code>std::enable_if</code> 实现模板的部分特化。这里检查是否 <code>K</code> 是整数类型（<code>std::is_integral&lt;K&gt;::value</code>）并且 <code>TableSize</code> 是 2 的幂（<code>(TableSize &amp; (TableSize - 1)) == 0</code>）。如果条件为真，则模板参数 <code>int</code> 被设置为 0，否则，此模板不可用。</li><li>这里也是用到了c++的<code>SFINAE</code>特性</li></ul><blockquote><p><code>TableSize &amp; (TableSize - 1)</code> 是一个位运算操作，用于检查一个数是否是2的幂。</p><ul><li>如果一个数是2的幂，那么它的二进制表示中只有一个位是1，其余位都是0。</li><li>如果减去1，所有的1都变成0，而低位的0都变成1。</li></ul><p>通过使用按位与（<code>&amp;</code>）操作，只有在两个相应的位都是1时结果才是1。因此，如果 <code>TableSize</code> 是2的幂，那么 <code>TableSize &amp; (TableSize - 1)</code> 将等于0。</p><p>这个检查在哈希表的实现中经常用来确保哈希表的大小是2的幂，这有助于提高散列函数的效果，使得键在哈希表中更均匀地分布。</p></blockquote><p><code>AtomicHashMap</code>类的内部定义了一个<code>Bucket table_[TableSize]</code>的数组，哈希函数其实就是线性的取余，里面对哈希表的操作也比较简单，就是先去根据键的值取余去拿到对应的<code>Bucket</code>，然后再去<code>Buket</code>中操作</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/Peealy/article/details/116895964">一文看懂哈希表并学会使用C++ STL 中的哈希表_哈希表end函数-CSDN博客</a></li><li><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp16.html">实现线程安全的查找表 · 恋恋风辰的编程笔记 (llfc.club)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-线程池</title>
      <link href="/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h2><p>在<code>cyber/base/thread_pool.h</code>中实现了一个线程池的类，写得很高级，我们来分析一下，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(std::<span class="type">size_t</span> thread_num, std::<span class="type">size_t</span> max_task_num = <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">      -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">  BoundedQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; task_queue_;</span><br><span class="line">  std::atomic_bool stop_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数入参为 线程数量和最大任务数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(std::<span class="type">size_t</span> threads, std::<span class="type">size_t</span> max_task_num)</span></span></span><br><span class="line"><span class="function">    : stop_(false) &#123;</span></span><br><span class="line">  <span class="comment">/*创建一个BoundedQueue，采用的等待策略是阻塞策略*/</span></span><br><span class="line">  <span class="keyword">if</span> (!task_queue_.<span class="built_in">Init</span>(max_task_num, <span class="keyword">new</span> <span class="built_in">BlockWaitStrategy</span>())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue init failed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化线程池 创建空的任务，每个任务的逻辑就是 */</span></span><br><span class="line">  workers_.<span class="built_in">reserve</span>(threads);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">    workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">while</span> (!stop_) &#123;</span><br><span class="line">        <span class="comment">/*返回值为空的可调用对象*/</span></span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">if</span> (task_queue_.<span class="built_in">WaitDequeue</span>(&amp;task)) &#123;</span><br><span class="line">          <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before using the return value, you should check value.valid()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::Enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">      std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">  std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">  <span class="keyword">if</span> (stop_) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">future</span>&lt;return_type&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">Enqueue</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="comment">/* 唤醒线程池里所有线程，然后等待所有子线程执行完毕，释放资源*/</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (stop_.<span class="built_in">exchange</span>(<span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">BreakAllWait</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::thread&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-线程池的实现"><a href="#2-线程池的实现" class="headerlink" title="2. 线程池的实现"></a>2. 线程池的实现</h2><p>线程池是一种多线程处理形式，它处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。</p><p> 首先先来看一下线程池的模型：</p><p><img src="/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20231129165547298.png" alt="image-20231129165547298"></p><p>线程池中有两个队列，一个工作队列，这就是线程池维护的线程队列，另一个是任务队列，工作队列中的线程去任务队列中领取任务从而执行，空闲的线程呢则等待直到任务队列有任务可获取。</p><p>基于此我们来看<code>ThreadPool</code>类中定义的成员变量：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">BoundedQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; task_queue_;</span><br><span class="line">std::atomic_bool stop_;</span><br></pre></td></tr></table></figure><ul><li>工作队列的数据结构是<code>vector</code>类型，就是一个数组，数组中的每一个元素都是一个<code>std::thread</code></li><li>任务队列的数据结构是前面实现的<code> BoundedQueue</code>，<code> BoundedQueue</code>中的每一个元素都是c++中的一个可调用对象：<code>std::function&lt;void()&gt;</code>，是一个返回值为空，参数列表也为空的可调用对象</li><li>还有一个原子变量用于判断线程池是否还在工作</li></ul><p>然后来看线程池的构造函数：传入的参数为线程的数量和所能创建的最大的线程数量，将<code>stop_</code>标志位置为<code>false</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(std::<span class="type">size_t</span> threads, std::<span class="type">size_t</span> max_task_num)</span></span></span><br><span class="line"><span class="function">    : stop_(false) &#123;</span></span><br><span class="line">  <span class="comment">/*创建一个BoundedQueue，采用的等待策略是阻塞策略*/</span></span><br><span class="line">  <span class="keyword">if</span> (!task_queue_.<span class="built_in">Init</span>(max_task_num, <span class="keyword">new</span> <span class="built_in">BlockWaitStrategy</span>())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue init failed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化线程池 创建空的任务，每个任务都是一个while循环 */</span></span><br><span class="line">  workers_.<span class="built_in">reserve</span>(threads);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">    workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">while</span> (!stop_) &#123;</span><br><span class="line">        <span class="comment">/*返回值为空的可调用对象*/</span></span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">if</span> (task_queue_.<span class="built_in">WaitDequeue</span>(&amp;task)) &#123;</span><br><span class="line">          <span class="comment">/*如果出队成功，说明领取到了任务，则就去执行此任务*/</span></span><br><span class="line">          <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先是初始化任务队列<code>task_queue_</code>，并且采用<code>BlockWaitStrategy</code>的线程同步方式，在这种方式下，当队列中没有数据的时候，去队列取数据的线程会被阻塞，直到有线程向队列中添加元素，此时就会通过信号量机制通知阻塞的线程可以继续执行了</p></li><li><p>然后是初始化工作队列，由于<code>workers_</code>数组中的每一个元素都是一个<code>std::function&lt;void()&gt;</code>，所以在初始化的时候是通过<code>lamda</code>表达式来创建的，使用 <code>[this]</code> 捕获列表是为了能够在<code> lambda</code> 函数中访问当前类的成员变量 <code>stop_</code> 和任务队列 <code>task_queue_</code>。如果没有使用 <code>[this]</code>，那么在 <code>lambda</code> 函数中就不能直接访问当前类的成员，因为<code> lambda</code> 默认是不捕获任何外部变量的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">     <span class="keyword">while</span> (!stop_) &#123;</span><br><span class="line">       <span class="comment">/*返回值为空的可调用对象*/</span></span><br><span class="line">       std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">       <span class="keyword">if</span> (task_queue_.<span class="built_in">WaitDequeue</span>(&amp;task)) &#123;</span><br><span class="line">         <span class="comment">/*如果出队成功，说明领取到了任务，则就去执行此任务*/</span></span><br><span class="line">         <span class="built_in">task</span>();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当执行<code>emplace_back</code>操作时此时就会创建线程，然后线程一旦创建就会开始执行，执行的操作就是上面这个<code>while</code>循环里代码，此时每个线程都会去执行这一步<code>task_queue_.WaitDequeue(&amp;task)</code>操作，但是由于任务队列中还未放入任务，所以此时创建的所有线程都会被阻塞。</p></li></ul><p>然后来看关键的向任务队列中添加任务的函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before using the return value, you should check value.valid()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::Enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">      std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">  std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">  <span class="keyword">if</span> (stop_) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">future</span>&lt;return_type&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">Enqueue</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数有两个模板参数，第一个模板函数代表一个可调用对象，这个可调用对象就可以理解成我们一个任务，我们在这个函数里会将这个可调用对象封装然后进行入队，第二个模板参数是模板参数包，用于给这个可调用对象传参。这两个模板参数都是以<code>&amp;&amp;</code>万能引用的方式传入的</p><p>函数的返回值类型是<code>std::future&lt;T&gt;</code>类型的，而这个<code>T</code>是什么类型呢：<code>std::result_of&lt;F(Args...)&gt;::type</code></p><p>通过c++11提供的<code>std::result_of</code>推导出了调用<code>F(Args)</code>后的返回值类型。</p><p>拿到这个<code>return_type</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure><p>然后是对这个传入的可调用对象的封装，通过封装使得任务队列中的每个元素都是统一类型，这样工作队列去面对的就是统一的任务类型了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">    std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br></pre></td></tr></table></figure><ul><li><p>首先<code>task</code>是一个智能指针，通过<code>std::make_shared</code>创建</p></li><li><p>指针的模板类型是<code>std::packaged_task&lt;return_type()&gt;</code>，<code>std::packaged_task</code>可以用来封装任何可以调用的目标，从而用于实现异步的调用。<code>return_type()</code>是<code>std::packaged_task</code>的模板参数，代表封装的是一个<code>return_type()</code>类型的可调用对象，这不就是我们传入的这个<code>F(Args)</code>吗，区别在于没有参数而已，这时候就轮到<code>std::bind</code>出场了</p></li><li><p>假设不用智能指针封装，那么代码该这么写：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">return_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...))</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>std::bind</code>起到的作用就是将函数和参数打包生成一个可调用对象，这个可调用对象不用传参了，c++去调用的时候函数的参数已经被打包到<code>bind</code>内部，这不就刚好满足我们上面的需求吗，经过上面一系列操作，我们的任务队列中存储的就是一个个指向具体任务的指针了。注意这里使用<code>std::forward</code>是为了对传进来的模板参数进行完美转发</p></li></ul><p>接着创建了一个<code>future</code>对象：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure><p>这个<code>future</code>对象的模板参数是<code>return_type</code>，用于和上面创建的任务队列里的<code>std::packaged_task&lt;return_type()&gt;</code>可调用对象的返回值相绑定，后续当任务执行完毕我们就可以通过<code>res.get()</code>来异步的获取任务执行后的返回值</p><p>后面就是入队操作了：再次利用<code>std::function</code>，将<code>task</code>指向的<code>std::packaged_task</code>对象取出并包装为void函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">task_queue_.<span class="built_in">Enqueue</span>([task]() &#123; (*task)(); &#125;);</span><br></pre></td></tr></table></figure><p>传入的是一个<code>lamda</code>表达式，捕获<code>task</code>，表达式内部就是去执行这个可调用对象，通过<code>(*task)()</code></p><p>在任务入队之后，还记得在之前实现<code>BoundedQueue</code>时会去执行<code>NotifyOne</code>操作，这样就会唤醒阻塞在队列上的一个工作者线程去拿到传入的这个<code>std::function&lt;void()&gt;</code>去执行。</p><p><img src="/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20231129210355863.png" alt="image-20231129210355863"></p><p>最后来看析构函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (stop_.<span class="built_in">exchange</span>(<span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">BreakAllWait</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::thread&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将<code>stop_</code>标志位设置为<code>true</code></li><li>调用<code> task_queue_.BreakAllWait();</code>来唤醒所有的线程，等待所有线程执行完毕后销毁资源</li></ul><p>这个线程池的设计涉及到c++11很多知识点：</p><ul><li><p>左值与右值引用</p></li><li><p>引用折叠与完美转发</p></li><li><p><code>std::thread</code></p></li><li><p><code>std::future</code></p></li><li><p><code>std::bind</code></p></li><li><p><code>std::function</code></p></li><li><p><code>std::packaged_task</code></p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>[<a href="https://zhuanlan.zhihu.com/p/469607144">C++特性]对std::move和std::forward的理解 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现线程池 - 知乎 (zhihu.com)</a></li><li><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp07.html">C++ 并发三剑客future, promise和async · 恋恋风辰的编程笔记 (llfc.club)</a></li><li><a href="https://www.bilibili.com/video/BV18w411i74T/?spm_id_from=333.337.search-card.all.click&vd_source=1325a6af2d360c06e8e0c5e177802b1b">C++ 并发编程(7) 并发三剑客async,promise和future_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-原子读写锁</title>
      <link href="/2023/11/25/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8E%9F%E5%AD%90%E8%AF%BB%E5%86%99%E9%94%81/"/>
      <url>/2023/11/25/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8E%9F%E5%AD%90%E8%AF%BB%E5%86%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h2><p>在<code>cyber/base/atomic_rw_lock.h</code>中实现了一个读写锁，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicRWLock</span> &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ReadLockGuard</span>&lt;AtomicRWLock&gt;;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteLockGuard</span>&lt;AtomicRWLock&gt;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> RW_LOCK_FREE = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> WRITE_EXCLUSIVE = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> MAX_RETRY_TIMES = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">AtomicRWLock</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AtomicRWLock</span><span class="params">(<span class="type">bool</span> write_first)</span> : write_first_(write_first) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// all these function only can used by ReadLockGuard/WriteLockGuard;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReadLock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">WriteLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReadUnlock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">WriteUnlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AtomicRWLock</span>(<span class="type">const</span> AtomicRWLock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  AtomicRWLock&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AtomicRWLock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  std::atomic&lt;<span class="type">uint32_t</span>&gt; write_lock_wait_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  std::atomic&lt;<span class="type">int32_t</span>&gt; lock_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">bool</span> write_first_ = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int32_t</span> lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">  <span class="keyword">if</span> (write_first_) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE || write_lock_wait_num_.<span class="built_in">load</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int32_t</span> rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(rw_lock_free, WRITE_EXCLUSIVE,</span><br><span class="line">                                          std::memory_order_acq_rel,</span><br><span class="line">                                          std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="comment">// rw_lock_free will change after CAS fail, so init agin</span></span><br><span class="line">    rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">    <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">      <span class="comment">// saving cpu</span></span><br><span class="line">      std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">      retry_times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="2-原子读写锁的实现"><a href="#2-原子读写锁的实现" class="headerlink" title="2.原子读写锁的实现"></a>2.原子读写锁的实现</h2><p>读写锁的特性：</p><ul><li>当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会<strong>阻塞</strong>（不是失败）。</li><li>当读写锁被加了读锁时，其他线程对该锁加写锁会<strong>阻塞</strong>，加读锁会成功。</li></ul><p>简单说就是运行多个线程同时读，但是同时只能允许一个线程去写，非常适合读多少写的场景</p><p>首先<code>AtomicRWLock </code>中声明了两个友元类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ReadLockGuard</span>&lt;AtomicRWLock&gt;;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteLockGuard</span>&lt;AtomicRWLock&gt;;</span><br></pre></td></tr></table></figure><p>这两个友元类定义在<code>cyber/base/rw_lock_guard.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RWLock&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadLockGuard</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReadLockGuard</span><span class="params">(RWLock&amp; lock)</span> : rw_lock_(lock) &#123;</span> rw_lock_.<span class="built_in">ReadLock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReadLockGuard</span>() &#123; rw_lock_.<span class="built_in">ReadUnlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">ReadLockGuard</span>(<span class="type">const</span> ReadLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  ReadLockGuard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ReadLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  RWLock&amp; rw_lock_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RWLock&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriteLockGuard</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">WriteLockGuard</span><span class="params">(RWLock&amp; lock)</span> : rw_lock_(lock) &#123;</span></span><br><span class="line">    rw_lock_.<span class="built_in">WriteLock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">WriteLockGuard</span>() &#123; rw_lock_.<span class="built_in">WriteUnlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">WriteLockGuard</span>(<span class="type">const</span> WriteLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  WriteLockGuard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WriteLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  RWLock&amp; rw_lock_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看见这两个类在创建的时候构造函数会去调用读写锁的读或者写操作去持有锁，在析构的时候会去解锁，这就是利用c++的RAII机制实现对加锁和开锁的封装，这样就不用用户手动去加锁和释放锁了，和c++提供的<code>std::lock_guard</code>用法类似</p><p>读写锁的操作是靠几个变量来控制的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">uint32_t</span>&gt; write_lock_wait_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int32_t</span>&gt; lock_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> write_first_ = <span class="literal">true</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> RW_LOCK_FREE = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> WRITE_EXCLUSIVE = <span class="number">-1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> MAX_RETRY_TIMES = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li><code>write_lock_wait_num_</code> 代表了有多少个线程等着写就是多少个线程等着持有读锁</li><li><code>lock_num_</code>代表持有锁的线程的数量，由于读锁是允许多个线程同时读的，所以</li><li><code>RW_LOCK_FREE</code>：标志位，代表此时没有线程持有锁，可读可写</li><li><code>WRITE_EXCLUSIVE</code>：标志位，代表此时锁被一个写的线程暂用</li><li><code>MAX_RETRY_TIMES</code>：尝试获取锁的时候连续尝试次数，就像自旋锁那样，连续失败MAX_RETRY_TIMES次则会让出线程的执行权</li><li><code>write_first_</code>：默认写的操作优先</li></ul><p>我们先来看读写锁的写锁：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int32_t</span> rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(rw_lock_free, WRITE_EXCLUSIVE,</span><br><span class="line">                                          std::memory_order_acq_rel,</span><br><span class="line">                                          std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="comment">// rw_lock_free will change after CAS fail, so init agin</span></span><br><span class="line">    rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">    <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">      <span class="comment">// saving cpu</span></span><br><span class="line">      std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">      retry_times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>write_lock_wait_num_</code>记录了想要持有读锁的线程的数量，因此每次<code>WriteLock()</code>操作需要+1</li><li>接着循环会去比较<code>lock_num_</code>和<code>rw_lock_free</code>的值，会出现以下两种情况：<ul><li>1.：<code>lock_num_</code> &#x3D;  <code>rw_lock_free</code>&#x3D;&#x3D; <code>0</code>，代表此时没人用锁，则将<code>lock_num_</code>的值置为<code>WRITE_EXCLUSIVE=-1</code>,直接跳出循环，此时假设另外一个线程也来写，而<code>lock_num_=-1</code>，所以必须等待前一个持有写锁的人解锁才行，所以解锁操作也显而易见了，就是将<code>lock_num_+1</code>恢复到<code>RW_LOCK_FREE</code></li><li>2：<code>lock_num_&gt;=1</code>代表其他线程持有了读锁，或<code>lock_num_&gt;=WRITE_EXCLUSIVE</code>这种情况就是上面提到的另外一个线程持有了读锁，但是还没解锁，那么此时该线程就会去执行<code>while</code>循环里的操作，在while循环里会重置<code>rw_lock_free</code>的值，然后循环判断几次如果还在等待就执行<code>yield()</code>操作让当前线程释放cpu所有权。</li></ul></li></ul><p>再来看读写锁的读锁：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int32_t</span> lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">  <span class="keyword">if</span> (write_first_) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE || write_lock_wait_num_.<span class="built_in">load</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于默认写优先就是说我在写的时候是不允许读的，先进入一个分支执行<code>do</code>操作：然后去进行判断是否有线程在执行写操作，即<code>lock_num &lt; RW_LOCK_FREE || write_lock_wait_num_.load() &gt; 0</code>，则想要读的这个线程就让出cpu等着写的线程写完先，如果写完了重新加载一下<code>lock_num</code>的值，然后去执行<code>lock_num_.compare_exchange_weak</code>这个操作，这里有两种情况：</p><ul><li>1.<code>lock_num_==lock_num</code>(即大于等于0)，可能你会说这不是肯定的吗？这个还真不一定，虽然刚执行过<code>lock_num = lock_num_.load()</code>;但是<code>lock_num</code>是个多线程控制的值，随时在变。然后将<code>lock_num_</code>的值加一</li><li>2.<code>lock_num_!=lock_num  lock_num</code>赋值为<code>lock_num_</code>（无用） 重新循环 简单点来讲就是：刚刚的判断好好的，正当我要办事的时候，突然有线程偷偷改变了值，一切判断作废，重新来过</li></ul><p>最后是解锁操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><p>读锁解锁就是将大于0的<code>lock_num_</code>做减1操作，写锁的解锁就是将-1转到0</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://liujiayu.blog.csdn.net/article/details/124732353">百度自动驾驶apollo源码解读1：std::atomic实现读写锁_阿波罗自动驾驶代码-CSDN博客</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/569073042">原子读写锁的实现 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://subingwen.cn/linux/thread-sync/">线程同步 | 爱编程的大丙 (subingwen.cn)</a></p></li><li><p><a href="https://blog.csdn.net/kenjianqi1647/article/details/117998175">C++11锁的用法( 多线程，并发，错误使用、std::ref用法、RAII)_c++11智能锁-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 原子读写锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-有界无锁队列</title>
      <link href="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
      <url>/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h2><p>在<code>cyber/base/bounded_queue.h</code>中实现了一个有界无锁队列的模板类，通过c++提供的原子操作来确保线程安全，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedQueue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BoundedQueue</span>() &#123;&#125;</span><br><span class="line">  BoundedQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> BoundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">BoundedQueue</span>(<span class="type">const</span> BoundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  ~<span class="built_in">BoundedQueue</span>();</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">uint64_t</span> size)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">uint64_t</span> size, WaitStrategy* strategy)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(T&amp;&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WaitEnqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WaitEnqueue</span><span class="params">(T&amp;&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T* element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WaitDequeue</span><span class="params">(T* element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Size</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetWaitStrategy</span><span class="params">(WaitStrategy* WaitStrategy)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head_.<span class="built_in">load</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> tail_.<span class="built_in">load</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Commit</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> commit_.<span class="built_in">load</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">GetIndex</span><span class="params">(<span class="type">uint64_t</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; head_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; tail_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; commit_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="comment">// alignas(CACHELINE_SIZE) std::atomic&lt;uint64_t&gt; size_ = &#123;0&#125;;</span></span><br><span class="line">  <span class="type">uint64_t</span> pool_size_ = <span class="number">0</span>;</span><br><span class="line">  T* pool_ = <span class="literal">nullptr</span>;</span><br><span class="line">  std::unique_ptr&lt;WaitStrategy&gt; wait_strategy_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">bool</span> break_all_wait_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BoundedQueue&lt;T&gt;::~<span class="built_in">BoundedQueue</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (wait_strategy_) &#123;</span><br><span class="line">    <span class="built_in">BreakAllWait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pool_) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">      pool_[i].~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(pool_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Init</span>(<span class="type">uint64_t</span> size) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Init</span>(size, <span class="keyword">new</span> <span class="built_in">SleepWaitStrategy</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Init</span>(<span class="type">uint64_t</span> size, WaitStrategy* strategy) &#123;</span><br><span class="line">  <span class="comment">// Head and tail each occupy a space</span></span><br><span class="line">  pool_size_ = size + <span class="number">2</span>;</span><br><span class="line">  pool_ = <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(std::<span class="built_in">calloc</span>(pool_size_, <span class="built_in">sizeof</span>(T)));</span><br><span class="line">  <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    <span class="keyword">new</span> (&amp;(pool_[i])) <span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  wait_strategy_.<span class="built_in">reset</span>(strategy);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Enqueue</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_commit = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_tail = tail_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_tail = old_tail + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetIndex</span>(new_tail) == <span class="built_in">GetIndex</span>(head_.<span class="built_in">load</span>(std::memory_order_acquire))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!tail_.<span class="built_in">compare_exchange_weak</span>(old_tail, new_tail,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  pool_[<span class="built_in">GetIndex</span>(old_tail)] = element;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old_commit = old_tail;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">      old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">      std::memory_order_relaxed)));</span><br><span class="line">  <span class="comment">//唤醒一个等待的线程，告诉它队列中已经有新的元素可以被取出或处理了。</span></span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">NotifyOne</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Enqueue</span>(T&amp;&amp; element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_commit = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_tail = tail_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_tail = old_tail + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetIndex</span>(new_tail) == <span class="built_in">GetIndex</span>(head_.<span class="built_in">load</span>(std::memory_order_acquire))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!tail_.<span class="built_in">compare_exchange_weak</span>(old_tail, new_tail,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  pool_[<span class="built_in">GetIndex</span>(old_tail)] = std::<span class="built_in">move</span>(element);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old_commit = old_tail;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">      old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">      std::memory_order_relaxed)));</span><br><span class="line">  <span class="comment">//唤醒一个等待的线程，告诉它队列中已经有新的元素可以被取出或处理了。</span></span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">NotifyOne</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Dequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_head = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_head = head_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_head = old_head + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_head == commit_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *element = pool_[<span class="built_in">GetIndex</span>(new_head)];</span><br><span class="line">  &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_weak</span>(old_head, new_head,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitEnqueue</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Enqueue</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitEnqueue</span>(T&amp;&amp; element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Enqueue</span>(std::<span class="built_in">move</span>(element))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitDequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dequeue</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint64_t</span> BoundedQueue&lt;T&gt;::<span class="built_in">Size</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> tail_ - head_ - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Empty</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Size</span>() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint64_t</span> BoundedQueue&lt;T&gt;::<span class="built_in">GetIndex</span>(<span class="type">uint64_t</span> num) &#123;</span><br><span class="line">  <span class="keyword">return</span> num - (num / pool_size_) * pool_size_;  <span class="comment">// faster than %</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> BoundedQueue&lt;T&gt;::<span class="built_in">SetWaitStrategy</span>(WaitStrategy* strategy) &#123;</span><br><span class="line">  wait_strategy_.<span class="built_in">reset</span>(strategy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> BoundedQueue&lt;T&gt;::<span class="built_in">BreakAllWait</span>() &#123;</span><br><span class="line">  break_all_wait_ = <span class="literal">true</span>;</span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">BreakAllWait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-有界无锁队列的实现"><a href="#2-有界无锁队列的实现" class="headerlink" title="2.有界无锁队列的实现"></a>2.有界无锁队列的实现</h2><p>首先来看<code>BoundedQueue</code>这个模板类拥有的数据成员：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; head_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; tail_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; commit_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// alignas(CACHELINE_SIZE) std::atomic&lt;uint64_t&gt; size_ = &#123;0&#125;;</span></span><br><span class="line"><span class="type">uint64_t</span> pool_size_ = <span class="number">0</span>;</span><br><span class="line">T* pool_ = <span class="literal">nullptr</span>;</span><br><span class="line">std::unique_ptr&lt;WaitStrategy&gt; wait_strategy_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> break_all_wait_ = <span class="literal">false</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有界的无锁队列是采用顺序存储结构来实现的，可以理解为一个数组，所以头部和尾部的描述就不是使用的链式结构的指针来维护的，直接定义为<code>u64</code>格式的索引，<code>pool_size_</code>就是这个数组的大小，<code>wait_strategy_</code>是一个<code>unique_ptr</code>，因此<code>wait_strategy_</code>指向的内容不允许被其他指针共享，<code>T* pool</code>是指针，用来指向队列数组的头，在初始化时需要为此指针分配内存大小</p><p>还定义了一个私有函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 由于是无符号整数，所以返回的是索引，类似于取余*/</span></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint64_t</span> BoundedQueue&lt;T&gt;::GetIndex(<span class="type">uint64_t</span> num) &#123;</span><br><span class="line">  <span class="keyword">return</span> num - (num / pool_size_) * pool_size_;  <span class="comment">// faster than %</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明一下上面的操作相当于取余操作，因为无符号整型的数相除，得到的值也是一个无符号数，如果相除的值小于1，则得到的值是0，所以实现了类似取余的操作。</p><p>然后看<code>init</code>函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Init</span>(<span class="type">uint64_t</span> size, WaitStrategy* strategy) &#123;</span><br><span class="line">  <span class="comment">// Head and tail each occupy a space</span></span><br><span class="line">  pool_size_ = size + <span class="number">2</span>;</span><br><span class="line">  pool_ = <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(std::<span class="built_in">calloc</span>(pool_size_, <span class="built_in">sizeof</span>(T)));</span><br><span class="line">  <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    <span class="keyword">new</span> (&amp;(pool_[i])) <span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  wait_strategy_.<span class="built_in">reset</span>(strategy);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>std::calloc(pool_size_, sizeof(T))</code>: 这部分使用了 C 标准库函数 <code>calloc</code>，该函数用于分配指定数量的元素并将它们的内存初始化为零。在这里，它分配了 <code>pool_size_</code> 个元素，每个元素的大小为 <code>sizeof(T)</code> 字节。<code>calloc</code> 与 <code>malloc</code> 不同之处在于它会将分配的内存初始化为零。</p></li><li><p><code>reinterpret_cast&lt;T*&gt;(...)</code>: 这是 C++ 中的类型转换语法，用于将 <code>calloc</code> 返回的指针从 <code>void*</code> 类型转换为 <code>T*</code> 类型。<code>reinterpret_cast</code> 表示底层的二进制表示不发生改变，这种转换通常用于进行低级别的类型转换。</p></li><li><p><code>new (&amp;(pool_[i])) T();</code> 这个用法是在指定的内存地址上调用 T 类型的构造函数。这是一个称为 “placement new” 的 C++ 特性。它允许我们在给定的内存地址上构造对象，而不是在默认的堆上分配内存。这通常用于需要对内存进行更精细控制的场景。</p></li></ul><p>在调用<code>init</code>函数后，队列的内存模型如下：</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124152948409.png" alt="image-20231124152948409"></p><p>这里其实我没想明白为啥要<code>pool_size_ = size + 2;</code>看写的注释说是<code>head_</code>和<code>tail_</code>会占空间。</p><p>接着是向队列中添加元素：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Enqueue</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_commit = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_tail = tail_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_tail = old_tail + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetIndex</span>(new_tail) == <span class="built_in">GetIndex</span>(head_.<span class="built_in">load</span>(std::memory_order_acquire))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!tail_.<span class="built_in">compare_exchange_weak</span>(old_tail, new_tail,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  pool_[<span class="built_in">GetIndex</span>(old_tail)] = element;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old_commit = old_tail;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">      old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">      std::memory_order_relaxed)));</span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">NotifyOne</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是将<code>new_tail+1</code>，然后判断队列是否越界，然后调用<code>tail_.compare_exchange_weak</code>来原子的更新<code>tail</code>_的值。</p><blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  //tail_为原子变量，将当前的tail_的值和old_tail进行比较，如果相等，则tail_更新为new_tail</span><br><span class="line">  //返回true,!操作返回fasle，使得跳出循环，开始下面的入队操作</span><br><span class="line">  //否则，如果tail_的值和old_tail不相等（将old_tail更新为当前的tail_值），</span><br><span class="line">  //说明其他线程已经做了do里边的操作并且tail_值已经更新，已经抢先入队</span><br><span class="line">  //这时返回false,!操作返回true，继续下一次执行do里面的操作，等待入队的时机（或队列已满返回false）</span><br><span class="line">//在old_tail的位置入队，old_tail可能在上面的循环了进行了多次的累加</span><br><span class="line">//和程序入口的old_tail可能已经不同了</span><br></pre></td></tr></table></figure></blockquote><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124165704805.png" alt="image-20231124165704805"></p><p>上面的逻辑是当两个线程操作时，假设其中一个线程执行完毕<code>new_tail = old_tail + 1;</code>后，另外一个线程已经更新了<code>tail_</code>的值，此时就会出现第二张图的情况，<code>tail_</code>不等去当前线程获得的<code>old_tail_</code>，因此将当前线程的<code>old_tail</code>跟新为新的<code>tail_</code>，然后再返回while循环，将<code>new_tail_+1</code>，然后再进行比较发现此时的<code>tail_=old_tail_</code>了，然后再次更新<code>tail_</code>的值就成了第三幅图的样子。</p><p>然后将新加的值放入<code>pool_[GetIndex(old_tail)]</code>中</p><blockquote><p>这里使用了一个很有意思的宏<code>#define cyber_unlikely(x) (__builtin_expect((x), 0))</code></p><p>宏定义使用了 GCC 内建函数 <code>__builtin_expect</code>，它是 GCC 编译器提供的一个特殊内建函数，用于提供条件概率的提示，以帮助编译器进行更好的代码优化。</p><p>具体而言，这个宏的作用是提示编译器表达式 <code>(x)</code> 的结果是不太可能的。<code>__builtin_expect</code> 函数的参数是两个值，第一个是表达式，第二个是期望的结果。在这里，<code>0</code> 表示不太可能的分支。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  old_commit = old_tail;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">    old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">    std::memory_order_relaxed)));</span><br></pre></td></tr></table></figure><p>这里有点绕，假设只有一个线程执行入队操作，那么<code>old_commit</code>和<code>commit</code>的值是相等的，所以此时会将<code>commit_</code>的值更新到新的<code>tail_</code>的位置</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124163223274.png" alt="image-20231124163223274"></p><p>假设有两个线程操作了此队列：后修改<code>tail_</code>的那个线程就会出现如下的情况：<code>old_commit!=commit</code>，因此此线程的<code>old_commit</code>值会被更新成<code>commit</code>的值，然后在do里面<code>old_commit</code>又会被更新成<code>old_tail</code>的值，相当于它一直阻塞在这里了</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124170412439.png" alt="image-20231124170412439"></p><p>而对于先修改<code>tail_</code>的那个线程来说：<code>old_commit=commit</code>，因此会跳出do循环，同时将<code>commit_</code>的值更新成此线程的<code>new_tail</code>的值，即上面那个线程的<code>old_tail</code>的值。</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124170550072.png" alt="image-20231124170550072"></p><p>因此commit_的值是完全根据入队的顺序进行递增的，不同线程根据入队的循序依次跳出该循环,哪个线程先完成入队操作，哪个线程先跳出该while循环。</p><blockquote><p>但我感觉这个commit的值没啥屌用阿，md还很难理解</p></blockquote><p>然后是从队列中取出元素：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Dequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_head = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_head = head_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_head = old_head + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_head == commit_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *element = pool_[<span class="built_in">GetIndex</span>(new_head)];</span><br><span class="line">  &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_weak</span>(old_head, new_head,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当队列里有数据的时候，<code>head_</code>和<code>old_head</code>比较，如果相等，则更新为<code>new_head</code>并返回<code>true</code>，退出循环。如果不等，则说明其他线程已经取走了当前的<code>head</code>元素，将<code>old_head</code>更新为<code>head_</code>值并进入下一次do里面的操作，这里说明一下为什么去元素是从<code>new_head</code>处取，因为插入元素时，<code>head_</code>和<code>tail_</code>处是不会放元素的。</p><p>当队列里没数据的时候，第一次<code>do</code>的操作，会对<code>new_head</code>的值和<code>commit_</code>的值进行判断，如果这两个值相等，说明队列里没数据，则返回<code>false</code></p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124172803708.png" alt="image-20231124172803708"></p><p>然后是实现了等待策略的插入函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitEnqueue</span>(T&amp;&amp; element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Enqueue</span>(std::<span class="built_in">move</span>(element))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现了等待机制，如果队列未满，则立马插入返回，否则进入空等状态</p><p>实现了等待策略的取出函数：如果队列中没数据则空等</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitDequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dequeue</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的入队操作就是往尾部添加元素，然后移动尾部指针。出队操作就是从头部取出一个元素，然后移动头部指针，虽然移动了头部指针，但是之前申请的内存是还在的，并不会释放。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/569493127">有界队列及其无锁实现 - 知乎 (zhihu.com)</a></li><li><a href="https://liujiayu.blog.csdn.net/article/details/125657500">百度自动驾驶apollo源码解读9:无锁有界队列BoundedQueue_cyberrt boundedqueue-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 无界无锁队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-无界无锁队列</title>
      <link href="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
      <url>/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h2><p>在<code>cyber/base/unbounded_queue.h</code>中实现了一个无界无锁队列的模板类，通过c++提供的原子操作来确保线程安全，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnboundedQueue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UnboundedQueue</span>() &#123; <span class="built_in">Reset</span>(); &#125;</span><br><span class="line">  UnboundedQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UnboundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">UnboundedQueue</span>(<span class="type">const</span> UnboundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">UnboundedQueue</span>() &#123; <span class="built_in">Destroy</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Destroy</span>();</span><br><span class="line">    <span class="built_in">Reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Enqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    node-&gt;data = element;</span><br><span class="line">    Node* old_tail = tail_.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tail_.<span class="built_in">compare_exchange_strong</span>(old_tail, node)) &#123;</span><br><span class="line">        old_tail-&gt;next = node;</span><br><span class="line">        old_tail-&gt;<span class="built_in">release</span>();</span><br><span class="line">        size_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T* element)</span> </span>&#123;</span><br><span class="line">    Node* old_head = head_.<span class="built_in">load</span>();</span><br><span class="line">    Node* head_next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      head_next = old_head-&gt;next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (head_next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_strong</span>(old_head, head_next));</span><br><span class="line">    *element = head_next-&gt;data;</span><br><span class="line">    size_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">    old_head-&gt;<span class="built_in">release</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_.<span class="built_in">load</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_.<span class="built_in">load</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    std::atomic&lt;<span class="type">uint32_t</span>&gt; ref_count;</span><br><span class="line">    Node* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">Node</span>() &#123; ref_count.<span class="built_in">store</span>(<span class="number">2</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (ref_count.<span class="built_in">load</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    head_.<span class="built_in">store</span>(node);</span><br><span class="line">    tail_.<span class="built_in">store</span>(node);</span><br><span class="line">    size_.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ite = head_.<span class="built_in">load</span>();</span><br><span class="line">    Node* tmp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (ite != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      tmp = ite-&gt;next;</span><br><span class="line">      <span class="keyword">delete</span> ite;</span><br><span class="line">      ite = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;Node*&gt; head_;</span><br><span class="line">  std::atomic&lt;Node*&gt; tail_;</span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-无界无锁队列的实现"><a href="#2-无界无锁队列的实现" class="headerlink" title="2.无界无锁队列的实现"></a>2.无界无锁队列的实现</h2><p>队列（queue）是只允许在一端进行插入操作，在另一端进行删除操作的线性表，简称“队”。队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾（rear），允许删除的一端称为队头(front)。向队列中插入新的数据元素称为入队，新入队的元素就成为了队列的队尾元素。从队列中删除队头元素称为出队，其后继元素成为新的队头元素。</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/20200915111440959.png" alt="img"></p><blockquote><p>队列作为一种特殊的线性表，也同样存在两种存储结构：顺序存储结构和链式存储结构，可以分别用数组和链表来实现队列。</p></blockquote><p>在cyberrt中是采用链式结构来实现的，通过链表来进行维护，看上面的代码，先看<code>Node</code>的组成：</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124115312276.png" alt="image-20231124115312276"></p><p><code>Node</code>中的成员包含一个模板类的数据<code>data</code>,一个指向下一个节点的指针和一个用于引用计数的<code>count</code>值,<code>release</code>函数用于释放此节点。</p><p><code>UnboundedQueue</code>内部有三个成员，它的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UnboundedQueue</span>() &#123; <span class="built_in">Reset</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    head_.<span class="built_in">store</span>(node);</span><br><span class="line">    tail_.<span class="built_in">store</span>(node);</span><br><span class="line">    size_.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  std::atomic&lt;Node*&gt; head_;</span><br><span class="line">  std::atomic&lt;Node*&gt; tail_;</span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; size_;</span><br></pre></td></tr></table></figure><p><code>head_</code>即是队列的头节点指针，<code>tail_</code>是队列的尾节点指针，<code>size_</code>是节点的个数，这三个变量都是原子类型，保证了在多线程时操作这三个变量时都是线程安全的。</p><p>当<code>UnboundedQueue</code>创建时会去调用<code>Reset()</code>函数，<code>Reset()</code>函数会去<code>new</code>一个<code>Node</code>对象，在<code>Node</code>的构造函数中会将<code>ref_count</code>的值设置为2，因为在队列初始化时头指针和尾指针都指向了同一个节点，所以<code>ref_count=2</code></p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124120233507.png" alt="image-20231124120233507"></p><p>再来看像队列添加元素的函数<code>void Enqueue(const T&amp; element)</code>，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Enqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">  node-&gt;data = element;</span><br><span class="line">  Node* old_tail = tail_.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail_.<span class="built_in">compare_exchange_strong</span>(old_tail, node)) &#123;</span><br><span class="line">      old_tail-&gt;next = node;</span><br><span class="line">      old_tail-&gt;<span class="built_in">release</span>();</span><br><span class="line">      size_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先同样会新建一个<code>Node</code>，然后对新建的<code>Node</code>的<code>data</code>赋值，我们知道向队列插入元素是在尾部添加，这里使用了一个<code>compare_exchange_strong</code>函数来将<code>tail</code>与<code>old_tail</code>进行比较，如果是同一个则将tail的替换成新建的这个node，然后现在队列的尾部指针就是新建这个<code>node</code>了,这个<code>compare_exchange_strong</code>写的非常巧妙，如果没有发生多线程竞争的话，<code>compare_exchange_strong</code>返回true  ,意味着循环一次就结束，<code>tail_</code>的值被设为了<code>node</code>。因为<code>compare_exchange_strong</code>是线程安全的。</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124121117146.png" alt="image-20231124121117146"></p><p>可以看见当尾插一个新的节点后上一个节点的引用计数就变成了1，因为调用了<code>release()</code>函数，<code>release()</code>中会对节点引用计数减一，同时如果此节点的引用计数变成了0则销毁此节点释放内存</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (ref_count.<span class="built_in">load</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的整体结构如下：尾部节点的引用计数始终是2，链表里面所有成员的引用计数都是1。</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124122433323.png" alt="image-20231124122433323"></p><p>然后来看从队列中取出数据的函数，取出数据时就是从头部取了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T* element)</span> </span>&#123;</span><br><span class="line">  Node* old_head = head_.<span class="built_in">load</span>();</span><br><span class="line">  Node* head_next = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    head_next = old_head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head_next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_strong</span>(old_head, head_next));</span><br><span class="line">  *element = head_next-&gt;data;</span><br><span class="line">  size_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">  old_head-&gt;<span class="built_in">release</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单，就是将之前的头指针指向第二个节点，同样使用了<code>compare_exchange_strong</code>来保证线程安全，取出数据后之前的头节点就没用了因此调用<code>release()</code>函数去删除这个节点。</p><p>然后最后是队列的销毁函数，这个函数就比较简单了：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ite = head_.<span class="built_in">load</span>();</span><br><span class="line">  Node* tmp = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (ite != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    tmp = ite-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> ite;</span><br><span class="line">    ite = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从头节点开始遍历，依次删除节点，直到遍历到最后一个节点，因为最后一个节点的<code>next</code>指针指向了<code>nullptr</code>，所以到此停止。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://liujiayu.blog.csdn.net/article/details/129615374">百度自动驾驶apollo源码解读13:无锁无界队列UnboundedQueue_H-KING的博客-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/599202353">C++原子变量atomic详解 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/Jacky_Feng/article/details/108595654">【数据结构】队列(顺序队列、循环队列、链队列）-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 无界无锁队列 </tag>
            
            <tag> 原子操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-线程等待策略</title>
      <link href="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/"/>
      <url>/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程等待策略"><a href="#1-线程等待策略" class="headerlink" title="1.线程等待策略"></a>1.线程等待策略</h2><p>在<code>base/wait_strategy.h</code>这个头文件中定义了线程切换的策略类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitStrategy</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NotifyOne</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">WaitStrategy</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BlockWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyOne</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_one</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    cv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_all</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex mutex_;</span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SleepWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SleepWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepWaitStrategy</span><span class="params">(<span class="type">uint64_t</span> sleep_time_us)</span></span></span><br><span class="line"><span class="function">      : sleep_time_us_(sleep_time_us) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(sleep_time_us_));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetSleepTimeMicroSeconds</span><span class="params">(<span class="type">uint64_t</span> sleep_time_us)</span> </span>&#123;</span><br><span class="line">    sleep_time_us_ = sleep_time_us;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint64_t</span> sleep_time_us_ = <span class="number">10000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YieldWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">YieldWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BusySpinWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BusySpinWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeoutBlockWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TimeoutBlockWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TimeoutBlockWaitStrategy</span><span class="params">(<span class="type">uint64_t</span> timeout)</span></span></span><br><span class="line"><span class="function">      : time_out_(std::chrono::milliseconds(timeout)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyOne</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_one</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (cv_.<span class="built_in">wait_for</span>(lock, time_out_) == std::cv_status::timeout) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_all</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetTimeout</span><span class="params">(<span class="type">uint64_t</span> timeout)</span> </span>&#123;</span><br><span class="line">    time_out_ = std::chrono::<span class="built_in">milliseconds</span>(timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex mutex_;</span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line">  std::chrono::milliseconds time_out_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>WaitStrategy基类：</strong><ul><li><code>WaitStrategy</code> 是一个虚基类，定义了等待策略的基本接口。</li><li>其中包括 <code>NotifyOne()</code> 、 <code>BreakAllWait()</code> 和 <code>EmptyWait()</code> 纯虚函数。</li></ul></li><li><strong>BlockWaitStrategy类：</strong><ul><li><code>BlockWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了阻塞式等待策略。</li><li>它使用了互斥锁和条件变量，通过 <code>cv_.wait(lock)</code> 进行线程等待，通过 <code>cv_.notify_one()</code> 唤醒一个等待的线程，通过 <code>cv_.notify_all()</code> 唤醒所有等待的线程。</li><li>线程会一直阻塞在此直到另外一个线程来唤醒，当线程被唤醒后才会返回<code>true</code></li></ul></li><li><strong>SleepWaitStrategy类：</strong><ul><li><code>SleepWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了休眠式等待策略。</li><li>在 <code>EmptyWait()</code> 中，通过 <code>std::this_thread::sleep_for()</code> 函数使当前线程休眠一段时间。</li><li>线程会休眠一段时间，不会进行阻塞，睡眠时间结束后返回<code>true</code></li></ul></li><li><strong>YieldWaitStrategy类：</strong><ul><li><code>YieldWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了让出CPU时间片的等待策略。</li><li>在 <code>EmptyWait()</code> 中，通过 <code>std::this_thread::yield()</code> 函数让当前线程放弃其时间片。</li><li>线程时间片切换，返回<code>true</code></li></ul></li><li><strong>BusySpinWaitStrategy类：</strong><ul><li><code>BusySpinWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了忙等待策略。</li><li>在 <code>EmptyWait()</code> 中，直接返回 <code>true</code>，表示一直忙等。</li><li>始终返回<code>true</code>，一直等待</li></ul></li><li><strong>TimeoutBlockWaitStrategy类：</strong><ul><li><code>TimeoutBlockWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了带有超时的阻塞等待策略。</li><li>它在 <code>EmptyWait()</code> 中，使用 <code>cv_.wait_for(lock, time_out_)</code>，允许线程等待一段时间，如果超时则返回 <code>false</code>，否则返回 <code>true</code>。</li><li>线程在超时时间内没有被唤醒，此时 <code>EmptyWait</code> 方法将返回 <code>false</code>，反映了等待过程中的超时情况。如果被唤醒，返回 <code>true</code>。线程在确定时间内为阻塞状态</li></ul></li></ol><p>uml类图如下：</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/uml.png" alt="uml"></p><h2 id="2-参考连接"><a href="#2-参考连接" class="headerlink" title="2.参考连接"></a>2.参考连接</h2><ul><li><p><a href="https://cloud.tencent.com/developer/article/2339238">C++ std::condition_variable 条件变量用法-腾讯云开发者社区-腾讯云 (tencent.com)</a></p></li><li><p><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp03.html">C++ 互斥和死锁 · 恋恋风辰的编程笔记 (llfc.club)</a></p></li><li><p><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp04.html">unique_lock，读写锁以及递归锁 · 恋恋风辰的编程笔记 (llfc.club)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/499085575">多线程不安全因素？线程安全问题分析总结 - 知乎 (zhihu.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> fastrtps </tag>
            
            <tag> 分布式通信中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-常用宏分析</title>
      <link href="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/"/>
      <url>/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从这篇blog开始，我们来分析百度CyberRt这个高性能的分布式通信中间件</p></blockquote><p>CyberRt的源码组成如下：</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/image-20231123135714615.png" alt="image-20231123135714615"></p><p><code>base</code>文件夹是Apollo开发的高性能基础库，我们先从这个文件夹里的代码看起:</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/image-20231123202400187.png" alt="image-20231123202400187"></p><p>从文件命名中可以看见实现了与线程相关的如线程池、锁、无锁队列、哈希表等等基础组件，我们就开始从零造轮子吧</p><h2 id="1-c-前置知识"><a href="#1-c-前置知识" class="headerlink" title="1.c++前置知识"></a>1.c++前置知识</h2><h3 id="std-nothrow"><a href="#std-nothrow" class="headerlink" title="std::nothrow"></a>std::nothrow</h3><p><code>(std::nothrow)</code> 是在C++中用于进行内存分配时的一种选项。通常，当你使用 <code>new</code> 运算符创建对象时，如果内存分配失败，<code>new</code> 会抛出 <code>std::bad_alloc</code> 异常。但是，当你希望在分配失败时不抛出异常，而是返回一个空指针，你可以使用 <code>(std::nothrow)</code> 作为参数传递给 <code>new</code>。</p><p>具体来说，使用 <code>(std::nothrow)</code> 会使得 <code>new</code> 在分配失败时返回一个空指针而不是抛出异常。这样，你可以在分配失败时通过检查返回的指针是否为空来处理错误，而不必使用异常处理机制。</p><p>以下是一个示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试分配一个非常大的数组，可能导致分配失败</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="literal">nullptr</span>;</span><br><span class="line">    arr = <span class="built_in">new</span>(std::nothrow) <span class="type">int</span>[<span class="number">1000000000000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory allocation failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory allocation successful.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] arr;  <span class="comment">// 记得释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们尝试分配一个非常大的整数数组。由于这个数组可能太大而无法成功分配，我们使用 <code>(std::nothrow)</code>，这样 <code>new</code> 在分配失败时会返回一个空指针。在分配失败的情况下，我们打印一条错误消息。这样，我们可以通过检查指针是否为空来处理内存分配失败的情况，而不必处理异常。</p><h3 id="std-once-flag-amp-amp-std-call-once"><a href="#std-once-flag-amp-amp-std-call-once" class="headerlink" title="std::once_flag &amp;&amp; std::call_once"></a>std::once_flag &amp;&amp; std::call_once</h3><p>在C++中，<code>std::once_flag</code> 是一个用于确保只执行一次代码的标记。它通常与 <code>std::call_once</code> 函数一起使用，以确保其中的代码只会在多线程环境下被执行一次。</p><p>多线程环境中，多个线程可能同时尝试执行某个特定的代码块，但有些代码块可能只需要执行一次。这时，就可以使用 <code>std::once_flag</code> 和 <code>std::call_once</code> 来确保代码块只会在第一次调用时执行，而后续调用会被忽略。</p><p>在C++中，<code>std::once_flag</code> 是一个用于确保只执行一次代码的标记。它通常与 <code>std::call_once</code> 函数一起使用，以确保其中的代码只会在多线程环境下被执行一次。</p><p>多线程环境中，多个线程可能同时尝试执行某个特定的代码块，但有些代码块可能只需要执行一次。这时，就可以使用 <code>std::once_flag</code> 和 <code>std::call_once</code> 来确保代码块只会在第一次调用时执行，而后续调用会被忽略。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(flag.mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双检锁，检查是否已经被执行过</span></span><br><span class="line">    <span class="keyword">if</span> (!flag.called) &#123;</span><br><span class="line">        <span class="comment">// 调用传入的函数</span></span><br><span class="line">        <span class="built_in">func</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置标志，表示函数已经执行过</span></span><br><span class="line">        flag.called = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个简化的示例中，<code>std::once_flag</code> 包含一个互斥锁（<code>mutex</code>）和一个布尔标志（<code>called</code>）。当第一个线程调用 <code>std::call_once</code> 时，它会获得互斥锁，检查标志。如果标志为假，表示函数还没有执行过，于是调用传入的函数，然后设置标志为真，释放互斥锁。如果标志为真，说明函数已经执行过，不再重复执行。</p><p>通过使用互斥锁和双检锁的技术，<code>std::call_once</code> 在多线程环境下能够保证传入的函数只执行一次，同时尽可能地减小了锁的开销。需要注意的是，尽管双检锁可以提高性能，但也需要小心处理一些细节，以防止出现竞态条件和内存可见性的问题。在实践中，使用现代C++标准库提供的 <code>std::call_once</code> 是比手动实现更为安全和简便的选择。</p><h3 id="std-enable-if"><a href="#std-enable-if" class="headerlink" title="std::enable_if"></a>std::enable_if</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::type</span><br></pre></td></tr></table></figure><p>这行代码使用了<code>std::enable_if</code>，它是一个模板元编程工具，用于在编译时根据条件启用或禁用模板的某个部分。</p><ul><li><code>std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;</code>：这是一个模板元编程的条件，它基于 <code>HasShutdown&lt;T&gt;::value</code> 的值。如果 <code>HasShutdown&lt;T&gt;::value</code> 为 <code>true</code>，那么这个表达式的结果是 <code>std::enable_if</code> 的一个特殊的内部类型，否则没有这个内部类型。</li><li><code>typename</code>：这是告诉编译器，后面的 <code>std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::type</code> 是一个类型名，而不是一个成员变量或函数。</li></ul><p>所以，整个表达式的意思是：如果 <code>HasShutdown&lt;T&gt;::value</code> 为 <code>true</code>，则这是一个有效的类型；否则，这个表达式没有有效的类型。</p><h2 id="2-宏分析"><a href="#2-宏分析" class="headerlink" title="2.宏分析"></a>2.宏分析</h2><h3 id="2-1-特征判断宏"><a href="#2-1-特征判断宏" class="headerlink" title="2.1 特征判断宏"></a>2.1 特征判断宏</h3><p><code>DEFINE_TYPE_TRAIT</code>定义在<code>base/macros.h</code>中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TYPE_TRAIT(name, func)                     \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                           \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename Class&gt;</span>                             \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(decltype(&amp;Class::func)*) &#123; \</span></span><br><span class="line"><span class="meta">      return true;                                        \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(...) &#123;                     \</span></span><br><span class="line"><span class="meta">      return false;                                       \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">    static constexpr bool value = Test<span class="string">&lt;T&gt;</span>(nullptr);       \</span></span><br><span class="line"><span class="meta">  &#125;;                                                      \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  constexpr bool name<span class="string">&lt;T&gt;</span>::value;</span></span><br></pre></td></tr></table></figure><ol><li><p><code>DEFINE_TYPE_TRAIT(name, func)</code> 定义了一个宏，该宏接受两个参数，<code>name</code> 是要定义的类型特征结构体的名称，<code>func</code> 是要检查的成员函数的名称。这个宏在内部定义了一个名为<code>name</code>的结构体，此结构体中提供了两个函数模板。</p></li><li><p><code>template &lt;typename T&gt; struct name &#123; ... &#125;;</code> 定义了一个模板结构体，该结构体接受一个类型参数 <code>T</code>。实际上这个宏就是用来检查传入的这个<code>T</code>是否包含有<code>func</code>这个函数，借助了<code>name</code>这个结构体来实现</p></li><li><p><code>name</code>结构体的内部有一个数据成员就是<code>value</code>，<code>value</code>的类型是<code>static constexpr bool</code>，是一个静态常量，这里使用<code>constexpr</code>来声明此变量是为了让编译器在编译的时候就把<code>value</code>的值计算出来，<code>value</code>的值就代表了传入的这个<code>T</code>是否有<code>func</code>这个函数，这个值的计算是通过调用<code>Test&lt;T&gt;</code>这个函数模板来实现的，传入的参数是<code>nullptr</code></p></li><li><p><code>Test&lt;T&gt;</code>这个函数模板有一个泛化的版本和一个特化的版本，首先来看特化的版本</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Class&gt;                             \</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="keyword">decltype</span>(&amp;Class::func)*)</span> </span>&#123; \</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;                                        \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过<code>decltype</code>去识别<code>&amp;Class::func</code>，如果说<code>&amp;Class::func</code>是存在的话，那么<code>decltype(&amp;Class::func)</code>推断出的类型就是一个指向成员函数函数的指针，这就说明了<code>class </code>存在一个名为<code>func</code>的函数，后面这个<code>*</code>号我没想明白为啥要加估计是为了告诉编译器传入的参数是一个指针类型吧，如果是这样的话代码可以改成下面这个样子更具有可读性：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Class&gt;                             \</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="keyword">decltype</span>(&amp;Class::func)* ptr)</span> </span>&#123; \</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;                                        \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样也就解释了为啥后面计算<code>value</code>值得时候传入了一个<code>nullptr</code>作为参数。回到最初，假设我现在传入的这个<code>T</code>这个类没有<code>func</code>这个成员，那么编译器就会去调用下面这个泛化的版本，并且上面那个特化的版本不会报错，这叫做c++的<code>SFINAE</code>特性</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;                                   \</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(...)</span> </span>&#123;                     \</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;                                       \</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ol><p>当你想要检查一个类型是否有某个成员函数时，你可以使用这个宏。下面是一个简单的例子，假设你想检查一个类型是否有 <code>size</code> 成员函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TYPE_TRAIT(name, func)                     \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                           \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename Class&gt;</span>                             \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(decltype(&amp;Class::func)*) &#123; \</span></span><br><span class="line"><span class="meta">      return true;                                        \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(...) &#123;                     \</span></span><br><span class="line"><span class="meta">      return false;                                       \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">    static constexpr bool value = Test<span class="string">&lt;T&gt;</span>(nullptr);       \</span></span><br><span class="line"><span class="meta">  &#125;;                                                      \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  constexpr bool name<span class="string">&lt;T&gt;</span>::value;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏定义类型特征结构体</span></span><br><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasSize, size)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个示例类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用类型特征检查类型是否有成员函数</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;HasSize for MyClass: &quot;</span> &lt;&lt; HasSize&lt;MyClass&gt;::value &lt;&lt; std::endl;  <span class="comment">// 输出 1 (true)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 另一个示例类，没有 size 成员函数</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AnotherClass</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;HasSize for AnotherClass: &quot;</span> &lt;&lt; HasSize&lt;AnotherClass&gt;::value &lt;&lt; std::endl;  <span class="comment">// 输出 0 (false)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DEFINE_TYPE_TRAIT(HasSize, size)</code> 定义了一个名为 <code>HasSize</code> 的类型特征结构体，用于检查类型是否有 <code>size</code> 成员函数。然后，通过 <code>HasSize&lt;MyClass&gt;::value</code> 和 <code>HasSize&lt;AnotherClass&gt;::value</code> 分别检查了 <code>MyClass</code> 和 <code>AnotherClass</code> 是否有 <code>size</code> 成员函数。根据定义，<code>MyClass</code> 有 <code>size</code> 成员函数，而 <code>AnotherClass</code> 没有，因此输出结果分别为 <code>1</code>（true）和 <code>0</code>（false）。</p><h3 id="2-2-单例宏"><a href="#2-2-单例宏" class="headerlink" title="2.2 单例宏"></a>2.2 单例宏</h3><p>代码在：<code>cyber/common/macros.h</code>中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasShutdown, Shutdown)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(T *instance)</span> </span>&#123;</span><br><span class="line">  instance-&gt;<span class="built_in">Shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    T *instance)</span> </span>&#123;</span><br><span class="line">  (<span class="type">void</span>)instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// There must be many copy-paste versions of these macros which are same</span></span><br><span class="line"><span class="comment">// things, undefine them to avoid conflict.</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> UNUSED</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DISALLOW_COPY_AND_ASSIGN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNUSED(param) (void)param</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line"><span class="meta">  classname(const classname &amp;) = delete;    \</span></span><br><span class="line"><span class="meta">  classname &amp;operator=(const classname &amp;) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_SINGLETON(classname)                                      \</span></span><br><span class="line"><span class="meta"> public:                                                                  \</span></span><br><span class="line"><span class="meta">  static classname *Instance(bool create_if_needed = true) &#123;              \</span></span><br><span class="line"><span class="meta">    static classname *instance = nullptr;                                 \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span></span><br><span class="line"><span class="meta">      static std::once_flag flag;                                         \</span></span><br><span class="line"><span class="meta">      std::call_once(flag,                                                \</span></span><br><span class="line"><span class="meta">                     [&amp;] &#123; instance = new (std::nothrow) classname(); &#125;); \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">    return instance;                                                      \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta">  static void CleanUp() &#123;                                                 \</span></span><br><span class="line"><span class="meta">    auto instance = Instance(false);                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (instance != nullptr) &#123;                                            \</span></span><br><span class="line"><span class="meta">      CallShutdown(instance);                                             \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta"> private:                                                                 \</span></span><br><span class="line"><span class="meta">  classname();                                                            \</span></span><br><span class="line"><span class="meta">  DISALLOW_COPY_AND_ASSIGN(classname)</span></span><br></pre></td></tr></table></figure><ol><li><p>首先定了两个很有意思的函数模板</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasShutdown, Shutdown)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(T *instance)</span> </span>&#123;</span><br><span class="line">  instance-&gt;<span class="built_in">Shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    T *instance)</span> </span>&#123;</span><br><span class="line">  (<span class="type">void</span>)instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DEFINE_TYPE_TRAIT(HasShutdown, Shutdown)</code>结合上面所讲的这个宏定义了一个名为<code>HasShutdown</code>的结构体用于判断传入的模板<code>T</code>这个类是否包含<code>Shutdown</code>这个成员函数，然后又使用了c++的<code>SFINAE</code>特性做了一个很有意思的操作</p><ul><li><p><code>typename</code>告诉了编译器后面<code>std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::type</code>这玩意儿是一个类型，上面这两个<code>CallShutdown</code>的函数模板入参都是一样的，唯一有区别的就是这个返回值的类型。</p></li><li><p>我们来看看<code>std::enable_if</code>的源码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Primary template.</span></span><br><span class="line"><span class="comment">/// Define a member typedef @c type only if a boolean constant is true.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span>, <span class="keyword">typename</span> _Tp = <span class="type">void</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> enable_if</span><br><span class="line">  &#123; &#125;;</span><br><span class="line">     </span><br><span class="line"><span class="comment">// Partial specialization for true.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">true</span>, _Tp&gt;</span><br><span class="line">  &#123; <span class="keyword">typedef</span> _Tp type; &#125;;</span><br></pre></td></tr></table></figure><p>可以看见c++官方对<code>std::enable_if</code>做了两种定义，一个泛化版本和一个特化版本</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::enable_if&lt;<span class="literal">true</span>, T&gt; <span class="comment">//用的是偏特化的版本</span></span><br><span class="line">std::enable_if&lt;<span class="literal">false</span>, T&gt; <span class="comment">// 用的是泛化的</span></span><br></pre></td></tr></table></figure><p>假设<code>HasShutdown&lt;T&gt;::value</code>的值为<code>true</code>，那么上面两个<code>CallShutdown</code>函数就变成了如下两种情况：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::enable_if&lt;<span class="literal">true</span>&gt;::type     </span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;<span class="literal">false</span>&gt;::type</span><br></pre></td></tr></table></figure><p>很明显<code>std::enable_if&lt;false&gt;::type</code>会走泛化版本，此时<code>std::enable_if</code>内部是没有<code>type</code>这个成员的，由于<code>SFINAE</code>特性的存在，此时并不会报错，所以编译器只会去走<code>std::enable_if&lt;true, T&gt; </code>，但是这里我很奇怪的一点是<code>typename std::enable_if&lt;true&gt;::type</code>这里没有传第二模板参数呀，按我的理解是不是应该&#96;&#96;typename std::enable_if&lt;true,T&gt;::type<code>这样子用，我不是很明白，我想了一下，我先姑且认为编译器会先去做泛化版本的判断，此时由于泛化版本中</code> template&lt;bool, typename _Tp &#x3D; void&gt;<code>，第二模板参数被默认成了</code>void<code>此时编译器发现前面这个bool值为</code>true<code>然后就去走下面这个特化版本，在特化版本中就会定义</code>type<code>的值，此时就是：</code>typedef void type&#96;了。</p><p>同理假设<code>HasShutdown&lt;T&gt;::value</code>的值为<code>fasle</code>，上面两个<code>CallShutdown</code>函数就反过来了，当去调用<code>CallShutdown</code>函数时就会走下面这个版本。</p></li></ul><p>综上所述，上面这两个函数模板就是用于检测类型 <code>T</code> 具有 <code>Shutdown</code> 成员函数，那么这个函数将被启用，否则将被禁用。在启用的情况下，它调用 <code>instance-&gt;Shutdown()</code>。类型 <code>T</code> 不具有 <code>Shutdown</code> 成员函数的情况。在这种情况下，这个函数什么都不做。</p></li><li><p><code>DISALLOW_COPY_AND_ASSIGN</code> 宏用于禁止拷贝和赋值操作。它通过将拷贝构造函数和拷贝赋值操作符声明为 <code>delete</code> 来阻止对象的拷贝和赋值。这通常用于单例模式等情况，以确保对象只能有一个实例。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line"><span class="meta">  classname(const classname &amp;) = delete;    \</span></span><br><span class="line"><span class="meta">  classname &amp;operator=(const classname &amp;) = delete;</span></span><br></pre></td></tr></table></figure></li><li><p><code>DECLARE_SINGLETON</code> 宏用于声明一个单例模式的类。具体来说，它包含以下功能：</p><ul><li><code>Instance(bool create_if_needed = true)</code> 函数用于获取单例对象的实例。如果单例对象尚未创建，它将使用 <code>std::call_once</code> 和 <code>new</code> 运算符创建一个实例。这确保在多线程环境下仅执行一次对象的创建操作。</li><li><code>CleanUp()</code> 函数用于清理单例对象。它调用 <code>CallShutdown</code> 函数来执行对象的清理操作。</li><li><code>classname()</code> 构造函数声明为 <code>private</code>，确保类的实例只能通过 <code>Instance</code> 函数创建。</li><li><code>DISALLOW_COPY_AND_ASSIGN(classname)</code> 用于禁止拷贝和赋值操作，将默认构造也声明成私有的，以确保类的唯一性。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_SINGLETON(classname)                                      \</span></span><br><span class="line"><span class="meta"> public:                                                                  \</span></span><br><span class="line"><span class="meta">  static classname *Instance(bool create_if_needed = true) &#123;              \</span></span><br><span class="line"><span class="meta">    static classname *instance = nullptr;                                 \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span></span><br><span class="line"><span class="meta">      static std::once_flag flag;                                         \</span></span><br><span class="line"><span class="meta">      std::call_once(flag,                                                \</span></span><br><span class="line"><span class="meta">                     [&amp;] &#123; instance = new (std::nothrow) classname(); &#125;); \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">    return instance;                                                      \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta">  static void CleanUp() &#123;                                                 \</span></span><br><span class="line"><span class="meta">    auto instance = Instance(false);                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (instance != nullptr) &#123;                                            \</span></span><br><span class="line"><span class="meta">      CallShutdown(instance);                                             \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta"> private:                                                                 \</span></span><br><span class="line"><span class="meta">  classname();                                                            \</span></span><br><span class="line"><span class="meta">  DISALLOW_COPY_AND_ASSIGN(classname)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3.参考链接"></a>3.参考链接</h2><ul><li><a href="https://liujiayu.blog.csdn.net/article/details/130346051">百度自动驾驶apollo源码解读14:接口存在判定宏DEFINE_TYPE_TRAIT_H-KING的博客-CSDN博客</a></li><li><a href="https://liujiayu.blog.csdn.net/article/details/130367869">百度自动驾驶apollo源码解读15:懒汉式单例宏DECLARE_SINGLETON-CSDN博客</a></li><li><a href="https://www.cnblogs.com/yb-blogs/p/13702717.html">C++ enable_if 探究 - BoBro - 博客园 (cnblogs.com)</a></li><li><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/enable-if-class?view=msvc-170">enable_if 类 | Microsoft Learn</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> fastrtps </tag>
            
            <tag> 分布式通信中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>riscv编译工具链构建说明</title>
      <link href="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="riscv编译工具链构建说明"><a href="#riscv编译工具链构建说明" class="headerlink" title="riscv编译工具链构建说明"></a>riscv编译工具链构建说明</h2><p>构建<code>riscv-gnu-toolchain</code>有几种方式：</p><ul><li>第一种是直接下载源码然后本地编译，然后 <code>make install</code></li><li>第二种如果使用的是<code>ubuntu20</code>，可以直接使用 apt 安装</li><li>第三种就是下载别人已经编译好的文件，然后解压，配置一下工具链路径</li></ul><p>编译器有这几种类型，以64位的编译器为例子，三种不同类型编译器的区别后面会说明</p><ul><li>riscv64-linux-gnu-gcc</li><li>riscv64-unknown-elf-gcc</li><li>riscv64-unknown-linux-gnu-gcc</li></ul><h2 id="源码构建"><a href="#源码构建" class="headerlink" title="源码构建"></a><strong>源码构建</strong></h2><p><code>riscv-gnu-toolchain</code>的官方仓库在：<a href="https://github.com/riscv-collab/riscv-gnu-toolchain">riscv-collab&#x2F;riscv-gnu-toolchain: GNU toolchain for RISC-V, including GCC (github.com)</a>，下载上面的源码，然后按照官方提供的编译命令进行编译安装，但是绝大多数时候是编译不过的，因为官方的源码依赖种的第三方文件我们下载不下来，有一个解决办法就是去<code>gittee</code>镜像上去把对应的包下载然后放进源码种，这样编译是能成功。关于如何在<code>gittee</code>上去下载第三方依赖请各位百度。</p><p>官网提供的编译方式如下：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716140122180.png" alt="image-20230716140122180"></p><p>这里建议直接使用第三种配置编译方式，可以编译生成32位和64位的编译器：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/opt/riscv --enable-multilib</span><br></pre></td></tr></table></figure><blockquote><p>这里使用源码编译太操蛋了，我捣鼓了好久，不推荐</p></blockquote><h2 id="apt-构建"><a href="#apt-构建" class="headerlink" title="apt 构建"></a><strong>apt 构建</strong></h2><p><code>apt</code>构建会比较简单，这里只针对<code>ubuntu20.04</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libc6-riscv64-cross</span><br><span class="line">sudo apt install binutils-riscv64-linux-gnu</span><br><span class="line">sudo apt install gcc-riscv64-linux-gnu</span><br><span class="line">sudo apt install binutils-riscv64-unknown-elf</span><br><span class="line">sudo apt install gcc-riscv64-unknown-elf</span><br></pre></td></tr></table></figure><p>执行上面的命令会生成两种类型的编译器：</p><ul><li>riscv64-linux-gnu-gcc</li><li>riscv64-unknown-elf-gcc</li></ul><p>但是<code>riscv64-unknown-elf-gcc</code>这个编译器是不含c库的，比如你的代码种如果包含了<code>stdio.h</code>想使用<code>printf</code>函数就会报错。不推荐使用<code>apt install</code>安装的<code>riscv64-unknown-elf-gcc</code>编译器。</p><p><code>riscv64-linux-gnu-gcc</code>，使用这个编译器就可以使用C库了，例如我有下面这样一段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用编译器来编译：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc hello.c</span><br></pre></td></tr></table></figure><p>然后使用<code>qemu</code>来执行</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-riscv64 a.out</span><br></pre></td></tr></table></figure><p>这里应该会报一个错误：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-riscv64: Could not open <span class="string">&#x27;/lib/ld-linux-riscv64-lp64.d.so.1&#x27;</span>:No such file or direcyory</span><br></pre></td></tr></table></figure><p>没找到文件的原因是，因为文件下载的地方，和查找的地方不一样，只要把文件cp一下就可以了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /usr/riscv64-linux-gnu/lib/* /lib/</span><br></pre></td></tr></table></figure><p>然后再运行应该就没问题了。</p><h2 id="下载二进制文件构建"><a href="#下载二进制文件构建" class="headerlink" title="下载二进制文件构建"></a><strong>下载二进制文件构建</strong></h2><p>进入<code>riscv-gnu-toolchain</code>的<code>github</code>仓库，找到右边的<code>tags</code></p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143145875.png" alt="image-20230716143145875"></p><p>点击进入：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143217518.png" alt="image-20230716143217518"></p><p>可以看见这里有已经编译好的二进制文件，截至我打开的时候，最新的版本是2023.07.07，点击进入</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143310196.png" alt="image-20230716143310196"></p><p>这里有已经编译好的编译器，分别对应不同的ubuntu版本，有32位和64位两个版本的。</p><p>其中<code>riscv64-elf-ubuntu-20.04-gcc-nightly-2023.07.07-nightly.tar.gz</code>解压后的编译器就是：<code>riscv64-unknown-elf-gcc</code>，<strong>但是官方编译的版本是带C库的</strong>。</p><p><code>riscv64-glibc-ubuntu-20.04-llvm-nightly-2023.07.07-nightly.tar.gz</code>解压后的编译器是：<code>riscv64-unknown-linux-gnu-gcc</code>，假设你用这个编译器去编译上面的<code>hello.c</code>文件，编译是没问题的，但是如果你使用<code>qemu-riscv64 a.out</code>去执行，同样会报错误：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> qemu-riscv64: Could not open <span class="string">&#x27;/lib/ld-linux-riscv64-lp64.d.so.1&#x27;</span>:No such file or direcyory</span><br></pre></td></tr></table></figure><p>同样我们也想到可以将这个编译器的<code>lib</code>文件拷贝过去，但是我在它的<code>lib</code>种却找不到这个动态库，如下：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716144055264.png" alt="image-20230716144055264"></p><p>如果说你拷贝了<code>riscv64-linux-gnu-gcc</code>,那么这里执行应该不会报错。</p><blockquote><p>riscv的编译工具链真的很操蛋！！！！！！！！！！</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://blog.csdn.net/bebebug/article/details/127829361">qemu-riscv64: could not open ‘&#x2F;lib&#x2F;ld-linux-riscv64-lp64d.so.1‘_qemu-x86_64: could not open ‘&#x2F;lib64&#x2F;ld-linux-x86-6_嵌入一下？的博客-CSDN博客</a></p></li><li><p><a href="https://blog.csdn.net/Longyu_wlz/article/details/109150134">(69条消息) qemu 运行 riscv 内核失败记录_longyu_wlz的博客-CSDN博客</a></p></li><li><p><a href="https://gitee.com/unicornx/riscv-operating-system-mooc/issues/I4D6N9">stdio.h 头文件找不到 · Issue #I4D6N9 · unicornx&#x2F;riscv-operating-system-mooc - Gitee.com</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> riscv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写STL之List</title>
      <link href="/2023/06/20/%E6%89%8B%E5%86%99STL-List/"/>
      <url>/2023/06/20/%E6%89%8B%E5%86%99STL-List/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码仓库：<a href="https://github.com/yanglianoo/My_STL/tree/timer">yanglianoo&#x2F;My_STL at timer (github.com)</a></p></blockquote><h1 id="1-List概述"><a href="#1-List概述" class="headerlink" title="1.List概述"></a>1.List概述</h1><p>C++标准模板库（STL）中的<code>list</code>是一个双向链表容器，提供了在链表中高效存储和访问数据的功能。它是一个模板类具有以下特性：</p><ol><li>链表结构：<code>list</code>是由节点组成的链表，每个节点包含数据以及指向前一个节点和后一个节点的指针。这种结构使得在<code>list</code>中插入、删除和移动元素非常高效，因为不需要像动态数组那样进行内存的移动和重分配。</li><li>双向访问：<code>list</code>支持双向访问，可以从链表的开头或末尾快速访问元素。你可以使用迭代器进行正向或反向遍历，也可以使用<code>front()</code>和<code>back()</code>函数访问第一个和最后一个元素。</li><li>动态大小：<code>list</code>的大小可以动态增长或缩小，无需预先分配固定大小的内存。</li><li>插入和删除：在<code>list</code>中插入和删除元素非常高效。通过使用迭代器，可以在常数时间内在任意位置插入或删除元素。</li><li>不支持随机访问：<code>list</code>不支持通过索引进行随机访问，这意味着不能像数组那样使用索引来访问元素。如果需要随机访问，<code>vector</code>可能更适合。</li><li>没有连续存储：由于<code>list</code>是一个链表，它的元素在内存中不是连续存储的，这可能会对缓存性能产生一些影响。</li><li>不支持快速的随机访问、排序和二分查找：由于没有随机访问，对<code>list</code>进行排序和二分查找会比较低效。如果需要这些功能，你可以考虑使用<code>vector</code>或<code>deque</code>容器。</li></ol><p><code>STL</code>库中<code>list</code>的定义如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Allocator</span> = std::allocator&lt;T&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> list;</span><br></pre></td></tr></table></figure><table><thead><tr><th>T</th><th>元素的类型。<code>T</code> 必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>Allocator</th><th>用于获取&#x2F;释放内存及构造&#x2F;析构内存中元素的分配器。类型必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/Allocator"><em>分配器</em> <em>(Allocator)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>成员函数</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/list">(构造函数)</a></td><td>构造 <code>list</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/~list">(析构函数)</a></td><td>析构 <code>list</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/operator%3D">operator&#x3D;</a></td><td>赋值给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/assign">assign</a></td><td>将值赋给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/get_allocator">get_allocator</a></td><td>返回相关的分配器 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/push_front">push_front</a></td><td>插入元素到容器起始 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace_front">emplace_front</a>(C++11)</td><td>在容器头部原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/pop_front">pop_front</a></td><td>移除首元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/swap">swap</a></td><td>交换内容 (公开成员函数)</td></tr></tbody></table><blockquote><p>参考链接：<a href="https://zh.cppreference.com/w/cpp/container/list">std::list - cppreference.com</a></p></blockquote><h1 id="2-构造节点"><a href="#2-构造节点" class="headerlink" title="2. 构造节点"></a>2. 构造节点</h1><p>list的数据结构有两种，一种是双向链表，结构如下：</p><p><img src="/2023/06/20/%E6%89%8B%E5%86%99STL-List/1632118785.jpg" alt="图解几种常见的线性表 - 命中水"></p><p>在双向链表中，每一个节点为一个node，node包含一个指向上一个节点的prev指针和指向下一个节点的next指针，头节点的prev指针指向nullptr，尾节点的next指针指向nullptr。</p><p>一种是双向循环链表，和双向链表不同的就是，双向循环链表头节点的prev指针指向了尾节点，尾节点的next指针指向了头节点，由此组成了一个循环。</p><p><img src="/2023/06/20/%E6%89%8B%E5%86%99STL-List/3650507100.jpg" alt="图解几种常见的线性表 - 命中水"></p><p>我们实现的list是基于双向链表的，list是一个C++的类，由很多个节点构成，因此先来定义一下节点的数据结构，node节点由两个指针和存储的数据组成，是一个模板类，定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">list_node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    list_node&lt;T&gt;* prev;</span><br><span class="line">    list_node&lt;T&gt;* next;</span><br><span class="line">    <span class="built_in">list_node</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">            :<span class="built_in">next</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            ,<span class="built_in">prev</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            ,<span class="built_in">data</span>(value)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-构造迭代器"><a href="#3-构造迭代器" class="headerlink" title="3.构造迭代器"></a>3.构造迭代器</h1><p>在list的使用种，用两种类型的迭代器，一种是普通的<code>iterator</code>，还有一种就是不可修改的<code>const_iterator</code>，这里的不可修改是指节点的数据不可修改，迭代器构造如下，和vector的迭代器类似，需要去重载不同的操作符。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, Ref, ptr&gt; self;</span><br><span class="line"><span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">list_iterator</span>(Node* node)</span><br><span class="line">:_node(node)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//拷贝构造、赋值重载，默认浅拷贝即可</span></span><br><span class="line"><span class="comment">//析构函数，指针指向的节点不属于迭代器的，无需自己销毁</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//解引用,*it = it.operator*()</span></span><br><span class="line">Ref&amp; <span class="keyword">operator</span>* ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line">ptr <span class="keyword">operator</span>-&gt; () <span class="comment">//本来调用为it-&gt;-&gt;_value,编译器通过处理省略了一个-&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_node-&gt;_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置--</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置--</span></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != it._node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node == it._node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>list_iterator</code>内部维护了一个<code>list_node&lt;T&gt;*</code>类型的指针，用来指向<code>list</code>的每一个节点，这里解释一下为啥<code>list_iterator</code>模板类为啥有三个模板参数，那是为了方便通过typedef来定义<code>iterator</code>和<code>const_iterator</code>，在后面list类中可以如下定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br></pre></td></tr></table></figure><h1 id="4-构造list类"><a href="#4-构造list类" class="headerlink" title="4.构造list类"></a>4.构造list类</h1><p>首先list类中包含了如下的成员变量，除了一个node类型的指针还维护了一个_size，当对list容器进行操作时，需要对_size实现增减操作。由于采用循环链表实现，所以当初始化链表时只需要定义一个头节点，让<code>head</code>节点的<code>prev</code>和<code>next</code>指针都指向自己就可以了.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">list</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, T&amp;, T*&gt; iterator; <span class="comment">//普通迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator; <span class="comment">//const迭代器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* _head;</span><br><span class="line">    <span class="type">size_t</span> _size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty_initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="built_in">T</span>());</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line"></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义默认构造函数</span></span><br><span class="line">   <span class="built_in">list</span>()&#123; <span class="built_in">empty_initialize</span>(); &#125;</span><br><span class="line">    <span class="comment">//定义析构函数</span></span><br><span class="line">   ~<span class="built_in">list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span>[] _head;</span><br><span class="line">        _head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后我们来定义一些和迭代器有关的函数，首先是<code>begin()</code>和<code>end()</code>，用来返回头节点指针和尾节点指针，这里我们定义<code>_head-&gt;next</code>为<code>begin</code>，<code>end</code>为<code>_head</code>，然后有两个重载版本。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(_head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-容量"><a href="#2-1-容量" class="headerlink" title="2.1 容量"></a>2.1 容量</h2><p>和容量相关的接口比较简单，这里不赘述，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-修改器"><a href="#2-2-修改器" class="headerlink" title="2.2 修改器"></a>2.2 修改器</h2><p>在实现其他修改器之前，可先定义<code>insert</code>和<code>erase</code>函数,代码逻辑并不复杂，实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//往pos位置插入元素T</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node* cur = pos._node;</span><br><span class="line">        Node* prev = cur-&gt;_prev;</span><br><span class="line"></span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">        new_node-&gt;_prev = prev;</span><br><span class="line">        new_node-&gt;_next = cur;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        prev-&gt;_next = new_node;</span><br><span class="line">        cur-&gt;_prev = new_node;</span><br><span class="line"></span><br><span class="line">        _size++;</span><br><span class="line">        <span class="comment">//隐式转换为iterator</span></span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//删除pos位置的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(pos != <span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        Node* cur = pos._node;</span><br><span class="line">        Node* prev = cur-&gt;_prev;</span><br><span class="line">        Node* next = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        prev-&gt;_next = next;</span><br><span class="line">        next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line">        _size--;</span><br><span class="line">        <span class="keyword">delete</span> [] cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除范围为 [first, last) 的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator first, iterator last )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == last) &#123; <span class="keyword">return</span> last;&#125;</span><br><span class="line"></span><br><span class="line">        Node* first_node = first._node;</span><br><span class="line">        Node* last_node = last._node;</span><br><span class="line"></span><br><span class="line">        Node* prev = first_node-&gt;_prev;</span><br><span class="line">        Node* next = last_node;</span><br><span class="line"></span><br><span class="line">        prev-&gt;_next = next;</span><br><span class="line">        next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (first_node != last_node)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* cur = first_node;</span><br><span class="line">            first_node = first_node-&gt;_next;</span><br><span class="line">            <span class="keyword">delete</span> [] cur;</span><br><span class="line">            count++; </span><br><span class="line">        &#125;</span><br><span class="line">        _size-=count;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他的修改器就可基于insert和erase函数来实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>(),<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">begin</span>(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-元素访问"><a href="#2-3-元素访问" class="headerlink" title="2.3 元素访问"></a>2.3 元素访问</h2><p>提供了访问头节点和尾节点数据的接口：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(--<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-其他构造函数"><a href="#2-4-其他构造函数" class="headerlink" title="2.4 其他构造函数"></a>2.4 其他构造函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>(<span class="type">size_t</span> count, <span class="type">const</span> T&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(<span class="type">size_t</span> count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(<span class="built_in">T</span>());</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt&gt;</span><br><span class="line">    <span class="built_in">list</span>(InputIt first, InputIt last) : <span class="built_in">list</span>() </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">while</span> (first != last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">push_back</span>(*first);</span><br><span class="line">++first;</span><br><span class="line">            _size++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(<span class="type">const</span> list&amp; other): <span class="built_in">list</span>() </span><br><span class="line">    &#123;</span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">tmp</span><span class="params">(other.begin(), other.end())</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(_head, tmp._head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(std::initializer_list&lt;T&gt; init) : <span class="built_in">list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> T&amp; value : init) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list&lt;T&gt; &amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> T&amp; value : other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;T&gt;&amp; <span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> T&amp; value : ilist) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h1><p>list已完成，未进行测试，list是比较简单的，当然我们还有一些机制没有实现，比如逆向迭代器，assign函数等，不过核心的接口都已经实现，后续可完善。</p>]]></content>
      
      
      <categories>
          
          <category> 手写STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础-存储访问</title>
      <link href="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/"/>
      <url>/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-存储器使用场景"><a href="#1-存储器使用场景" class="headerlink" title="1.存储器使用场景"></a>1.存储器使用场景</h1><p>先来看如下这一张图，CPU运行程序的流程如下：</p><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614133226741.png" alt="image-20230614133226741"></p><p>1：假设我现在在电脑上编译了一个<code>hello.c</code>的程序，编译完成后为<code>hello.bin</code>的一个二进制文件，此时这个程序还存储在我们电脑的硬盘上，这个硬盘可能是机械硬盘也可能是固态硬盘，这些都是外存储器。</p><p>2：将<code>hello.bin</code>装载进内存，这里的内存就是插在电脑上的内存条，<code>hello.bin</code>包含了cpu要执行的指令和运行所需要的数据。</p><p>3：CPU从内存中逐条读取指令及相关指令，然后依次执行完成对数据的处理。</p><p>4：将处理结果送回内存保存，然后再将处理结果送到外存储器。</p><p>所以其实在CPU运行的过程中主要是分为两类存储器：</p><ul><li><p>内存储器</p><p>存取速度快 </p><p>成本高、容量相对较小 </p><p>直接与CPU连接，CPU对内存 中可直接进行读、写操作 </p><p>属于易失性存储器(volatile)， 用于临时存放正在运行的程序和数据，掉电就没了数据。</p></li><li><p>外存储器（简称外存或辅存）</p><p>– 存取速度慢 – 成本低、容量很大 </p><p>– 不与CPU直接连接，先传送到内 存，然后才能被CPU使用。</p><p> – 属于非易失性存储器，用于长久存放系统中几乎所有的信息</p></li></ul><blockquote><p>这里可能会有个疑问，CPU访问内存的方式是通过地址总线来访问的，CPU是如何访问外存的呢：</p><p>CPU访问外部存储器（外存）的方式通常是通过输入输出（I&#x2F;O）指令和I&#x2F;O总线来实现的。外存通常指的是硬盘、固态硬盘（SSD）、光盘、磁带等非易失性存储介质。</p><p>与内存访问不同，外存的访问速度相对较慢，因此CPU在执行指令时通常不直接与外存进行交互，而是通过操作系统和设备控制器等中间层来实现。以下是CPU访问外存的一般过程：</p><ol><li>CPU发送I&#x2F;O指令：当需要读取或写入外存中的数据时，CPU会发出相应的I&#x2F;O指令，这些指令通常包括读取（IN）和写入（OUT）操作。</li><li>I&#x2F;O总线传输：CPU将I&#x2F;O指令发送到I&#x2F;O总线上。I&#x2F;O总线是一种特殊的总线，用于传输CPU和外部设备之间的数据和控制信号。</li><li>设备控制器响应：I&#x2F;O总线上连接着各种外部设备控制器，如硬盘控制器或磁带控制器。当设备控制器接收到CPU发送的I&#x2F;O指令时，它会解析指令并准备执行相应的读取或写入操作。</li><li>数据传输：设备控制器根据指令从外存读取数据或将数据写入外存。这个过程涉及到设备控制器与外存之间的数据传输，可能需要通过外存总线或其他特定接口进行。</li><li>完成操作：设备控制器完成读取或写入操作后，将状态信息返回给CPU，指示操作是否成功或是否有错误发生。</li></ol></blockquote><p>主存的结构如下：</p><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614140500484.png" alt="image-20230614140500484"></p><p>一个存储单元为一个bit，按字节编址的话一个地址对应的就是8个字节，数据总线读取一个地址的数据就一次性读取8个bit，这8个bit的地址都是一样的</p><p>如果CPU的数据总线是64位，则一次性最大可以读取64bit的数据也就是8个字节。</p><p>地址线为36位，则可以寻址的范围是0~2^36-1，即主存地址空间为64GB。</p><h1 id="2-存储器分类"><a href="#2-存储器分类" class="headerlink" title="2.存储器分类"></a>2.存储器分类</h1><h2 id="2-1-RAM"><a href="#2-1-RAM" class="headerlink" title="2.1 RAM"></a>2.1 RAM</h2><p>内存（主存，RAM，Random Access Memory）：</p><ol><li>主存是CPU直接访问的存储器，用于存储当前执行的程序、数据和临时计算结果。</li><li>分类：<ul><li>随机访问存储器（RAM）：包括动态随机访问存储器（DRAM）和静态随机访问存储器（SRAM）。DRAM存储器成本较低，容量较大，但读写速度相对较慢；SRAM存储器读写速度快，但成本较高。</li><li>缓存（Cache）：用于在CPU和主存之间提供快速数据访问，减少CPU等待数据的时间。根据接近CPU的级别不同，可以分为一级缓存（L1 Cache）、二级缓存（L2 Cache）等多级别缓存。</li></ul></li><li>应用场景：<ul><li>执行指令和存储数据：CPU从内存中读取指令和数据进行运算和处理。</li><li>运行操作系统和应用程序：操作系统和应用程序加载到内存中运行，提供计算、存储和交互功能。</li></ul></li></ol><h2 id="2-2-ROM"><a href="#2-2-ROM" class="headerlink" title="2.2 ROM"></a>2.2 ROM</h2><p>ROM是只读存储器（Read-Only Memory）的缩写，它是一种用于存储固定数据的存储器类型。与可写的存储器（如RAM）不同，ROM中的数据在制造或编程之后就无法被修改。</p><p>以下是一些关键特点和应用场景，以帮助更好理解ROM：</p><p>特点：</p><ol><li>只读性质：ROM中的数据在制造或编程之后就无法被修改或擦除。</li><li>非易失性：与RAM不同，ROM中的数据在断电或重新启动后仍然保持不变。</li><li>持久存储：ROM用于存储固定的数据，如固件、引导程序、不经常更改的配置信息等。</li></ol><p>应用场景：</p><ol><li>固件：ROM常用于存储计算机系统或电子设备的固件，包括BIOS（基本输入&#x2F;输出系统）、固件程序和引导加载器等。</li><li>引导程序：计算机启动时，ROM中的引导程序负责初始化硬件和加载操作系统。</li><li>芯片固化数据：ROM用于存储芯片的校准数据、配置信息和厂商特定的数据，以便在设备制造后使用。</li><li>只读存储媒体：一些光盘和芯片类型，如CD-ROM、DVD-ROM、Blu-ray Disc、EPROM（可擦除可编程只读存储器）等，被设计为只读存储介质。</li></ol><p>需要注意的是，不同类型的ROM可以具有不同的特性。例如，EPROM是一种可擦除可编程只读存储器，允许通过特殊操作将其中的数据擦除并重新编程，而普通的ROM则不具备这种功能。此外，还有一些衍生类型的ROM，如EEPROM（可擦除可编程只读存储器）、Flash存储器等，它们具有一定的可擦除和可重新编程的能力。</p><h2 id="2-3-储存器功能分类"><a href="#2-3-储存器功能分类" class="headerlink" title="2.3 储存器功能分类"></a>2.3 储存器功能分类</h2><ul><li>寄存器(Register) <ul><li>封装在CPU内，用于存放当前正在执行的指令和使用的数据 </li><li>用触发器实现，速度快，容量小（几~几十个）</li></ul></li><li>高速缓存(Cache) </li><li>位于CPU内部或附近，用来存放当前要执行的局部程序段和数据 </li><li>-用SRAM实现，速度可与CPU匹配，容量小（几MB） </li><li>内存储器MM（主存储器Main (Primary) Memory）<ul><li>位于CPU之外，用来存放已被启动的程序及所用的数据 </li><li>用DRAM实现，速度较快，容量较大（几GB）</li></ul></li><li>外存储器AM (辅助存储器Auxiliary &#x2F; Secondary Storage) <ul><li>位于主机之外，用来存放暂不运行的程序、数据或存档文件</li><li>用磁盘、SSD等实现，容量大而速度慢</li></ul></li></ul><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614140240489.png" alt="image-20230614140240489"></p><h1 id="3-嵌入式存储实例"><a href="#3-嵌入式存储实例" class="headerlink" title="3.嵌入式存储实例"></a>3.嵌入式存储实例</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器 </tag>
            
            <tag> 计算机系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树详解</title>
      <link href="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-设备树简介"><a href="#1-设备树简介" class="headerlink" title="1.设备树简介"></a>1.设备树简介</h1><p>传统上，操作系统内核会直接编译进所有支持的硬件设备的驱动程序。但是，随着硬件设备的不断增多和变化，这种方法变得不够灵活。设备树的引入解决了这个问题。设备树将硬件的描述信息以一种结构化的方式存储在单独的文件中，然后在引导过程中由操作系统内核加载和解析。</p><p>设备树文件使用一种称为”Device Tree Source”（DTS）的语言编写，它是一种人类可读的文本格式。该文件描述了硬件设备的层次结构、寄存器地址、中断线路、DMA通道和其他相关属性。这些信息对于内核来说非常重要，因为它们允许内核正确地初始化和配置硬件设备。</p><p>设备树文件经过<code>DTC</code>编译后会生成一种称为”Device Tree Blob”（DTB）的二进制格式。DTB文件在引导过程中由引导加载程序（Bootloader）提供给内核。内核会解析DTB文件，根据其中的描述信息初始化硬件设备，并加载相应的驱动程序。</p><p>设备树的作用在于用来描述一个具体的硬件平台的硬件资源，如果没有设备树，当我有一个新的硬件平台时，在移植操作系统时需要去修改源码去适配这个具体的硬件平台。有了设备树之后，bootloader就能直接从设备树中获取硬件信息，而不需要去修改源码，使得Linux内核的兼容性和可移植性大大增强。</p><ul><li><p><code>DTS：</code>Device Tree Source，<code>.dts</code>格式的文件，是一种<code>ASII </code>文本格式的设备树描述，也是我们要编写的设备树源码，一般一个<code>.dts</code>文件对应一个硬件平台，位于Linux源码的<code>/arch/***/boot/dts”</code>目录下。</p></li><li><p><code>DTC：</code>Device Tree Compiler，是指编译设备树源码的工具，一般情况下我们需要手动安装这个编译工具。</p></li><li><p><code>DTB </code>：是设备树源码编译生成的文件，类似于我们C语言中“.C”文件编译生成“.bin”文件</p></li></ul><img src="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/1503563-20200915000144208-924995757.png" alt="Linux驱动之设备树的基础知识 - 山无言 - 博客园" style="zoom:67%;"><blockquote><p>参考链接：<a href="https://doc.embedfire.com/linux/imx6/base/zh/latest/linux_driver/driver_tree.html">doc.embedfire.com&#x2F;linux&#x2F;imx6&#x2F;base&#x2F;zh&#x2F;latest&#x2F;linux_driver&#x2F;driver_tree.html</a></p></blockquote><h1 id="2-设备树基本语法架构分析"><a href="#2-设备树基本语法架构分析" class="headerlink" title="2.设备树基本语法架构分析"></a>2.设备树基本语法架构分析</h1><h2 id="2-1-dts基本框架"><a href="#2-1-dts基本框架" class="headerlink" title="2.1 dts基本框架"></a>2.1 dts基本框架</h2><p><code>1.头文件</code>：设备树是可以像C语言那样使用“#include”引用“.h”后缀的头文件，也可以引用设备树“.dtsi”后缀的头文件。因此这里<code>k210.dts</code>引用了<code>k210.dtsi</code>中的文件</p><p><code>2.设备树节点</code>：每一个<code>&#123; &#125;</code>都是一个节点，<code>/ &#123;…&#125;</code>表示“根节点”， 在根节点内部的“aliases {…}”、“chosen {…}”、“memory {…}”等字符，都是根节点的子节点。</p><p><code>3.设备树节点追加内容</code>：向已经存在的子节点追加数据，这些已经存在的节点可能定义在<code>.dts</code>文件里，也可能定义在<code>.dtsi</code>文件里，这些节点比根节点下的子节点多了一个<code>&amp;</code>。</p><p>设备树由一个根节点和众多子节点组成，子节点也可以继续包含其他节点，也就是子节点的子节点。</p><h3 id="2-1-1节点基本格式"><a href="#2-1-1节点基本格式" class="headerlink" title="2.1.1节点基本格式"></a>2.1.1节点基本格式</h3><p>设备树中的每个节点都按照以下约定命名：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">node-name@unit-address<span class="punctuation">&#123;</span></span><br><span class="line">    属性<span class="number">1</span> = …</span><br><span class="line">    属性<span class="number">2</span> = …</span><br><span class="line">    属性<span class="number">3</span> = …</span><br><span class="line">    子节点…</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>节点格式中的<code> node-name</code> 用于指定节点的名称。 它的长度为1至31个字符，只能由如下字符组成:</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>0-9</td><td>数字</td></tr><tr><td>a-z</td><td>小写字母</td></tr><tr><td>A-Z</td><td>大写字母</td></tr><tr><td>,</td><td>英文逗号</td></tr><tr><td>.</td><td>英文句号</td></tr><tr><td>_</td><td>下划线</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>-</td><td>减号</td></tr></tbody></table><blockquote><p>注意：根节点没有节点名，它直接使用“&#x2F;”指代这是一个根节点。</p></blockquote><p><code>@unit-address</code> ：其中的符号“@”可以理解为是一个分割符，“unit-address”用于指定“单元地址”， 它的值要和节点“reg”属性的第一个地址一致。如果节点没有“reg”属性值，可以直接省略“@unit-address”， 不过要注意这时要求同级别的设备树下（相同级别的子节点）节点名唯一,从这个侧面也可以了解到， 同级别的子节点的节点名可以相同，但是要求“单元地址”不同，node-name@unit-address 的整体要求同级唯一。</p><h3 id="2-1-2-节点标签"><a href="#2-1-2-节点标签" class="headerlink" title="2.1.2 节点标签"></a>2.1.2 节点标签</h3><p>例如：</p><pre><code>sysctl: sysctl@50440000 &#123;        compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;;        reg = &lt;0x50440000 0x1000&gt;;        #clock-cells = &lt;1&gt;;&#125;;</code></pre><p>则<code>sysctl</code>就代表了<code>sysctl@50440000</code>这个节点的标签，用<code>:</code>来指明。通常节点标签是节点名的简写，所以它的作用是当其它位置需要引用时可以使用节点标签来向该节点中追加内容。</p><h3 id="2-1-3-节点路径"><a href="#2-1-3-节点路径" class="headerlink" title="2.1.3 节点路径"></a>2.1.3 节点路径</h3><p>通过指定从根节点到所需节点的完整路径，可以唯一地标识设备树中的节点，<code>不同层次的设备树节点名字可以相同，同层次的设备树节点要唯一</code>。 这有点类似于我们Windows上的文件，一个路径唯一标识一个文件或文件夹，不同目录下的文件文件名可以相同。</p><h3 id="2-1-4-节点属性"><a href="#2-1-4-节点属性" class="headerlink" title="2.1.4 节点属性"></a>2.1.4 节点属性</h3><ul><li><p><strong>compatible属性</strong>：属性值类型：字符串</p><p>compatible属性值由一个或多个字符串组成，有多个字符串时使用“,”分隔开。设备树中的每一个代表了一个设备的节点都要有一个compatible属性。 compatible是系统用来决定绑定到设备的设备驱动的关键。 compatible属性是用来查找节点的方法之一，另外还可以通过节点名或节点路径查找指定节点。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>model属性</strong>：属性值类型：字符串</p><p>model属性用于指定设备的制造商和型号，推荐使用“制造商, 型号”的格式，当然也可以自定义。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;Kendryte K210 generic&quot;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>status属性</strong></p><p>状态属性用于指示设备的“操作状态”，通过status可以去禁止设备或者启用设备，可用的操作状态如下表。默认情况下不设置status属性设备是使能的。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* External sound card */</span></span><br><span class="line"><span class="symbol">sound:</span> <span class="title class_">sound</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>reg属性</strong></p><p>reg属性描述设备资源在其父总线定义的地址空间内的地址。通常情况下用于表示一块内存的起始地址（偏移地址）和长度， 在特定情况下也有不同的含义。 ret属性的书写格式为reg &#x3D; &lt; cells cells cells cells cells cells…&gt;，长度根据实际情况而定， 这些数据分为地址数据（地址字段），长度数据（大小字段）</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure><p>这里描述了三段内存：起始地址为0x80000000，大小为0x400000；起始地址为：0x80400000 ，0x200000；起始地址为：0x80600000，大小为：0x200000。每一个cells都是32位的，如果想要描述一个64位的地址，需要先设置#address-cells 和 #size-cells属性的值。</p></li><li><p><strong>#address-cells 和 #size-cells</strong></p><p>#address-cells，用于指定子节点reg属性“地址字段”所占的长度（单元格cells的个数）。</p><p> #size-cells，用于指定子节点reg属性“大小字段”所占的长度（单元格cells的个数）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line">    ocrams: sram@900000 &#123;</span><br><span class="line">            compatible = &quot;fsl,lpm-sram&quot;;</span><br><span class="line">            reg = &lt;0x900000 0x4000&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如当#address-cells&#x3D;2，#address-cells&#x3D;1，则reg内的数据含义为<code>reg = &lt;address address size address address size&gt;</code>，这样就可以来描述一个64位的地址了。</p></li><li><p><strong>device_type</strong></p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">    <span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;arm,cortex-a7&quot;</span><span class="punctuation">;</span></span><br><span class="line">        device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>device_type属性也是一个很少用的属性，只用在CPU和内存的节点上。 如上例中所示，device_type用在了CPU节点。</p></li><li><p><strong>ranges</strong></p></li></ul><h3 id="2-1-5-特殊节点"><a href="#2-1-5-特殊节点" class="headerlink" title="2.1.5 特殊节点"></a>2.1.5 特殊节点</h3><ul><li><code>aliases</code>子节点：aliases子节点的作用就是为其他节点起一个别名，如下所示。</li></ul><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">    can0 = <span class="variable">&amp;flexcan1</span><span class="punctuation">;</span></span><br><span class="line">    can1 = <span class="variable">&amp;flexcan2</span><span class="punctuation">;</span></span><br><span class="line">    ethernet0 = <span class="variable">&amp;fec1</span><span class="punctuation">;</span></span><br><span class="line">    ethernet1 = <span class="variable">&amp;fec2</span><span class="punctuation">;</span></span><br><span class="line">    gpio0 = <span class="variable">&amp;gpio1</span><span class="punctuation">;</span></span><br><span class="line">    gpio1 = <span class="variable">&amp;gpio2</span><span class="punctuation">;</span></span><br><span class="line">    gpio2 = <span class="variable">&amp;gpio3</span><span class="punctuation">;</span></span><br><span class="line">    gpio3 = <span class="variable">&amp;gpio4</span><span class="punctuation">;</span></span><br><span class="line">    gpio4 = <span class="variable">&amp;gpio5</span><span class="punctuation">;</span></span><br><span class="line">    i2c0 = <span class="variable">&amp;i2c1</span><span class="punctuation">;</span></span><br><span class="line">    i2c1 = <span class="variable">&amp;i2c2</span><span class="punctuation">;</span></span><br><span class="line">    <span class="comment">/*----------- 以下省略------------*/</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以“can0 &#x3D; &amp;flexcan1;”为例。“flexcan1”是一个节点的名字， 设置别名后我们可以使用“can0”来指代flexcan1节点，与节点标签类似。 在设备树中更多的是为节点添加标签，没有使用节点别名，别名的作用是“快速找到设备树节点”。 在驱动中如果要查找一个节点，通常情况下我们可以使用“节点路径”一步步找到节点。 也可以使用别名“一步到位”找到节点。</p><ul><li><code>chosen子节点</code>：chosen子节点位于根节点下，如下所示</li></ul><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">stdout-path</span> <span class="operator">=</span> <span class="variable">&amp;uart1</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>chosen子节点不代表实际硬件，它主要用于给内核传递参数。 这里只设置了“stdout-path &#x3D;&amp;uart1;”一条属性，表示系统标准输出stdout使用串口uart1。 此外这个节点还用作uboot向linux内核传递配置参数的“通道”， 我们在Uboot中设置的参数就是通过这个节点传递到内核的， 这部分内容是uboot和内核自动完成的。</p><h1 id="3-Linux内核中K210设备树分析"><a href="#3-Linux内核中K210设备树分析" class="headerlink" title="3.Linux内核中K210设备树分析"></a>3.Linux内核中K210设备树分析</h1><p>从Linux 5.7 开始，Linux内核开始支持国产 RISC-V 芯片 K210，在本地的linux5.10版本中的<code>/arch/riscv/boot/dts</code>文件夹中可以找到kendryte的K210设备树文件，我们以此为例子，来分析设备树的语法与语义</p><p><img src="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/image-20230611222950267.png" alt="image-20230611222950267"></p><h2 id="3-1-k210-dts分析"><a href="#3-1-k210-dts分析" class="headerlink" title="3.1 k210.dts分析"></a>3.1 k210.dts分析</h2><p>其中<code>k210.dts</code>的文件如下：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;k210.dtsi&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">//设置节点基本属性</span></span><br><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;Kendryte K210 generic&quot;</span><span class="punctuation">;</span>  <span class="comment">//指定为嘉楠的K210</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span>     <span class="comment">//设置compatible属性</span></span><br><span class="line"><span class="comment">// 设置chosen特殊节点，</span></span><br><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">bootargs</span> <span class="operator">=</span> <span class="string">&quot;earlycon console=ttySIF0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">stdout-path</span> <span class="operator">=</span> <span class="string">&quot;serial0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;uarths0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li>第一行：引用头文件，<code>k210.dts</code>引用了<code>k210.dtsi</code>中的文件</li><li>3~12行：k210的根节点，每一个设备树只有一个根节点。 如果打开<code>k210.dtsi</code>文件可以发现它也有一个根节点，虽然<code>k210.dts</code>引用了<code>k210.dtsi</code>文件， 但这并不代表设备树有两个根节点，因为不同文件的根节点最终会合并为一个。<ul><li><code>bootargs = &quot;earlycon console=ttySIF0&quot;;</code> 是 “chosen” 节点的属性之一。它用于指定系统引导过程中传递给内核的启动参数（boot arguments）。在这里，设置的启动参数是 “earlycon console&#x3D;ttySIF0”，表示使用早期控制台（early console）并将其输出重定向到名为 “ttySIF0” 的串口设备。</li><li><code>stdout-path = &quot;serial0&quot;;</code> 是 “chosen” 节点的另一个属性。它用于指定标准输出（stdout）的路径。在这里，标准输出被设置为名为 “serial0” 的设备。</li></ul></li><li>13~15行：设备树增加内容。向<code>uarths0</code>子节点添加了一个属性，<code>status = &quot;okay&quot;;</code> 在这里，状态被设置为 “okay”，表示<code>uarths0</code>设备节点处于可用状态，可以正常使用。</li></ul><h2 id="3-2-k210-dtsi分析"><a href="#3-2-k210-dtsi分析" class="headerlink" title="3.2 k210.dtsi分析"></a>3.2 k210.dtsi分析</h2><h3 id="3-2-1-根节点"><a href="#3-2-1-根节点" class="headerlink" title="3.2.1 根节点"></a>3.2.1 根节点</h3><p><code>k210.dtsi</code>的文件如下：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dt-bindings/clock/k210-clk.h&gt;</span></span></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Although the K210 is a 64-bit CPU, the address bus is only 32-bits</span></span><br><span class="line"><span class="comment"> * wide, and the upper half of all addresses is ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">serial0 = <span class="variable">&amp;uarths0</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The K210 has an sv39 MMU following the priviledge specification v1.9.</span></span><br><span class="line"><span class="comment"> * Since this is a non-ratified draft specification, the kernel does not</span></span><br><span class="line"><span class="comment"> * support it and the K210 support enabled only for the !MMU case.</span></span><br><span class="line"><span class="comment"> * Be consistent with this by setting the CPUs MMU type to &quot;none&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">timebase-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7800000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="title class_">cpu@1</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu1_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">sram:</span> <span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-names</span> <span class="operator">=</span> <span class="string">&quot;sram0&quot;</span>, <span class="string">&quot;sram1&quot;</span>, <span class="string">&quot;aisram&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">clocks</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">in0:</span> <span class="title class_">oscillator</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fixed-clock&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">26000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">soc</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-soc&quot;</span>, <span class="string">&quot;simple-bus&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">ranges</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;plic0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">sysctl:</span> <span class="title class_">sysctl@50440000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-sysctl&quot;</span>, <span class="string">&quot;simple-mfd&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x50440000</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">clint0:</span> <span class="title class_">clint@2000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,clint0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x2000000</span> <span class="number">0xC000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span>  <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">3</span> <span class="variable">&amp;cpu0_intc</span> <span class="number">7</span></span></span><br><span class="line"><span class="params"><span class="variable">&amp;cpu1_intc</span> <span class="number">3</span> <span class="variable">&amp;cpu1_intc</span> <span class="number">7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_ACLK&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">plic0:</span> <span class="title class_">interrupt-controller@c000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-plic0&quot;</span>, <span class="string">&quot;riscv,plic0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xC000000</span> <span class="number">0x4000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">11</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">0xffffffff</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="variable">&amp;cpu1_intc</span> <span class="number">11</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cpu1_intc</span> <span class="number">0xffffffff</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,ndev</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">65</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,max-priority</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">uarths0:</span> <span class="title class_">serial@38000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-uarths&quot;</span>, <span class="string">&quot;sifive,uart0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x38000000</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">33</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>在第一行中包含了一个c语言中的头文件<code>#include &lt;dt-bindings/clock/k210-clk.h&gt;</code>，这个文件位于<code>linux-5.10.99/include/dt-bindings/clock</code>下，打开此文件如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> K210_CLK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Arbitrary identifiers for clocks.</span></span><br><span class="line"><span class="comment"> * The structure is: in0 -&gt; pll0 -&gt; aclk -&gt; cpu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since we use the hardware defaults for now, set all these to the same clock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_PLL0   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_PLL1   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_ACLK   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_CPU    0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* K210_CLK_H */</span></span></span><br></pre></td></tr></table></figure><p>可以看到，只是定义了一些宏定义，后续可能用到</p><p><code>7~13</code>行</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">serial0 = <span class="variable">&amp;uarths0</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>#address-cells = &lt;1&gt;;</code> 指定了设备树中地址单元的数量，这里设置为 1。</li><li><code>#size-cells = &lt;1&gt;;</code> 指定了设备树中大小单元的数量，这里也设置为 1。</li><li><code>compatible = &quot;kendryte,k210&quot;;</code> 表示设备树描述的硬件与 Kendryte K210 SoC 兼容。这个属性用于标识设备树所描述的硬件平台或设备的兼容性。</li><li><code>aliases</code>：定义了一个别名 <code>serial0</code>，它指向名为 <code>uarths0</code> 的设备。</li></ul><h3 id="3-2-2-cpu节点"><a href="#3-2-2-cpu节点" class="headerlink" title="3.2.2 cpu节点"></a>3.2.2 cpu节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;    <span class="comment">// 地址单元为1</span></span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;        <span class="comment">// 大小单元为0</span></span></span><br><span class="line"><span class="attr">timebase-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7800000</span>&gt;</span><span class="punctuation">;</span>  <span class="comment">//指定cpu时钟基准频率7800000hz</span></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="title class_">cpu@1</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu1_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>cpu单元定义了两个核心分别为cpu0和cpu1，两个cpu核心的配置差不都，下面依次描述一下具体描述了哪些信息，这里以cpu0为例子：</p><ul><li><p>device_type &#x3D; “cpu”：表示此节点为cpu。</p></li><li><p>reg &#x3D; &lt;0&gt;：标明这是0号处理器。</p></li><li><p>compatible &#x3D; “kendryte,k210”, “sifive,rocket0”, “riscv”：指定cpu的标识。</p></li><li><p>riscv,isa &#x3D; “rv64imafdc”：表明该cpu为rv64imafdc架构。</p></li><li><p>mmu-type &#x3D; “none”：cpu不启用mmu，未开启虚拟内存功能。</p></li><li><p>i-cache-size &#x3D; &lt;0x8000&gt;：指令缓存的大小为 0x8000，即 32768 字节（或 32 KB）。</p></li><li><p>i-cache-block-size &#x3D; &lt;64&gt;：指令缓存的块大小为 64 字节。</p></li><li><p>d-cache-size &#x3D; &lt;0x8000&gt;：数据缓存（Data Cache）的大小为 0x8000，即 32768 字节（或 32 KB）。</p></li><li><p>d-cache-block-size &#x3D; &lt;64&gt;：数据缓存的块大小为 64 字节。</p></li><li><p>clocks &#x3D; &lt;&amp;sysctl K210_CLK_CPU&gt;：指向设备树中名为 <code>sysctl</code> 的节点， <code>sysctl</code> 定义在下面的<code>soc</code>节点中,并使用 K210_CLK_CPU 作为其子节点，K210_CLK_CPU这个宏定义在<code>k210-clk.h</code>中，值为：0。表明cpu0的时钟是 <code>sysctl</code> 节点中的0号子时钟</p></li><li><p>clock-frequency &#x3D; &lt;390000000&gt;：指定时钟的频率为390MHZ</p></li><li><p>cpu0_intc：中断控制器节点，用于处理与 CPU 0 相关的中断。</p><ul><li><code>#interrupt-cells = &lt;1&gt;</code>：指定了中断单元的数量，即中断号码的位数。在这种情况下，每个中断使用一个单元（一个整数值）来表示。</li><li><code>interrupt-controller</code>：表示该节点是中断控制器。</li><li><code>compatible = &quot;riscv,cpu-intc&quot;</code>：指定了该中断控制器节点与 RISC-V 架构的 CPU 中断控制器兼容。</li></ul></li></ul><h3 id="3-2-3-SRAM节点"><a href="#3-2-3-SRAM节点" class="headerlink" title="3.2.3 SRAM节点"></a>3.2.3 SRAM节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sram:</span> <span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-names</span> <span class="operator">=</span> <span class="string">&quot;sram0&quot;</span>, <span class="string">&quot;sram1&quot;</span>, <span class="string">&quot;aisram&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>memory@80000000</code>：指定了 SRAM 的基地址为 <code>0x80000000</code>。</li><li><code>device_type = &quot;memory&quot;</code>：指定了设备类型为内存。</li><li><code>reg</code>：指定了 SRAM 的物理地址范围。在这种情况下，SRAM 被划分为三个连续的地址范围：<ul><li><code>&lt;0x80000000 0x400000&gt;</code>：<code>sram0</code> 的地址范围为从 <code>0x80000000</code> 到 <code>0x803FFFFF</code>，大小为 4 MB。</li><li><code>&lt;0x80400000 0x200000&gt;</code>：<code>sram1</code> 的地址范围为从 <code>0x80400000</code> 到 <code>0x805FFFFF</code>，大小为 2 MB。</li><li><code>&lt;0x80600000 0x200000&gt;</code>：<code>aisram</code> 的地址范围为从 <code>0x80600000</code> 到 <code>0x807FFFFF</code>，大小为 2 MB。</li></ul></li><li><code>reg-names = &quot;sram0&quot;, &quot;sram1&quot;, &quot;aisram&quot;</code>：指定了对应于每个地址范围的名称</li></ul><h3 id="3-2-4-clocks节点"><a href="#3-2-4-clocks节点" class="headerlink" title="3.2.4 clocks节点"></a>3.2.4 clocks节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">clocks</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">in0:</span> <span class="title class_">oscillator</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fixed-clock&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">26000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>该设备树中的 <code>clocks</code> 节点定义了一个名为 <code>in0</code> 的时钟，具体如下：</p><ul><li><code>in0</code>：时钟的名称为 <code>in0</code>。</li><li><code>oscillator</code>：指定了该时钟源为一个振荡器。</li><li><code>compatible = &quot;fixed-clock&quot;</code>：指定了时钟的类型为固定频率时钟。</li><li><code>#clock-cells = &lt;0&gt;</code>：表示该时钟节点不需要附加的时钟单元属性。</li><li><code>clock-frequency = &lt;26000000&gt;</code>：指定了时钟的频率为 26 MHz。</li></ul><h3 id="3-2-5-soc节点"><a href="#3-2-5-soc节点" class="headerlink" title="3.2.5 soc节点"></a>3.2.5 soc节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;kendryte,k210-soc&quot;, &quot;simple-bus&quot;;</span><br><span class="line">ranges;  //省略ranges属性，不存在地址映射</span><br><span class="line">interrupt-parent = &lt;&amp;plic0&gt;;   </span><br><span class="line"></span><br><span class="line">sysctl: sysctl@50440000 &#123;</span><br><span class="line">compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;;</span><br><span class="line">reg = &lt;0x50440000 0x1000&gt;;</span><br><span class="line">#clock-cells = &lt;1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">clint0: clint@2000000 &#123;</span><br><span class="line">#interrupt-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;riscv,clint0&quot;;</span><br><span class="line">reg = &lt;0x2000000 0xC000&gt;;</span><br><span class="line">interrupts-extended =  &lt;&amp;cpu0_intc 3 &amp;cpu0_intc 7</span><br><span class="line">&amp;cpu1_intc 3 &amp;cpu1_intc 7&gt;;</span><br><span class="line">clocks = &lt;&amp;sysctl K210_CLK_ACLK&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">plic0: interrupt-controller@c000000 &#123;</span><br><span class="line">#interrupt-cells = &lt;1&gt;;</span><br><span class="line">interrupt-controller;</span><br><span class="line">compatible = &quot;kendryte,k210-plic0&quot;, &quot;riscv,plic0&quot;;</span><br><span class="line">reg = &lt;0xC000000 0x4000000&gt;;</span><br><span class="line">interrupts-extended = &lt;&amp;cpu0_intc 11&gt;, &lt;&amp;cpu0_intc 0xffffffff&gt;,</span><br><span class="line">      &lt;&amp;cpu1_intc 11&gt;, &lt;&amp;cpu1_intc 0xffffffff&gt;;</span><br><span class="line">riscv,ndev = &lt;65&gt;;</span><br><span class="line">riscv,max-priority = &lt;7&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uarths0: serial@38000000 &#123;</span><br><span class="line">compatible = &quot;kendryte,k210-uarths&quot;, &quot;sifive,uart0&quot;;</span><br><span class="line">reg = &lt;0x38000000 0x1000&gt;;</span><br><span class="line">interrupts = &lt;33&gt;;</span><br><span class="line">clocks = &lt;&amp;sysctl K210_CLK_CPU&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>interrupt-parent = &lt;&amp;plic0&gt;</code>：指定了中断控制器的父节点，这里使用的是 plic0 中断控制器的引用。</p></li><li><p><code>sysctl: sysctl@50440000</code>：这是一个子节点，描述了系统控制器 (sysctl)。它有以下属性：</p><ul><li><code>compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;</code>：指定了系统控制器的兼容性标识符，表示该节点描述的是 Kendryte K210 SoC 的系统控制器，并且它是一个多功能设备。</li><li><code>reg = &lt;0x50440000 0x1000&gt;</code>：指定了系统控制器在内存中的地址范围。</li><li><code>#clock-cells = &lt;1&gt;</code>：指定了该节点使用的时钟单元数。</li></ul></li><li><p><code>clint0: clint@2000000</code>：这是另一个子节点，描述了 CLINT (Core Local Interruptor)。它有以下属性：</p><ul><li><code>compatible = &quot;riscv,clint0&quot;</code>：指定了 CLINT 的兼容性标识符。</li><li><code>reg = &lt;0x2000000 0xC000&gt;</code>：指定了 CLINT 在内存中的地址范围。</li><li><code>interrupts-extended</code>：指定了 CLINT 支持的中断引脚，这里使用的是 <code>cpu0_intc</code> 和 <code>cpu1_intc</code> 的引用。</li><li><code>clocks = &lt;&amp;sysctl K210_CLK_ACLK&gt;</code>：指定了 CLINT 使用的时钟源，这里使用的是 <code>sysctl</code> 节点中的 <code>K210_CLK_ACLK</code> 时钟。</li></ul></li><li><p><code>plic0: interrupt-controller@c000000</code>：这是另一个子节点，描述了 PLIC (Platform-Level Interrupt Controller)。它有以下属性：</p><ul><li><code>compatible = &quot;kendryte,k210-plic0&quot;, &quot;riscv,plic0&quot;</code>：指定了 PLIC 的兼容性标识符。</li><li><code>reg = &lt;0xC000000 0x4000000&gt;</code>：指定了 PLIC 在内存中的地址范围。</li><li><code>interrupts-extended</code>：指定了 PLIC 支持的中断引脚，这里使用的是 <code>cpu0_intc</code> 和 <code>cpu1_intc</code> 的引用。</li><li><code>riscv,ndev = &lt;65&gt;</code>：指定了 PLIC 支持的设备数量。</li><li><code>riscv,max-priority = &lt;7&gt;</code>：指定了 PLIC 支持的最大优先级</li></ul></li><li><p><code>uarths0: serial@38000000</code>：这是串口设备的节点定义，名称为 <code>uarths0</code>，描述了串口在内存中的地址范围。</p><ul><li><code>compatible = &quot;kendryte,k210-uarths&quot;, &quot;sifive,uart0&quot;</code>：指定了串口设备的兼容性标识符，表示该节点描述的是 Kendryte K210 SoC 的 <code>uarths0</code> 串口，并且它兼容 SiFive 的 UART0 设备。</li><li><code>reg = &lt;0x38000000 0x1000&gt;</code>：指定了串口设备在内存中的地址范围。</li><li><code>interrupts = &lt;33&gt;</code>：指定了串口设备的中断引脚，这里使用的是中断号 33。</li><li><code>clocks = &lt;&amp;sysctl K210_CLK_CPU&gt;</code>：指定了串口设备使用的时钟源，这里使用的是 <code>sysctl</code> 节点中的 <code>K210_CLK_CPU</code> 时钟。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 设备树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源码构建Qemu</title>
      <link href="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/"/>
      <url>/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Qemu介绍"><a href="#1-Qemu介绍" class="headerlink" title="1.Qemu介绍"></a>1.Qemu介绍</h1><p>QEMU（Quick Emulator）是一个开源的虚拟化软件，它可以模拟多个硬件平台，包括处理器和外设，从而允许在一个平台上运行多个不同的操作系统。QEMU可以运行在多个主机平台上，包括Linux、Windows、macOS等。</p><p>QEMU的主要功能是模拟一个完整的计算机系统，包括处理器、内存、存储器、网络接口等，它可以将客户操作系统（例如Linux、Windows等）当作应用程序运行在主机操作系统之上，从而实现虚拟化。QEMU还支持通过二进制代码转换的方式实现虚拟化加速，例如使用KVM（Kernel-based Virtual Machine）模块加速虚拟机的运行。</p><p>QEMU可以用于多种用途，包括：</p><ol><li>系统仿真：可以模拟不同的处理器架构（如x86、ARM等）来运行和测试操作系统和应用程序，方便开发人员进行交叉平台开发和调试。</li><li>虚拟机：可以在一个物理机上运行多个虚拟机实例，每个虚拟机可以运行不同的操作系统，实现资源的隔离和共享，提供虚拟化环境。</li><li>可移植性：QEMU可以将一个操作系统或应用程序打包成一个虚拟机镜像，这个镜像可以在不同的平台上运行，提供了一种便携式的软件分发方式。</li></ol><blockquote><p>官方源码地址：<a href="https://github.com/qemu/qemu">Qemu的github源码</a></p><p>官网地址：<a href="https://www.qemu.org/">QEMU</a></p><p>qemu的文档地址：<a href="https://www.qemu.org/docs/master/">Welcome to QEMU’s documentation! — QEMU documentation</a></p></blockquote><h1 id="2-源码下载"><a href="#2-源码下载" class="headerlink" title="2.源码下载"></a>2.源码下载</h1><p>在笔者下载源码的时间，目前<code>qemu</code>的版本已经更新到了<code>8.0.2</code>，我的ubuntu环境为：<code>WSL2 ubuntu20.04.05</code></p><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611160604923.png" alt="image-20230611160604923"></p><p>安装所需编译环境：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install ninja-build pkg-config libglib2.0-dev libpixman-1-dev libgtk-3-dev libcap-ng-dev libattr1-dev libsdl2-dev device-tree-compiler bison flex gperf intltool mtd-utils libslirp-dev</span><br></pre></td></tr></table></figure><p>源码下载与编译：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~$ <span class="built_in">mkdir</span> qemu</span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ <span class="built_in">cd</span> qemu/</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ wget https://download.qemu.org/qemu-8.0.2.tar.xz</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ tar xvJf qemu-8.0.2.tar.xz</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ <span class="built_in">cd</span> qemu-8.0.2/</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ ./configure</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ make -j8</span><br></pre></td></tr></table></figure><p>编译完成后会生成一个<code>./build</code>目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ <span class="built_in">cd</span> build/</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由于我之前使用package的方式在本地安装了一个qemu，因此先将其卸载</span></span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ sudo apt-get remove --auto-remove qemu-system-x86</span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ sudo apt-get purge --auto-remove qemu-system-x86</span><br><span class="line"><span class="comment">#卸载完成后进入build目录执行安装命令，需要sudo不然会报错</span></span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2/build$ sudo make install</span><br></pre></td></tr></table></figure><p>测试，查看<code>qemu</code>版本号，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-img -V</span><br></pre></td></tr></table></figure><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611164450596.png" alt="image-20230611164450596"></p><p>启动qemu，这里以riscv64为例：<code>qemu-system-riscv64</code></p><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611164621585.png" alt="image-20230611164621585"></p><p>大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> Qemu&amp;虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-3.实模式</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-X86cpu工作原理"><a href="#1-X86cpu工作原理" class="headerlink" title="1. X86cpu工作原理"></a>1. X86cpu工作原理</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611121633671.png" alt="image-20230611121633671"></p><p>程序计数器<code>PC</code>存储了下一条要运行的指定的地址，在x86cpu上，<code>PC</code>就是：<code>cs：ip</code>，控制单元读取<code>ip</code>寄存器中的地址后，将此地址送上地址总线，<code>cpu</code>由此得到了要执行的指令，然后将指令存入指令寄存器<code>IR</code>中。下一步指令译码器将此指令解码，解码后得到了操作数和操作码，于是操作控制器<code>OC</code>就给运算单元下令，运算单元就开始执行指令。<code>ip</code>寄存器的值被加上当前指令的大小，由此循环。</p><p>IA32的指令格式如下：</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611123557111.png" alt="image-20230611123557111"></p><h2 id="2-实模式的寻址"><a href="#2-实模式的寻址" class="headerlink" title="2. 实模式的寻址"></a>2. 实模式的寻址</h2><p>8086的地址总线是20位宽，意味着寻址范围为：<code>2^20=1MB</code>，但内部寄存器都是16位的，若采用单一寄存器来寻址只能访问：<code>2^16=64KB</code>空间。</p><p>为了解决16位寄存器不能寻址20位的问题，因此通过先把16位的段基址左移四位变成20位后，在加上段内偏移地址，这样就形成了20位地址，只要保证了段基址是20位的，偏移地址是多少位就不用关心了。</p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU3RyaXZlIGZvciB0aGUgYmVzdO-8gQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="3.操作系统——CPU的实模式、保护模式和长模式_Strive for the best！的博客-CSDN博客" style="zoom: 50%;"><p>下面列举一下寻址实例：所有的利用寄存器寻址的方式，每个寄存器都有对应的段基址，寄存器的默认段基址见上一章</p><ol><li><p>直接寻址（Direct addressing）：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> AX, [<span class="number">0x1234</span>]</span><br><span class="line"><span class="keyword">mov</span> ax, [fs:<span class="number">0x5678</span>]</span><br></pre></td></tr></table></figure><p>0x1234是段内偏移地址，默认的段地址是DS，这一条指令是将内存地址<code>DS:0x1234</code>处的值写入<code>ax</code>寄存器。</p><p>第二条指定显示指定段基址为<code>fs</code>,因此是将内存地址<code>FS:0x5678</code>处的值写入<code>ax</code>寄存器。</p><p>注意：段基址都需要先左移4位再与段内偏移相加</p></li><li><p>基址寻址（Base addressing）：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> AX, [BX + <span class="number">0x10</span>]</span><br></pre></td></tr></table></figure><p>这个例子中，将从BX寄存器所指定的内存地址加上偏移量0x10处读取一个字（16位）的数据，并将其存储在AX寄存器中。bx默认的段寄存器为DS，因此实际的寻址地址为：<code>DS:bx+0x10</code></p></li></ol><h2 id="3-栈的布局"><a href="#3-栈的布局" class="headerlink" title="3.栈的布局"></a>3.栈的布局</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611131141910.png" alt="image-20230611131141910"></p><p>栈空间也是内存中一段区域，我们程序员可以自由分配，SS栈段寄存器左移4位指向栈底，栈的生长是向低地址方向发展，sp指向了栈顶。</p><p>在进行函数调用时，例如使用call指令，需要将PC压栈，然后跳转。</p>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-2.X86寄存器详解</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是寄存器"><a href="#1-什么是寄存器" class="headerlink" title="1.什么是寄存器"></a>1.什么是寄存器</h1><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果以及一些CPU运行需要的信息</p><p>x86架构CPU走的是<code>复杂指令集（CISC）</code> 路线，提供了丰富的指令来实现强大的功能，与此同时也提供了大量寄存器来辅助功能实现。寄存器分为两类，一类对程序员不可见，这一类寄存器用于支撑CPU内部运行，程序员无法操作。一类对程序员可见，在进行汇编编写程序时，能够直接操作。</p><ul><li>通用寄存器：<code>EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP</code></li><li>标志寄存器：<code>EFLAGS</code></li><li>指令寄存器：<code>EIP</code></li><li>段寄存器：<code>CS、DS、ES、FS、GS、SS</code></li><li>控制寄存器：<code>CR0、CR1、CR2、CR3、CR4</code></li><li>调试寄存器：<code>DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7</code></li><li>描述符寄存器：<code>GDTR、IDTR、LDTR、TR</code></li></ul><h1 id="2-实模式下寄存器（16bit）"><a href="#2-实模式下寄存器（16bit）" class="headerlink" title="2.实模式下寄存器（16bit）"></a>2.实模式下寄存器（16bit）</h1><p>在x86架构下，实模式可以使用的通用寄存器有 <code>AX、BX、CX、DX、SI、DI、BP</code> 和 <code>SP</code>。这些寄存器都是16位的，可以分为两个8位的寄存器来使用。</p><p>此外，还有一些特殊用途的寄存器，包括：</p><ul><li><code>IP</code>（指令指针寄存器）：保存当前执行的指令地址。</li><li><code>CS</code>（代码段寄存器）：保存代码段的起始地址。</li><li><code>DS</code>（数据段寄存器）：保存数据段的起始地址。</li><li><code>ES</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>GS</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>FS</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>SS</code>（堆栈段寄存器）：保存堆栈段的起始地址。</li><li><code>FLAGS</code>（标志寄存器）：包含各种标志位，如零标志、进位标志、符号标志等</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230611122704382.png" alt="image-20230611122704382"></p><p>其中<code>FS</code>,<code>GS</code>附加段寄存器是在32位CPU中增加的，但是在32位CPU中在实模式下同样可以使用，因为32位CPU兼容16位CPU的特性。</p><table><thead><tr><th>16位寄存器</th><th>功能</th><th>高8位</th><th>低8位</th></tr></thead><tbody><tr><td><code>AX</code></td><td>累加寄存器，常用于算术运算，保存与外设输入输出的数据</td><td><code>AH</code></td><td><code>AL</code></td></tr><tr><td><code>CX</code></td><td>计数寄存器，常用于循环指令中的循环次数</td><td><code>CH</code></td><td><code>CL</code></td></tr><tr><td><code>DX</code></td><td>数据寄存器，通常情况下只用于保存外设控制器的端口号地址</td><td><code>DH</code></td><td><code>DL</code></td></tr><tr><td><code>BX</code></td><td>基址寄存器，来存储内存地址，段基址为DS</td><td><code>BH</code></td><td><code>BL</code></td></tr><tr><td><code>SP</code></td><td>栈指针寄存器，段基址为SS，用来指向栈顶</td><td></td><td></td></tr><tr><td><code>BP</code></td><td>栈帧的基址寄存器，段基址为SS</td><td></td><td></td></tr><tr><td><code>SI</code></td><td>源变址寄存器，存储数据源地址,段基址为DS</td><td></td><td></td></tr><tr><td><code>DI</code></td><td>目的变址寄存器，存储数据目的地址,段基址为DS</td><td></td><td></td></tr></tbody></table><blockquote><p>BP指向栈底，SP指向栈顶，两者共同维护了栈空间。<code>push</code> 和 <code>pop</code> 可更改<code>SP</code>的值,<code>sp</code>指针的值会自动更新</p></blockquote><h2 id="2-1-寄存器用法举例"><a href="#2-1-寄存器用法举例" class="headerlink" title="2.1 寄存器用法举例"></a>2.1 寄存器用法举例</h2><ul><li><p><code>SI、DI</code></p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">mov</span> ecx, <span class="number">10</span>  <span class="comment">; 设置循环计数为10</span></span><br><span class="line">    <span class="keyword">mov</span> esi, <span class="number">0</span>  <span class="comment">; 设置SI寄存器为0作为初始值</span></span><br><span class="line">    <span class="keyword">mov</span> edi, <span class="number">100</span>  <span class="comment">; 设置DI寄存器为100作为初始值</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">loop_start:</span></span><br><span class="line">    <span class="keyword">mov</span> eax, [esi]  <span class="comment">; 从源地址(SI)读取数据到EAX寄存器</span></span><br><span class="line">    <span class="keyword">mov</span> [edi], eax  <span class="comment">; 将数据存储到目的地址(DI)</span></span><br><span class="line">    <span class="keyword">add</span> esi, <span class="number">4</span>  <span class="comment">; 增加SI的值，以便读取下一个双字</span></span><br><span class="line">    <span class="keyword">add</span> edi, <span class="number">4</span>  <span class="comment">; 增加DI的值，以便存储到下一个地址</span></span><br><span class="line">    loop loop_start  <span class="comment">; 循环，减少ECX计数，直到为零</span></span><br></pre></td></tr></table></figure><p>在这个例子中，SI和DI寄存器用作源地址和目的地址。循环从源地址读取数据，然后将其存储到目的地址，然后递增SI和DI以访问下一个元素。通过loop指令和ECX计数器，循环执行直到计数为零。</p></li><li><p><code>BP、SP</code></p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">push</span> ebp         <span class="comment">; 保存当前函数的旧的基址到堆栈中</span></span><br><span class="line"><span class="keyword">mov</span> ebp, esp     <span class="comment">; 将当前堆栈指针存储到基址指针寄存器BP中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sub</span> esp, <span class="number">16</span>      <span class="comment">; 分配16字节的局部变量空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> dword ptr [ebp<span class="number">-4</span>], <span class="number">10</span>   <span class="comment">; 将值10存储到基址指针寄存器BP-4指向的位置（局部变量）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> eax, dword ptr [ebp<span class="number">-4</span>]  <span class="comment">; 从基址指针寄存器BP-4指向的位置读取值到EAX寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> esp, <span class="number">16</span>      <span class="comment">; 释放局部变量空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pop</span> ebp          <span class="comment">; 恢复旧的基址到基址指针寄存器BP中</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-保护模式下寄存器（32bit）"><a href="#3-保护模式下寄存器（32bit）" class="headerlink" title="3.保护模式下寄存器（32bit）"></a>3.保护模式下寄存器（32bit）</h1><h2 id="3-1-保护模式寄存器介绍"><a href="#3-1-保护模式寄存器介绍" class="headerlink" title="3.1 保护模式寄存器介绍"></a>3.1 保护模式寄存器介绍</h2><p>在32位保护模式下，x86架构提供了更多的通用寄存器以及扩展功能。以下是32位保护模式下可以使用的寄存器：</p><ol><li>通用寄存器（General Purpose Registers）：<ul><li><code>EAX</code>：累加器寄存器（Accumulator Register）。</li><li><code>EBX</code>：基址寄存器（Base Register）。</li><li><code>ECX</code>：计数寄存器（Counter Register）。</li><li><code>EDX</code>：数据寄存器（Data Register）。</li><li><code>ESI</code>：源索引寄存器（Source Index Register）。</li><li><code>EDI</code>：目的索引寄存器（Destination Index Register）。</li><li><code>EBP</code>：基址指针寄存器（Base Pointer Register）。</li><li><code>ESP</code>：堆栈指针寄存器（Stack Pointer Register）。</li></ul></li><li>扩展通用寄存器：<ul><li><code>EIP</code>：指令指针寄存器（Instruction Pointer Register）。</li><li><code>EFLAGS</code>：标志寄存器（Flags Register），用于存储各种标志位，如零标志、进位标志、符号标志等。</li></ul></li><li>段寄存器（Segment Registers）：<ul><li><code>CS</code>：代码段寄存器（Code Segment Register）。</li><li><code>DS</code>：数据段寄存器（Data Segment Register）。</li><li><code>ES</code>：附加段寄存器（Extra Segment Register）。</li><li><code>FS、GS、SS</code>：附加段寄存器，用于访问额外的数据段。</li></ul></li><li>控制寄存器（Control Registers）：<ul><li><code>CR0、CR2、CR3、CR4</code>：用于控制和管理保护模式的特性，如分页机制、特权级等。</li></ul></li><li>段描述符寄存器（Descriptor Registers）：<ul><li><code>GDTR</code>：全局描述符表寄存器（Global Descriptor Table Register）。</li><li><code>IDTR</code>：中断描述符表寄存器（Interrupt Descriptor Table Register）。</li><li><code>LDTR</code>：局部描述符表寄存器（Local Descriptor Table Register）。</li><li><code>TR</code>：任务寄存器（Task Register）。</li></ul></li></ol><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230128173803324.png" alt="image-20230128173803324" style="zoom: 80%;"><h2 id="3-2-控制寄存器"><a href="#3-2-控制寄存器" class="headerlink" title="3.2 控制寄存器"></a>3.2 控制寄存器</h2><h3 id="3-2-1-CR0寄存器"><a href="#3-2-1-CR0寄存器" class="headerlink" title="3.2.1 CR0寄存器"></a>3.2.1 <code>CR0</code>寄存器</h3><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230609214128132.png" alt="image-20230609214128132"></p><ul><li><p><code>PE: Protection Enble </code></p><p>当此位为0，代表在CPU处在实模式，此位为1，表示CPU处在保护模式；从实模式切换到保护模式时需要将此位置为1.</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="meta">#进入保护模式</span></span><br><span class="line"><span class="keyword">mov</span> eax, cr0</span><br><span class="line"><span class="keyword">or</span> eax, <span class="number">0x00000001</span></span><br><span class="line"><span class="keyword">mov</span> cr0, eax</span><br></pre></td></tr></table></figure></li><li><p><code>TS：Task Switched</code></p></li><li><p><code>WP：Write Protect</code></p><p>对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志。当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作；当该位复位时则反之。该标志有利于UNIX类操作系统在创建进程时实现写时复制（Copy on Write）技术。</p></li><li><p><code>AM：Alignment Mask</code></p></li><li><p><code>NW：Not Writethrough</code></p></li><li><p><code>CD：Cache Disable</code></p></li><li><p><code>PG：Paging</code></p><p>是否启动分页机制的位，只有在保护模式以上才能开启分页机制。PG位为1开启分页机制，PG位为0关闭分页机制</p></li></ul><p>在CPU刚上电时，处理器被复位成PE&#x3D;0,PG&#x3D;0。</p><h3 id="3-2-2-CR2寄存器"><a href="#3-2-2-CR2寄存器" class="headerlink" title="3.2.2 CR2寄存器"></a>3.2.2 <code>CR2</code>寄存器</h3><h3 id="3-2-3-CR3寄存器"><a href="#3-2-3-CR3寄存器" class="headerlink" title="3.2.3 CR3寄存器"></a>3.2.3 <code>CR3</code>寄存器</h3><h3 id="3-2-4-CR4寄存器"><a href="#3-2-4-CR4寄存器" class="headerlink" title="3.2.4 CR4寄存器"></a>3.2.4 <code>CR4</code>寄存器</h3><h2 id="3-3-EFLAGS寄存器"><a href="#3-3-EFLAGS寄存器" class="headerlink" title="3.3 EFLAGS寄存器"></a>3.3 <code>EFLAGS</code>寄存器</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230611124419683.png" alt="image-20230611124419683"></p><ul><li>CF：进位标志</li><li>PF：奇偶位标志</li><li>AF：辅助进位标志</li><li>ZF：零标志位</li><li>SF：符号标注位</li><li>TF：陷阱标志位</li><li>IF：中断标志位。若IF为1，表示中断开启；若为0，表示中断关闭</li><li>DF：方向标志位。</li><li>OF：溢出标志位。</li><li>IOPL：特权级标志位，占2个bit，标志了4个特权级</li><li>NT：任务嵌套标志位</li><li>RF：恢复标志位</li><li>VM：虚拟8086模式</li><li>AC：对齐检查</li><li>VIF：虚拟中断标志位</li><li>VIP：虚拟中断挂起标志位</li><li>ID：识别标志位</li><li>22~31：没有实际用途，占位用，为了将来拓展</li></ul><h2 id="3-4-段描述符寄存器"><a href="#3-4-段描述符寄存器" class="headerlink" title="3.4 段描述符寄存器"></a>3.4 段描述符寄存器</h2><h3 id="3-4-1-GDTR寄存器"><a href="#3-4-1-GDTR寄存器" class="headerlink" title="3.4.1 GDTR寄存器"></a>3.4.1 <code>GDTR</code>寄存器</h3><p>GDTR是个48位的寄存器，专门用来储存GDT的内存地址和大小</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626124256061.png" alt="image-20230626124256061"></p><p>GDT：Global Descriptor Table，全局段描述符，在保护模式下，GDT在内存中有且只有一个，GDT的数据结构如下，每个描述符8个字节，64个bit，可以存放在内存当中任意位置，addr相当于GDT的内存起始地址，GDT的总长度就就是GDT界限</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/20201026145225176.png" alt="在这里插入图片描述"></p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626124507958.png" alt="image-20230626124507958"></p><p>段描述符的主要属性都在高32位：</p><ul><li><p>0~7位：段基址的16-23</p></li><li><p>24~31位：段基址的24-31</p></li><li><p>8~11位：type字段，共四位，用来指定本描述符的类型</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626132808111.png" alt="image-20230626132808111"></p></li><li><p>12位：S字段，用于指示系统是否是系统段。S为0表示系统段，S为1表示数据段，type字段要和S字段配合在一起才能确定段描述符的确切类型。</p></li><li><p>15位：Present，即段是否存在。如果段存在于内存中，P为1，否则为0</p></li><li><p>16~19位：段界限的16-19位</p></li><li><p>20位：AVL，随便用，操作系统可以随便用这一位</p></li><li><p>21位：L字段，用来设置是否是64位代码段。L为1表示64位代码段，否则表示32位代码段。</p></li><li><p>22位：D&#x2F;B字段</p></li><li><p>23位：G字段，用来设置段界限的单位大小，若G为0，表示段界限的单位是4KB，若界为1，表示段界限的单位是4KB</p></li><li><p>24~31位：段基址的最后8位</p></li></ul><p>在实模式下，段寄存器中存储的是段基地址，即内存段的起始地址，而在保护模式下，由于段基址已经存入了段描述符中，所以段寄存器不再存放段基址，而是存放一个叫选择子的东西，选择子用来在段描述符表中索引相应的段描述符，数据结构如下：</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626133735851.png" alt="image-20230626133735851"></p><ul><li>0~1位：RPL，存储请求特权级，总共有0、1、2、3四个特权级</li><li>2位：TI，用来表示是GDT还是LDT，TI为0表示在GDT中索引描述符，TI为1表示在LDT中索引描述符</li></ul><p>在代码中我们可以定义对应的结构体来定义GDT和选择子以及全局描述符表指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">descriptor_t</span> /* 共 8 个字节 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> limit_low;      <span class="comment">// 段界限 0 ~ 15 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> base_low : <span class="number">24</span>;    <span class="comment">// 基地址 0 ~ 23 位 16M</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> type : <span class="number">4</span>;        <span class="comment">// 段类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> segment : <span class="number">1</span>;     <span class="comment">// 1 表示代码段或数据段即非系统段，0 表示系统段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> DPL : <span class="number">2</span>;         <span class="comment">// Descriptor Privilege Level 描述符特权等级 0 ~ 3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> present : <span class="number">1</span>;     <span class="comment">// 存在位，1 在内存中，0 在磁盘上</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> limit_high : <span class="number">4</span>;  <span class="comment">// 段界限 16 ~ 19;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> available : <span class="number">1</span>;   <span class="comment">// 该安排的都安排了，送给操作系统吧</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> long_mode : <span class="number">1</span>;   <span class="comment">// 64 位扩展标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> big : <span class="number">1</span>;         <span class="comment">// 32 位 还是 16 位;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> granularity : <span class="number">1</span>; <span class="comment">// 粒度 4KB 或 1B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base_high;       <span class="comment">// 基地址 24 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">descriptor_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 段选择子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">selector_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u8 RPL : <span class="number">2</span>; <span class="comment">// Request Privilege Level</span></span><br><span class="line">    u8 TI : <span class="number">1</span>;  <span class="comment">// Table Indicator</span></span><br><span class="line">    u16 index : <span class="number">13</span>;</span><br><span class="line">&#125; <span class="type">selector_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pointer_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 limit;</span><br><span class="line">    u32 base;</span><br><span class="line">&#125; _packed <span class="type">pointer_t</span>;</span><br></pre></td></tr></table></figure><p>下一步就是填充GDT和GDT_PTR</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充GDT</span></span><br><span class="line"><span class="type">descriptor_t</span> gdt[GDT_SIZE]; <span class="comment">//内核全局描述符表</span></span><br><span class="line">    <span class="built_in">memset</span>(gdt, <span class="number">0</span>, <span class="keyword">sizeof</span>(gdt));</span><br><span class="line"></span><br><span class="line">    <span class="type">descriptor_t</span> *desc;</span><br><span class="line">    desc = gdt + KERNEL_CODE_IDX;</span><br><span class="line">    descriptor_init(desc, <span class="number">0</span>, <span class="number">0xFFFFF</span>);</span><br><span class="line">    desc-&gt;segment = <span class="number">1</span>;     <span class="comment">// 代码段</span></span><br><span class="line">    desc-&gt;granularity = <span class="number">1</span>; <span class="comment">// 4K</span></span><br><span class="line">    desc-&gt;big = <span class="number">1</span>;         <span class="comment">// 32 位</span></span><br><span class="line">    desc-&gt;long_mode = <span class="number">0</span>;   <span class="comment">// 不是 64 位</span></span><br><span class="line">    desc-&gt;present = <span class="number">1</span>;     <span class="comment">// 在内存中</span></span><br><span class="line">    desc-&gt;DPL = <span class="number">0</span>;         <span class="comment">// 内核特权级</span></span><br><span class="line">    desc-&gt;type = <span class="number">0b1010</span>;   <span class="comment">// 代码 / 非依从 / 可读 / 没有被访问过</span></span><br><span class="line"><span class="comment">//填充 gdt_ptr</span></span><br><span class="line">    gdt_ptr.base = (u32)&amp;gdt;</span><br><span class="line">    gdt_ptr.limit = <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>然后使用lgdt命令将全局描述符表指针加载到GDTR寄存器中:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">lgdt [gdt_ptr]</span><br></pre></td></tr></table></figure><h3 id="3-4-2-IDTR寄存器"><a href="#3-4-2-IDTR寄存器" class="headerlink" title="3.4.2 IDTR寄存器"></a>3.4.2 <code>IDTR</code>寄存器</h3><p>idtr寄存器用于存储中断描述符表的地址和表界限</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626145545075.png" alt="image-20230626145545075"></p><p>在中断描述符表中可以存储的是中断描述符，这里的中断描述符分为四类，以不同门的叫法来描述，在上面描述GDT的时候，提到S字段和type字段一起决定了这个描述符是什么，对于GDT来说，我们设置S位为1，代表非系统段，对于中断描述符来说需要将S位设为0，由此延申出了四种描述符：</p><ul><li>任务门描述符</li></ul><p>​任务门和任务状态段 (Task Status Segment，TSS) 是Intel处理器在硬件一级提供的任务切换机制，所以任务门需要和TSS配合在一起使用，在任务门中记录的是TSS选择子，偏移量未使用。任务门可以存在于全局描述符表GDT、局部描述符表LDT、中断描述符表IDT中。描述符中任务门的type值为二进制0101，其结构如下图所示。顺便说一句大多数操作系统 (包括Linux) 都未用TSS实现任务切换</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150722494.png" alt="image-20230626150722494"></p><ul><li>中断门描述符</li></ul><p>​中断门包含了中断处理程序所在段的段选择子和段内偏移地址。当通过此方式进入中断后，标志寄存器eflags中的IF位自动置0，也就是在进入中断后，自动把中断关闭，避免中断嵌套。Linux就是利用中断门实现的系统调用，就是那个著名的int0x80。中断门只允许存在于IDT中。描述符中中断门的type值为二进制1110，其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150752429.png" alt="image-20230626150752429"></p><ul><li>陷阱门描述符</li></ul><p>​陷阱门和中断门非常相似，区别是由陷阱门进入中断后，标志寄存器eflags中的IF位不会自动置0。陷阱门只允许存在于IDT中。描述符中陷阱门的type值为二进制1111。其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150816386.png" alt="image-20230626150816386"></p><ul><li>调用门描述符</li></ul><p>​调用门是提供给用户进程进入特权0级的方式，其DPL为3。调用门中记录例程的地址，它不能用int指令调用，只能用call和imp指令。调用门可以安装在GDT和LDT中。描述符中调用门的type值为二进制1100。其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150841553.png" alt="image-20230626150841553"></p><p>同样我们可以使用一个结构体来描述中断描述符：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 offset0;     <span class="comment">//段内偏移 0 ~ 15位</span></span><br><span class="line">    u16 selector;    <span class="comment">//代码段选择子</span></span><br><span class="line">    u8 reserved;     <span class="comment">//保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;     <span class="comment">//任务们/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>;  <span class="comment">//segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;      <span class="comment">//使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>;  <span class="comment">//是否有效</span></span><br><span class="line">    u16 offset1;     <span class="comment">//段内偏移 16 ~ 31位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br></pre></td></tr></table></figure><p>然后填充中断描述符和中断</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="type">void</span>* <span class="type">handler_t</span>; <span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="comment">//定义idt</span></span><br><span class="line">   <span class="type">gate_t</span> idt[IDT_SIZE];</span><br><span class="line"><span class="comment">//中断处理程序段内偏移</span></span><br><span class="line">   <span class="keyword">extern</span> <span class="type">handler_t</span> handler_entry_table[ENTRY_SIZE];</span><br><span class="line"><span class="comment">//初始化中断描述符表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; IDT_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line">        <span class="type">handler_t</span> handler = handler_entry_table[i];</span><br><span class="line">        gate-&gt;offset0 = (u32)handler &amp; <span class="number">0xffff</span>;         <span class="comment">//段内偏移 0 ~ 15位</span></span><br><span class="line">        gate-&gt;offset1 = ((u32)handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>; <span class="comment">//段内偏移 16 ~ 31位</span></span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;    <span class="comment">//代码段选择子</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;         <span class="comment">//保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;        </span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;              <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;          <span class="comment">// 是否有效</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后将idt_ptr填充进IDTR寄存器中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载中断描述符表</span></span><br><span class="line">idt_ptr.base = (u32)idt;</span><br><span class="line">idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-LDTR寄存器"><a href="#3-4-3-LDTR寄存器" class="headerlink" title="3.4.3 LDTR寄存器"></a>3.4.3 <code>LDTR</code>寄存器</h3><h3 id="3-4-4-TR寄存器"><a href="#3-4-4-TR寄存器" class="headerlink" title="3.4.4 TR寄存器"></a>3.4.4 <code>TR</code>寄存器</h3><h1 id="4-长模式下寄存器（64bit）"><a href="#4-长模式下寄存器（64bit）" class="headerlink" title="4.长模式下寄存器（64bit）"></a>4.长模式下寄存器（64bit）</h1><p>在长模式下，也称为64位保护模式（64-bit Protected Mode）或x86-64架构，x86处理器提供了更广泛的寄存器集合。以下是长模式下可以使用的寄存器：</p><ol><li>通用寄存器（General Purpose Registers）：<ul><li><code>RAX</code>：累加器寄存器（Accumulator Register）。</li><li><code>RBX</code>：基址寄存器（Base Register）。</li><li><code>RCX</code>：计数寄存器（Counter Register）。</li><li><code>RDX</code>：数据寄存器（Data Register）。</li><li><code>RSI</code>：源索引寄存器（Source Index Register）。</li><li><code>RDI</code>：目的索引寄存器（Destination Index Register）。</li><li><code>RBP</code>：基址指针寄存器（Base Pointer Register）。</li><li><code>RSP</code>：堆栈指针寄存器（Stack Pointer Register）。</li><li><code>R8-R15</code>：扩展的通用寄存器。</li></ul></li><li>扩展通用寄存器：<ul><li><code>RIP</code>：指令指针寄存器（Instruction Pointer Register）。</li><li><code>RFLAGS</code>：标志寄存器（Flags Register），包含各种标志位。</li></ul></li><li>段寄存器（Segment Registers）：<ul><li><code>CS</code>：代码段寄存器（Code Segment Register）。</li><li><code>DS</code>：数据段寄存器（Data Segment Register）。</li><li><code>ES</code>：附加段寄存器（Extra Segment Register）。</li><li><code>FS、GS、SS</code>：附加段寄存器，用于访问额外的数据段。</li></ul></li><li>控制寄存器（Control Registers）：<ul><li><code>CR0、CR2、CR3、CR4、CR8</code>：用于控制和管理保护模式的特性，如分页机制、特权级等。</li></ul></li><li>段描述符寄存器（Descriptor Registers）：<ul><li><code>GDTR</code>：全局描述符表寄存器（Global Descriptor Table Register）。</li><li><code>IDTR</code>：中断描述符表寄存器（Interrupt Descriptor Table Register）。</li><li><code>LDTR</code>：局部描述符表寄存器（Local Descriptor Table Register）。</li><li><code>TR</code>：任务寄存器（Task Register）。</li></ul></li><li>XMM寄存器（SSE寄存器）：<ul><li><code>XMM0-XMM15</code>：128位的向量寄存器，用于执行SSE（Streaming SIMD Extensions）指令集中的向量运算。</li></ul></li><li>YMM寄存器（AVX寄存器）：<ul><li><code>YMM0-YMM15</code>：256位的向量寄存器，用于执行AVX（Advanced Vector Extensions）指令集中的向量运算。</li></ul></li><li>ZMM寄存器（AVX-512寄存器）：<ul><li><code>ZMM0-ZMM31</code>：512位的向量寄存器，用于执行AVX-512指令集中的向量运算。</li></ul></li></ol><h1 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5. 参考链接"></a>5. 参考链接</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/400007642">中断描述符表 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://blog.csdn.net/abc123lzf/article/details/109289567">(67条消息) x86保护模式——全局描述符表GDT详解_gdt全局描述符表_A__Plus的博客-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-1.概述</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h2><ul><li><p>开发环境：</p><ul><li><code>ubuntu20.04.5 WSL</code></li><li><code>sudo apt install nasm</code>: 安装汇编编译器 nasm</li><li><code>sudo apt install bochs-x</code>: 安装虚拟机 bochs</li><li><code>sudo apt-get install qemu-system</code> ：下载安装可以模拟全部硬件的qemu</li><li><code>sudo apt install gdb</code> ：安装gdb调试器</li><li><code>sudo apt-get install gcc-multilib</code>&amp;&amp;<code>sudo apt-get install g++-multilib</code>： 安装在64位的机器上产生32位的程序</li></ul></li><li><p>参考书籍:</p><ul><li>操作系统真相还原</li><li>30天自制操作系统</li><li>Orange’S:一个操作系统的实现</li></ul></li></ul><blockquote><p>源码地址：<a href="https://github.com/yanglianoo/Onix">yanglianoo&#x2F;Onix: 基于X86的操作系统，C语言 (github.com)</a></p></blockquote><h2 id="2-操作系统大纲"><a href="#2-操作系统大纲" class="headerlink" title="2.操作系统大纲"></a>2.操作系统大纲</h2><ul><li>系统引导<ul><li>自写bootloader</li><li>grub 引导</li></ul></li><li>硬件及驱动<ul><li>CPU : 32位X86架构</li><li>显示器：VGA</li><li>中断控制器：8259A</li><li>键盘</li><li>硬盘</li><li>时钟：内部时钟，外部时钟</li><li>网卡</li></ul></li><li>任务调度：内核进程，用户态线程</li><li>中断系统：外部中断、软中断、异常</li><li>内存管理</li><li>文件系统</li><li>系统调用</li><li>shell</li><li>网络</li></ul><h2 id="3-计算机组成概述"><a href="#3-计算机组成概述" class="headerlink" title="3.计算机组成概述"></a>3.计算机组成概述</h2><p>通常，计算机由以下几部分组成：</p><ul><li>负责计算和处理数据的 CPU</li><li>负责存储程序和数据的存储器</li><li>和外部进行数据交换的 I&#x2F;O（Input&#x2F;Output，输入输出装置）。</li></ul><p>各部分<code>通过总线连接</code>就构成了一台计算机</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.001-16862005447604.png" alt="img"></p><p>CPU在运行程序的逻辑如下：</p><ul><li><p><code>1.将磁盘上的程序加载到内存中</code></p></li><li><p><code>2.读取内存中的指令</code></p><p>首先，CPU 要把即将执行的指令从内存中读取出来。CPU 中有个 PC（Program Counter，程序计数器）寄存器，其中保存着即将执行的指令的地址。指令的读取是通过将 PC 寄存器的值输出给内存，由内存返回该值对应地址中的指令</p></li><li><p><code>3.对指令进行解码</code></p><p>然后，CPU 对读取的指令所对应的操作进行解码。指令有很多种，有进行各种运算的指令、控制下一条命令的指令、对内存和 I&#x2F;O 进行读写的指令，还有对 CPU 进行控制的指令。这些指令由 CPU 中被称为指令解码器的模块进行解码。可以用来保存地址和运算结果的寄存器称为通用寄存器（General Purpose Register）</p></li><li><p><code>4.执行指令</code></p><p>最后，CPU 对解码器确定的操作进行处理。CPU 可以从内部存储装置——寄存器或外部的内存读取数据并处理，然后将结果写回寄存器或内存。</p></li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.004.png" alt="img"></p><p>CPU 执行的指令，由代表操作种类的<code>操作码</code>和代表操作对象的<code>操作数</code>两部分组成。指令本身用特定的二进制序列来表示，这种二进制序列称为机器语言。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.005.png" alt="img"></p><blockquote><p>操作数：通常为寄存器地址、内存地址、立即数等</p><p>操作码：对应为cpu具体的操作，如加法、减法等</p></blockquote><p>根据执行的指令的特征，CPU 分为 <code>RISC</code>（Reduced Instruction Set Computer，精简指令集计算机）和 <code>CISC</code>（Complex Instruction Set Computer，复杂指令集计算机）两种</p><h3 id="3-1-内存和地址"><a href="#3-1-内存和地址" class="headerlink" title="3.1 内存和地址"></a>3.1 内存和地址</h3><p>所有能够存储数据的存储器都可称为内存，内存是用来存放运行时指令（程序）和数据的存储器。</p><p>我们一般说的电脑的内存条为DRAM，就是用来保存<code>程序运行</code>时的指令和数据。像固态硬盘、机械硬盘等存储介质也可用于存储指令和数据，但由于其访问速度实在是太慢，因此适用于计算机<code>长期保存数据和程序</code>的存储器。</p><p>内存使用地址的概念来管理存储的数据。地址表示的是数据存储的位置，如同数据的住所一样。每个数据单元都有一个地址。大多情况下数据单元是一个字节（8 位）长度。这种方式称为字节编址。不同架构的CPU有不同的编址方式。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.006.png" alt="img"></p><p>如上图，CPU可通过总线寻址找到内存空间每个数据单元，并从中取出每个数据单元存储的数据。</p><p>内存等存储器的特点是速度越快成本越高。因此通常使用“高速小容量”、“中速中等容量”到“低速大容量”等多种存储器组合的混合型架构。这种构造称为存储器层级。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.007.png" alt="img"></p><p>在存储层面，速度最快的是 CPU 中的寄存器。CPU 比内存速度快很多，由 CPU 直 接访问内存效率较低。为了提高内存访问速度，在 CPU 和内存间增加了被称为缓存的高速小容量存储器。</p><p>缓存可以暂时性地缓冲存储从内存中读取的数据。CPU 在访问内存时，如果需要的数据已经保存在缓存中，则可直接从缓存中读取，以提高访问效率。根据容量和速度的不同，缓存也分为多个层级，通常为一级缓存、二级缓存等多个级别。</p><h3 id="3-2-IO"><a href="#3-2-IO" class="headerlink" title="3.2 IO"></a>3.2 IO</h3><p>I&#x2F;O（Input&#x2F;Output）是进行数据输入输出的装置。计算机通过 I&#x2F;O 和外部实现数据交换。计算机的处理操作按照从外部读取数据、在内部处理数据、再向外部输出结果的顺序进行。以个人电脑为例，如下图所示，它从鼠标或键盘输入数据，处理器根据程序处理数据，通过显示器等向外部输出结果。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.009.png" alt="img"></p><p>访问 I&#x2F;O 的方式大致分为<code>存储器映射 I/O</code> 和<code>端口映射 I/O </code>两种。</p><ul><li><code>存储器映射 I/O</code> :存储器映射 I&#x2F;O 方式中，I&#x2F;O 也和内存一样使用地址进行管理，可以和访问内存一样的方式进行访问</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.010.png" alt="img"></p><ul><li><code>端口映射访问</code>:端口映射 I&#x2F;O 方式中，CPU 含有支持访问 I&#x2F;O 的专用指令。</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.011.png" alt="img"></p><h3 id="3-3-字节序"><a href="#3-3-字节序" class="headerlink" title="3.3 字节序"></a>3.3 字节序</h3><p>将多字节数据存储在内存中时，各字节的存储顺序称为字节序。比如，将 4 字节数据 0x12345678 放入内存时，地址 0 中放 0x12、地址 1 中放 0x34、地址 2 中放 0x56、地址 3 中放 0x78 的方式，称为大端序。相对地，地址 0 中放 0x78、地址 1 中放 0x56、地址 2 中放 0x34、地址 3 中放 0x12 的方式，称为小端序。不同CPU采用的字节序不尽相同</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.008.png" alt="img"></p><h3 id="3-4-总线"><a href="#3-4-总线" class="headerlink" title="3.4 总线"></a>3.4 总线</h3><p>总线是 CPU、内存和 I&#x2F;O 之间交换数据的共同通道。总线将一根信号线在多个模块间共享进行通信。</p><p>总线包括<code>地址总线、数据总线、控制总线、IO总线</code>，顾名思义数据线是用于数据读取、地址总线用于地址寻址、控制总线用于控制cpu行为。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.012.png" alt="img"></p><p>当计算机中的各个组件之间需要进行数据传输和控制信号传递时，总线起到了关键的作用。下面是对四种主要总线的简要介绍：</p><ol><li>地址总线（Address Bus）：<ul><li>作用：地址总线用于传输CPU或其他设备发出的内存或外设的地址信息。</li><li>功能：它决定了CPU或其他设备要访问的内存单元或外设的位置。地址总线的宽度决定了系统能够寻址的内存空间大小。例如，32位地址总线可以寻址的内存空间大小为2^32个字节（4GB）。</li></ul></li><li>数据总线（Data Bus）：<ul><li>作用：数据总线用于传输CPU或其他设备之间的数据。</li><li>功能：数据总线承载着实际的数据传输，包括指令、操作数、计算结果等。数据总线的宽度决定了一次可以传输的数据位数，例如，32位数据总线可以一次传输32位（4字节）的数据。</li></ul></li><li>控制总线（Control Bus）：<ul><li>作用：控制总线用于传输各种控制信号，包括指令控制、时序控制和状态信号等。</li><li>功能：控制总线通过不同的信号线传递各种控制信号，例如，读取（Read）和写入（Write）信号用于指示数据传输的方向，时钟信号用于同步操作，中断信号用于通知CPU有外部事件需要处理等。</li></ul></li><li>I&#x2F;O总线（I&#x2F;O Bus）：<ul><li>作用：I&#x2F;O总线用于连接CPU和外部设备之间进行输入输出操作。</li><li>功能：I&#x2F;O总线是一种专门用于输入输出的总线，它提供了一种通信通道，使得CPU能够与外部设备进行数据交换。通过I&#x2F;O总线，CPU可以发送读取（IN）和写入（OUT）指令来控制外部设备的数据读取和写入。</li></ul></li></ol><p>这四种总线相互配合，构成了计算机系统中各个组件之间的连接和通信桥梁。它们共同工作，使得CPU能够与内存和外设进行数据传输、控制信号传递和输入输出操作，实现计算机的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写STL之Vector</title>
      <link href="/2023/06/07/%E6%89%8B%E5%86%99STL-Vector/"/>
      <url>/2023/06/07/%E6%89%8B%E5%86%99STL-Vector/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码仓库：<a href="https://github.com/yanglianoo/My_STL/tree/timer">yanglianoo&#x2F;My_STL at timer (github.com)</a></p></blockquote><h2 id="1-Vector-概述"><a href="#1-Vector-概述" class="headerlink" title="1.Vector 概述"></a>1.Vector 概述</h2><p>在C++ STL（标准模板库）中，<code>vector</code> 是一个动态数组容器，它是一个模板类具有以下特性：</p><ol><li><strong>动态大小</strong>: <code>vector</code> 的大小可以根据需要动态增长或缩小。它可以自动调整内部存储空间，以适应容器中元素的数量。</li><li><strong>连续存储</strong>: <code>vector</code> 中的元素在内存中是连续存储的，这使得对元素的随机访问变得高效。</li><li><strong>快速插入和删除</strong>: 在 <code>vector</code> 的末尾插入或删除元素是高效的，时间复杂度为常数。但在中间或开头插入或删除元素的操作可能会导致元素的移动，时间复杂度为线性。</li><li><strong>随机访问</strong>: <code>vector</code> 支持通过索引进行随机访问。可以使用下标运算符 <code>[]</code> 或 <code>at()</code> 函数来访问特定位置的元素。</li><li><strong>动态调整内存</strong>: 当 <code>vector</code> 的大小超过当前分配的内存空间时，它会重新分配更大的内存块，并将现有元素移动到新的内存中。这可以确保容器始终具有足够的内存来存储元素。</li><li><strong>元素访问</strong>: 可以使用迭代器来遍历 <code>vector</code> 中的元素。可以使用 <code>begin()</code> 和 <code>end()</code> 成员函数获取指向容器开头和结尾的迭代器。</li><li><strong>容器操作</strong>: <code>vector</code> 支持许多常见的容器操作，如排序、查找、插入和删除元素。它还提供了与其他容器兼容的接口，例如迭代器、范围构造函数和算法函数。</li></ol><p><code>STL</code>库中<code>vector</code>的定义如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Allocator</span> = std::allocator&lt;T&gt;&gt; </span><br><span class="line">    <span class="keyword">class</span> vector;</span><br></pre></td></tr></table></figure><table><thead><tr><th>T</th><th>元素的类型。<code>T</code> 必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>Allocator</th><th>用于获取&#x2F;释放内存及构造&#x2F;析构内存中元素的分配器。类型必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/Allocator"><em>分配器</em> <em>(Allocator)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>成员函数</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/vector">(构造函数)</a></td><td>构造 <code>vector</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/~vector">(析构函数)</a></td><td>析构 <code>vector</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/operator%3D">operator&#x3D;</a></td><td>赋值给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/assign">assign</a></td><td>将值赋给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/get_allocator">get_allocator</a></td><td>返回相关的分配器 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/at">at</a></td><td>访问指定的元素，同时进行越界检查 (公开成员函数)</td></tr><tr><td>operator[]</td><td>访问指定的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/data">data</a></td><td>直接访问底层数组 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/reserve">reserve</a></td><td>预留存储空间 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/capacity">capacity</a></td><td>返回当前存储空间能够容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/shrink_to_fit">shrink_to_fit</a></td><td>通过释放未使用的内存减少内存的使用 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/swap">swap</a></td><td>交换内容</td></tr></tbody></table><blockquote><p>参考链接: <a href="https://zh.cppreference.com/w/cpp/container/vector">std::vector - cppreference.com</a></p></blockquote><h2 id="2-构造Vector"><a href="#2-构造Vector" class="headerlink" title="2.构造Vector"></a>2.构造Vector</h2><p>自己手写<code>vector</code>时，迭代器不是通用的<code>Allocator</code>类型，需要在<code>vector</code>内部实现一个自定义的迭代器</p><p>vector模板类定义如下，需要维护三个私有的成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;    <span class="comment">//实际数组大小</span></span><br><span class="line">    <span class="type">int</span> _capacity;<span class="comment">//最大容量</span></span><br><span class="line">    T* _elem;     <span class="comment">//数据区指针  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：模板类的实现和声明不能分离编译，因此最好将模板类的声明和实现都放在头文件中<br>参考链接：<a href="https://blog.csdn.net/u011201045/article/details/38679417">(64条消息) C++中模板类的编译过程_c++模板编译_jiazhucai的博客-CSDN博客</a></p></blockquote><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>构造函数定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>();   <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(std::initiallizer_list&lt;T&gt; init) <span class="comment">// c++11 列表初始化</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other); <span class="comment">//用另外一个vector来构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other,<span class="type">int</span> left,<span class="type">int</span> right); <span class="comment">//用另外一个vector区间构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">size_t</span> count, T&amp; value); <span class="comment">//初始化为count个 value</span></span><br></pre></td></tr></table></figure><h4 id="2-1-1-辅助函数"><a href="#2-1-1-辅助函数" class="headerlink" title="2.1.1 辅助函数"></a>2.1.1 辅助函数</h4><p>在定义构造函数具体实现时需要定义几个辅助函数:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span>; <span class="comment">//空间不足时扩容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink</span><span class="params">()</span></span>; <span class="comment">//装填因子过小时压缩</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyFrom</span> <span class="params">( T <span class="type">const</span>* A, <span class="type">int</span> left, <span class="type">int</span> right )</span></span>; <span class="comment">//复制数组区间 A[left, right]</span></span><br></pre></td></tr></table></figure><ul><li>内存扩充函数<code>expand()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_CAPACITY 3 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">expand</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_size &lt;= _capacity) <span class="keyword">return</span>;  <span class="comment">//当size 小于等于 capacity 时 不需要扩容</span></span><br><span class="line">    <span class="keyword">if</span>(_capacity &lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY; <span class="comment">//当capacity小于最小大小，更改capacity为最小大小</span></span><br><span class="line">    <span class="comment">/* 反复翻倍，直到 _capacity &gt; _size*/</span></span><br><span class="line">    <span class="keyword">while</span> (_capacity &lt; _size)</span><br><span class="line">    &#123;</span><br><span class="line">        _capacity *=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T* old_data = _data;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity &lt;&lt; <span class="number">1</span>];  <span class="comment">//capacity 增大一倍，重新 new 内存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;_size; i++)       <span class="comment">//赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = old_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] old_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内存缩小函数<code>shrink()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">shrink</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capacity &lt; DEFAULT_CAPACITY &lt;&lt; <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//不致收缩倒DEFAULT_CAPACITY以下</span></span><br><span class="line">    <span class="keyword">if</span>(_size &lt;&lt; <span class="number">2</span> &gt; _capacity) <span class="keyword">return</span>;  <span class="comment">//以 25% 为边界</span></span><br><span class="line"></span><br><span class="line">    T* old_data = _data;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = old_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] old_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>区间复制函数<code>copyFrom ( T const* A, int left, int right )</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">copyFrom</span> ( T <span class="type">const</span>* A, <span class="type">int</span> left, <span class="type">int</span> right )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _capacity = (right - left) * <span class="number">2</span>;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[_size] = A[left];</span><br><span class="line">        _size++;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-构造函数实现"><a href="#2-2-2-构造函数实现" class="headerlink" title="2.2.2 构造函数实现"></a>2.2.2 构造函数实现</h4><ul><li><code>vector()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*构造函数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>():_data(<span class="literal">nullptr</span>),_capacity(<span class="number">0</span>),_size(<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(const vector&lt;T&gt;&amp; *other*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">copyFrom</span>(other._data,<span class="number">0</span>,other._size); <span class="comment">//直接调用 copyFrom 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(std::initializer_list&lt;T&gt; *init*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* c++11 列表初始化 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(std::initializer_list&lt;T&gt; init)</span><br><span class="line">&#123;</span><br><span class="line">    _size = init.<span class="built_in">size</span>();</span><br><span class="line">    _capacity = _size * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; elem : init)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(int *count*, T&amp; *value*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(<span class="type">size_t</span> count, T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    _size = count;</span><br><span class="line">    _capacity = <span class="number">2</span> * _size;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i =<span class="number">0</span>; i&lt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-析构函数"><a href="#2-2-析构函数" class="headerlink" title="2.2 析构函数"></a>2.2 析构函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::~<span class="built_in">vector</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-赋值"><a href="#3-赋值" class="headerlink" title="3.赋值"></a>3.赋值</h2><p>实现的成员函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//成员函数</span></span><br><span class="line">    vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector&amp; other);</span><br><span class="line">    vector&amp; <span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">size_t</span> count,<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>vector&amp; operator=(const vector&amp; other)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;&amp; vector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> vector&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">copyFrom</span>(other._data,<span class="number">0</span>,other._size);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector&lt;T&gt;::operator=( std::initializer_list&lt;T&gt; *ilist* )</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;&amp; vector&lt;T&gt;::<span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = ilist.<span class="built_in">size</span>();</span><br><span class="line">    _capacity = _size * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; elem : ilist)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-元素访问"><a href="#4-元素访问" class="headerlink" title="4.元素访问"></a>4.元素访问</h2><p>元素访问的接口有如下这些：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//元素访问</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);</span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">data</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;<span class="number">0</span> || index &gt;= _size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data[_size<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* vector&lt;T&gt;::<span class="built_in">data</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h2><h3 id="5-1-迭代器使用实例"><a href="#5-1-迭代器使用实例" class="headerlink" title="5.1 迭代器使用实例"></a>5.1 迭代器使用实例</h3><p>在构建迭代器之前，先看看迭代器的用法，一般用于遍历容器中的各个元素</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 1. 使用迭代器进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1. Iterate using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 使用auto关键字进行简化</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2. Iterate using auto keyword: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 使用范围基于循环 (range-based loop)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3. Iterate using range-based loop: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 修改容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4. Modify elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        *it = *it * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 插入元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5. Insert elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> insertPos = vec.<span class="built_in">begin</span>() + <span class="number">2</span>; <span class="comment">// 在索引2的位置之后插入元素</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(insertPos, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 删除元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;6. Erase elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> erasePos = vec.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 删除索引1的元素</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(erasePos);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-迭代器类实现"><a href="#5-2-迭代器类实现" class="headerlink" title="5.2 迭代器类实现"></a>5.2 迭代器类实现</h3><p><code>iterrator</code>是一个类，在内部维护了一个指针，需要对其进行各种操作符重载，<code>iterrator</code>的具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterrator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            T * m_pointer;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Iterrator</span>():<span class="built_in">m_pointer</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">            <span class="built_in">Iterrator</span>(T * pointer) : <span class="built_in">m_pointer</span>(pointer) &#123;&#125;</span><br><span class="line">            ~<span class="built_in">Iterrator</span>() &#123;&#125;</span><br><span class="line">        <span class="comment">/* 判断两个迭代器是否相等 */</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Iterrator &amp; other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer == other.m_pointer;   </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* 迭代器赋值 */</span></span><br><span class="line">        Iterrator <span class="keyword">operator</span> = (<span class="type">const</span> Iterrator&amp; other)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer = other.m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 前缀递增*/</span></span><br><span class="line">        Iterrator &amp; <span class="keyword">operator</span> ++ ()</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer +=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 后缀递增 */</span></span><br><span class="line">        Iterrator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            ++(*<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> + (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            it.m_pointer += i;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterrator <span class="keyword">operator</span> += (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer += i;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> -= (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer -= i;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> - (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            it.m_pointer -= i;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="keyword">operator</span> - (<span class="type">const</span> Iterrator&amp; other) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer - other.m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T &amp; <span class="keyword">operator</span> * ()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T * <span class="keyword">operator</span> -&gt; ()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>记录：在对<code>Iterrator</code>前++和后++重载时，如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前缀递增*/</span></span><br><span class="line">Iterrator &amp; <span class="keyword">operator</span> ++ ()</span><br><span class="line">&#123;</span><br><span class="line">m_pointer +=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/* 后缀递增 */</span></span><br><span class="line">Iterrator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">     Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">     ++(*<span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中，后缀递增操作符(it++)可以通过接受一个额外的int参数进行区分，这是由C++语言规范所定义的。根据规范，后缀递增操作符的函数参数列表中必须有一个int类型的参数，尽管在函数体内并没有使用该参数。</p><p>这种设计是为了在语法上能够区分前缀递增和后缀递增操作。当编译器遇到<code>it++</code>表达式时，它会根据后缀递增操作符的函数参数列表中是否存在一个额外的int参数来决定使用后缀递增操作符的重载函数。</p><p>编译器会将后缀递增操作符的调用转换为对重载的后缀递增操作符函数的调用，并传递一个编译器生成的临时整数参数（通常是0）。</p><p>请注意，这个整数参数的名称在函数体内并没有使用，因为它的存在只是为了与前缀递增操作符进行区分，而不是为了实际使用。</p></blockquote><h3 id="5-3-迭代器操作函数实现"><a href="#5-3-迭代器操作函数实现" class="headerlink" title="5.3 迭代器操作函数实现"></a>5.3 迭代器操作函数实现</h3><p><code>begin</code>用于获取头指针，<code>end</code>用于获取尾指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//迭代器操作函数</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">begin</span>()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(_data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">end</span>()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(_data + _size)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要使用<code>typename</code>显示的告诉编译器<code>vector&lt;T&gt;::Iterator</code>是一个类型</p><h2 id="6-容量"><a href="#6-容量" class="headerlink" title="6.容量"></a>6.容量</h2><p>和容量相关的接口函数比较简单，实现的接口如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//容量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//判断容器是否为空</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//获取容器元素个数</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//获取容器最大存储个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> new_cap)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> vector&lt;T&gt;::<span class="built_in">empty</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _size==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">max_size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">capacity</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 重置容器大小 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">reserve</span>(<span class="type">size_t</span> new_cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capacity &gt;= new_cap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _size += new_cap;</span><br><span class="line">        <span class="built_in">expand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果 _capacity 过大则缩减*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">shrink_to_fit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shrink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-修改器"><a href="#7-修改器" class="headerlink" title="7.修改器"></a>7.修改器</h2><p>和修改容器有关的接口函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//修改器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> Iterator it ,<span class="type">const</span> T &amp; value)</span></span>;  </span><br><span class="line">    <span class="function">Iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> Iterator it ,<span class="type">int</span> n,<span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">erase</span><span class="params">(<span class="type">const</span> Iterator it)</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">erase</span><span class="params">(<span class="type">const</span> Iterator first,<span class="type">const</span> Iterator last)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector &amp; other)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>clear()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* clear操作，直接将 _size 清零*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator insert(const Iterator it ,int n,const T &amp; value)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在 it 的位置插入 n 个 T 元素*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Iterator it ,<span class="type">int</span> n,<span class="type">const</span> T &amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = it - <span class="built_in">begin</span>();</span><br><span class="line">    _size += n;</span><br><span class="line">    <span class="comment">//如果有需要，则扩容</span></span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=_size; i&gt;size;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i+n<span class="number">-1</span>] = _data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[size+i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;T&gt;::<span class="built_in">Iterator</span>(_data + size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator insert(const Iterator it ,const T &amp; value) </code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在 it 位置插入 1 个元素 value*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Iterator it ,<span class="type">const</span> T &amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    _size+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">    <span class="built_in">insert</span>(it,<span class="number">1</span>,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator erase(const Iterator it)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除 it 位置的元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Iterator it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">end</span>() - it == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _size -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = it - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = count; i &lt; _size <span class="number">-1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = _data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    _size -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator erase(const Iterator first,const Iterator last)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 区间删除 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Iterator first,<span class="type">const</span> Iterator last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( first == last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> first;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> f = first - <span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> l = last - <span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> ( l &lt; _size) <span class="comment">// [last,_szie) 顺次前移 l - f 个单元</span></span><br><span class="line">        &#123;</span><br><span class="line">            _data[f++] = _data[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        _size = f;  <span class="comment">//更新规模</span></span><br><span class="line">        <span class="built_in">shrink</span>(); <span class="comment">//若有必要则缩容</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void push_back(const T &amp; value)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在尾部插入一个元素value */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size &lt; _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[_size] = value; </span><br><span class="line">        _size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _size++;</span><br><span class="line">        <span class="built_in">expand</span>();</span><br><span class="line">        <span class="type">int</span> index = _size - <span class="number">1</span>;</span><br><span class="line">        _data[index] = value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void pop_back()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 弹出最后一个元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void resize(size_t size)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">resize</span>(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size &gt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        _size = size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i= _size; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _data[i] = <span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _size = size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = size;</span><br><span class="line">    <span class="built_in">expand</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void swap(vector &amp; other)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 两个 vector 交换*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">swap</span>(vector &amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    T * data = other._data;</span><br><span class="line">    <span class="type">int</span> size = other._size;</span><br><span class="line">    <span class="type">int</span> capacity = other._capacity;</span><br><span class="line"></span><br><span class="line">    other._data = _data;</span><br><span class="line">    other._size = _size;</span><br><span class="line">    other._capacity = _capacity;</span><br><span class="line"></span><br><span class="line">    _data = data;</span><br><span class="line">    _size = size;</span><br><span class="line">    _capacity = capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>至此，<code>vector</code> 构造完毕，未进行测试，不知道是否有<code>bug</code></p>]]></content>
      
      
      <categories>
          
          <category> 手写STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
