<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CyberRt源码剖析--07协程调度框架</title>
      <link href="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/"/>
      <url>/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-什么是协程"><a href="#7-1-什么是协程" class="headerlink" title="7.1 什么是协程"></a>7.1 什么是协程</h2><p>协程的核心在于将程序的执行流程划分为多个可控的片段，每个片段能够在特定时点暂停或恢复运行。这种机制通过协作式调度实现，开发者可在代码中显式指定挂起和恢复的时机，从而避免传统线程因抢占式调度带来的复杂同步问题。协程的生命周期包括以下四个阶段：</p><p>1.创建（Creation）：协程通过特定的语法或函数被创建，此时协程处于就绪状态，等待被调度执行。</p><p>2.挂起（Yield）：协程在执行过程中可以主动或被动地暂停执行，将控制权交还给协程调度器。挂起操作通常在等待 I&#x2F;O 操作、等待其他协程完成或主动让出 CPU 时发生。</p><p>3.恢复（Resume）：协程调度器可以在适当的时候恢复协程的执行，从上次挂起的位置继续运行，直到完成任务或再次挂起。</p><p>4.销毁（Destruction）：当协程完成任务后，会被销毁并释放占用的资源。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/176892178839516.png" alt="img"></p><ul><li>如上图左边假设一个<code>MainTask</code>是一个线程去调用<code>Task()</code>函数去执行一个功能，如果<code>Task()</code>是一个普通函数，那么<code>MainTask</code>会等待<code>Task()</code>执行完毕返回后继续执行<code>MainTask</code>的步骤</li><li>如上图右边如果<code>MainTask</code>去执行<code>Cotask()</code>，而<code>Cotask()</code>是一个协程，<code>Cotask()</code>在执行的过程中可以通过<code>yield()</code>或者<code>await()</code>这样的函数暂停自己的执行，并且返回到<code>MainTask</code>继续执行，而主函数也可以调用<code>resume()</code>这样的函数重新回到<code>Cotask()</code>这个协程执行，并不会像函数那样必须执行完毕才返回。这样就做到了用户态的并发，一个线程里可以存在多个协程，并且可以提供一个协程调度器来调度这些协程进行执行。</li><li>协程实现的关键在于如何在协程切换的时候能够保存当前的执行信息，并且在切换回当前协程时能够恢复执行状态继续往下执行</li><li>相比于线程，线程是操作系统调度的最小单位，每个线程都会占用cpu时间片，同时需要切换线程上下文，协程在用户态切换，带来的开销会小很多，当然协程只是并发并不是并行。</li></ul><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/17689217883931.png" alt="img"></p><h2 id="7-2-协程框架的设计"><a href="#7-2-协程框架的设计" class="headerlink" title="7.2 协程框架的设计"></a>7.2 协程框架的设计</h2><h3 id="7-2-1-协程栈管理"><a href="#7-2-1-协程栈管理" class="headerlink" title="7.2.1 协程栈管理"></a>7.2.1 协程栈管理</h3><p>实现的协程为有栈协程（Stackful Coroutine），即每个协程拥有独立的栈空间。与无栈协程（Stackless Coroutine）相比，有栈协程能够更灵活地支持复杂的函数调用和上下文保存，尽管其内存开销稍大。为单个协程执行分配的栈空间大小为2MB，这一容量足以容纳协程运行所需的上下文信息，包括函数调用栈、局部变量和寄存器状态。协程上下文的具体内容因CPU架构而异，针对当前主流嵌入式和服务器平台，实现了AArch64和x86_64两种CPU架构下的协程设计。以x86_64架构为例，具体讲解协程框架的设计与实现细节。</p><table><thead><tr><th><strong>Register</strong></th><th><strong>Usage</strong></th><th><strong>Callee saved</strong></th></tr></thead><tbody><tr><td>rax</td><td>临时寄存器；在可变参数情况下，传递有关使用的向量寄存器数量的信息；第一个返回寄存器</td><td>No</td></tr><tr><td>rbx</td><td>被调用方保存的寄存器</td><td>Yes</td></tr><tr><td>rcx</td><td>用于向函数传递第四个整数参数</td><td>No</td></tr><tr><td>rdx</td><td>用于向函数传递第三个参数，第二个返回寄存器</td><td>No</td></tr><tr><td>rsp</td><td>栈指针</td><td>Yes</td></tr><tr><td>rbp</td><td>被调用方保存的寄存器，可选择用作栈帧指针</td><td>Yes</td></tr><tr><td>rsi</td><td>用于向函数传递第二个参数</td><td>No</td></tr><tr><td>rdi</td><td>用于向函数传递第一个参数</td><td>No</td></tr><tr><td>r8</td><td>用于向函数传递第五个参数</td><td>No</td></tr><tr><td>r9</td><td>用于向函数传递第六个参数</td><td>No</td></tr><tr><td>r10</td><td>临时寄存器，用于传递函数的静态链指针</td><td>No</td></tr><tr><td>r11</td><td>临时寄存器</td><td>No</td></tr><tr><td>r12~r14</td><td>被调用方保存的寄存器</td><td>Yes</td></tr><tr><td>r15</td><td>被调用方保存的寄存器，可选择用作全局偏移表基指针</td><td>Yes</td></tr><tr><td>r16~r31</td><td>临时寄存器</td><td>No</td></tr></tbody></table><p>根据x86_64的应用程序二进制接口（ABI）规定，如表所示，在进行函数调用时，被调用者（Callee）需要保存rbx、rbp、rsp、r12、r15总共7个寄存器。这些寄存器在函数调用链中起到关键作用，例如rbx和r12、r15用于保存长期使用的变量，rbp作为栈帧指针，而rsp则维护栈顶位置。协程的本质是一个特殊的函数，其切换过程本质上是对函数执行流的控制，因此在进行协程切换时，也需要将这7个寄存器保存到协程栈中，以确保切换后协程能够正确恢复执行状态。在CyberRT的设计中，rsp寄存器由于其特殊性（直接影响栈操作），被保存在额外的独立空间中，而rdi寄存器则因需要传递参数（例如协程初始化时的入口函数指针）而被一并保存至栈中。每个寄存器占用8字节（64位架构下），因此协程栈中需要56字节的空间来存储这些寄存器相关信息。此外，考虑到实际应用中可能涉及更深的调用栈和额外的局部变量，2MB的栈空间设计既保证了足够的余量，又避免了过度的内存浪费。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/17689217883932.png" alt="img"></p><p>基于上述对协程栈的需求，设计了RoutineContext结构来代表协程栈空间，并额外设置了一个sp变量用于指向协程栈的栈底位置。这一设计便于在切换时快速定位栈底并恢复上下文。RoutineContext会在创建协程之前进行初始化，其初始化过程如图所示。在初始化RoutineContext时，首先将rdi寄存器指向一个名为CRoutine的模块，此CRoutine是与当前RoutineContext绑定的具体协程实现，负责定义协程的执行逻辑。其余寄存器的值（如rbx、r12~r15等）在初始化时被置为0，以避免未定义行为。CRoutineEntry作为一个函数指针，会被设置为指向一个具体的执行函数（通常是协程的入口函数），而RoutineContext的sp变量则被设置为当前栈空间的栈底地址，即存放rbp寄存器值的内存地址。这一栈底地址的选择考虑了x86_64架构下栈的向下增长特性，确保后续压栈操作不会覆盖关键数据。</p><h3 id="7-2-2-协程主体"><a href="#7-2-2-协程主体" class="headerlink" title="7.2.2 协程主体"></a>7.2.2 协程主体</h3><p>协程的主体由CRoutine模块构成，其设计目标是为协程提供一个清晰的逻辑封装，包括状态管理、上下文绑定和执行控制。CRoutine的类成员变量如表所示，类成员函数如表所示。</p><p>CRoutine类成员变量</p><table><thead><tr><th><strong>名称</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>Name</td><td>协程的名字</td></tr><tr><td>State</td><td>协程的状态</td></tr><tr><td>Context</td><td>协程绑定的RoutineContext</td></tr><tr><td>Priority</td><td>协程的优先级</td></tr><tr><td>Main_stack</td><td>主栈指针</td></tr><tr><td>Current_routine</td><td>当前线程执行的协程对应的CRoutine对象</td></tr><tr><td>Func</td><td>协程的执行体函数</td></tr></tbody></table><p> CRoutine对外接口函数</p><table><thead><tr><th><strong>名称</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>Run()</td><td>执行Func函数</td></tr><tr><td>Stop()</td><td>设置协程的状态为STOP</td></tr><tr><td>Wake()</td><td>设置协程的状态为READY</td></tr><tr><td>HangUp()</td><td>设置协程的状态为IO_WAIT</td></tr><tr><td>Sleep()</td><td>设置协程的状态为睡眠，暂停执行一段时间</td></tr><tr><td>Yield()</td><td>挂起当前协程</td></tr><tr><td>Resume()</td><td>恢复执行当前协程</td></tr><tr><td>GetMainStack()</td><td>获取主栈地址</td></tr><tr><td>GetCurrentRoutine()</td><td>获取Current_routine的值</td></tr></tbody></table><p>CRoutine支持五种状态的相互切换，包括READY（就绪）、RUNNING（运行）、IO_WAIT（I&#x2F;O等待）、SLEEP（睡眠）和STOP（停止），其状态转换过程如图所示。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/17689217883943.png" alt="img"></p><p>在初始化时，CRoutine被设置为READY状态，表示协程已准备好被调度器分配资源执行。状态的切换通过定义的成员函数实现，Sleep()可用于暂停协程以等待定时事件，而HangUp()则适用于异步I&#x2F;O操作([52])的等待场景。在构造CRoutine时，会同步创建一个对应的RoutineContext，并通过Context成员变量建立关联。RoutineContext中的CRoutineEntry函数负责调用当前CRoutine的Run()函数以执行协程逻辑，执行完毕后则调用Yield()函数挂起当前协程，从而将控制权交回调度器。</p><h3 id="7-2-3-协程执行"><a href="#7-2-3-协程执行" class="headerlink" title="7.2.3 协程执行"></a>7.2.3 协程执行</h3><p>协程的执行由主线程中的协程调度器负责分配。在一个主线程中，可能同时存在多个协程，每个协程都可以被调度器动态切换执行。协程在运行时占用主线程的CPU时间片资源，与传统的多线程并发不同，协程通过协作式调度避免了线程间的竞争开销。调度器通过调用协程的Resume()函数恢复协程的执行，该函数内部实现换栈操作，即先保存主线程的栈状态，再恢复目标协程的栈状态。执行Resume()函数前，主线程栈和协程栈的状态如图1所示；执行后，栈状态如图2所示。</p><p>\1. 协程执行前栈空间</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/17689217883944.png" alt="img"></p><ol><li>协程执行后栈空间</li></ol><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/17689217883945.png" alt="img"></p><p>Resume()函数总共做了五个步骤：</p><ul><li>Step1保存主线程上下文，执行push指令，将rdi、r12~r15、rbx、rbp保存到主线程的栈空间中。随着压栈操作的进行，主线程的栈指针也会发生相应变化。</li><li>Step2保存主栈指针，将主栈的栈指针保存到即将切换的协程的Main_stack成员变量中。协程执行完毕后，将根据Main_stack的值恢复主线程的上下文。</li><li>Step3切换协程栈，协程的栈指针保存在RoutineContext的sp变量中，通过将rsp寄存器的值设置为sp变量的值，即完成了协程栈的切换。</li><li>Step4恢复协程上下文，执行pop指令，将保存在协程栈中的rdi、r12~r15、rbx、rbp恢复到CPU的寄存器中，从而完成换栈操作。</li><li>Step5跳转执行，执行ret指令，ret会从栈顶弹出一个值，并将该值加载到指令指针（RIP寄存器）中。此时，RIP会指向CRoutineEntry，而CRoutineEntry内部会调用协程的Run()函数，从而实现协程的执行。</li></ul><h3 id="7-2-4-协程挂起"><a href="#7-2-4-协程挂起" class="headerlink" title="7.2.4 协程挂起"></a>7.2.4 协程挂起</h3><p>上文提到，在CRoutineEntry函数中，协程完成Run()函数的执行后，需要调用Yield()函数主动将当前线程的CPU使用权交还给主线程继续执行。与线程的抢占式调度不同，协程的挂起是协作式的，由协程自身决定何时让出控制权。协程挂起的逻辑与运行逻辑相反：运行时是从主线程切换到协程，需要保存主线程上下文并恢复协程上下文；而挂起时则是保存当前协程的上下文并恢复主线程的上下文，其过程如图3所示。</p><p>\3. 协程挂起栈空间</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/17689217883946.png" alt="img"></p><p>Yield()函数同样涉及到五个步骤的操作：</p><ul><li>Step1保存协程上下文，执行push指令，将当前协程的上下文（即rdi、r12~r15、rbx、rbp）保存到协程栈中，此时会发生压栈操作。</li><li>Step2保存协程栈地址，将当前的rsp指针所指向的协程栈地址保存到RoutineContext的sp变量中。</li><li>Step3切换主栈，在Resume()函数中，主栈的栈指针已被保存到Main_stack变量中，因此将rsp的值设置为Main_stack的值，即完成了从协程栈到主栈的切换。</li><li>Step4恢复主线程上下文，执行pop指令，将Resume()函数中保存在主栈中的rdi、r12~r15、rbx、rbp寄存器的值恢复到CPU寄存器中。</li><li>Step5返回主线程，执行ret指令，恢复主线程的执行流程。</li></ul><h2 id="7-3-协程调度器的设计"><a href="#7-3-协程调度器的设计" class="headerlink" title="7.3 协程调度器的设计"></a>7.3 协程调度器的设计</h2><p>基于协程的程序运行逻辑如图4所示，在一个进程（Process）内运行着多个线程（Thread），每个线程内部运行着多个协程（CRoutine）。这些协程通过主进程的协程调度器（Scheduler）进行管理和调度，每个协程绑定独立的RoutineContext以保存其栈和上下文信息。调度器的设计目标是实现协程的高效分配和执行，确保任务的实时性和资源利用率。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/17689217883947.png" alt="img"></p><p>代码涉及到几个重要的类:</p><ul><li><code>sheduler</code>：调度器基类</li><li><code>processor</code>：抽象的cpu基类</li><li><code>processor_context</code>：抽象cpu的上下文</li></ul><p>具体实现的子类：</p><ul><li><code>SchedulerClassic</code>、<code>SchedulerChoreography</code>：<code>sheduler</code>的子类，代表两种不同的调度器，目前只实现了<code>SchedulerClassic</code>这种调度器</li><li><code>ClassicContext</code>、<code>ChoreographyContext</code>：<code>processor_context</code>的子类，代表两种调度器对应的抽象cpu的上下文</li></ul><p>这些类的关系如图所示：</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/17689217883948.png" alt="img"></p><h3 id="7-3-1-调度器配置"><a href="#7-3-1-调度器配置" class="headerlink" title="7.3.1 调度器配置"></a>7.3.1 调度器配置</h3><p>协程调度器支持通过配置文件灵活调整其运行特性，以适应不同的应用需求。一份典型的调度器配置文件采用JSON格式，便于解析和修改。其中，policy字段用于指定调度器的调度策略，本文目前实现了一种名为classic的调度策略；classic_conf字段则用于定义classic策略下的具体配置细节，例如线程分组和协程优先级。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/17689217883949.png" alt="img"></p><p>在classic策略下，调度器会对进程中的线程和协程进行分组管理，同一组内的线程和协程共享相同的调度方式和资源分配策略。组（groups）支持的配置选项如表所示，涵盖了线程数量、CPU亲和性、调度策略和任务优先级等关键参数。配置文件中的tasks字段用于定义当前组下运行的协程，用户可以通过该字段设置协程的名称和优先级。例如，在机器人系统中，可将环境感知任务配置为高优先级协程，而日志记录任务配置为低优先级协程，以确保关键任务的实时性。</p><table><thead><tr><th><strong>配置选项</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>name</td><td>组的名字</td></tr><tr><td>processor_num</td><td>线程数量</td></tr><tr><td>affinity</td><td>线程的cpu亲和性</td></tr><tr><td>cpuset</td><td>线程运行的cpu核心号</td></tr><tr><td>processor_policy</td><td>线程调度策略</td></tr><tr><td>processor_prio</td><td>线程优先级</td></tr><tr><td>tasks.name</td><td>协程的名字</td></tr><tr><td>tasks.prio</td><td>协程的优先级</td></tr></tbody></table><h3 id="7-3-2-调度器管理"><a href="#7-3-2-调度器管理" class="headerlink" title="7.3.2 调度器管理"></a>7.3.2 调度器管理</h3><p>调度器（Scheduler）的主要成员函数如表所示，涵盖了任务创建、派发和线程管理的核心功能。</p><table><thead><tr><th><strong>成员函数</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>CreateTask()</td><td>创建协程任务</td></tr><tr><td>DispatchTask()</td><td>派发协程任务到线程上</td></tr><tr><td>CreateProcessor()</td><td>创建线程，并设置cpu亲和性和调度策略</td></tr><tr><td>NotifyProcessor()</td><td>唤醒线程</td></tr></tbody></table><p>在Scheduler的构造函数中，首先会解析配置文件并读取相关配置信息，然后调用CreateProcessor()函数。该函数会根据配置文件中的processor_num参数创建相应数量的线程，并依次设置线程的CPU亲和性策略和调度策略。</p><p>线程的CPU 亲和性策略可通过POSIX线程库中的 pthread_setaffinity_np函数实现，CPU 亲和性策略包括以下两种模式:</p><ul><li>“1to1”模式：每个线程在运行过程中始终绑定到一个固定的 CPU 核心。例如，在group2中，CPU亲和性策略设为“1to1”，线程数量为16个，核心号范围为“8-15,24-31”。在此模式下，1号线程仅能运行在8号CPU上，2号线程仅能运行在9号CPU上，依此类推。</li><li>“range”模式：线程可以在指定的 CPU 核心范围内自由调度。例如，在 group1 中，设置的可运行CPU核心号为“0-7,16-23”，线程数量为16个。在此模式下，这16个线程可在CPU -7和16-23之间灵活运行。</li></ul><p>线程的调度策略决定了线程在系统中的运行方式，影响其优先级和执行顺序。POSIX线程库提供pthread_setschedparam函数，用于设置线程的调度策略和优先级。常见的调度策略包括：</p><ul><li>1.SCHED_FIFO([57])（先进先出调度）：该策略适用于实时任务，线程按照优先级执行，高优先级线程不会被低优先级线程抢占，直到线程主动释放CPU或被阻塞。</li><li>2.SCHED_RR([58])（时间片轮转调度）：该策略与 SCHED_FIFO 类似，但线程会在相同优先级下轮流执行，每个线程拥有固定的时间片，时间片到期后，调度器会将其放到同优先级的队列末尾。</li><li>3.SCHED_OTHER([59])（普通时间共享调度）：这是默认的调度策略，适用于大多数普通任务。线程的优先级较低，并且调度器会根据系统负载动态调整线程的执行顺序，以保证公平性。</li></ul><p>Scheduler创建的所有线程会共同访问一个全局的数据结构：CR_GROUP，CR_GROUP是一个映射表，以配置文件中的group的name作为键，MULTI_PRIO_QUEUE作为值，MULTI_PRIO_QUEUE为一个数组，此数组按照协程的优先级进行排列，数组中的每一个元素即为此优先级对应的协程队列。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/176892178839410.png" alt="img"></p><p>在完成线程的创建后，全局的线程布置结构如图所示，每个线程主体为Run()函数，此函数的逻辑为：（1）根据当前线程所属的group的名字作为键去访问CR_GROUP中对应的协程优先级数组。（2）通过双重循环遍历，检查所有队列中是否有状态为READY的协程。若找到，则返回该协程并调用Resume()执行；若无就绪协程，则阻塞线程等待NotifyProcessor()唤醒。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/176892178839411.png" alt="img"></p><p>协程任务的创建是通过CreateTask()函数来实现的，在此函数中会创建一个新的协程（CRoutine），并根据协程的名字分配优先级，最后将其放入CR_GROUP的协程队列中。</p><h2 id="7-4-基于协程的通信架构设计"><a href="#7-4-基于协程的通信架构设计" class="headerlink" title="7.4 基于协程的通信架构设计"></a>7.4 基于协程的通信架构设计</h2><h3 id="7-4-1-Cache-buffer"><a href="#7-4-1-Cache-buffer" class="headerlink" title="7.4.1 Cache_buffer"></a>7.4.1 Cache_buffer</h3><p>为实现协程任务处理与分布式通信中间件的协同运行，设计了一套数据缓存与分发机制。核心组件Cache_buffer用于存储从Receiver读取的数据，其结构为环形队列，队列中的每个元素对应一条消息数据，具体设计如图所示。基于Cache_buffer，进一步构造了ChannelBuffer，采用&lt;channel_id, Cache_buffer&gt;键值对形式，使每个channel具备独立的数据缓存能力。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/176892178839412.png" alt="img"></p><h3 id="7-4-2-ChannelBuffer"><a href="#7-4-2-ChannelBuffer" class="headerlink" title="7.4.2 ChannelBuffer"></a>7.4.2 ChannelBuffer</h3><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/176892178839413.png" alt="img"></p><ul><li><code>ChannelBuffer</code>是对<code>CacheBuffer</code>的包装，提供了三个函数用于操控内部包含的这个<code>ChannelBuffer</code>，<code>Fetch</code>用于取出指定index位置的数据，<code>Latest</code>用于获取<code>CacheBuffer</code>最新添加的数据，<code>FetchMulti</code>用于获取指定个数的一堆数据。</li><li>每个<code>ChannelBuffer</code>都会和一个确定的<code>channel_id_</code>对应，即一个<code>channel_id_</code>和一个<code>Cache_buffer</code>组成一队</li></ul><h3 id="7-4-3-DataNotifier"><a href="#7-4-3-DataNotifier" class="headerlink" title="7.4.3 DataNotifier"></a>7.4.3 DataNotifier</h3><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/176892178839414.png" alt="img"></p><ul><li><code>DataNotifier</code>内部维护了一个<code>map</code>，<code>map</code>的索引为<code>channel_id</code>，值为一个<code>vector</code>，这个<code>vector</code>内部会保存很多个<code>Notifier</code>，<code>Notifier</code>实际上就是一个函数</li><li><code>DataNotifier</code>提供了一个<code>AddNotifier</code>函数来向对应<code>channel_id</code>的<code>NotifyVector</code>添加<code>Notifier</code></li><li><code>DataNotifier</code>提供了一个<code>Notify</code>函数，函数参数为<code>channel_id</code>，此函数会把对应的<code>NotifyVector</code>中保存的<code>Notifier</code>函数遍历执行一遍</li></ul><h3 id="7-4-4-协程通信流程"><a href="#7-4-4-协程通信流程" class="headerlink" title="7.4.4 协程通信流程"></a>7.4.4 协程通信流程</h3><p>在CyberRT的设计中，订阅方被封装为节点（Node）中的Subscriber。每个Subscriber创建时生成一个协程（CRoutine），用于处理来自Publisher的数据，其通信架构如图所示。同时，每个Subscriber创建时同步生成一个协程，并绑定一个DataVistor对象。DataVistor内部维护一个ChannelBuffer，协程通过回调函数持续尝试从中提取数据。若ChannelBuffer为空，协程调用Yield()函数切换至等待状态；若提取到数据，则执行Subscriber的回调逻辑，处理完成后再次调用Yield()切换。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-07%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/176892178839415.png" alt="img"></p><p>数据分发由DataDispatcher负责，其设计为全局单例对象。当DataVistor创建时，会根据对应的channel将其ChannelBuffer的读写权限注册至DataDispatcher。Transport层的Receiver接收到某channel的数据后，DataDispatcher将数据填充至该channel对应的ChannelBuffer，供协程后续处理。这种机制通过集中式分发与权限注册，实现了数据从接收到处理的有序传递。</p>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析--06基于有向图的拓扑机制设计</title>
      <link href="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-06%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-06%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="6-1-拓扑图中的角色定义"><a href="#6-1-拓扑图中的角色定义" class="headerlink" title="6.1 拓扑图中的角色定义"></a>6.1 拓扑图中的角色定义</h2><p>在发布-订阅架构的基础上，进一步抽象出拓扑图中的角色，以清晰描述节点间的通信关系。如图所示，拓扑图中的核心角色包括Publisher（发布者）、Subscriber（订阅者）和Node（节点）。这些角色的定义如下：</p><p>Publisher（发布者）：负责生成并发布数据的实体，对应于前文所述的Transmitter。一个Publisher通过指定的Channel发布数据，其身份由Identity和RoleAttributes唯一标识。</p><p>Subscriber（订阅者）：负责订阅并接收数据的实体，对应于Receiver。一个Subscriber通过订阅特定的Channel获取数据，并通过回调函数处理接收到的信息。</p><p>Node（节点）：通信平面中的基本管理单元，一个Node可以同时包含多个Publisher和Subscriber。在一个进程中，可创建多个Node，Node通过Transport层提供的接口创建和管理这些角色，并维护其与外部节点的连接关系。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-06%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/17689216018195.png" alt="img"></p><h2 id="6-2-拓扑图的底层数据结构设计"><a href="#6-2-拓扑图的底层数据结构设计" class="headerlink" title="6.2 拓扑图的底层数据结构设计"></a>6.2 拓扑图的底层数据结构设计</h2><p>前文已阐明，有向图因其在表示方向性关系和支持动态调整方面的优势，被选为拓扑机制的核心模型。本节聚焦于拓扑图的组成要素——顶点（Vertice）、边（Edge）和图（Graph），以下从顶点与边的定义、图的整体结构及其关系表达三个方面，系统阐述该数据结构的设计。</p><p>顶点是拓扑图的基本构成单元，代表分布式通信平面中的独立实体。每个顶点对应于一个Node节点。</p><p>边是有向图中连接顶点的纽带。每条边由三个要素组成，如表所示：</p><table><thead><tr><th><strong>参数名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>源顶点（src）</td><td>数据流的起点，对应发送方的Node节点。</td></tr><tr><td>目标顶点（dst）</td><td>数据流的终点，对应接收方的Node节点。</td></tr><tr><td>边属性（value）</td><td>描述边的信息，对应通信中的Channel标识</td></tr></tbody></table><p>图（Graph）作为顶点与边的集合，提供了拓扑关系的全局视图。图采用邻接表形式组织，其结构由以下两个主要部分构成：</p><ul><li>邻接表（Adjacency List）：邻接表以每个顶点为中心，记录其所有下游顶点（即出边指向的目标顶点）。邻接表通过键值映射实现，其中键为源顶点的标识，值为目标顶点的集合。</li><li>边信息集合（Edge Info）：为支持双向关系查询，图中额外维护了一个边信息集合，以边属性（如Channel标识）为索引，记录与该属性相关的所有源顶点和目标顶点。</li></ul><p>通信平面中的拓扑关系可通过图（Graph）进行描述，如图所示，通信平面中存在了四个节点：NodeA、NodeB、NodeC、NodeD，这四个节点对应图中的顶点，每个节点中分布着Publisher和Subscriber，节点与节点间通过channel互相传递数据，自然的channel标识就被设置为拓扑图的边。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-06%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/17689216018181.png" alt="img"></p><h2 id="6-3-拓扑图的动态管理"><a href="#6-3-拓扑图的动态管理" class="headerlink" title="6.3 拓扑图的动态管理"></a>6.3 拓扑图的动态管理</h2><p>拓扑的动态管理通过节点管理器来实现（NodeManager），每个节点都会对应一个节点管理器，NodeManager会在本地维护一张拓扑图，当有新的通信角色加入或者离开拓扑图时都会广播变更消息（ChangeMsg），已在图中的节点就会根据此广播的变更消息更新本地维护的拓扑图。ChangeMsg消息结构定义如表所示。</p><p>NodeManager的数据广播操作借助FastRTPS实现。在NodeManager中，分别维护一个RtpsWriter和RtpsReader，用于发送和接收ChangeMsg。如图所示，当Publisher或Subscriber加入或退出时，其所属NodeManager通过RtpsWriter向”change_broadcast”通道发送ChangeMsg，所有节点的RtpsReader从该通道接收消息，并根据接收到的ChangeMsg更新本地拓扑图。例如，一个新Publisher加入Node A时，NodeManager广播包含其RoleAttributes的ChangeMsg，其他节点的NodeManager据此在本地图中添加相应的边。</p><table><thead><tr><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Timestamp</td><td>时间戳</td></tr><tr><td>OperateType</td><td>角色动作，代表加入还是离开拓扑图</td></tr><tr><td>RoleType</td><td>角色类型，拓扑图中有三种类型：Node、Pubslisher、Subsriber</td></tr><tr><td>RoleAttributes</td><td>角色的通信标识，其中包含了Channel相关信息</td></tr><tr><td>NodeName</td><td>角色所属的Node的标识</td></tr></tbody></table><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-06%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/17689216018182.png" alt="img"></p><h2 id="6-4-拓扑机制设计"><a href="#6-4-拓扑机制设计" class="headerlink" title="6.4 拓扑机制设计"></a>6.4 拓扑机制设计</h2><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-06%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/17689216018183.png" alt="img"></p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-06%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/17689216018194.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析--05基于共享内存的通信实现</title>
      <link href="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/"/>
      <url>/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-什么是共享内存"><a href="#5-1-什么是共享内存" class="headerlink" title="5.1 什么是共享内存"></a>5.1 什么是共享内存</h2><p>共享内存（Shared Memory）是操作系统层面实现高效进程间通信（Inter-Process Communication, IPC）的关键机制，其核心设计理念在于突破传统进程间内存隔离的限制，使多个进程能够直接访问同一物理内存区域，从而显著提升数据传输效率并减少通信过程中的数据复制开销。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689214877479.png" alt="img"></p><h2 id="5-2-CyberRT共享内存通信模型"><a href="#5-2-CyberRT共享内存通信模型" class="headerlink" title="5.2 CyberRT共享内存通信模型"></a>5.2 CyberRT共享内存通信模型</h2><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689214877461.png" alt="img"></p><p>发送进程中的Transmitter在发送数据时会绑定一个确定的<code>channel_id</code>，同时根据此<code>channel_id</code>去创建一片共享内存，这片共享内存被定义成一个<code>Segment</code>。接收进程中的<code>Receiver</code>也会存在自己所关注的<code>channel_id</code>，在接收进程设计了一个<code>SegmentMap：&lt;channel_id, Segment&gt;</code>的数据结构，<code>SegmentMap</code>保存了<code>channel_id</code>和对应共享内存<code>Segment</code>之间的索引关系，<code>Receiver</code>在获取对应<code>channel_id</code>上的数据时会首先向<code>SegmentMap</code>中注册，后续获取数据通过去<code>SegmentMap</code>根据<code>channel_id</code>找到<code>Segment</code>从而拿到数据。<code>Transmitter</code>在向一个<code>Segment</code>写入数据后会发送通知信息代表自己已经将数据写入完毕，<code>Receiver</code>可以从此<code>Segment</code>中拿到数据。通知信息被定义为<code>ReadableInfo</code>，在同一主机中会专门创建一块名为<code>Indicator</code>的共享内存用于存放这些通知信息。在接收进程中<code>Dispatcher</code>用于监测是否有<code>Segment</code>上的数据被更新写入了，<code>Dispatcher</code>内部会有一个单独的线程不断的去遍历读取<code>Indicator</code>上的通知消息来判断是哪个<code>channel_id</code>上的<code>Transmitter</code>发送了数据，即如果发送进程的<code>Transmitter</code>向其<code>channel_id</code>对应的<code>Segment</code>写入数据了则<code>Dispatcher</code>会实时监测到将数据分发给订阅者。</p><h3 id="5-2-1-Segment定义"><a href="#5-2-1-Segment定义" class="headerlink" title="5.2.1 Segment定义"></a>5.2.1 Segment定义</h3><p>Segment的内存结构定义如图所示，每个Segment共享的内容有：一个State、n个Block、n个Buffer、一个Unused。State控制的是当前Segment进程间的共享状态；Buffer储存了Transmitter发送的每条数据；Block控制了Buffer的读写状态；Unused为未使用内存区域，设置为冗余内存。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689214877462.png" alt="img"></p><p>一个Segment的内存占用大小是和想要传递的消息数据大小息息相关的。具体地，比如假设传递的一条消息的大小在10kb~100kb，则对应第2条规则，首先规则中定义了每个Block的大小为1024字节，一个Segment中Block个数为128，buffer的个数也对应为128个，一个buffer由两部分组成：承载消息的Message和额外的MessageInfo。MessageInfo的大小固定为1024个字节，因此此时一个buffer的大小就是128kb+1kb &#x3D;129kb。除此之外规定Segment头部的State的大小为1024字节，Segment的尾部未使用的部分占用的大小为1024*4&#x3D;4kb。</p><table><thead><tr><th><strong>消息大小</strong></th><th><strong>Block数量</strong></th><th><strong>Buffer数量</strong></th><th><strong>消息占用<strong><strong>内存</strong></strong>（字节）</strong></th></tr></thead><tbody><tr><td>0~16k</td><td>512</td><td>512</td><td>1024*16</td></tr><tr><td>16k~128k</td><td>128</td><td>128</td><td>1024*128</td></tr><tr><td>128k~1M</td><td>64</td><td>64</td><td>1024*1024</td></tr><tr><td>1M~8M</td><td>32</td><td>32</td><td>1024<em>1024</em>8</td></tr><tr><td>8M~16M</td><td>16</td><td>16</td><td>1024<em>1024</em>16</td></tr><tr><td>16M~32M</td><td>8</td><td>8</td><td>1024<em>1024</em>32</td></tr></tbody></table><p>State由四个原子变量组成，need_remap_用于控制当前的Segment是否需要重新映射，ceiling_msg_size_代表消息数据的大小即一个Buffer的字节数，从上面的规则可以看出，如果数据消息越大，那么Segment维护的队列长度越短。seq_代表的是当前正在写的Block的索引，Transmitter每发送一条消息就会去写入一个Block和一个Buffer，每次写完数据后就会将seq+1，reference_count代表使用这片内存的用户的个数。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689214877473.png" alt="img"></p><p>Block由三个原子变量组成，，lock_num_用于控制Block对应的那个buffer的读写互斥，用于做到进程间的安全读写，msg_size__和msg_info_size_代表着消息的长度。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689214877474.png" alt="img"></p><h3 id="5-2-2-Indicator定义"><a href="#5-2-2-Indicator定义" class="headerlink" title="5.2.2 Indicator定义"></a>5.2.2 Indicator定义</h3><p>为了实现多进程间各发布者和订阅者之间的消息通知机制，创建了一个特殊的数据结构Indicator，当第一个发布节点启动后则会去开辟一块全局唯一的共享内存用于存放Indicator。此Indicator是同主机上所有发布者和订阅者共享的</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689214877475.png" alt="img"></p><p>Indicator为一个队列形的数据结构，可存储4096个ReadableInfo，每个ReadableInfo会对应一个索引，此索引会被写入到Indicator尾部的seq数组中，因此seq数组的大小也为4096。头部的next_seq是一个原子变量代表着下一个可写的ReadableInfo的索引，host_id为每个主机的唯一标识；channel_id 即代表发布者向哪个channel_id上的Segment写入数据；block_index即代表着写入数据的Segment的block索引。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689214877476.png" alt="img"></p><h2 id="5-3-基于共享内存的发布方实现"><a href="#5-3-基于共享内存的发布方实现" class="headerlink" title="5.3 基于共享内存的发布方实现"></a>5.3 <strong>基于<strong><strong>共享内存</strong></strong>的发布方实现</strong></h2><p>通信架构中ShmTransmitter会实现基于共享内存的发布方，其软件架构如图所示。根据通信流程可知，ShmTransmitter会向一个channel上写数据，并且写入的数据结构类型也是发送方事先确定好的，每个channel会对应一个Segment，因此ShmTransmitter在发布数据时会先去根据要发布的数据结构的类型和大小根据上述的规则去创建一片Segment，即在重载的Enable函数中会根据当前Transmitter的channel_id去新建一块Segment，Segment为一片全局的共享内存，在linux环境下有两种方式来创建共享内存，分别是基于System V IPC和 POSIX IPC，使用这两种方式都可以。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689214877477.png" alt="img"></p><p>在创建完毕Segment后就可以往这片Segment上写入数据了，通过Transmitt函数来实现。数据写入的目标是向Segment中的其中一个Block和对应的Buffer填入数据，因此需要事先拿到一个Buffer的索引，而State的seq_就记录了该索引。State中的seq_初始值为0，每一次获取可写的Block索引时都会将seq_的值增加1，如果seq_的值超过了当前Segment的Block的数量，则从头轮转，即使用取余操作，使得seq_的值限定在0和Block的数量数量之间。同时获取可写的Block索引这步操作是一个循环操作，只有在确定拿到的这个Block的索引对应的Block是可写的才会将此索引返回从而跳出循环操作。Block是根据头部的lock_num_来进行读写互斥的，lock_num_是一个原子变量，初始值为0，因此对此变量的读写是进程安全的，假设当前的Block是可写的，那么会去原子性的判断ock_num_的值是否为0，如果为0，则将lock_num_的值置为负数，代表有一个进程已经占用了此Block，如果此时有另外一个进程也想来对此Block进行写入，则先判断lock_num_的值发现为负数，则不可被此进程进行写。</p><p>通过上面的操作就能从Segment中去拿到一个可写的Block和对应的Buffer，接着就是向此Block和Buffer写入数据，当写入数据后需要释放对此Block和Buffer的独占所有权，这里就是将此Block的lock_num_的值重新置为0，说明没有进程在对此Block写入数据了。</p><p>当ShmTransmitter向一个channel_id上的Segment中的某个Block和Buffer上写入完毕数据后，接着需要填充一个ReadableInfo，因此首先需要向Indicator中请求，此时全局的Indicator头部的next_seq就是可写的ReadableInfo的索引，发布者写入ReadableInfo之前会将next_seq原子性的增加1，然后再向拿到的索引处写入通知信息。</p><p>订阅者进程中会不断读取Indicator上的ReadableInfo的信息进行数据分发，具体来说内部会单独启用一个线程，此线程的主体为一个无限循环的函数，内部会单独保存一个本地的seq索引，初始值为0。线程循环函数会循环读取Indicator头部的next_seq的值和本地的seq进行比对，如果next_seq的值不等于本地的seq则说明由其他发布者发布了数据并且写入了ReadableInfo，此时就可根据本地保存的seq去Indicator索引seq数组，然后将本地的seq更新为seq数组中的值，接着就可去拿到本地seq对应的ReadableInfo，最后比对channel_id判断当前发布者进程是否包含此channel_id的订阅者，如果存在则根据channel_id去索引Segment，然后根据ReadableInfo中的block_index去把发布者写入的数据读取出来。</p><h2 id="5-4-基于共享内存的订阅方实现"><a href="#5-4-基于共享内存的订阅方实现" class="headerlink" title="5.4 基于共享内存的订阅方实现"></a>5.4 <strong>基于<strong><strong>共享内存</strong></strong>的订阅方实现</strong></h2><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-05%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689214877478.png" alt="img"></p><p>基于共享内存的数据订阅方由ShmReceiver与ShmDispatcher联合实现，具体设计如图所示，ShmReceiver的实现和RtpsReceiver类似，会把传入ShmReceiver的回调函数进行打包后然后调用ShmDispatcher的AddListener函数。在ShmDispatcher中定义了SegmentMap：&lt;channel_id, Segment&gt;，用于保存channel_id和Segment的索引关系，在AddListener函数中会根据ShmReceiver的channel_id去创建一块Segment，创建完毕后就会将索引关系注册到SegmentMap中。在ShmDispatcher中单独创建了一个独立的线程thread_,此线程的执行主体为ThreadFunc函数，在ThreadFunc函数内部会不断地轮询Indicator去获取ReadableInfo，如果有ShmTransmitter发送了数据则就会往Indicator中写入一条新的ReadableInfo，此时会被ThreadFunc捕捉到，如果此ReadableInfo的channel_id能在SegmentMap中查找到则说明是当前进程的ShmReceiver订阅的。随后将读取到的ReadableInfo传递给ReadMessage函数处理，在ReadMessage函数中会取出对应的Segment，再从此Segment中取出Block和Buffer，最后将Buffer中的Message和MessageInfo传递给OnMessage函数，最后通过信号槽机制执行回调处理。</p><p>在通信中间件框架中，拓扑机制是实现网络节点互联管理的核心组成部分，其设计目标在于确保分布式系统中节点加入或退出时，网络能够动态调整并维持通信的连贯性与一致性。拓扑结构本质上是网络中各站点互联形式的抽象表达，在本文设计的通信中间件中体现为：当一个新节点加入通信平面时，其他节点通过广播机制感知其存在并更新全局拓扑图。新节点可能扮演发布者或订阅者的角色，在正式参与数据交互前，需广播其属性信息，以便网络中的其他节点据此建立连接。然而，如何高效地表示和管理这种动态的节点关系，是拓扑机制设计的关键问题。</p><p>在分布式系统中，节点间的通信关系具有方向性（例如从发布者到订阅者的数据流）和动态性（节点可能随时加入或退出），这对拓扑表示方法提出了较高要求。有向图作为一种经典的图论模型，能够以O(V+E)（E为边数）的空间复杂度高效表示稀疏网络，同时通过邻接表或边列表结构支持节点的动态增删操作。此外，有向图天然支持方向性关系的表达，能够清晰刻画发布者到订阅者的单向数据流，符合发布-订阅架构的通信特性。因此，本文选择基于有向图构建拓扑机制，以充分利用其在表示复杂网络关系、支持动态调整及优化查询效率方面的优势。</p><p>在具体实现中，本设计通过有向图抽象分布式系统中节点间的通信关系，其中顶点表示通信实体，有向边表示数据流方向（如从发布者到订阅者的Channel连接）。当新节点加入时，其属性信息通过广播分发，其他节点据此更新本地拓扑图，从而实现网络的自适应调整。以下将从角色定义、底层数据结构及动态管理三个方面，详细阐述该机制的设计与实现。</p>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析--04基于FastRTPS的通信实现</title>
      <link href="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-04%E5%9F%BA%E4%BA%8EFastRTPS%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/"/>
      <url>/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-04%E5%9F%BA%E4%BA%8EFastRTPS%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-FastRTPS通信流程"><a href="#4-1-FastRTPS通信流程" class="headerlink" title="4.1 FastRTPS通信流程"></a>4.1 FastRTPS通信流程</h2><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-04%E5%9F%BA%E4%BA%8EFastRTPS%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689213718935.png" alt="img"></p><p>在基于FastRTPS实现跨进程通信时，发送端和接收端需遵循特定流程完成配置，以实现数据通信。其具体步骤如下所述，在发送端，首先要创建RtpsParticipant。接着，创建RtpsWriter的配置信息实例并完成填充，随后创建RtpsWriter和RtpsWriter History，最后将RtpsWriter进行注册。准备工作完成后，就可以进行数据装载与发送。在接收端，同样需要先创建RtpsParticipant，然后创建RtpsReader的配置信息实例并填充相关信息，创建RtpsReader并为其设置回调函数，再创建RtpsReader History，完成这些步骤后，就能在接收到数据时执行回调操作。当发送端和接收端都按照上述流程配置完成，双方即可开始通信。</p><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-04%E5%9F%BA%E4%BA%8EFastRTPS%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689213718931.png" alt="img"></p><h2 id="4-2-基于FastRTPS的发送端的实现"><a href="#4-2-基于FastRTPS的发送端的实现" class="headerlink" title="4.2 基于FastRTPS的发送端的实现"></a>4.2 基于FastRTPS的发送端的实现</h2><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-04%E5%9F%BA%E4%BA%8EFastRTPS%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689213718932.png" alt="img"></p><p>在本通信架构中，RtpsTransmitter负责实现基于FastRTPS的发送端功能，具体设计思路如下：在FastRTPS通信模型中，一个RtpsParticipant可创建多个RtpsWriter。因此无需为每个RtpsTransmitter单独创建RtpsParticipant，同一进程内的所有RtpsTransmitter可共享由Transport单例类创建的全局RtpsParticipant。在具体实现时，本文基于RtpsParticipant的向上继续抽象了一层Participant。</p><p>RtpsTransmitter重载的Enable函数按照创建RtpsWriter的流程执行初始化操作，完成后生成RtpsWriter及WriterHistory实例。Enable操作完成后，RtpsTransmitter即可通过Transmit函数发布数据。Transmit函数发送的数据包含两部分：Message（用户定义且支持序列化的数据结构）和MessageInfo（附加消息）。这两部分数据最终被写入WriterHistory。在FastRTPS中，WriterHistory缓存的数据结构由附加消息（WriteParams）和缓存消息（CacheChange_t）组成，其中MessageInfo被转换为WriteParams，Message被转换为CacheChange_t。随后，这两部分数据通过RtpsWriter发送至网络。</p><h2 id="4-3-基于FastRTPS的接收端的实现"><a href="#4-3-基于FastRTPS的接收端的实现" class="headerlink" title="4.3 基于FastRTPS的接收端的实现"></a>4.3 基于FastRTPS的接收端的实现</h2><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-04%E5%9F%BA%E4%BA%8EFastRTPS%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689213718933.png" alt="img"></p><p>基于FastRTPS的接收端设计时引入了RtpsReader的抽象层Reader，其内部包含RtpsReader、ReaderHistory和ReaListener三个组件。ReaListener是RtpsReader的回调处理类：当RtpsReader从ReaderHistory读取数据后，ReaListener的onNewCacheChangeAdded函数被自动触发。该函数调用ReaListener内部维护的回调函数（callback）完成处理。通过Reader抽象层，统一了基于FastRTPS接收端的组件设计。</p><h2 id="4-4-基于FastRTPS的数据订阅端的实现"><a href="#4-4-基于FastRTPS的数据订阅端的实现" class="headerlink" title="4.4 基于FastRTPS的数据订阅端的实现"></a>4.4 基于FastRTPS的数据订阅端的实现</h2><p><img src="/2026/01/20/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-04%E5%9F%BA%E4%BA%8EFastRTPS%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/17689213718934.png" alt="img"></p><p>数据订阅端由RtpsReceiver和RtpsDispatcher共同构成，二者需与Reader建立关联，具体实现如下：RtpsReceiver的回调函数首先在OnNewMessage函数中进行初步封装，随后通过Enable函数完成注册。注册过程调用RtpsDispatcher的AddListener函数实现，该函数以当前Receiver的channel_id为索引，将RtpsReceiver的OnNewMessage函数注册至前文所述的二级回调索引表。注册完成后，调用AddReader函数创建新的Reader实例，并在创建时将RtpsDispatcher的OnMessage函数指定为Reader的回调函数。由此，当channel上的Reader接收到数据时，onNewCacheChangeAdded函数被触发，继而调用RtpsDispatcher的OnMessage函数。OnMessage函数根据channel_id，在二级回调索引表中依次执行订阅该channel的所有Receiver的OnNewMessage函数，从而实现数据的分发与回调执行。</p>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRT源码剖析--03通信架构</title>
      <link href="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/"/>
      <url>/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/176892110857216.png" alt="img"></p><ul><li><strong>序列化</strong>模块：序列化模块负责将用户自定义的数据结构转换为可传输的二进制格式，并支持反向解析。本模块采用嵌入式序列化方案，用户仅需定义C++数据结构体并通过标准化宏调用即可完成序列化操作。该方案支持C++基本数据类型（如int、float）以及STL容器（如vector、map）</li><li><strong>发布订阅系统：</strong>发布-订阅系统是本设计中分布式通信中间件的核心模块之一，负责实现节点间高效、解耦的通信。该系统采用基于消息驱动的架构，由发布者、订阅者和消息代理三个部分组成。发布者负责发布特定主题（Channel）的消息，订阅者则订阅感兴趣的主题，消息代理充当中枢，接收并转发发布者的消息至对应的订阅者。在分布式系统中，节点间的通信可能涉及不同的网络环境，如同一主机内的通信与跨主机的通信。针对这一问题，当节点位于同一主机时发布订阅框架会优先选择共享内存进行通信，这样可以避免网络协议栈的开销，从而实现更低延迟的通信；而当节点位于不同主机时，框架则采用基于FastRTPS网络通信方式。在多层次的网络架构中，通信方式会根据实际情况动态选择，确保在不同环境下都能够提供高效的通信服务。</li><li><strong>服务发现机制：</strong>在点对点通信中，节点需要了解目标节点的信息以建立通信连接。为解决这一问题，设计了动态拓扑发现机制，节点间的连接信息通过<strong>有向图</strong>进行维护。每当节点加入或退出通信平面时，它会广播自身的信息，其他节点根据这些信息动态更新拓扑结构</li><li><strong>高性能基础库：</strong>为满足分布式通信中间件对基础功能的需求，设计了一个高性能基础库，涵盖了数据结构、线程同步机制以及设计模式等多种基础功能。该库提供了如无锁队列、无锁哈希表、线程池、目标池等关键模块</li><li><strong>日志库：</strong>日志库用于记录中间件在运行过程中不同级别的日志信息，支持输出至文件和控制台。该日志库基于C++的ofstream类实现文件写入，并定义了一组宏：log_debug、log_info、log_warn、log_error、log_fatal，分别对应不同的日志级别，方便用户在代码中输出相应的日志信息，帮助调试和运行时问题定位。</li></ul><h2 id="3-1-序列化"><a href="#3-1-序列化" class="headerlink" title="3.1 序列化"></a>3.1 序列化</h2><p>在分布式系统与高性能计算领域，序列化作为数据交换和存储的重要环节，其性能直接影响系统的整体效率和数据传输能力。尤其在数据量庞大且通信频繁的场景下，传统序列化方法可能因效率不足而成为系统瓶颈。因此，设计一种高性能序列化机制需在确保数据正确性和完整性的前提下，尽量减少计算资源消耗并提升传输效率。本节详细阐述本文设计的高性能序列化机制，序列化机制主要目标包括：通过优化二进制格式和减少序列化数据量降低网络带宽占用；通过减少内存复制和重复分配优化内存使用效率；通过灵活的接口支持不同数据结构的序列化需求。</p><p>该机制的核心组件为DataStream模块，如图所示，此模块负责将数据结构转换为二进制流并完成存储与解析任务。DataStream内部使用基于C++ STL的<code>std::vector&lt;char&gt;</code>容器作为缓冲区（buffer），每个元素占用1字节，支持动态长度调整。序列化过程通过write函数和重载的&gt;&gt;操作符将数据写入缓冲区，反序列化则通过read函数和重载的&lt;&lt;操作符从缓冲区读取数据。利用C++函数重载特性，DataStream能够处理多种数据类型的读写操作。模块中定义了一个pos变量，用于记录缓冲区的当前读写位置：数据写入时，pos根据写入字节数增加；数据读取时，pos根据读取字节数减少。</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/17689211085711.png" alt="img"></p><ul><li>对于基本数据类型（如整型、浮点型、字符型等），框架通过预定义的序列化策略实现紧凑存储。每个数据字段在序列化时以1字节的DataType枚举值开头，用于标识数据类型，后接具体值。例如，bool和char类型各占用2字节（DataType 1字节 + 值1字节），int32和uint32占用5字节（DataType 1字节 + 值4字节），int64和uint64占用9字节（DataType 1字节 + 值8字节），float占用5字节，double占用9字节，enum占用5字节。对于字符串等变长类型，序列化时需额外存储长度字段（以int32编码，占5字节），后接实际字符数据（长度可变），以便反序列化时根据长度准确读取数据。具体字段长度和编码格式如表3.1所示。</li></ul><p>表3.1 基本数据类型序列化协议</p><table><thead><tr><th><strong>字段类型</strong></th><th><strong>长度（字节）</strong></th><th><strong>底层编码格式</strong></th></tr></thead><tbody><tr><td>bool</td><td>2</td><td>DataType(1) + Value(1)</td></tr><tr><td>char</td><td>2</td><td>DataType(1) + Value(1)</td></tr><tr><td>int32</td><td>5</td><td>DataType(1) + Value(4)</td></tr><tr><td>uint32</td><td>5</td><td>DataType(1) + Value(4)</td></tr><tr><td>int64</td><td>9</td><td>DataType(1) + Value(8)</td></tr><tr><td>uint64</td><td>9</td><td>DataType(1) + Value(8)</td></tr><tr><td>float</td><td>5</td><td>DataType(1) + Value(4)</td></tr><tr><td>double</td><td>9</td><td>DataType(1) + Value(8)</td></tr><tr><td>enum</td><td>5</td><td>DataType(1) + Value(4)</td></tr><tr><td>string</td><td>可变长度</td><td>DataType(1) +Length(5) + Value(length)</td></tr></tbody></table><ul><li>例如现在有三个数据：int a，bool b，float c需要储存，则根据上述协议进行序列化存储后DataStream模块的buffer内存分布如图3.3所示，总共占据12字节的内存大小。</li></ul><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/17689211085712.png" alt="img"></p><p>图3.3 基础数据类型序列化示意图</p><ul><li>对于C++的STL容器（如std::vector、std::list、std::map、std::set），序列化框架采用递归调用方式处理其元素。以std::vector<T>为例，序列化时首先写入1字节的DataType字段和5字节的Length字段（表示元素个数，按int32处理），随后对每个元素根据类型T调用对应的序列化方法。若T为基本类型，则按表3.1的策略处理；若T为复合类型，则继续递归分解。对于std::map&lt;k,v&gt;，序列化时写入DataType和Length字段（表示键值对数量），然后按插入顺序依次序列化每个键k和值v。反序列化时，先读取DataType和Length，再根据Length依次解析每个元素或键值对，重建容器结构。各容器类型的序列化格式如表3.2所示。</T></li></ul><p>表3.2 复合数据类型序列化协议</p><table><thead><tr><th><strong>字段类型</strong></th><th><strong>长度（字节）</strong></th><th><strong>底层编码格式</strong></th></tr></thead><tbody><tr><td>std::vector<T></T></td><td>可变长度</td><td>DataType(1) + Length(5) + Value(T + T +T + …)</td></tr><tr><td>std::list<T></T></td><td>可变长度</td><td>DataType(1) + Length(5) + Value(T + T +T + …)</td></tr><tr><td>std::map&lt;k,v&gt;</td><td>可变长度</td><td>DataType(1) + Length(5) + Value((K,V) + (K,V) + …)</td></tr><tr><td>std::set<T></T></td><td>可变长度</td><td>DataType(1) + Length(5) + Value(T + T +T + …)</td></tr></tbody></table><ul><li>如图3.4所示现在有一个<code>std::vector&lt;int&gt;a=&#123;1,2&#125;</code>的数据结构需要储存，根据上述协议序列化后的DataStream模块的buffer内存分布如图所示，a中的每一个元素都是int32类型，头部写入了类型和长度信息。</li></ul><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/17689211085713.png" alt="img"></p><p>图3.4 复合数据类型序列化示意图</p><ul><li>针对自定义类，设计了特定的序列化协议。自定义类的序列化格式如表3.3所示。自定义类的序列化结构包括1字节的Type字段（标识自定义类类型）和后续的成员变量数据（长度可变，包含D1 + D2 + D3 + …）。为实现此功能，自定义类需继承Serializable接口类，并使用SERIALIZE宏重载serialize和unserialize函数。Serializable类声明了serialize和unserialize两个纯虚函数，子类通过继承自动获得这两个接口。SERIALIZE宏接受可变参数（即类的成员变量），在serialize函数中首先写入Type字段，随后递归将所有成员变量写入DataStream的缓冲区。反序列化时，unserialize函数读取Type字段确认类型后，从DataStream的缓冲区依次解析成员变量数据。</li></ul><p>表3.3 自定义数据结构序列化协议</p><table><thead><tr><th><strong>字段类型</strong></th><th><strong>字段长度（字节）</strong></th><th><strong>底层编码格式</strong></th></tr></thead><tbody><tr><td>自定义类</td><td>可变长度</td><td>Type(1) + Value(D1 + D2 + D3 + …)</td></tr></tbody></table><h2 id="3-2-发布订阅系统"><a href="#3-2-发布订阅系统" class="headerlink" title="3.2 发布订阅系统"></a>3.2 发布订阅系统</h2><p>  将通信流程明确划分为发布方和订阅方两个独立模块，其通信模型如图3.5所示。在该架构中，发布方被定义为Transmitter，负责生成并传输数据；订阅方被定义为Receiver，负责接收并处理数据。发布方与订阅方之间无需建立直接交互，数据传输通过共享的通信主题（在本设计中称为channel）得以实现。具体而言，发布方将数据写入指定的channel，而订阅方通过订阅该channel自动获取相关数据。</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/17689211085714.png" alt="img"></p><p>如图3.6所示，在发布方，Transmitter将用户定义的消息（Message）序列化为字节流，随后根据所选通信模式将其传输至网络或共享内存。在订阅方，Receiver通过集成的Dispatcher组件监测新数据的到达。Dispatcher将接收到的字节流反序列化为用户定义的消息格式，并将其传递至Receiver的回调函数以供后续处理。为优化资源利用效率，每个进程仅维护单一的Dispatcher实例，供所有Receiver共享。本设计支持两种通信模式：基于共享内存的同主机通信和基于FastRTPS的网络通信。为确保两种模式操作接口的统一性，在发布-订阅层下抽象出一套通用接口，并通过C++的继承与函数重载机制实现。</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/17689211085725.png" alt="img"></p><p>本文设计了一个中央通信层（Transport），负责创建发布者和订阅者。在发布方，设计了RtpsTransmitter和ShmTransmitter两个类，二者均继承自Transmitter基类。其中，RtpsTransmitter适用于基于FastRTPS的网络通信，而ShmTransmitter适用于基于共享内存的近域通信。在Transmitter类中定义了一系列抽象接口，RtpsTransmitter和ShmTransmitter根据各自通信方式的特点对这些接口进行重载实现。在订阅方，根据底层通信机制的差异，分别设计了RtpsReceiver和ShmReceiver，二者均继承自Receiver基类。与之对应的Dispatcher组件亦分为RtpsDispatcher和ShmDispatcher两种类型，分别适配不同的通信模式。</p><p>源码层级：</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/17689211085726.png" alt="img"></p><h2 id="3-3-通信实体身份标识设计"><a href="#3-3-通信实体身份标识设计" class="headerlink" title="3.3 通信实体身份标识设计"></a>3.3 通信实体身份标识设计</h2><p>在上述发布-订阅通信架构中，系统包含多个Transmitter（发布方）和Receiver（订阅方）。这些实体既可能共存于进程节点，也可能分布于不同的进程节点。在这种复杂的分布式环境下，需要对Transmitter和Receiver进行准确且唯一的身份标识。</p><p>为此，CyberRT提出了一种基于64位无符号哈希值的身份标识方案。具体实现过程如下：每当创建Transmitter或Receiver实例时，系统利用uuid库生成一个64位唯一标识符。随后，该标识符经过哈希处理，生成一个64位无符号哈希值，命名为Identity，并与对应的Transmitter或Receiver实例关联。</p><p>为实现通信实体与其运行环境的有效关联，设计了一种配置结构体，命名为<code>RoleAttributes</code>，用于封装与主机和进程相关的描述信息。通过Identity与RoleAttributes的结合，可对系统中任一主机上的通信实体进行精确标识。</p><table><thead><tr><th><strong>名称</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Host_name</td><td>string</td><td>此字段记录了主机的名称，使进程能够标识其运行的物理或虚拟主机环境。</td></tr><tr><td>Host_ip</td><td>string</td><td>定义了主机的网络IP地址，为进程间的网络通信提供了必要的地址信息。</td></tr><tr><td>Process_id</td><td>int32_t</td><td>标识了与通信实体关联的进程ID，确保了进程级别的唯一识别。</td></tr><tr><td>Channel_name</td><td>string</td><td>记录了用于通信的通道名称，这个名称是通信双方约定的逻辑通道，用于区分不同的通信内容或策略。</td></tr><tr><td>Channel_id</td><td>uint64_t</td><td>基于通道名称的哈希值生成的通道ID，为每个通信通道提供了一个全局唯一的标识符。</td></tr></tbody></table><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/17689211085727.png" alt="img"></p><p>基于上述两个核心标识元素，进一步设计了<code>Endpoint</code>类。该类的设计目标在于整合<code>Identity</code>和<code>RoleAttributes</code>，建立一个统一的通信实体身份与属性描述框架。在<code>Endpoint</code>类的结构中，定义了两个关键成员变量：<code>id_</code>和<code>attr_</code>。其中，<code>id_</code>用于存储<code>Identity</code>，以完整记录通信实体的唯一身份标识；<code>attr_</code>用于存储<code>RoleAttributes</code>，确保通信实体运行环境的相关信息得以全面保留。</p><p><code>Transmitter</code>和<code>Receiver</code>作为核心通信实体，均继承自<code>Endpoint</code>类。这种继承设计使得<code>Transmitter</code>和<code>Receiver</code>天然具备<code>Endpoint</code>类定义的身份标识与运行环境描述功能，从而能够在通信过程中高效支持身份识别、环境适配以及通信管理。</p><h2 id="3-4-通信顶层Transport设计"><a href="#3-4-通信顶层Transport设计" class="headerlink" title="3.4 通信顶层Transport设计"></a>3.4 通信顶层Transport设计</h2><p><code>Transport</code>类被设计为全局单例类。这一设计特性确保了在系统整个生命周期内，<code>Transport</code>类仅维持单一实例。Transport类对外提供了两个核心接口：<code>CreateTransmitter</code>和<code>CreateReceiver</code>，这两者构成了通信中间件系统中创建发布方和订阅方的关键功能实现。<code>CreateTransmitter</code>接口用于生成发布方（<code>Transmitter</code>）实例，其接收两个必要参数：一是<code>RoleAttributes</code>类型的参数，用于精确标识通信实体的身份及环境属性；二是<code>OptionMode</code>类型的参数，用于指定通信模式。根据<code>OptionMode</code>的取值，接口将创建相应的<code>Transmitter</code>实例。具体而言，当<code>OptionMode</code>取值为<code>RTPS</code>时，将实例化一个<code>RTPSTransmitter</code>对象；当<code>OptionMode</code>取值为SHM时，则生成一个<code>ShmTransmitter</code>对象。<code>CreateReceiver</code>接口则负责创建订阅方（Receiver）实例，其参数设计与<code>CreateTransmitter</code>接口类似，同样包含<code>RoleAttributes和OptionMode</code>。此外，该接口还需额外传入一个回调函数，该函数在<code>Receiver</code>接收到数据时被触发，以执行后续的数据处理任务。在C++11编程环境中，通过<code>std::function</code>对回调函数进行封装，从而实现灵活且类型安全的回调机制。</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/17689211085728.png" alt="img"></p><h2 id="3-5-发送-x2F-接收模块设计"><a href="#3-5-发送-x2F-接收模块设计" class="headerlink" title="3.5 发送&#x2F;接收模块设计"></a>3.5 发送&#x2F;接收模块设计</h2><h3 id="3-5-1-Transmitter"><a href="#3-5-1-Transmitter" class="headerlink" title="3.5.1 Transmitter"></a>3.5.1 <code>Transmitter</code></h3><p>在上述通信架构中，<code>Transmitter</code>类继承自Endpoint类，作为发送端的核心组件，其设计主要聚焦于数据发送、序列化、帧序号管理以及通信模式的选择。</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/17689211085729.png" alt="img"></p><p>具体包括以下几个方面：</p><p> （1）抽象化接口：为确保<code>Transmitter</code>能够灵活支持多种通信模式，本文将<code>Transmitter</code>定义为一个抽象模板基类，所有具体通信实现（如基于共享内存的<code>ShmTransmitter</code>或基于<code>FastRTPS的RTPSTransmitter</code>）均继承自该基类。模板参数指定为用户欲传输的数据结构类型，从而实现通用性与灵活性的结合。</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>核心职责</strong></th></tr></thead><tbody><tr><td>Enable()</td><td>激活传输通道</td></tr><tr><td>Disable()</td><td>关闭传输通道，释放资源</td></tr><tr><td>Transmit()</td><td>执行协议相关的消息序列化与发送,子类必须实现传输策略</td></tr></tbody></table><p>（2）帧序号管理：在<code>Transmitter</code>内部定义了一个无符号整型变量<code>seq_num_</code>，用于为每条消息分配唯一的帧序号。这一设计旨在确保消息传输的顺序性，有效防止数据丢失或乱序现象的发生。</p><p>（3）支持消息附加信息：本文设计了<code>msg_info_</code>数据结构，用于存储消息的附加信息。该结构包含三部分关键字段，并提供了对应的获取与设置接口。每条实际发送的消息均附带一条<code>msg_info_</code>实例。<code>Transmitter</code>的构造函数负责对<code>msg_info_</code>进行初始化。</p><table><thead><tr><th><strong>名称</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>seq_num</td><td>uint64_t</td><td>发送数据的帧号</td></tr><tr><td>sender_id</td><td>Identify</td><td>当前Transmitter的id</td></tr><tr><td>channel_id</td><td>uint64_t</td><td>发送的channel</td></tr></tbody></table><h3 id="3-5-2-Receiver"><a href="#3-5-2-Receiver" class="headerlink" title="3.5.2 Receiver"></a>3.5.2 Receiver</h3><p><code>Receiver</code>类作为接收端的核心组件，同样继承<code>Endpoint</code>类，负责处理从<code>Transmitter</code>接收到的消息并进行相应响应。</p><p>为实现消息接收与数据处理的解耦，避免在<code>Receiver</code>内部直接实现复杂的业务逻辑，本文设计了一个统一的C++可调用对象MessageListener。该对象在构造Receiver时作为参数传入，</p><table><thead><tr><th><strong>参数名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>MessagePtr</td><td>指向接收到的消息对象的智能指针</td></tr><tr><td>MessageInfo</td><td>接收到的消息相关的附加信息</td></tr><tr><td>Roleattributes</td><td>前接收端角色的属性</td></tr></tbody></table><p>Receiver的构造函数需接收两个参数：一是RoleAttributes，用于初始化继承自Endpoint类的属性；二是MessageListener，用于初始化Receiver内部维护的回调函数对象msg_listener_。Receiver类定义了三个核心接口</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>核心职责</strong></th></tr></thead><tbody><tr><td>Enable()</td><td>激活接收通道，初始化资源</td></tr><tr><td>Disable()</td><td>关闭接收通道，释放资源</td></tr><tr><td>OnNewMessage(const   MessagePtr&amp;，const MessageInfo&amp;)</td><td>数据回调处理，调用 MessageListener 进行处理</td></tr></tbody></table><p>其中，Enable()和Disable()的实现与Transmitter中类似，需由具体子类根据通信模式重写以确保适配性。OnNewMessage()为Receiver中的数据回调处理方法，每当接收到新消息时，该方法将被触发。它将消息对象（MessagePtr）、消息附加信息（MessageInfo）以及接收端的角色属性（RoleAttributes）传递至msg_listener_，并执行相应的调用操作。</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/176892110857210.png" alt="img"></p><h2 id="3-6-数据分发器设计"><a href="#3-6-数据分发器设计" class="headerlink" title="3.6 数据分发器设计"></a>3.6 数据分发器设计</h2><p>Dispatcher组件的核心功能在于接收Transmitter发送至共享主题的数据，并将其精确分发至对应的Receiver，从而触发相应的回调处理逻辑。为实现这一目标，Dispatcher需具备以下三项关键能力：</p><ul><li>（1）Receiver注册管理：Dispatcher负责管理所有Receiver实例，确保每个Receiver能够正确接收并处理其所订阅的消息。</li><li>（2）消息获取与转发：Dispatcher需从不同共享主题中获取数据，并根据消息内容将其转发至适当的Receiver。</li><li>（3）回调函数触发：在成功获取并转发数据后，Dispatcher需触发与接收数据关联的回调函数，以确保消息得到有效处理。</li></ul><p>基于上述需求，在设计Dispatcher时引入了信号-槽机制。该机制是一种广泛应用于事件驱动系统的设计模式，能够有效解耦组件间的依赖关系，同时保障消息传递与处理的顺畅性。其核心概念包括：</p><ul><li>信号（Signal）：表示事件或数据的发送，通常由发送方（如Transmitter）触发。当数据准备就绪或事件发生时，信号被激活。</li><li>槽（Slot）：表示对信号的响应或处理逻辑，通常由接收方（如Receiver）定义，描述消息或事件的处理方式。</li></ul><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/176892110857211.png" alt="img"></p><p>Slot类内部维护了一个支持可变模板参数包的可调用对象（Callback），并通过布尔变量标记当前槽的激活状态。由于一个信号可被多个槽观察，Signal类内部维护了一个双向链表（SlotList）以存储相关槽</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/176892110857212.png" alt="img"></p><p>每个订阅该信号的槽通过Signal类的Connect函数添加至链表。该函数根据传入的Callback创建并激活新槽，将其插入SlotList，并返回一个表示信号与槽连接关系的Connection对象。Connection类内部包含两个关键变量：槽实例及其所观察的信号。当信号触发时，Signal类通过重载的()操作符遍历SlotList，依次执行各槽中的回调函数，从而实现信号至槽的高效传递。这种设计确保了信号与槽之间的松耦合，同时为异步事件处理提供了灵活且高效的机制。</p><p>通信模型中，一个channel的数据可被多个Receiver订阅。因此，可将一个channel绑定至一个信号，订阅该channel的Receiver则作为槽，通过信号-槽连接将其回调函数注册至信号。当channel接收到数据时，绑定的信号被触发，通知所有关联槽执行相应Receiver的回调函数。为此，设计了ListenerHandler类以管理channel与Signal的绑定关系。此外，信号与槽连接后生成多个Connection实例，ListenerHandler还负责管理这些连接，</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/176892110857213.png" alt="img"></p><p>ListenerHandler维护了一个信号对象MessageSignal以及一个存储多个Connection的映射结构ConnectionMap。每个channel绑定一个独立的MessageSignal，用于管理该channel上所有Receiver的回调函数，而ConnectionMap以Receiver的Identity作为索引存储所有连接信息。当Receiver订阅channel时，ListenerHandler通过Connect方法将Receiver的回调函数注册至MessageSignal，并返回Connection记录该绑定关系；当channel数据到达时，MessageSignal调用Run函数依次触发所有订阅者的回调函数。</p><p>前文已详细阐述了Dispatcher组件的设计逻辑与信号-槽机制的基本架构。以下将进一步探讨Dispatcher的具体实现过程，。Dispatcher被设计为虚基类，旨在提供通用的消息分发机制。然而，由于底层通信方式的差异，数据获取方法需由Dispatcher子类根据具体需求实现。因此，Dispatcher为不同通信协议预留了定制化的数据获取接口。</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/176892110857214.png" alt="img"></p><p>为实现<code>channel</code>与信号的绑定，<code>Dispatcher</code>内部设计了一个名为<code>msg_listeners_</code>的映射结构，用于保存<code>channel</code>与<code>MessageSignal</code>的对应关系。每个<code>channel</code>对应一个<code>ListenerHandler</code>实例，而每个<code>ListenerHandler</code>内部维护其<code>ConnectionMap</code>，通过两级索引机制建立<code>Receiver</code>与<code>channel</code>的订阅关系。<code>Dispatcher</code>的<code>AddListener</code>函数负责建立此二级连接：首先根据传入的<code>channel_id</code>在<code>msg_listeners_</code>中进行索引，若无对应<code>ListenerHandler</code>则创建新实例并建立与<code>channel_id</code>的映射关系；若存在则直接获取对应实例。随后，调用<code>ListenerHandler</code>的<code>Connect</code>方法注册传入的回调函数。</p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-03%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/176892110857215.png" alt="img"></p><p>通过上述两级索引机制，可精确定义Receiver与channel的对应关系。前文提及，基于底层通信方式的差异，Dispatcher派生出两个子类。这些子类额外实现获取channel数据的具体方法，并在数据到达时依据两级索引依次执行所有关联回调函数。</p>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRT源码剖析--02如何学习CyberRT</title>
      <link href="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-02%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0CyberRT/"/>
      <url>/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-02%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0CyberRT/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-cpp前置知识"><a href="#2-1-cpp前置知识" class="headerlink" title="2.1 cpp前置知识"></a>2.1 cpp前置知识</h2><ul><li><p><strong>cpp</strong>基础语法：<a href="https://www.bilibili.com/video/BV1et411b73Z/?spm_id_from=333.337.search-card.all.click&vd_source=1325a6af2d360c06e8e0c5e177802b1b">https://www.bilibili.com/video/BV1et411b73Z/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1325a6af2d360c06e8e0c5e177802b1b</a></p></li><li><p><strong>cpp</strong>进阶</p></li></ul><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-02%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0CyberRT/17689200184145.png" alt="img"></p><ul><li><p><strong>数据结构</strong>：<a href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/">https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/</a></p></li><li><p><strong>cpp11 新特性</strong></p><ul><li>智能指针</li><li>移动语义：<code>std::move</code></li><li>原子变量，CAS操作（无锁同步）</li><li>Lambda表达式 ,<code>std::functon</code>可调用对象</li><li>并发与多线程相关：<code>std::thread, std::mutex, std::lock_guard</code>等</li><li><code>SFINAE</code>特性（模板进阶）”Substitution Failure Is Not An Error”</li></ul></li><li><p><strong>设计模式</strong></p><ul><li>工厂模式</li><li>单例模式</li><li>观察者模式</li></ul></li><li><p><strong>编译链接</strong></p><ul><li>Makefile</li><li>g++&#x2F;gcc 编译</li></ul></li></ul><h2 id="2-2-CyberRT源码文件夹"><a href="#2-2-CyberRT源码文件夹" class="headerlink" title="2.2 CyberRT源码文件夹"></a>2.2 CyberRT源码文件夹</h2><p><strong>第一步：从基础库入手，读懂<strong><strong>源码</strong></strong>并仿写</strong></p><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-02%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0CyberRT/17689200184131.png" alt="img"></p><p><strong>第二步：编译FastRTPS，跑通FastRTPS</strong></p><p>我使用的源码版本为：2.12.0</p><p>文档地址：</p><p><a href="https://fast-dds.docs.eprosima.com/en/2.14.x/notes/previous_versions/previous_versions.html">https://fast-dds.docs.eprosima.com/en/2.14.x/notes/previous_versions/previous_versions.html</a></p><p>编译文档：</p><p><a href="https://fast-dds.docs.eprosima.com/en/2.14.x/installation/binaries/binaries_linux.html">https://fast-dds.docs.eprosima.com/en/2.14.x/installation/binaries/binaries_linux.html</a></p><p>编译安装的过程在上面的官网已经说得十分明白，我在这里说几个编译安装过程中可能遇到的<code>BUG</code></p><ul><li>编译<code>FastDDS</code>所需的<code>Cmake</code>版本较高，请先升级<code>Cmake</code>版本</li><li>在安装<code>Foonathan memory</code>这个库时，可能会出现如下问题<ul><li><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-02%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0CyberRT/17689200184142.png" alt="img"></p></li><li><p>这里是<code>cmake</code>找到了<code>Foonathan memory</code>这个库，从而不会去编译源码，导致安装失败，原因在于如果你的主机里安装了<code>ROS2</code>，<code>ROS2</code>里有<code>Foonathan memory</code>相关的<code>cmake</code>文件，而<code>ROS2</code>里的这个库实际上是个空壳子。为了解决这个问题，只需要在编译<code>Foonathan memory</code>时先去把<code>ROS2</code>的环境变量注释了，一般来说是在<code>.bashrc</code>中，把下面的环境变量注释即可，编译完成后再解除注释</p></li><li><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-02%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0CyberRT/17689200184143.png" alt="img"></p></li></ul></li><li>在编译完成<code>FastDDS</code>后可以去跑一下<code>example</code>下的<code>demo</code>，官方给出的编译方式似乎有点问题，请按照下面这篇博文去做：<ul><li><p><a href="https://bylee.blog.csdn.net/article/details/124705821">【FastDDS学习笔记】HelloWorld示例程序编译和运行_fastdds helloword-CSDN博客</a></p></li><li><p>主要的原因就在：<code>cmake .. -DCMAKE_PREFIX_PATH=~/Fast-DDS/install/</code> 这里<code>Cmake</code>编译时需要加一个路径参数</p></li></ul></li></ul><p><img src="/2026/01/20/CyberRT%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-02%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0CyberRT/17689200184144.gif" alt="img"></p><h2 id="2-3-魔改源码"><a href="#2-3-魔改源码" class="headerlink" title="2.3 魔改源码"></a>2.3 魔改源码</h2><p>我修改后的源码如下：<a href="https://gitee.com/yang_lian/cmw">https://gitee.com/yang_lian/cmw</a></p>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析--01CyberRT是什么</title>
      <link href="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-ROS1-VS-ROS2"><a href="#1-1-ROS1-VS-ROS2" class="headerlink" title="1.1 ROS1 VS ROS2"></a>1.1 ROS1 VS ROS2</h2><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/176891960232011.png" alt="img"></p><ul><li>ROS2 引入了DDS</li><li>ROS1 需要Master节点来管理通信</li></ul><p>发布订阅模型：</p><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/17689196023191.png" alt="img"></p><p><strong>ROS2 软件架构</strong></p><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/17689196023192.png" alt="img"></p><h2 id="1-2-DDS"><a href="#1-2-DDS" class="headerlink" title="1.2 DDS"></a>1.2 DDS</h2><p>Data Distribution Service，也就是数据分发服务，2004年由对象管理组织OMG发布和维护，是一套专门为实时系统设计的数据分发&#x2F;订阅标准：<a href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/library_overview/library_overview.html">https://fast-dds.docs.eprosima.com/en/latest/fastdds/library_overview/library_overview.html</a></p><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/17689196023193.png" alt="img"></p><p>DDS软件架构：</p><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/17689196023194.png" alt="img"></p><p>从上往下分为三个层级：DDS层、RTPS层、Transport层</p><p>可以看见<code>FastDDS</code>现在的架构有四层<code>Application</code>、<code>DDS</code>层、<code>RTPS</code>层<code>Transport</code>层</p><ul><li><code>DDS</code>层是对<code>RTPS</code>层的抽象，可以看见<code>DDS</code>层里有很多角色，如：<code>Publisher</code>、<code>Subscriber</code>、<code>DataWriter</code>、<code>DataReader</code>、<code>Topic</code>、<code>DomainParticipant</code>等，反而搞得很复杂</li><li>而<code>RTPS</code>层相对而言比较清晰简单<code>RTPSWriter</code>用于发送数据，<code>RTPSReader</code>用于读取数据，<code>RTPSParticipant</code>用于区分不同进程</li><li><code>Transport</code>层则为底层通信实现，可以看见它支持<code>udp</code>、<code>tcp</code>、<code>shm</code>三种通信方式</li></ul><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/17689196023195.png" alt="img"></p><ul><li><code>FastDDS</code>的早期版本其实不叫<code>FastDDS</code>，而是直接叫<code>Fast-Rtps</code>，意味着早期并没有实现<code>DDS</code>协议，并且不支持<code>shm</code>，只支持网络通信，<code>CyberRt</code>使用的就是以前这种只支持网络通信的版本作为不同主机之间的通讯协议，因此对于同主机之间不同进程的通信，<code>CyberRt</code>内部自己实现了基于共享内存的通信方式。</li></ul><p>FastRTPS官网：<a href="https://fast-rtps.docs.eprosima.com/en/v1.9.4/introduction.html">https://fast-rtps.docs.eprosima.com/en/v1.9.4/introduction.html</a></p><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/17689196023196.png" alt="img"></p><h2 id="1-3-CyberRT"><a href="#1-3-CyberRT" class="headerlink" title="1.3 CyberRT"></a>1.3 CyberRT</h2><p>源码地址：<a href="https://github.com/storypku/CyberRT">https://github.com/storypku/CyberRT</a></p><p>源码层级：</p><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/17689196023197.png" alt="img"></p><p>CyberRT软件架构：</p><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/17689196023198.png" alt="img"></p><p>数据传输： 在一个分布式计算系统中，根据两个节点间的位置关系需要使用不同的传输方式 - INTRA：如果是同进程的，因为在同一地址空间，直接传指针就完了。 - SHM(Shared memory)：如果是同一机器上，但跨进程的，为了高效可以使用共享内存。 - RTPS：如果是跨设备的，那就老老实实通过网络传吧。 - HYBRID: 框架需要根据节点间关系选择合适的传输后端。</p><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/17689196023209.png" alt="img"></p><p>源码架构：</p><p><img src="/2026/01/20/CyberRT%E5%89%96%E6%9E%90-01CyberRT%E6%98%AF%E4%BB%80%E4%B9%88/176891960232010.png" alt="img"></p><p>可以把CyberRT拆分为两个部分</p><ul><li>分布式通信 </li><li>协程计算框架</li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核启动流程分析</title>
      <link href="/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核启动流程分析"><a href="#Linux内核启动流程分析" class="headerlink" title="Linux内核启动流程分析"></a>Linux内核启动流程分析</h1><p>我在学习Linux驱动的时候总感觉蒙着一层雾，让我看不清Linux内核的核心，Linux内核有很多子系统，我觉得有必要先从<code>Linux Kernel</code>的启动去宏观的看一下各个子系统是哪个时刻被启动的，我主要以<code>ARM64</code>为例子来分析Linux 内核的启动流程。我们知道在<code>Linux</code>内核启动之前是<code>uboot</code>，<code>uboot</code>会做一些初始化工作，如初始化ddr，我使用的内核源码为迅为电子提供的<code>RK3588</code>的<code>linux SDK</code>，内核版本为<code>5.10.198</code></p><h2 id="1-内核链接文件"><a href="#1-内核链接文件" class="headerlink" title="1. 内核链接文件"></a>1. 内核链接文件</h2><p>​内核编译后生成的目标文件是ELF格式的vmlinux，vmlinux文件是各个源代码按照<code>vmlinux.lds</code>设定的规则，链接后得到的Object文件，并不是一个可执行的文件，不能在ARM平台上运行；通常会对其压缩，生成zImage或bzImage；通常内核映像以压缩格式存储，并不是一个可执行的内核；因此内核阶段需要先对内核映像自解压，他们的文件头部打包有解压缩程序</p><p>​<code>Linux</code>内核的链接文件目录在<code>arch/arm64/kernel/vmlinux.lds.S</code>，内核在编译时会根据<code>vmlinux.lds.S</code>生成<code>vmlinux.lds</code>，<code>vmlinux.lds</code>就是内核最后的链接脚本，会用于链接生成内核镜像<code>vmlinux</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//arch/arm64/kernel/vmlinux.lds.S</span><br><span class="line">/* SPDX-License-Identifier: GPL-2.0 */</span><br><span class="line">/*</span><br><span class="line"> * ld script to make ARM Linux kernel</span><br><span class="line"> * taken from the i386 version by Russell King</span><br><span class="line"> * Written by Martin Mares &lt;mj@atrey.karlin.mff.cuni.cz&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;asm-generic/vmlinux.lds.h&gt;</span><br><span class="line">#include &lt;asm/cache.h&gt;</span><br><span class="line">#include &lt;asm/kernel-pgtable.h&gt;</span><br><span class="line">#include &lt;asm/thread_info.h&gt;</span><br><span class="line">#include &lt;asm/memory.h&gt;</span><br><span class="line">#include &lt;asm/page.h&gt;</span><br><span class="line">#include &lt;asm/pgtable.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;image.h&quot;</span><br><span class="line"></span><br><span class="line">/* .exit.text needed in case of alternative patching */</span><br><span class="line">#define ARM_EXIT_KEEP(x)x</span><br><span class="line">#define ARM_EXIT_DISCARD(x)</span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_text)</span><br><span class="line"></span><br><span class="line">jiffies = jiffies_64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define HYPERVISOR_EXTABLE\</span><br><span class="line">. = ALIGN(SZ_8);\</span><br><span class="line">__start___kvm_ex_table = .;\</span><br><span class="line">*(__kvm_ex_table)\</span><br><span class="line">__stop___kvm_ex_table = .;</span><br><span class="line"></span><br><span class="line">#define HYPERVISOR_TEXT\</span><br><span class="line">/*\</span><br><span class="line"> * Align to 4 KB so that\</span><br><span class="line"> * a) the HYP vector table is at its minimum\</span><br><span class="line"> *    alignment of 2048 bytes\</span><br><span class="line"> * b) the HYP init code will not cross a page\</span><br><span class="line"> *    boundary if its size does not exceed\</span><br><span class="line"> *    4 KB (see related ASSERT() below)\</span><br><span class="line"> */\</span><br><span class="line">. = ALIGN(SZ_4K);\</span><br><span class="line">__hyp_idmap_text_start = .;\</span><br><span class="line">*(.hyp.idmap.text)\</span><br><span class="line">__hyp_idmap_text_end = .;\</span><br><span class="line">__hyp_text_start = .;\</span><br><span class="line">*(.hyp.text)\</span><br><span class="line">HYPERVISOR_EXTABLE\</span><br><span class="line">__hyp_text_end = .;</span><br><span class="line"></span><br><span class="line">#define IDMAP_TEXT\</span><br><span class="line">. = ALIGN(SZ_4K);\</span><br><span class="line">__idmap_text_start = .;\</span><br><span class="line">*(.idmap.text)\</span><br><span class="line">__idmap_text_end = .;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_HIBERNATION</span><br><span class="line">#define HIBERNATE_TEXT\</span><br><span class="line">. = ALIGN(SZ_4K);\</span><br><span class="line">__hibernate_exit_text_start = .;\</span><br><span class="line">*(.hibernate_exit.text)\</span><br><span class="line">__hibernate_exit_text_end = .;</span><br><span class="line">#else</span><br><span class="line">#define HIBERNATE_TEXT</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span><br><span class="line">#define TRAMP_TEXT\</span><br><span class="line">. = ALIGN(PAGE_SIZE);\</span><br><span class="line">__entry_tramp_text_start = .;\</span><br><span class="line">*(.entry.tramp.text)\</span><br><span class="line">. = ALIGN(PAGE_SIZE);\</span><br><span class="line">__entry_tramp_text_end = .;</span><br><span class="line">#else</span><br><span class="line">#define TRAMP_TEXT</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The size of the PE/COFF section that covers the kernel image, which</span><br><span class="line"> * runs from stext to _edata, must be a round multiple of the PE/COFF</span><br><span class="line"> * FileAlignment, which we set to its minimum value of 0x200. &#x27;stext&#x27;</span><br><span class="line"> * itself is 4 KB aligned, so padding out _edata to a 0x200 aligned</span><br><span class="line"> * boundary should be sufficient.</span><br><span class="line"> */</span><br><span class="line">PECOFF_FILE_ALIGNMENT = 0x200;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">#define PECOFF_EDATA_PADDING\</span><br><span class="line">.pecoff_edata_padding : &#123; BYTE(0); . = ALIGN(PECOFF_FILE_ALIGNMENT); &#125;</span><br><span class="line">#else</span><br><span class="line">#define PECOFF_EDATA_PADDING</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line"> * XXX: The linker does not define how output sections are</span><br><span class="line"> * assigned to input sections when there are multiple statements</span><br><span class="line"> * matching the same input section name.  There is no documented</span><br><span class="line"> * order of matching.</span><br><span class="line"> */</span><br><span class="line">/DISCARD/ : &#123;</span><br><span class="line">ARM_EXIT_DISCARD(EXIT_TEXT)</span><br><span class="line">ARM_EXIT_DISCARD(EXIT_DATA)</span><br><span class="line">EXIT_CALL</span><br><span class="line">*(.discard)</span><br><span class="line">*(.discard.*)</span><br><span class="line">*(.interp .dynamic)</span><br><span class="line">*(.dynsym .dynstr .hash .gnu.hash)</span><br><span class="line">*(.eh_frame)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = KIMAGE_VADDR + TEXT_OFFSET;</span><br><span class="line"></span><br><span class="line">.head.text : &#123;</span><br><span class="line">_text = .;</span><br><span class="line">HEAD_TEXT</span><br><span class="line">&#125;</span><br><span class="line">.text : &#123;/* Real text segment*/</span><br><span class="line">_stext = .;/* Text and read-only data*/</span><br><span class="line">__exception_text_start = .;</span><br><span class="line">*(.exception.text)</span><br><span class="line">__exception_text_end = .;</span><br><span class="line">IRQENTRY_TEXT</span><br><span class="line">SOFTIRQENTRY_TEXT</span><br><span class="line">ENTRY_TEXT</span><br><span class="line">TEXT_TEXT</span><br><span class="line">SCHED_TEXT</span><br><span class="line">CPUIDLE_TEXT</span><br><span class="line">LOCK_TEXT</span><br><span class="line">KPROBES_TEXT</span><br><span class="line">HYPERVISOR_TEXT</span><br><span class="line">IDMAP_TEXT</span><br><span class="line">HIBERNATE_TEXT</span><br><span class="line">TRAMP_TEXT</span><br><span class="line">*(.fixup)</span><br><span class="line">*(.gnu.warning)</span><br><span class="line">. = ALIGN(16);</span><br><span class="line">*(.got)/* Global offset table*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">_etext = .;/* End of text section */</span><br><span class="line"></span><br><span class="line">RO_DATA(PAGE_SIZE)/* everything from this point to     */</span><br><span class="line">EXCEPTION_TABLE(8)/* __init_begin will be marked RO NX */</span><br><span class="line">NOTES</span><br><span class="line"></span><br><span class="line">. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">__init_begin = .;</span><br><span class="line">__inittext_begin = .;</span><br><span class="line"></span><br><span class="line">INIT_TEXT_SECTION(8)</span><br><span class="line">.exit.text : &#123;</span><br><span class="line">ARM_EXIT_KEEP(EXIT_TEXT)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = ALIGN(4);</span><br><span class="line">.altinstructions : &#123;</span><br><span class="line">__alt_instructions = .;</span><br><span class="line">*(.altinstructions)</span><br><span class="line">__alt_instructions_end = .;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = ALIGN(PAGE_SIZE);</span><br><span class="line">__inittext_end = .;</span><br><span class="line">__initdata_begin = .;</span><br><span class="line"></span><br><span class="line">.init.data : &#123;</span><br><span class="line">INIT_DATA</span><br><span class="line">INIT_SETUP(16)</span><br><span class="line">INIT_CALLS</span><br><span class="line">CON_INITCALL</span><br><span class="line">SECURITY_INITCALL</span><br><span class="line">INIT_RAM_FS</span><br><span class="line">*(.init.rodata.* .init.bss)/* from the EFI stub */</span><br><span class="line">&#125;</span><br><span class="line">.exit.data : &#123;</span><br><span class="line">ARM_EXIT_KEEP(EXIT_DATA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PERCPU_SECTION(L1_CACHE_BYTES)</span><br><span class="line"></span><br><span class="line">.rela.dyn : ALIGN(8) &#123;</span><br><span class="line">*(.rela .rela*)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__rela_offset= ABSOLUTE(ADDR(.rela.dyn) - KIMAGE_VADDR);</span><br><span class="line">__rela_size= SIZEOF(.rela.dyn);</span><br><span class="line"></span><br><span class="line">. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">__initdata_end = .;</span><br><span class="line">__init_end = .;</span><br><span class="line"></span><br><span class="line">_data = .;</span><br><span class="line">_sdata = .;</span><br><span class="line">RW_DATA_SECTION(L1_CACHE_BYTES, PAGE_SIZE, THREAD_ALIGN)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Data written with the MMU off but read with the MMU on requires</span><br><span class="line"> * cache lines to be invalidated, discarding up to a Cache Writeback</span><br><span class="line"> * Granule (CWG) of data from the cache. Keep the section that</span><br><span class="line"> * requires this type of maintenance to be in its own Cache Writeback</span><br><span class="line"> * Granule (CWG) area so the cache maintenance operations don&#x27;t</span><br><span class="line"> * interfere with adjacent data.</span><br><span class="line"> */</span><br><span class="line">.mmuoff.data.write : ALIGN(SZ_2K) &#123;</span><br><span class="line">__mmuoff_data_start = .;</span><br><span class="line">*(.mmuoff.data.write)</span><br><span class="line">&#125;</span><br><span class="line">. = ALIGN(SZ_2K);</span><br><span class="line">.mmuoff.data.read : &#123;</span><br><span class="line">*(.mmuoff.data.read)</span><br><span class="line">__mmuoff_data_end = .;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PECOFF_EDATA_PADDING</span><br><span class="line">__pecoff_data_rawsize = ABSOLUTE(. - __initdata_begin);</span><br><span class="line">_edata = .;</span><br><span class="line"></span><br><span class="line">BSS_SECTION(0, 0, 0)</span><br><span class="line"></span><br><span class="line">. = ALIGN(PAGE_SIZE);</span><br><span class="line">idmap_pg_dir = .;</span><br><span class="line">. += IDMAP_DIR_SIZE;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span><br><span class="line">tramp_pg_dir = .;</span><br><span class="line">. += PAGE_SIZE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_SW_TTBR0_PAN</span><br><span class="line">reserved_ttbr0 = .;</span><br><span class="line">. += RESERVED_TTBR0_SIZE;</span><br><span class="line">#endif</span><br><span class="line">swapper_pg_dir = .;</span><br><span class="line">. += SWAPPER_DIR_SIZE;</span><br><span class="line">swapper_pg_end = .;</span><br><span class="line"></span><br><span class="line">__pecoff_data_size = ABSOLUTE(. - __initdata_begin);</span><br><span class="line">_end = .;</span><br><span class="line"></span><br><span class="line">STABS_DEBUG</span><br><span class="line"></span><br><span class="line">HEAD_SYMBOLS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The HYP init code and ID map text can&#x27;t be longer than a page each,</span><br><span class="line"> * and should not cross a page boundary.</span><br><span class="line"> */</span><br><span class="line">ASSERT(__hyp_idmap_text_end - (__hyp_idmap_text_start &amp; ~(SZ_4K - 1)) &lt;= SZ_4K,</span><br><span class="line">&quot;HYP init code too big or misaligned&quot;)</span><br><span class="line">ASSERT(__idmap_text_end - (__idmap_text_start &amp; ~(SZ_4K - 1)) &lt;= SZ_4K,</span><br><span class="line">&quot;ID map text too big or misaligned&quot;)</span><br><span class="line">#ifdef CONFIG_HIBERNATION</span><br><span class="line">ASSERT(__hibernate_exit_text_end - (__hibernate_exit_text_start &amp; ~(SZ_4K - 1))</span><br><span class="line">&lt;= SZ_4K, &quot;Hibernate exit text too big or misaligned&quot;)</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span><br><span class="line">ASSERT((__entry_tramp_text_end - __entry_tramp_text_start) == PAGE_SIZE,</span><br><span class="line">&quot;Entry trampoline text too big&quot;)</span><br><span class="line">#endif</span><br><span class="line">/*</span><br><span class="line"> * If padding is applied before .head.text, virt&lt;-&gt;phys conversions will fail.</span><br><span class="line"> */</span><br><span class="line">ASSERT(_text == (KIMAGE_VADDR + TEXT_OFFSET), &quot;HEAD is misaligned&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>在此文件的开头指定了输出的架构以及内核入口地址为<code>_text</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_text)</span><br></pre></td></tr></table></figure></li><li><p><code>_text</code>是代码段的起始地址，定义在下面的<code>SECTIONS</code>部分，可以看见<code>_text</code>即为<code>.head_text</code>段，地址为：</p><p><code>KIMAGE_VADDR + TEXT_OFFSET</code>，这两个宏定义在<code>arch/arm64/include/asm/memory.h</code>中</p><p><img src="/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20240607140937077.png" alt="image-20240607140937077"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">. = KIMAGE_VADDR + TEXT_OFFSET;</span><br><span class="line"></span><br><span class="line">.head.text : &#123;</span><br><span class="line">_text = .;</span><br><span class="line">HEAD_TEXT</span><br><span class="line">&#125;</span><br><span class="line">.text : &#123;/* Real text segment*/</span><br><span class="line">_stext = .;/* Text and read-only data*/</span><br><span class="line">__exception_text_start = .;</span><br><span class="line">*(.exception.text)</span><br><span class="line">__exception_text_end = .;</span><br><span class="line">IRQENTRY_TEXT</span><br><span class="line">SOFTIRQENTRY_TEXT</span><br><span class="line">ENTRY_TEXT</span><br><span class="line">TEXT_TEXT</span><br><span class="line">SCHED_TEXT</span><br><span class="line">CPUIDLE_TEXT</span><br><span class="line">LOCK_TEXT</span><br><span class="line">KPROBES_TEXT</span><br><span class="line">HYPERVISOR_TEXT</span><br><span class="line">IDMAP_TEXT</span><br><span class="line">HIBERNATE_TEXT</span><br><span class="line">TRAMP_TEXT</span><br><span class="line">*(.fixup)</span><br><span class="line">*(.gnu.warning)</span><br><span class="line">. = ALIGN(16);</span><br><span class="line">*(.got)/* Global offset table*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-内核启动第一阶段"><a href="#2-内核启动第一阶段" class="headerlink" title="2. 内核启动第一阶段"></a>2. 内核启动第一阶段</h2><h3 id="2-1-内核启动入口点"><a href="#2-1-内核启动入口点" class="headerlink" title="2.1 内核启动入口点"></a>2.1 内核启动入口点</h3><p>我手上有一块迅为的RK3588的板子，我们来将编译好的<code>vmlinux</code>的<code>elf</code>文件读一下看一下入口地址是多少：</p><p><img src="/2024/06/07/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20240607141148612.png" alt="image-20240607141148612"></p><p>使用迅为提供的编译器将其反汇编，在得到的汇编文件<code>vmlinux.s</code>中查找入口地址：<code>0xffffffc008000000</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmlinux:     file format elf64-littleaarch64</span><br><span class="line">vmlinux</span><br><span class="line">architecture: aarch64, flags 0x00000150:</span><br><span class="line">HAS_SYMS, DYNAMIC, D_PAGED</span><br><span class="line">start address 0xffffffc008000000</span><br><span class="line"></span><br><span class="line">Disassembly of section .head.text:</span><br><span class="line"></span><br><span class="line">ffffffc008000000 &lt;_text&gt;:</span><br><span class="line">ffffffc008000000:91005a4d addx13, x18, #0x16</span><br><span class="line">ffffffc008000004:146c7fff bffffffc009b20000 &lt;primary_entry&gt;</span><br></pre></td></tr></table></figure><p>由上面的反汇编文件可知，<code>Linux</code>内核的第一条指令是<code>add x13, x18, #0x16</code>，对应的符号是<code>.head.text</code>，在<code>include/linux/init.h</code>中有如下定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* For assembly routines */</span><br><span class="line">#define __HEAD.section&quot;.head.text&quot;,&quot;ax&quot;</span><br><span class="line">#define __INIT.section&quot;.init.text&quot;,&quot;ax&quot;</span><br></pre></td></tr></table></figure><p>即<code>__HEAD</code>这个宏代表的就是<code>.head.text</code>这个段，所以去寻找<code>__HEAD</code>这个宏看哪里使用了，在<code>arch/arm64/kernel/head.S</code>中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Kernel startup entry point.</span><br><span class="line"> * ---------------------------</span><br><span class="line"> *</span><br><span class="line"> * The requirements are:</span><br><span class="line"> *   MMU = off, D-cache = off, I-cache = on or off,</span><br><span class="line"> *   x0 = physical address to the FDT blob.</span><br><span class="line"> *</span><br><span class="line"> * This code is mostly position independent so you call this at</span><br><span class="line"> * __pa(PAGE_OFFSET).</span><br><span class="line"> *</span><br><span class="line"> * Note that the callee-saved registers are used for storing variables</span><br><span class="line"> * that are useful before the MMU is enabled. The allocations are described</span><br><span class="line"> * in the entry routines.</span><br><span class="line"> */</span><br><span class="line">__HEAD</span><br><span class="line">_head:</span><br><span class="line">/*</span><br><span class="line"> * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span><br><span class="line"> */</span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">/*</span><br><span class="line"> * This add instruction has no meaningful effect except that</span><br><span class="line"> * its opcode forms the magic &quot;MZ&quot; signature required by UEFI.</span><br><span class="line"> */</span><br><span class="line">addx13, x18, #0x16</span><br><span class="line">bprimary_entry</span><br><span class="line">#else</span><br><span class="line">bprimary_entry// branch to kernel start, magic</span><br><span class="line">.long0// reserved</span><br><span class="line">#endif</span><br><span class="line">.quad0// Image load offset from start of RAM, little-endian</span><br><span class="line">le64sym_kernel_size_le// Effective size of kernel image, little-endian</span><br><span class="line">le64sym_kernel_flags_le// Informative flags, little-endian</span><br><span class="line">.quad0// reserved</span><br><span class="line">.quad0// reserved</span><br><span class="line">.quad0// reserved</span><br><span class="line">.asciiARM64_IMAGE_MAGIC// Magic number</span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">.longpe_header - _head// Offset to the PE header.</span><br><span class="line"></span><br><span class="line">pe_header:</span><br><span class="line">__EFI_PE_HEADER</span><br><span class="line">#else</span><br><span class="line">.long0// reserved</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这里就是内核的启动点，在上面的注释中说了<code>linux</code>内核启动之前需要关闭<code>MMU</code>以及<code>D-cache</code>，<code>I-cache</code>可以开启或者关闭，同时<code>x0</code>为<code>FDT blob</code>的物理地址</p><ul><li><code>D-cache</code>是数据缓存</li><li><code>I-cache</code>是指令缓存</li><li><code>FDT </code>是<code>uboot</code>使用的扁平设备树，flatted device tree，</li></ul><blockquote><p>数据缓存有可能缓存了bootloader的数据，如果不清除，可能导致内核访问错误的数据。而bootloader的指令与内核指令无关，所以可以不关闭指令缓存。</p></blockquote><p><code>add x13, x18, #0x16</code> 用于形成 “MZ” 签名。主要是为了满足 UEFI 固件对映像文件格式的要求，而不是为了执行任何有意义的计算。其作用是确保生成的机器码包含必要的 “MZ” 签名，使得内核映像可以被 UEFI 识别和启动。相当于一个魔数。然后执行<code>bprimary_entry</code>跳转到<code>primary_entry</code>函数执行：</p><h3 id="2-2-primary-entry函数"><a href="#2-2-primary-entry函数" class="headerlink" title="2.2 primary_entry函数"></a>2.2 primary_entry函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__INIT</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The following callee saved general purpose registers are used on the</span><br><span class="line"> * primary lowlevel boot path:</span><br><span class="line"> *</span><br><span class="line"> *  Register   Scope                      Purpose</span><br><span class="line"> *  x21        primary_entry() .. start_kernel()        FDT pointer passed at boot in x0</span><br><span class="line"> *  x23        primary_entry() .. start_kernel()        physical misalignment/KASLR offset</span><br><span class="line"> *  x28        __create_page_tables()                   callee preserved temp register</span><br><span class="line"> *  x19/x20    __primary_switch()                       callee preserved temp registers</span><br><span class="line"> *  x24        __primary_switch() .. relocate_kernel()  current RELR displacement</span><br><span class="line"> */</span><br><span class="line">SYM_CODE_START(primary_entry)</span><br><span class="line">blpreserve_boot_args</span><br><span class="line">blinit_kernel_el// w0=cpu_boot_mode</span><br><span class="line">adrpx23, __PHYS_OFFSET</span><br><span class="line">andx23, x23, MIN_KIMG_ALIGN - 1// KASLR offset, defaults to 0</span><br><span class="line">blset_cpu_boot_mode_flag</span><br><span class="line">bl__create_page_tables</span><br><span class="line">/*</span><br><span class="line"> * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span><br><span class="line"> * details.</span><br><span class="line"> * On return, the CPU will be ready for the MMU to be turned on and</span><br><span class="line"> * the TCR will have been set.</span><br><span class="line"> */</span><br><span class="line">bl__cpu_setup// initialise processor</span><br><span class="line">b__primary_switch</span><br><span class="line">SYM_CODE_END(primary_entry)</span><br></pre></td></tr></table></figure><p><code>primary_entry</code>会依次执行<code>preserve_boot_args</code>、<code>init_kernel_el</code>、<code>set_cpu_boot_mode_flag</code>、<code>__create_page_tables</code>、<code>__cpu_setup</code>、<code>__primary_switch</code></p><h4 id="2-2-1-preserve-boot-args"><a href="#2-2-1-preserve-boot-args" class="headerlink" title="2.2.1 preserve_boot_args"></a>2.2.1 preserve_boot_args</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Preserve the arguments passed by the bootloader in x0 .. x3</span><br><span class="line"> */</span><br><span class="line">SYM_CODE_START_LOCAL(preserve_boot_args)</span><br><span class="line">movx21, x0// x21=FDT，// 将dtb的地址暂存在x21寄存器，释放出x0使用</span><br><span class="line"></span><br><span class="line">adr_lx0, boot_args// 将boot_args数组的地址保存到x0中</span><br><span class="line">stpx21, x1, [x0]// 保存x21、x1的值到boot_args[0]、boot_args[1]</span><br><span class="line">stpx2, x3, [x0, #16]       // 将x2、x3的值保存到boot_args[2]、boot_args[3</span><br><span class="line"></span><br><span class="line">dmbsy// needed before dc ivac with 内存屏障</span><br><span class="line">// MMU off</span><br><span class="line"></span><br><span class="line">movx1, #0x20// 4 x 8 bytes  x1 = 32</span><br><span class="line">b__inval_dcache_area// tail call 无效化数据缓存区域</span><br><span class="line">SYM_CODE_END(preserve_boot_args)</span><br></pre></td></tr></table></figure><ul><li><p><code>boot_args</code>定义在<code>arch/arm64/setup.c</code>中，用于保存内核启动时的参数，是一个数组</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The recorded values of x0 .. x3 upon kernel entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u64 __cacheline_aligned boot_args[<span class="number">4</span>];</span><br></pre></td></tr></table></figure></li><li><p><code>stp</code> 是一个存储配对指令，将两个寄存器的值存储到连续的内存位置。</p></li></ul><h4 id="2-2-2-init-kernel-el"><a href="#2-2-2-init-kernel-el" class="headerlink" title="2.2.2 init_kernel_el"></a>2.2.2 init_kernel_el</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Starting from EL2 or EL1, configure the CPU to execute at the highest</span><br><span class="line"> * reachable EL supported by the kernel in a chosen default state. If dropping</span><br><span class="line"> * from EL2 to EL1, configure EL2 before configuring EL1.</span><br><span class="line"> *</span><br><span class="line"> * Since we cannot always rely on ERET synchronizing writes to sysregs (e.g. if</span><br><span class="line"> * SCTLR_ELx.EOS is clear), we place an ISB prior to ERET.</span><br><span class="line"> *</span><br><span class="line"> * Returns either BOOT_CPU_MODE_EL1 or BOOT_CPU_MODE_EL2 in w0 if</span><br><span class="line"> * booted in EL1 or EL2 respectively.</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START(init_kernel_el)</span><br><span class="line">mov_qx0, INIT_SCTLR_EL1_MMU_OFF  #将 INIT_SCTLR_EL1_MMU_OFF 常量加载到寄存器 x0 中</span><br><span class="line">msrsctlr_el1, x0    #将寄存器 x0 的值写入 sctlr_el1 寄存器，配置 EL1 的系统控制寄存器。</span><br><span class="line"></span><br><span class="line">mrsx0, CurrentEL    # 读取当前的异常级别（EL）到寄存器 x0 中。</span><br><span class="line">cmpx0, #CurrentEL_EL2  #比较当前 EL 是否为 EL2。</span><br><span class="line">b.eqinit_el2      #如果当前EL是EL2，则跳转到 init_el2 标签。</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(init_el1, SYM_L_LOCAL)</span><br><span class="line">isb</span><br><span class="line">mov_qx0, INIT_PSTATE_EL1 #将INIT_PSTATE_EL1常量加载到寄存器x0中，这个常量用于初始化 PSTATE 寄存器。</span><br><span class="line">msrspsr_el1, x0#将寄存器x0的值写入spsr_el1寄存器，配置EL1的Saved Program Status Register。</span><br><span class="line">msrelr_el1, lr #将链接寄存器（lr）的值写入 elr_el1 寄存器，配置 EL1 的 Exception Link Register。</span><br><span class="line">movw0, #BOOT_CPU_MODE_EL1 #将 BOOT_CPU_MODE_EL1 常量加载到寄存器 w0 中，表示当前的 CPU 模式为 EL1。</span><br><span class="line">eret</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(init_el2, SYM_L_LOCAL)</span><br><span class="line">mov_qx0, HCR_HOST_NVHE_FLAGS #将 HCR_HOST_NVHE_FLAGS 常量加载到寄存器 x0 中，用于配置 EL2 的 Hypervisor Configuration Register。</span><br><span class="line">msrhcr_el2, x0 #将寄存器 x0 的值写入 hcr_el2 寄存器。</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">init_el2_state</span><br><span class="line"></span><br><span class="line">/* Hypervisor stub */</span><br><span class="line">adr_lx0, __hyp_stub_vectors #使用 adr_l 宏将 __hyp_stub_vectors 的地址加载到寄存器 x0 中。__hyp_stub_vectors 是 EL2 的异常向量表地址。</span><br><span class="line">msrvbar_el2, x0 #将寄存器 x0 的值写入 vbar_el2 寄存器，设置 EL2 的向量基址寄存器。</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">msrelr_el2, lr #将链接寄存器（lr）的值写入 elr_el2 寄存器，配置 EL2 的 Exception Link Register。</span><br><span class="line">movw0, #BOOT_CPU_MODE_EL2  #将 BOOT_CPU_MODE_EL2 常量加载到寄存器 w0 中，表示当前的 CPU 模式为 EL2。</span><br><span class="line">eret</span><br><span class="line">SYM_FUNC_END(init_kernel_el)</span><br><span class="line"></span><br><span class="line">//arch/arm64/include/asm/virt.h</span><br><span class="line">#define BOOT_CPU_MODE_EL1(0xe11)</span><br><span class="line">#define BOOT_CPU_MODE_EL2(0xe12)</span><br></pre></td></tr></table></figure><p>这段代码实现了在不同异常级别（EL2 或 EL1）下对处理器进行初始化，并根据当前的启动级别设置相应的寄存器和状态，以便内核能够正确执行。主要步骤包括：</p><ol><li><strong>配置 EL1 的系统控制寄存器</strong>。</li><li><strong>检查当前异常级别</strong>。</li><li><strong>如果是 EL1</strong><ul><li>配置 PSTATE 和异常链接寄存器。</li><li>切换到 EL1 并继续执行。</li></ul></li><li><strong>如果是 EL2</strong><ul><li>配置 Hypervisor Configuration Register。</li><li>进一步初始化 EL2 状态。</li><li>设置异常向量基址。</li><li>切换到 EL2 并继续执行</li></ul></li></ol><h4 id="2-2-3-set-cpu-boot-mode-flag"><a href="#2-2-3-set-cpu-boot-mode-flag" class="headerlink" title="2.2.3 set_cpu_boot_mode_flag"></a>2.2.3 set_cpu_boot_mode_flag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Sets the __boot_cpu_mode flag depending on the CPU boot mode passed</span><br><span class="line"> * in w0. See arch/arm64/include/asm/virt.h for more info.</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(set_cpu_boot_mode_flag)</span><br><span class="line">adr_lx1, __boot_cpu_mode #将 __boot_cpu_mode 的地址加载到寄存器 x1 中</span><br><span class="line">cmpw0, #BOOT_CPU_MODE_EL2  #如果为不为EL2则跳转到标签1处</span><br><span class="line">b.ne1f</span><br><span class="line">addx1, x1, #4  #如果 w0 中的值等于 BOOT_CPU_MODE_EL2，则将 x1（即 __boot_cpu_mode 的地址）加上 4，以指向下一个 4 字节对齐的位置。</span><br><span class="line">1:strw0, [x1]// 将寄存器 w0 的值存储到内存地址 x1 指向的位置</span><br><span class="line">dmbsy</span><br><span class="line">dcivac, x1// Invalidate potentially stale cache line</span><br><span class="line">ret</span><br><span class="line">SYM_FUNC_END(set_cpu_boot_mode_flag)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * We need to find out the CPU boot mode long after boot, so we need to</span><br><span class="line"> * store it in a writable variable.</span><br><span class="line"> *</span><br><span class="line"> * This is not in .bss, because we set it sufficiently early that the boot-time</span><br><span class="line"> * zeroing of .bss would clobber it.</span><br><span class="line"> */</span><br><span class="line">SYM_DATA_START(__boot_cpu_mode)</span><br><span class="line">.longBOOT_CPU_MODE_EL2</span><br><span class="line">.longBOOT_CPU_MODE_EL1</span><br><span class="line">SYM_DATA_END(__boot_cpu_mode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//arch/arm64/include/asm/virt.h</span><br><span class="line">#define BOOT_CPU_MODE_EL1(0xe11)</span><br><span class="line">#define BOOT_CPU_MODE_EL2(0xe12)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>w0</code>寄存器保存了cpu的启动模式</li><li><code>__boot_cpu_mode</code>是一个<code>int64</code>的全局变量保存cpu的启动模式，前面四个字节的值为<code>0xe11</code>，后面四个字节的值为<code>0xe12</code></li></ul><h4 id="2-2-4-create-page-tables"><a href="#2-2-4-create-page-tables" class="headerlink" title="2.2.4 __create_page_tables"></a>2.2.4 __create_page_tables</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Setup the initial page tables. We only setup the barest amount which is</span><br><span class="line"> * required to get the kernel running. The following sections are required:</span><br><span class="line"> *   - identity mapping to enable the MMU (low address, TTBR0)</span><br><span class="line"> *   - first few MB of the kernel linear mapping to jump to once the MMU has</span><br><span class="line"> *     been enabled</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(__create_page_tables)</span><br><span class="line">movx28, lr</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Invalidate the init page tables to avoid potential dirty cache lines</span><br><span class="line"> * being evicted. Other page tables are allocated in rodata as part of</span><br><span class="line"> * the kernel image, and thus are clean to the PoC per the boot</span><br><span class="line"> * protocol.</span><br><span class="line"> */</span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">adrpx1, init_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Clear the init page tables.</span><br><span class="line"> */</span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">adrpx1, init_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">1:stpxzr, xzr, [x0], #16</span><br><span class="line">stpxzr, xzr, [x0], #16</span><br><span class="line">stpxzr, xzr, [x0], #16</span><br><span class="line">stpxzr, xzr, [x0], #16</span><br><span class="line">subsx1, x1, #64</span><br><span class="line">b.ne1b</span><br><span class="line"></span><br><span class="line">movx7, SWAPPER_MM_MMUFLAGS</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Create the identity mapping.</span><br><span class="line"> */</span><br><span class="line">adrpx0, idmap_pg_dir</span><br><span class="line">adrpx3, __idmap_text_start// __pa(__idmap_text_start)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_VA_BITS_52</span><br><span class="line">mrs_sx6, SYS_ID_AA64MMFR2_EL1</span><br><span class="line">andx6, x6, #(0xf &lt;&lt; ID_AA64MMFR2_LVA_SHIFT)</span><br><span class="line">movx5, #52</span><br><span class="line">cbnzx6, 1f</span><br><span class="line">#endif</span><br><span class="line">movx5, #VA_BITS_MIN</span><br><span class="line">1:</span><br><span class="line">adr_lx6, vabits_actual</span><br><span class="line">strx5, [x6]</span><br><span class="line">dmbsy</span><br><span class="line">dcivac, x6// Invalidate potentially stale cache line</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * VA_BITS may be too small to allow for an ID mapping to be created</span><br><span class="line"> * that covers system RAM if that is located sufficiently high in the</span><br><span class="line"> * physical address space. So for the ID map, use an extended virtual</span><br><span class="line"> * range in that case, and configure an additional translation level</span><br><span class="line"> * if needed.</span><br><span class="line"> *</span><br><span class="line"> * Calculate the maximum allowed value for TCR_EL1.T0SZ so that the</span><br><span class="line"> * entire ID map region can be mapped. As T0SZ == (64 - #bits used),</span><br><span class="line"> * this number conveniently equals the number of leading zeroes in</span><br><span class="line"> * the physical address of __idmap_text_end.</span><br><span class="line"> */</span><br><span class="line">adrpx5, __idmap_text_end</span><br><span class="line">clzx5, x5</span><br><span class="line">cmpx5, TCR_T0SZ(VA_BITS_MIN) // default T0SZ small enough?</span><br><span class="line">b.ge1f// .. then skip VA range extension</span><br><span class="line"></span><br><span class="line">adr_lx6, idmap_t0sz</span><br><span class="line">strx5, [x6]</span><br><span class="line">dmbsy</span><br><span class="line">dcivac, x6// Invalidate potentially stale cache line</span><br><span class="line"></span><br><span class="line">#if (VA_BITS &lt; 48)</span><br><span class="line">#define EXTRA_SHIFT(PGDIR_SHIFT + PAGE_SHIFT - 3)</span><br><span class="line">#define EXTRA_PTRS(1 &lt;&lt; (PHYS_MASK_SHIFT - EXTRA_SHIFT))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * If VA_BITS &lt; 48, we have to configure an additional table level.</span><br><span class="line"> * First, we have to verify our assumption that the current value of</span><br><span class="line"> * VA_BITS was chosen such that all translation levels are fully</span><br><span class="line"> * utilised, and that lowering T0SZ will always result in an additional</span><br><span class="line"> * translation level to be configured.</span><br><span class="line"> */</span><br><span class="line">#if VA_BITS != EXTRA_SHIFT</span><br><span class="line">#error &quot;Mismatch between VA_BITS and page size/number of translation levels&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">movx4, EXTRA_PTRS</span><br><span class="line">create_table_entry x0, x3, EXTRA_SHIFT, x4, x5, x6</span><br><span class="line">#else</span><br><span class="line">/*</span><br><span class="line"> * If VA_BITS == 48, we don&#x27;t have to configure an additional</span><br><span class="line"> * translation level, but the top-level table has more entries.</span><br><span class="line"> */</span><br><span class="line">movx4, #1 &lt;&lt; (PHYS_MASK_SHIFT - PGDIR_SHIFT)</span><br><span class="line">str_lx4, idmap_ptrs_per_pgd, x5</span><br><span class="line">#endif</span><br><span class="line">1:</span><br><span class="line">ldr_lx4, idmap_ptrs_per_pgd</span><br><span class="line">movx5, x3// __pa(__idmap_text_start)</span><br><span class="line">adr_lx6, __idmap_text_end// __pa(__idmap_text_end)</span><br><span class="line"></span><br><span class="line">map_memory x0, x1, x3, x6, x7, x3, x4, x10, x11, x12, x13, x14</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Map the kernel image (starting with PHYS_OFFSET).</span><br><span class="line"> */</span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">mov_qx5, KIMAGE_VADDR// compile time __va(_text)</span><br><span class="line">addx5, x5, x23// add KASLR displacement</span><br><span class="line">movx4, PTRS_PER_PGD</span><br><span class="line">adrpx6, _end// runtime __pa(_end)</span><br><span class="line">adrpx3, _text// runtime __pa(_text)</span><br><span class="line">subx6, x6, x3// _end - _text</span><br><span class="line">addx6, x6, x5// runtime __va(_end)</span><br><span class="line"></span><br><span class="line">map_memory x0, x1, x5, x6, x7, x3, x4, x10, x11, x12, x13, x14</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Since the page tables have been populated with non-cacheable</span><br><span class="line"> * accesses (MMU disabled), invalidate those tables again to</span><br><span class="line"> * remove any speculatively loaded cache lines.</span><br><span class="line"> */</span><br><span class="line">dmbsy</span><br><span class="line"></span><br><span class="line">adrpx0, idmap_pg_dir</span><br><span class="line">adrpx1, idmap_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line">adrpx0, init_pg_dir</span><br><span class="line">adrpx1, init_pg_end</span><br><span class="line">subx1, x1, x0</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line">retx28</span><br><span class="line">SYM_FUNC_END(__create_page_tables)</span><br></pre></td></tr></table></figure><p>页表的映射比较复杂，后面再分析，主要是的功能时缓存无效化、页表清空、虚拟地址配置，然后把内核进行了映射。</p><h4 id="2-2-5-cpu-setup"><a href="#2-2-5-cpu-setup" class="headerlink" title="2.2.5 __cpu_setup"></a>2.2.5 __cpu_setup</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//arch/arm64/mm/proc.S</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *__cpu_setup</span><br><span class="line"> *</span><br><span class="line"> *Initialise the processor for turning the MMU on.</span><br><span class="line"> *</span><br><span class="line"> * Output:</span><br><span class="line"> *Return in x0 the value of the SCTLR_EL1 register.</span><br><span class="line"> */</span><br><span class="line">.pushsection &quot;.idmap.text&quot;, &quot;awx&quot;</span><br><span class="line">SYM_FUNC_START(__cpu_setup)</span><br><span class="line">tlbivmalle1// 通过 tlbi 指令无效化本地 TLB,刷新tlb，用于后续映射</span><br><span class="line">dsbnsh</span><br><span class="line"></span><br><span class="line">movx1, #3 &lt;&lt; 20</span><br><span class="line">msrcpacr_el1, x1// Enable FP/ASIMD</span><br><span class="line">movx1, #1 &lt;&lt; 12// Reset mdscr_el1 and disable</span><br><span class="line">msrmdscr_el1, x1// access to the DCC from EL0</span><br><span class="line">isb// Unmask debug exceptions now,</span><br><span class="line">enable_dbg// since this is per-cpu</span><br><span class="line">reset_pmuserenr_el0 x1// Disable PMU access from EL0</span><br><span class="line">reset_amuserenr_el0 x1// Disable AMU access from EL0</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Memory region attributes</span><br><span class="line"> */</span><br><span class="line">mov_qx5, MAIR_EL1_SET #内存属性配置值写入 MAIR_EL1 寄存器，设置内存区域的属性</span><br><span class="line">msrmair_el1, x5</span><br><span class="line">/*</span><br><span class="line"> * Set/prepare TCR and TTBR. TCR_EL1.T1SZ gets further</span><br><span class="line"> * adjusted if the kernel is compiled with 52bit VA support.</span><br><span class="line"> */</span><br><span class="line">mov_qx10, TCR_TxSZ(VA_BITS) | TCR_CACHE_FLAGS | TCR_SMP_FLAGS | \</span><br><span class="line">TCR_TG_FLAGS | TCR_KASLR_FLAGS | TCR_ASID16 | \</span><br><span class="line">TCR_TBI0 | TCR_A1 | TCR_KASAN_SW_FLAGS | TCR_MTE_FLAGS</span><br><span class="line"></span><br><span class="line">tcr_clear_errata_bits x10, x9, x5</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_VA_BITS_52</span><br><span class="line">ldr_lx9, vabits_actual</span><br><span class="line">subx9, xzr, x9</span><br><span class="line">addx9, x9, #64</span><br><span class="line">tcr_set_t1szx10, x9</span><br><span class="line">#else</span><br><span class="line">ldr_lx9, idmap_t0sz</span><br><span class="line">#endif</span><br><span class="line">tcr_set_t0szx10, x9</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set the IPS bits in TCR_EL1.</span><br><span class="line"> */</span><br><span class="line">tcr_compute_pa_size x10, #TCR_IPS_SHIFT, x5, x6</span><br><span class="line">#ifdef CONFIG_ARM64_HW_AFDBM</span><br><span class="line">/*</span><br><span class="line"> * Enable hardware update of the Access Flags bit.</span><br><span class="line"> * Hardware dirty bit management is enabled later,</span><br><span class="line"> * via capabilities.</span><br><span class="line"> */</span><br><span class="line">mrsx9, ID_AA64MMFR1_EL1</span><br><span class="line">andx9, x9, #0xf</span><br><span class="line">cbzx9, 1f</span><br><span class="line">orrx10, x10, #TCR_HA// hardware Access flag update</span><br><span class="line">1:</span><br><span class="line">#endif/* CONFIG_ARM64_HW_AFDBM */</span><br><span class="line">msrtcr_el1, x10</span><br><span class="line">/*</span><br><span class="line"> * Prepare SCTLR</span><br><span class="line"> */</span><br><span class="line">mov_qx0, INIT_SCTLR_EL1_MMU_ON</span><br><span class="line">ret// return to head.S</span><br><span class="line">SYM_FUNC_END(__cpu_setup)</span><br></pre></td></tr></table></figure><p><code>__cpu_setup</code>定义在<code>arch/arm64/mm/proc.S</code>中，这段代码通过一系列步骤初始化处理器，以便安全地开启内存管理单元（MMU）。主要步骤包括：</p><ol><li>无效化本地 TLB</li><li>启用浮点和 SIMD 单元</li><li>设置调试寄存器</li><li>配置内存属性寄存器</li><li>配置翻译控制寄存器和基址寄存器</li><li>设置物理地址大小和硬件访问标志</li><li>准备系统控制寄存器并返回</li></ol><p>这些步骤确保处理器在启用 MMU 时能正确处理内存访问和管理</p><h4 id="2-2-6-primary-switch"><a href="#2-2-6-primary-switch" class="headerlink" title="2.2.6 __primary_switch"></a>2.2.6 __primary_switch</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SYM_FUNC_START_LOCAL(__primary_switch)</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">movx19, x0// preserve new SCTLR_EL1 value</span><br><span class="line">mrsx20, sctlr_el1// preserve old SCTLR_EL1 value</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">adrpx1, init_pg_dir</span><br><span class="line">bl__enable_mmu</span><br><span class="line">#ifdef CONFIG_RELOCATABLE</span><br><span class="line">#ifdef CONFIG_RELR</span><br><span class="line">movx24, #0// no RELR displacement yet</span><br><span class="line">#endif</span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">blrx8</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * If we return here, we have a KASLR displacement in x23 which we need</span><br><span class="line"> * to take into account by discarding the current kernel mapping and</span><br><span class="line"> * creating a new one.</span><br><span class="line"> */</span><br><span class="line">pre_disable_mmu_workaround</span><br><span class="line">msrsctlr_el1, x20// disable the MMU</span><br><span class="line">isb</span><br><span class="line">bl__create_page_tables// recreate kernel mapping</span><br><span class="line"></span><br><span class="line">tlbivmalle1// Remove any stale TLB entries</span><br><span class="line">dsbnsh</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">set_sctlr_el1x19// re-enable the MMU</span><br><span class="line"></span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">brx8</span><br><span class="line">SYM_FUNC_END(__primary_switch)</span><br></pre></td></tr></table></figure><p>这段代码主要是用于内核映射的重定位，如果内核地址需要重定位则需要查询页表进行重新映射，然后在最后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">brx8</span><br></pre></td></tr></table></figure><p>跳转到<code>__primary_switched</code>函数继续执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following fragment of code is executed with the MMU enabled.</span><br><span class="line"> *</span><br><span class="line"> *   x0 = __PHYS_OFFSET</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(__primary_switched)</span><br><span class="line">adrpx4, init_thread_union</span><br><span class="line">addsp, x4, #THREAD_SIZE</span><br><span class="line">adr_lx5, init_task</span><br><span class="line">msrsp_el0, x5// Save thread_info</span><br><span class="line"></span><br><span class="line">adr_lx8, vectors// load VBAR_EL1 with virtual</span><br><span class="line">msrvbar_el1, x8// vector table address</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">stpxzr, x30, [sp, #-16]!</span><br><span class="line">movx29, sp</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SHADOW_CALL_STACK</span><br><span class="line">adr_lscs_sp, init_shadow_call_stack// Set shadow call stack</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">str_lx21, __fdt_pointer, x5// Save FDT pointer</span><br><span class="line"></span><br><span class="line">ldr_lx4, kimage_vaddr// Save the offset between</span><br><span class="line">subx4, x4, x0// the kernel virtual and</span><br><span class="line">str_lx4, kimage_voffset, x5// physical mappings</span><br><span class="line"></span><br><span class="line">// Clear BSS</span><br><span class="line">adr_lx0, __bss_start</span><br><span class="line">movx1, xzr</span><br><span class="line">adr_lx2, __bss_stop</span><br><span class="line">subx2, x2, x0</span><br><span class="line">bl__pi_memset</span><br><span class="line">dsbishst// Make zero page visible to PTW</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)</span><br><span class="line">blkasan_early_init</span><br><span class="line">#endif</span><br><span class="line">movx0, x21// pass FDT address in x0</span><br><span class="line">blearly_fdt_map// Try mapping the FDT early</span><br><span class="line">blinit_feature_override// Parse cpu feature overrides</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">tstx23, ~(MIN_KIMG_ALIGN - 1)// already running randomized?</span><br><span class="line">b.ne0f</span><br><span class="line">blkaslr_early_init// parse FDT for KASLR options</span><br><span class="line">cbzx0, 0f// KASLR disabled? just proceed</span><br><span class="line">orrx23, x23, x0// record KASLR offset</span><br><span class="line">ldpx29, x30, [sp], #16// we must enable KASLR, return</span><br><span class="line">ret// to __primary_switch()</span><br><span class="line">0:</span><br><span class="line">#endif</span><br><span class="line">blswitch_to_vhe// Prefer VHE if possible</span><br><span class="line">addsp, sp, #16</span><br><span class="line">movx29, #0</span><br><span class="line">movx30, #0</span><br><span class="line">bstart_kernel</span><br><span class="line">SYM_FUNC_END(__primary_switched)</span><br></pre></td></tr></table></figure><p>此函数在启用 MMU 后执行，负责初始化各种系统寄存器和数据结构，清空 BSS 段，处理设备树和特性覆盖，并根据需要处理内核地址空间布局随机化（KASLR）。最后，它跳转到 <code>start_kernel</code> 函数，开始内核的主要启动过程。</p><h2 id="3-内核启动第二阶段"><a href="#3-内核启动第二阶段" class="headerlink" title="3. 内核启动第二阶段"></a>3. 内核启动第二阶段</h2><p>Linux内核启动的第二阶段也就是常说的C语言阶段，从start_kernel()函数开始；start_kernel()函数是所有Linux平台进入系统内核初始化后的入口函数；主要完成剩余的与硬件平台相关的初始化工作，这些初始化操作，有的是公共的，有的是需要配置才会执行的；内核工作需要的模块的初始化依次被调用，如：内存管理、调度系统、异常处理等；</p><h3 id="3-1-start-kernel"><a href="#3-1-start-kernel" class="headerlink" title="3.1 start_kernel"></a>3.1 start_kernel</h3><p>start_kernel()函数在init&#x2F;main.c文件中，主要完成Linux子系统的初始化工作；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">casmlinkage __visible <span class="type">void</span> __init __no_sanitize_address <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *command_line;</span><br><span class="line"><span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">smp_setup_processor_id();</span><br><span class="line">debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">cgroup_init_early();</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line">early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts are still disabled. Do necessary setups, then</span></span><br><span class="line"><span class="comment"> * enable them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">boot_cpu_init();</span><br><span class="line">page_address_init();</span><br><span class="line">pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);</span><br><span class="line">early_security_init();</span><br><span class="line">setup_arch(&amp;command_line);</span><br><span class="line">setup_boot_config(command_line);</span><br><span class="line">setup_command_line(command_line);</span><br><span class="line">setup_nr_cpu_ids();</span><br><span class="line">setup_per_cpu_areas();</span><br><span class="line">smp_prepare_boot_cpu();<span class="comment">/* arch-specific boot-cpu hooks */</span></span><br><span class="line">boot_cpu_hotplug_init();</span><br><span class="line"></span><br><span class="line">build_all_zonelists(<span class="literal">NULL</span>);</span><br><span class="line">page_alloc_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_ROCKCHIP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *s = saved_command_line;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *e = &amp;saved_command_line[<span class="built_in">strlen</span>(saved_command_line)];</span><br><span class="line"><span class="type">int</span> n =</span><br><span class="line">    pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, saved_command_line);</span><br><span class="line">n -= <span class="built_in">strlen</span>(<span class="string">&quot;Kernel command line: &quot;</span>);</span><br><span class="line">s += n;</span><br><span class="line"><span class="comment">/* command line maybe too long to print one time */</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; s &lt; e) &#123;</span><br><span class="line">n = pr_cont(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">s += n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, saved_command_line);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* parameters may set static keys */</span></span><br><span class="line">jump_label_init();</span><br><span class="line">parse_early_param();</span><br><span class="line">after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">  static_command_line, __start___param,</span><br><span class="line">  __stop___param - __start___param,</span><br><span class="line">  <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, &amp;unknown_bootoption);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">parse_args(<span class="string">&quot;Setting init args&quot;</span>, after_dashes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">   <span class="literal">NULL</span>, set_init_arg);</span><br><span class="line"><span class="keyword">if</span> (extra_init_args)</span><br><span class="line">parse_args(<span class="string">&quot;Setting extra init args&quot;</span>, extra_init_args,</span><br><span class="line">   <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, set_init_arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment"> * kmem_cache_init()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup_log_buf(<span class="number">0</span>);</span><br><span class="line">vfs_caches_init_early();</span><br><span class="line">sort_main_extable();</span><br><span class="line">trap_init();</span><br><span class="line">mm_init();</span><br><span class="line">poking_init();</span><br><span class="line">ftrace_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* trace_printk can be enabled here */</span></span><br><span class="line">early_trace_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the scheduler prior starting any interrupts (such as the</span></span><br><span class="line"><span class="comment"> * timer interrupt). Full topology setup happens at smp_init()</span></span><br><span class="line"><span class="comment"> * time - but meanwhile we still have a functioning scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sched_init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN(!irqs_disabled(),</span><br><span class="line"> <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line">local_irq_disable();</span><br><span class="line">radix_tree_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up housekeeping before setting up workqueues to allow the unbound</span></span><br><span class="line"><span class="comment"> * workqueue to take non-housekeeping into account.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">housekeeping_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allow workqueue creation and work item queueing/cancelling</span></span><br><span class="line"><span class="comment"> * early.  Work item execution depends on kthreads and starts after</span></span><br><span class="line"><span class="comment"> * workqueue_init().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">workqueue_init_early();</span><br><span class="line"></span><br><span class="line">rcu_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Trace events are available after this */</span></span><br><span class="line">trace_init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (initcall_debug)</span><br><span class="line">initcall_debug_enable();</span><br><span class="line"></span><br><span class="line">context_tracking_init();</span><br><span class="line"><span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">early_irq_init();</span><br><span class="line">init_IRQ();</span><br><span class="line">tick_init();</span><br><span class="line">rcu_init_nohz();</span><br><span class="line">init_timers();</span><br><span class="line">hrtimers_init();</span><br><span class="line">softirq_init();</span><br><span class="line">timekeeping_init();</span><br><span class="line">kfence_init();</span><br><span class="line">time_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For best initial stack canary entropy, prepare it after:</span></span><br><span class="line"><span class="comment"> * - setup_arch() for any UEFI RNG entropy and boot cmdline access</span></span><br><span class="line"><span class="comment"> * - timekeeping_init() for ktime entropy used in random_init()</span></span><br><span class="line"><span class="comment"> * - time_init() for making random_get_entropy() work on some platforms</span></span><br><span class="line"><span class="comment"> * - random_init() to initialize the RNG from from early entropy sources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">random_init(command_line);</span><br><span class="line">boot_init_stack_canary();</span><br><span class="line"></span><br><span class="line">perf_event_init();</span><br><span class="line">profile_init();</span><br><span class="line">call_function_init();</span><br><span class="line">WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line">kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HACK ALERT! This is early. We&#x27;re enabling the console before</span></span><br><span class="line"><span class="comment"> * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span></span><br><span class="line"><span class="comment"> * this. But we do want output early, in case something goes wrong.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">console_init();</span><br><span class="line"><span class="keyword">if</span> (panic_later)</span><br><span class="line">panic(<span class="string">&quot;Too many boot %s vars at `%s&#x27;&quot;</span>, panic_later,</span><br><span class="line">      panic_param);</span><br><span class="line"></span><br><span class="line">lockdep_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Need to run this when irqs are enabled, because it wants</span></span><br><span class="line"><span class="comment"> * to self-test [hard/soft]-irqs on/off lock inversion bugs</span></span><br><span class="line"><span class="comment"> * too:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">locking_selftest();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line"><span class="keyword">if</span> (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">pr_crit(<span class="string">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;</span>,</span><br><span class="line">    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)),</span><br><span class="line">    min_low_pfn);</span><br><span class="line">initrd_start = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">setup_per_cpu_pageset();</span><br><span class="line">numa_policy_init();</span><br><span class="line">acpi_early_init();</span><br><span class="line"><span class="keyword">if</span> (late_time_init)</span><br><span class="line">late_time_init();</span><br><span class="line">sched_clock_init();</span><br><span class="line">calibrate_delay();</span><br><span class="line"></span><br><span class="line">arch_cpu_finalize_init();</span><br><span class="line"></span><br><span class="line">pid_idr_init();</span><br><span class="line">anon_vma_init();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line"><span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">efi_enter_virtual_mode();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">thread_stack_cache_init();</span><br><span class="line">cred_init();</span><br><span class="line">fork_init();</span><br><span class="line">proc_caches_init();</span><br><span class="line">uts_ns_init();</span><br><span class="line">buffer_init();</span><br><span class="line">key_init();</span><br><span class="line">security_init();</span><br><span class="line">dbg_late_init();</span><br><span class="line">vfs_caches_init();</span><br><span class="line">pagecache_init();</span><br><span class="line">signals_init();</span><br><span class="line">seq_file_init();</span><br><span class="line">proc_root_init();</span><br><span class="line">nsfs_init();</span><br><span class="line">cpuset_init();</span><br><span class="line">cgroup_init();</span><br><span class="line">taskstats_init_early();</span><br><span class="line">delayacct_init();</span><br><span class="line"></span><br><span class="line">acpi_subsystem_init();</span><br><span class="line">arch_post_acpi_subsys_init();</span><br><span class="line">sfi_init_late();</span><br><span class="line">kcsan_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">arch_call_rest_init();</span><br><span class="line"></span><br><span class="line">prevent_tail_call_optimization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见依次调用了很多的初始化函数</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://mshrimp.github.io/2020/04/19/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EARM64/">Linux内核启动流程-基于ARM64 | Mshrimp blog</a></li><li><a href="https://b2qtatgfkp.feishu.cn/docx/CttXdvBEuomVmmxQcw5cqh5jnJg">05 Linux 内核 - 飞书云文档 (feishu.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> ARM64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核中同步机制的底层实现</title>
      <link href="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核同步机制剖析"><a href="#Linux内核同步机制剖析" class="headerlink" title="Linux内核同步机制剖析"></a>Linux内核同步机制剖析</h1><p>在Linux内核中提供了四种处理并发和竞争的方法，分别是原子操作、自旋锁、信号量、互斥量，事先说明下我使用的<code>linux</code>内核为版本为<code>4.19.232</code></p><h2 id="1-原子变量"><a href="#1-原子变量" class="headerlink" title="1. 原子变量"></a>1. 原子变量</h2><p>在了解原子变量在linux内核中是如何实现之前，建议先了解以下<code>SMP</code>系统和<code>UP</code>系统的不同，然后学习以下<code>cache</code>一致性相关知识，这里给出一个参考链接</p><blockquote><p><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#cpu-cache-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">2.4 CPU 缓存一致性 | 小林coding (xiaolincoding.com)</a></p></blockquote><p>原子操作又可以进一步细分为“整型原子操作”和“位原子操作”，这里首先对<strong>整型原子操作</strong>进行讲解。在 Linux 内核中使用 <code>atomic_t</code> 和<code> atomic64_t</code> 结构体分别来完成 32 位系统和 64 位系统的整形数据原子操作，两个结构体定义在内核源码<code>/include/linux/types.h</code>文件中，具体定义如下：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508114202431.png" alt="image-20240508114202431"></p><p>对整型原子变量的操作有以下一些函数，定义在内核源码的<code>/include/linux/atomic.h</code>中，</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>ATOMIC_INIT(int i)</code></td><td>定义原子变量的时候对其初始化，赋值为 i</td></tr><tr><td><code>int atomic_read(atomic_t *v)</code></td><td>读取 v 的值，并且返回。</td></tr><tr><td><code>void atomic_set(atomic_t *v, int i)</code></td><td>向原子变量 v 写入 i 值。</td></tr><tr><td><code>void atomic_add(int i, atomic_t *v)</code></td><td>原子变量 v 加上 i 值。</td></tr><tr><td><code>void atomic_sub(int i, atomic_t *v)</code></td><td>原子变量 v 减去 i 值。</td></tr><tr><td><code>void atomic_inc(atomic_t *v)</code></td><td>原子变量 v 加 1</td></tr><tr><td><code>void atomic_dec(atomic_t *v)</code></td><td>原子变量 v 减 1</td></tr><tr><td><code>int atomic_dec_return(atomic_t *v)</code></td><td>原子变量 v 减 1，并返回 v 的值。</td></tr><tr><td><code>int atomic_inc_return(atomic_t *v)</code></td><td>原子变量 v 加 1，并返回 v 的值。</td></tr><tr><td><code>int atomic_sub_and_test(int i, atomic_t *v)</code></td><td>原子变量 v 减 i，如果结果为 0 就返回真，否则返回假</td></tr><tr><td><code>int atomic_dec_and_test(atomic_t *v)</code></td><td>原子变量 v 减 1，如果结果为 0 就返回真，否则返回假</td></tr><tr><td><code>int atomic_inc_and_test(atomic_t *v)</code></td><td>原子变量 v 加 1，如果结果为 0 就返回真，否则返回假</td></tr><tr><td><code>int atomic_add_negative(int i, atomic_t *v)</code></td><td>原子变量 v 加 i，如果结果为负就返回真，否则返回假</td></tr></tbody></table><p>对原子位操作的函数有如下，和原子整形变量不同，原子位操作没有 <code>atomic_t </code>的数据结构，原子位操作是直接对内存进行操作</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>void set_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位置 1</td></tr><tr><td><code>void clear_bit(int nr,void *p)</code></td><td>将 p 地址的第 nr 位清零</td></tr><tr><td><code>void change_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位进行翻转</td></tr><tr><td><code>int test_bit(int nr, void *p)</code></td><td>获取 p 地址的第 nr 位的值</td></tr><tr><td><code>int test_and_set_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值</td></tr><tr><td><code>int test_and_clear_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位清零，并且返回 nr 位原来的值</td></tr><tr><td><code>int test_and_change_bit(int nr, void *p)</code></td><td>将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值</td></tr></tbody></table><p>我们以原子变量加操作的源码来分析，原子变量的操作在不同体系架构下是不同的，假设我现在定义一个原子变量，然后对其执行加操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> v = ATOMIC_INIT(<span class="number">1</span>);<span class="comment">//初始化原子类型变量 v,并设置为 1</span></span><br><span class="line"><span class="type">atomic_inc</span>(v);   <span class="comment">//将原子变量+1</span></span><br></pre></td></tr></table></figure><p><code>atomic_inc</code>这个宏定义在<code>linux/atomic.h</code>中：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508223825378.png" alt="image-20240508223825378"></p><p>可以看见<code>atomic_inc</code>实际上会去调用<code>atomic_add</code>来使得原子变量加一，<code>atomic_add</code>是一个和体系架构相关的宏函数，我们以<code>x86</code>平台和<code>arm</code>平台为例子，对于<code>linux/atomic.h</code>这个文件无论哪种架构都会去包含<code>\#include &lt;asm/atomic.h&gt;</code>这个头文件，不同的架构这个头文件内容是不一样的。</p><h3 id="1-1-X86平台原子操作的底层实现"><a href="#1-1-X86平台原子操作的底层实现" class="headerlink" title="1.1 X86平台原子操作的底层实现"></a>1.1 X86平台原子操作的底层实现</h3><p>我们首先来分析<code>x86</code>架构，<code>&lt;asm/atomic.h&gt;</code>这个头文件位于<code>arch/x86/include/asm/atomic.h</code>，在这个文件的最底部包含了一个头文件：<code>&lt;asm-generic/atomic-instrumented.h&gt;</code></p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508225051741.png" alt="image-20240508225051741"></p><p>在<code>&lt;asm-generic/atomic-instrumented.h&gt;</code>中定义了和<code>x86</code>架构下原子变量操作的函数</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508225142115.png" alt="image-20240508225142115"></p><p>例如<code>atomic_add</code>会去调用<code>arch_atomic_add</code>，而<code>arch_atomic_add</code>就定义在<code>arch/x86/include/asm/atomic.h</code>中：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240508225332327.png" alt="image-20240508225332327"></p><p><code>arch_atomic_add</code>这个函数内部做的操作就是原子变量加一，它是如何做的呢，先来看<code>LOCK_PREFIX</code>这个宏，定义在<code>arch/x86/include/asm/alternative-asm.h</code>中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">.macro LOCK_PREFIX</span><br><span class="line"><span class="number">672</span>:lock</span><br><span class="line">.pushsection .smp_locks,<span class="string">&quot;a&quot;</span></span><br><span class="line">.balign <span class="number">4</span></span><br><span class="line">.<span class="type">long</span> <span class="number">672b</span> - .</span><br><span class="line">.popsection</span><br><span class="line">.endm</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">.macro LOCK_PREFIX</span><br><span class="line">.endm</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看见只有在<code>SMP</code>系统下此宏才会被定义，在<code>SMP</code>系统下涉及到多核之间的<code>cache</code>数据同步与竞争关系，此时才会去定义这个宏，在不是<code>SMP</code>的系统下此宏为空，即单核情况下，这个宏为空，在单核情况下，上面的<code>arch_atomic_add</code>函数就变成了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;addl %1,%0&quot;</span></span></span><br><span class="line"><span class="params">     : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span><br><span class="line"><span class="params">     : <span class="string">&quot;ir&quot;</span> (i) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>addl</code>指令用于执行32位整数加法操作，<code>%1</code>代表i这个参数，<code>%0</code>代表<code>v-&gt;vounter</code>这个参数，<code>addl</code>指令有三个步骤</p><ul><li><strong>取值</strong>：汇编指令首先从 <code>%1</code>（即 <code>i</code>）获取一个整数值。</li><li><strong>加法运算</strong>：将从 <code>%1</code> 取得的值加到 <code>%0</code>（即 <code>v-&gt;counter</code> 内存位置的当前值）上。</li><li><strong>存储结果</strong>：将加法的结果写回 <code>%0</code>，也就是更新 <code>v-&gt;counter</code> 的值。</li></ul></li><li><p>而这三个步骤在单核情况下就是一条<code>addl</code>指令，在单核情况下是原子的，<code>addl</code>在执行时不会被打断</p></li></ul><p>在<code>SMP</code>系统下，由于每个核心都有自己的<code>cache</code>，因此通过锁总线的方式来保证<code>addl</code>指令在多核情况下对同一块内存的操作是一个cpu独占的，在读写完成后再通过<code>cache</code>一致性协议同步，上面这个<code>LOCK_PREFIX</code>宏定义了一些前缀，具体什么意思可以参照下面这个博客，总之就是使用<code>lock</code>指令进行了锁总线的操作，从而实现<code>addl</code>指令在多核情况下的原子性</p><blockquote><p><a href="https://blog.csdn.net/ture010love/article/details/7663008">Linux 内核 LOCK_PREFIX 的含义-CSDN博客</a></p></blockquote><h3 id="1-2-ARM架构的原子操作底层实现"><a href="#1-2-ARM架构的原子操作底层实现" class="headerlink" title="1.2 ARM架构的原子操作底层实现"></a>1.2 ARM架构的原子操作底层实现</h3><p><code>arm</code>架构会有一些不同，<code>ARMv3</code>至<code>ARMv7</code>支持32位寻址空间。<code>ARMv8-A</code>开始支持64位寻址空间，32位的<code>arm</code>架构和64位的<code>arm</code>架构在实现原子操作时是存在一些指令上的不同的。在<code>ARMv8.1</code>之前，为实现原子操作采用的方法主要是<code>LL/SC(Load-Link/Store-Conditional)</code>。ARMv7中实现<code>LL/SC</code>的指令是<code>LDREX/STREX</code>，其实就是比基础的<code>LDR</code>和<code>STR</code>指令多了一个”EX”，”EX”表示exclusive（独占）。具体说来就是，当用<code>LDREX</code>指令从内存某个地址取出数据放到寄存器后，一个硬件的<code>monitor</code>会将此地址标记为<code>exclusive</code>。</p><h4 id="1-2-1-ARM32原子操作"><a href="#1-2-1-ARM32原子操作" class="headerlink" title="1.2.1 ARM32原子操作"></a>1.2.1 ARM32原子操作</h4><p>我们先来看<code>ARMV7</code>是如何做的，还是以<code>atomic_add</code>这个宏为例子，<code>ARMV7</code>及以前的代码是放在<code>arch/arm</code>目录下，我们去<code>arch/arm/include/asm/atomic.h</code>中查找：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509135911099.png" alt="image-20240509135911099"></p><p>在此文件中首先定义了一个宏<code>__LINUX_ARM_ARCH__</code>如果<code>ARM</code>的架构版本大于等于6则说明是支持SMP系统的，如果<code>ARM</code>架构的版本小于<code>ARMV7</code>说明是不支持SMP系统的，多核情况下支持锁内存这样的指令，而单核情况下是不支持的，因此原子操作实际上是通过关闭中断来实现的</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509140147787.png" alt="image-20240509140147787"></p><p>在此文件的下半部分定义了一些宏：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509140456071.png" alt="image-20240509140456071"></p><p><code>ATOMIC_OPS</code>这个宏展开后会去依次调用<code>ATOMIC_OP</code>，<code>ATOMIC_OP_RETURN</code>，<code>ATOMIC_FETCH_OP</code>，在上面的代码中调用了<code>ATOMIC_OPS(add, +=, add)</code>，就相当于：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ATOMIC_OP(add, += , add)</span><br><span class="line">ATOMIC_OP(add, += , add)</span><br><span class="line">ATOMIC_FETCH_OP(op, c_op, asm_op)</span><br></pre></td></tr></table></figure><p>这三个宏都是在上面定义的，以SMP系统下的<code>ATOMIC_OP</code>为例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ARMv6 UP and SMP safe atomic ops.  We use load exclusive and</span></span><br><span class="line"><span class="comment"> * store exclusive to ensure that these are atomic.  We may loop</span></span><br><span class="line"><span class="comment"> * to ensure that the update happens.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, c_op, asm_op)\</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">unsigned long tmp;\</span></span><br><span class="line"><span class="meta">int result;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">prefetchw(&amp;v-&gt;counter);\</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;@ atomic_&quot;</span> #op <span class="string">&quot;\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;1:ldrex%0, [%3]\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;&quot;</span> #asm_op <span class="string">&quot;%0, %0, %4\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;strex%1, %0, [%3]\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;teq%1, #0\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bne1b&quot;</span>\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;=&amp;r&quot;</span> (result), <span class="string">&quot;=&amp;r&quot;</span> (tmp), <span class="string">&quot;+Qo&quot;</span> (v-&gt;counter)\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;r&quot;</span> (&amp;v-&gt;counter), <span class="string">&quot;Ir&quot;</span> (i)\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;cc&quot;</span>);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>展开后这个宏函数的名字就变成了，可以看见就是我们需要的<code>atomic_add</code>函数，其余的宏展开后同理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp;\</span><br><span class="line"><span class="type">int</span> result;\</span><br><span class="line">\</span><br><span class="line">prefetchw(&amp;v-&gt;counter);\</span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;@ atomic_add&quot;</span>\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">1</span>:ldrex%<span class="number">0</span>, [%<span class="number">3</span>]\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>add%<span class="number">0</span>, %<span class="number">0</span>, %<span class="number">4</span>\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>strex%<span class="number">1</span>, %<span class="number">0</span>, [%<span class="number">3</span>]\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>teq%<span class="number">1</span>, #<span class="number">0</span>\n<span class="string">&quot;\</span></span><br><span class="line"><span class="string">&quot;</span>bne<span class="number">1b</span><span class="string">&quot;\</span></span><br><span class="line"><span class="string">: &quot;</span>=&amp;r<span class="string">&quot; (result), &quot;</span>=&amp;r<span class="string">&quot; (tmp), &quot;</span>+Qo<span class="string">&quot; (v-&gt;counter)\</span></span><br><span class="line"><span class="string">: &quot;</span>r<span class="string">&quot; (&amp;v-&gt;counter), &quot;</span>Ir<span class="string">&quot; (i)\</span></span><br><span class="line"><span class="string">: &quot;</span>cc<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>unsigned long tmp;</code> 和 <code>int result;</code> 定义了两个变量，分别用于存储临时数据和操作结果。</p></li><li><p><code>prefetchw(&amp;v-&gt;counter);</code> 用于预取 <code>v-&gt;counter</code> 的写操作，这可能帮助提高性能。</p></li><li><p>定义了一个内联汇编块，用于实现原子操作。</p><ul><li><code>&quot;@ atomic_&quot; #op &quot;\n&quot;</code> 是一个注释，标识了操作类型。</li><li><code>&quot;ldrex %0, [%3]\n&quot;</code> 使用 <code>ldrex</code> 指令加载 <code>v-&gt;counter</code> 的值到 <code>result</code>，这是一个独占读取。</li><li><code>&quot;#asm_op %0, %0, %4\n&quot;</code> 执行指定的操作，如 <code>add</code>，结果存回 <code>result</code>。</li><li><code>&quot;strex %1, %0, [%3]\n&quot;</code> 使用 <code>strex</code> 尝试将 <code>result</code> 的新值存回 <code>v-&gt;counter</code>。如果在此期间 <code>v-&gt;counter</code> 被其他处理器修改过，则 <code>strex</code> 返回非零值。</li><li><code>&quot;teq %1, #0\n&quot;</code> 测试 <code>strex</code> 的结果是否为 0（表示成功）。</li><li><code>&quot;bne 1b&quot;</code> 如果 <code>strex</code> 失败（<code>tmp</code> 不为 0），则跳回标签 <code>1</code> 重新执行。</li></ul></li><li><p><code>&quot;+Qo&quot; (v-&gt;counter)</code> 表示 <code>v-&gt;counter</code> 是一个输入输出操作数（既被读也被写）。</p></li><li><p><code>&quot;r&quot; (&amp;v-&gt;counter)</code> 和 <code>&quot;Ir&quot; (i)</code> 分别传入 <code>v-&gt;counter</code> 的地址和整数 <code>i</code> 作为输入。</p></li><li><p><code>&quot;cc&quot;</code> 表示这段代码会修改条件寄存器。</p></li></ul><p>这段汇编代码的逻辑如下图所示：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/barriers-12a.png" alt="barriers-12a"></p><p>假设CPU A先进行load操作，并标记了变量v所在的内存地址为exclusive，在CPU A进行下一步的store操作之前，CPU B也进行了对变量v的load操作，那么这个内存地址的exclusive就成了CPU B标记的了。之后CPU A使用STREX进行store操作，它会测试store的目标地址的exclusive是不是自己标记的（是否为自己独占），结果不是，那么store失败。接下来CPU B也执行STREX，因为exclusive是自己标记的，所以可以store成功，exclusive标记也同步失效。此时CPU A会再次尝试一轮LL&#x2F;SC的操作，直到store成功。</p><p>而对于非SMP系统即单核系统：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, c_op, asm_op)\</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">unsigned long flags;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">raw_local_irq_save(flags);\</span></span><br><span class="line"><span class="meta">v-&gt;counter c_op i;\</span></span><br><span class="line"><span class="meta">raw_local_irq_restore(flags);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>可以看见直接使用开关中断的方式来实现</li></ul><h4 id="1-2-2-ARM64原子操作"><a href="#1-2-2-ARM64原子操作" class="headerlink" title="1.2.2 ARM64原子操作"></a>1.2.2 ARM64原子操作</h4><p><code>ARM64</code>原子操作相关的代码定义在<code>arch/arm64/include/atomic.h</code>，在此文件的开头有一个包含头文件的操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM64_LSE_ATOMICS) &amp;&amp; defined(CONFIG_AS_LSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/atomic_lse.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/atomic_ll_sc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>CONFIG_ARM64_LSE_ATOMICS</code>这个宏是在 ARMv8.1 架构中引入的一组增强的原子操作（LSE，Large System Extensions），这些操作提供了更高效的原子指令支持。</li><li><code>CONFIG_AS_LSE</code> 可能表示汇编器支持 <code>LSE</code> 指令集。</li><li>因此如果是<code>ARMv8.1</code>架构以后的使用的是<code>&lt;asm/atomic_lse.h&gt;</code>这个头文件，<code>ARMv8.1</code>以前大于<code>ARMV7</code>的使用的是<code>&lt;asm/atomic_ll_sc.h&gt;</code>头文件</li></ul><p>我们先来看<code>&lt;asm/atomic_ll_sc.h&gt;</code>文件即不支持<code>LSE</code>的原子操作是如何实现的：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509142531497.png" alt="image-20240509142531497"></p><p>和<code>ARMV7</code>一样调用<code>ATOMIC_OPS(and, and, )</code>，</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240509142631493.png" alt="image-20240509142631493"></p><p>展开后变成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, asm_op, constraint)\</span></span><br><span class="line"><span class="meta">__LL_SC_INLINE void\</span></span><br><span class="line"><span class="meta">__LL_SC_PREFIX(atomic_add(int i, atomic_t *v))\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">unsigned long tmp;\</span></span><br><span class="line"><span class="meta">int result;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">asm volatile(<span class="string">&quot;// atomic_add &quot;</span>\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>prfmpstl1strm, %2\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>1:ldxr%w0, %2\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>add%w0, %w0, %w3\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>stxr%w1, %w0, %2\n<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>cbnz%w1, 1b<span class="string">&quot;\</span></span></span><br><span class="line"><span class="string"><span class="meta">: &quot;</span>=&amp;r<span class="string">&quot; (result), &quot;</span>=&amp;r<span class="string">&quot; (tmp), &quot;</span>+Q<span class="string">&quot; (v-&gt;counter)\</span></span></span><br><span class="line"><span class="string"><span class="meta">: #constraint &quot;</span>r<span class="string">&quot; (i));\</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;\</span></span></span><br><span class="line"><span class="string"><span class="meta">__LL_SC_EXPORT(atomic_##op);</span></span></span><br></pre></td></tr></table></figure><ul><li><p><code>ldxr</code>和<code>ldrex</code>都是实现原子操作的 Load-Exclusive 指令，但它们适用于不同的 ARM 架构版本。</p></li><li><p>汇编指令详细执行原子操作：</p><ul><li><code>prfm pstl1strm, %2</code>：预取指令，为存储预取数据到一级流式存储器。</li><li><code>ldxr %w0, %2</code>：使用 Load-Exclusive 指令从 <code>v-&gt;counter</code> 加载数据到寄存器 <code>%w0</code>。</li><li><code>#asm_op %w0, %w0, %w3</code>：执行如加法、减法等操作，结果存回 <code>%w0</code>。</li><li><code>stxr %w1, %w0, %2</code>：使用 Store-Exclusive 指令尝试将 <code>%w0</code> 的值存回 <code>v-&gt;counter</code>。</li><li><code>cbnz %w1, 1b</code>：如果 <code>stxr</code> 指示存储失败（寄存器 <code>%w1</code> 不为零），则跳回标签 <code>1</code> 重新尝试。</li></ul></li><li><p>寄存器 <code>result</code> 和 <code>tmp</code> 分别用于存储操作的结果和临时数据。</p></li><li><p>约束 <code>&quot;+Q&quot; (v-&gt;counter)</code> 表示 <code>v-&gt;counter</code> 是一个读写操作数。</p></li><li><p><code>#constraint &quot;r&quot; (i)</code> 表示输入 <code>i</code> 作为寄存器输入，具体的约束由宏的调用者提供。</p></li></ul><p>对于<code>ARMv8.1 </code>架构及以后支持<code>LSE</code>指令集的原子操作实现需要去查看<code>&lt;asm/atomic_lse.h&gt;</code>，在上面的原子实现中，如果<code>stxr</code>指令失败会导致重试，重试一次还好，如果CPU之间竞争比较激烈，可能导致重试的次数较多，所以从2014年的ARMv8.1开始，ARM推出了用于原子操作的LSE(Large System Extension)指令集扩展，新增的指令包括CAS, SWP和LD<OP>, ST<OP>等，其中<OP>可以是ADD, CLR, EOR, SET等。</OP></OP></OP></p><p>来看看代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LL_SC_ATOMIC(op)__LL_SC_CALL(atomic_##op)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, asm_op)\</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">register int w0 asm (<span class="string">&quot;w0&quot;</span>) = i;\</span></span><br><span class="line"><span class="meta">register atomic_t *x1 asm (<span class="string">&quot;x1&quot;</span>) = v;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">asm volatile(\</span></span><br><span class="line"><span class="meta">__LSE_PREAMBLE\</span></span><br><span class="line"><span class="meta">ARM64_LSE_ATOMIC_INSN(__LL_SC_ATOMIC(op),\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;&quot;</span> #asm_op <span class="string">&quot;%w[i], %[v]\n&quot;</span>)\</span></span><br><span class="line"><span class="meta">: [i] <span class="string">&quot;+r&quot;</span> (w0), [v] <span class="string">&quot;+Q&quot;</span> (v-&gt;counter)\</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;r&quot;</span> (x1)\</span></span><br><span class="line"><span class="meta">: __LL_SC_CLOBBERS);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line">ATOMIC_OP(andnot, stclr)</span><br><span class="line">ATOMIC_OP(or, stset)</span><br><span class="line">ATOMIC_OP(xor, steor)</span><br><span class="line">ATOMIC_OP(add, stadd)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>展开后为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define __LL_SC_ATOMIC(op)__LL_SC_CALL(atomic_##op)</span><br><span class="line">#define ATOMIC_OP(op, asm_op)\</span><br><span class="line">static inline void atomic_add(int i, atomic_t *v)\</span><br><span class="line">&#123;\</span><br><span class="line">register int w0 asm (&quot;w0&quot;) = i;\</span><br><span class="line">register atomic_t *x1 asm (&quot;x1&quot;) = v;\</span><br><span class="line">\</span><br><span class="line">asm volatile(\</span><br><span class="line">__LSE_PREAMBLE\</span><br><span class="line">ARM64_LSE_ATOMIC_INSN(__LL_SC_ATOMIC(add),\</span><br><span class="line">&quot;&quot; stdadd&quot;%w[i], %[v]\n&quot;)\</span><br><span class="line">: [i] &quot;+r&quot; (w0), [v] &quot;+Q&quot; (v-&gt;counter)\</span><br><span class="line">: &quot;r&quot; (x1)\</span><br><span class="line">: __LL_SC_CLOBBERS);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ATOMIC_OP(andnot, stclr)</span><br><span class="line">ATOMIC_OP(or, stset)</span><br><span class="line">ATOMIC_OP(xor, steor)</span><br><span class="line">ATOMIC_OP(add, stadd)</span><br></pre></td></tr></table></figure><p>寄存器绑定：</p><ul><li>变量 <code>w0</code> 和 <code>x1</code> 分别绑定到 ARM64 寄存器 <code>w0</code> 和 <code>x1</code>。<code>w0</code> 是用来存储整数 <code>i</code>，而 <code>x1</code> 是用来存储指针 <code>v</code> 的地址。</li><li>使用 <code>asm</code> 关键字显式指定使用哪个寄存器，这有助于在内联汇编代码中直接引用这些寄存器。</li></ul><p>内联汇编：</p><ul><li><code>&quot; &quot; #asm_op &quot; %w[i], %[v]\n&quot;</code>：这是实际执行的原子操作指令，<code>#asm_op</code> 将被替换为传入的汇编操作符，如 <code>stadd</code>。</li><li>输出列表 (<code>[i] &quot;+r&quot; (w0), [v] &quot;+Q&quot; (v-&gt;counter)</code>)：定义了内联汇编修改的变量。<code>+r</code> 表示变量既是输入又是输出，<code>+Q</code> 表示内存操作数，也是读写的。</li><li>输入列表 (<code>&quot;r&quot; (x1)</code>)：提供给汇编的输入。</li><li>被破坏列表 (<code>__LL_SC_CLOBBERS</code>)：可能是一组被这段内联汇编修改的其他寄存器，以确保调用者能够保存和恢复这些寄存器的状态。</li></ul><p>直接一条指令实现了原子操作，类似于x86的lock指令</p><h2 id="2-自旋锁"><a href="#2-自旋锁" class="headerlink" title="2.自旋锁"></a>2.自旋锁</h2><p>自旋锁（spin lock）是一种非阻塞锁，也就是说，如果某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗 CPU 的时间，不停的试图获取锁。</p><p>内核中以 <code>spinlock_t </code>结构体来表示自旋锁，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock_types.h” 文件中，如下所示</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u8 __padding[LOCK_PADSIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line"><span class="type">arch_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> magic, owner_cpu;</span><br><span class="line"><span class="type">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure><ul><li><code>spinlock_t</code>这个结构体实际使用的是<code>raw_spinlock_t</code></li><li><code>raw_spinlock_t</code>内部使用的是<code>arch_spinlock_t</code>，一看就是一个和体系结构相关的自旋锁</li></ul><p>自旋锁相关 <code>API</code> 函数定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中，部分 API 函数如下所示</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>DEFINE_SPINLOCK(spinlock_t lock)</td><td>定义并初始化自旋锁</td></tr><tr><td>int spin_lock_init(spinlock_t *lock)</td><td>初始化自旋锁</td></tr><tr><td>void spin_lock(spinlock_t *lock)</td><td>获取指定的自旋锁，也叫做加锁</td></tr><tr><td>void spin_unlock(spinlock_t *lock)</td><td>释放指定的自旋锁</td></tr><tr><td>int spin_trylock(spinlock_t *lock)</td><td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td></tr><tr><td>int spin_is_locked(spinlock_t *lock)</td><td>检查指定的自旋锁是否被获取，如果没有被获取就返回非 0，否则返回0</td></tr></tbody></table><p>自旋锁的使用步骤：</p><ul><li><p>在访问临界资源的时候先申请自旋锁</p></li><li><p>获取到自旋锁之后就进入临界区，获取不到自旋锁就“原地等待”。</p></li><li><p>退出临界区的时候要释放自旋锁。</p></li></ul><p>我们要去分析自旋锁的代码实际上就是要去看<code>arch_spinlock_t</code>的相关操作，回到“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock_types.h”的最上面即<code>raw_spinlock_t</code>定义的地方<br><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240510171732998.png" alt="image-20240510171732998"></p><ul><li>如果是<code>SMP</code>系统使用的是<code>&lt;asm/spinlock_types.h&gt;</code>，否则使用的是<code>&lt;linux/spinlock_types_up.h&gt;</code></li></ul><p>到这里就到了自旋锁的分水岭，单核情况和多核情况自旋锁是完全不同的，这里先引入一个概念，关于抢占式内核与非抢占式内核：</p><ul><li><p>在非抢占式内核中，如果一个进程在内核态运行，其只有在以下两种情况会被切换：</p><ol><li>其运行完成（返回用户空间）</li><li>主动让出cpu（即主动调用schedule或内核中的任务阻塞——这同样也会导致调用schedule）</li></ol></li><li><p>在抢占式内核中，如果一个进程在内核态运行，其只有在以下四种情况会被切换：</p></li></ul><ol><li>其运行完成（返回用户空间）</li><li>主动让出cpu（即主动调用schedule或内核中的任务阻塞——这同样也会导致调用schedule）</li><li>当从中断处理程序正在执行，且返回内核空间之前（此时可抢占标志premptcount须为0）</li><li>当内核代码再一次具有可抢占性的时候，如解锁及使能软中断等。</li></ol><p><code>linux</code>内核是一个可抢占的内核， 在单cpu，可抢占内核中，自旋锁实现为“禁止内核抢占”，并不实现“自旋”。禁止内核抢占只是关闭“可抢占标志”，而不是禁止进程切换。显式使用schedule或进程阻塞（此也会导致调用schedule）时，还是会发生进程调度的。这也符合自旋锁的作用，加上自旋锁的线程是不会被阻塞的，禁止抢占会防止线程从运行态被切换。在多cpu，可抢占内核中，自旋锁实现为“禁止内核抢占” + “自旋”。</p><h3 id="2-1-单核情况下自旋锁的实现"><a href="#2-1-单核情况下自旋锁的实现" class="headerlink" title="2.1 单核情况下自旋锁的实现"></a>2.1 单核情况下自旋锁的实现</h3><p>有了上面的概念我们再来看单核情况下自旋锁的实现，上面说到我们需要去<code>&lt;linux/spinlock_types_up.h&gt;</code>寻找<code>arch_spinlock_t</code>的定义：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240518113330340.png" alt="image-20240518113330340"></p><p>可以看见是一个空的结构体，然后我们来看加锁函数<code>spin_lock</code>，定义在<code>include/linux/spinlock.h</code>中，此函数会去掉用<code>raw_spin_lock</code>的宏，这个宏也在此头文件中，然后会去调用<code>_raw_spin_lock</code>，此宏定义在<code>include/linux/spinlock_api_up.h</code>中，它会去调用<code>__LOCK</code>宏，<code>__LOCK</code>会调用<code>___LOCK</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/spinlock_api_up.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock)__LOCK(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___LOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; __acquire(lock); (void)(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; preempt_disable(); ___LOCK(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/compiler_types.h</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __acquire(x) (void)0</span></span><br></pre></td></tr></table></figure><ul><li>可以看见先做了<code>preempt_disable();</code>操作，用于禁止抢占</li><li>然后执行<code>__acquire(lock);</code>，可以看见就是将<code>lock</code>置为0，然后<code>(void)(lock);</code>置为空</li><li>所以在单核情况下自旋锁除了关闭内核抢占，什么都没做</li></ul><p>对于锁的释放<code>spin_unlock</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_unlock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_unlock(lock)_raw_spin_unlock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/spinlock_api_up.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_unlock(lock)__UNLOCK(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UNLOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; preempt_enable(); ___UNLOCK(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___UNLOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; (void)(lock); &#125; while (0)</span></span><br></pre></td></tr></table></figure><ul><li>调用<code> preempt_enable();</code>重新开启cpu的内核抢占</li></ul><h3 id="2-2-多核情况下自旋锁的实现"><a href="#2-2-多核情况下自旋锁的实现" class="headerlink" title="2.2 多核情况下自旋锁的实现"></a>2.2 多核情况下自旋锁的实现</h3><p>在多核情况下<code>arch_spinlock_t</code>的需要包含<code>&lt;asm/spinlock_types.h&gt;</code>中，这是一个和体系架构相关的头文件，在<code>x86</code>、<code>ARM32</code>、<code>ARM64</code>下的实现是不一样的，</p><h4 id="2-2-1-ARM32"><a href="#2-2-1-ARM32" class="headerlink" title="2.2.1 ARM32"></a>2.2.1 ARM32</h4><p>首先来看<code>ARM32</code>的实现，用到的头文件为“内核源码&#x2F;arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;spinlock_types.h”</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TICKET_SHIFT16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">u32 slock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">raw_tickets</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARMEB__</span></span><br><span class="line">u16 next;</span><br><span class="line">u16 owner;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">u16 owner;</span><br><span class="line">u16 next;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; tickets;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="type">arch_spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED&#123; &#123; 0 &#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>arch_spinlock_t</code>结构体内部是一个联合体，简单来说就是存放一个<code>u32</code>类型的数据，把一个<code>u32</code>拆分成两个<code>u16</code>，分别为<code>next</code>和 <code>owner</code></p><ul><li><code>owner</code>表示持有这个数字的线程可以获取自旋锁</li><li><code>next</code>表示如果后续再有线程请求获取这个自旋锁，就为此线程分配这个数字</li></ul></li><li><p><code>__ARMEB__</code>这个宏是标识大端和小端的</p></li><li><p><code>next</code>和<code>owner</code>设计的原因是为了保证<code>spinlock</code>的公平性，先申请持有锁的线程先拿到锁，举个例子</p><p>1.刚开始<code>owner=next=0</code>;<br>2.第一个thread获取<code>spinlock</code>，可获取成功，此时<code>owner=0,next=0</code><br>3.第二个thread获取spinlock,如果第一个thread 还没有释放spinlock，则next++,next变为1;</p><p>4.第三个thread获取spinlock,如果第一个thread 还没有释放spinlock，则next++,next变为2;</p><p>5.此时第一个thread释放spinlock，则执行<code>owner++,owner=1;</code></p><p>6.虽然此时第二个thread和第三个thread都在等待spinlock,但是因为第二个thread的next&#x3D;owner,所以第二个thread可以获取到spinlock，第三个thread则继续等待。</p><p>这样保证了spinlock的唤醒机制是先到先唤醒，后到后唤醒保证了公平性。</p></li></ul><p>基于上面的设计我们来看一下加锁操作，在<code>内核源码/include/linux/spinlock.h</code>中：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240519123433508.png" alt="image-20240519123433508"></p><p>初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spin_lock_init(_lock)\</span></span><br><span class="line"><span class="meta">do &#123;\</span></span><br><span class="line"><span class="meta">spinlock_check(_lock);\</span></span><br><span class="line"><span class="meta">raw_spin_lock_init(&amp;(_lock)-&gt;rlock);\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> raw_spin_lock_init(lock)\</span></span><br><span class="line"><span class="meta">do &#123; *(lock) = __RAW_SPIN_LOCK_UNLOCKED(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  include/linux/spinlock_types.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RAW_SPIN_LOCK_INITIALIZER(lockname)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,\</span></span><br><span class="line"><span class="meta">SPIN_DEBUG_INIT(lockname)\</span></span><br><span class="line"><span class="meta">SPIN_DEP_MAP_INIT(lockname) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RAW_SPIN_LOCK_UNLOCKED(lockname)\</span></span><br><span class="line"><span class="meta">(raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER(lockname)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  arch/arm/include/asm/spinlock_types.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED&#123; &#123; 0 &#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>可以看见初始化锁最后会调用到<code>arch/arm/include/asm/spinlock_types.h</code>文件中的<code>__ARCH_SPIN_LOCK_UNLOCKED</code>来将自旋锁中的<code>.raw_lock</code>成员初始化为0，在上面的自旋锁的定义中<code>arch_spinlock_t raw_lock;</code>最后实际上就是将<code>arch_spinlock_t</code>结构体中的<code>u32</code>变成了0，即初始化时<code>next=0 , owner=0</code></li></ul><p>加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include\linux\spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock) __raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">acquires</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">__acquire(lock);</span><br><span class="line">arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  arch/arm/include/asm/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_spin_lock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line">u32 newval;</span><br><span class="line"><span class="type">arch_spinlock_t</span> lockval;</span><br><span class="line"></span><br><span class="line">prefetchw(&amp;lock-&gt;slock);</span><br><span class="line">__asm__ __volatile__(</span><br><span class="line"><span class="string">&quot;1:ldrex%0, [%3]\n&quot;</span></span><br><span class="line"><span class="string">&quot;add%1, %0, %4\n&quot;</span></span><br><span class="line"><span class="string">&quot;strex%2, %1, [%3]\n&quot;</span></span><br><span class="line"><span class="string">&quot;teq%2, #0\n&quot;</span></span><br><span class="line"><span class="string">&quot;bne1b&quot;</span></span><br><span class="line">: <span class="string">&quot;=&amp;r&quot;</span> (lockval), <span class="string">&quot;=&amp;r&quot;</span> (newval), <span class="string">&quot;=&amp;r&quot;</span> (tmp)</span><br><span class="line">: <span class="string">&quot;r&quot;</span> (&amp;lock-&gt;slock), <span class="string">&quot;I&quot;</span> (<span class="number">1</span> &lt;&lt; TICKET_SHIFT)</span><br><span class="line">: <span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (lockval.tickets.next != lockval.tickets.owner) &#123;</span><br><span class="line">wfe();</span><br><span class="line">lockval.tickets.owner = READ_ONCE(lock-&gt;tickets.owner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smp_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>spin_lock</code>加锁，对于<code>ARM32</code>最终会调用到<code>arch_spin_lock</code></p></li><li><p><code>ldrex %0, [%3]</code>：将 <code>[lock-&gt;slock]</code> 的值加载到 <code>lockval</code> 中，并设置一个独占标志。就是加载锁的那个<code>u32</code>的值到<code>lockval</code>中。存储一个锁的值的本地副本<code>lockval</code></p></li><li><p><code>add %1, %0, %4</code>：将 <code>lockval</code> 和 <code>1 &lt;&lt; TICKET_SHIFT</code> 相加，结果存储在 <code>newval</code> 中。<code>TICKET_SHIFT</code>的值为<code>16</code>，即将高16位加一，那么<code>newval</code>的<code>next</code>就加一了</p></li><li><p><code>strex %2, %1, [%3]</code>：将 <code>newval</code> 写入到 <code>[lock-&gt;slock]</code> 中，如果成功（即 <code>tmp</code> 为 0），则表示锁获取成功，否则重试。</p></li><li><p>执行完毕上面的操作后就是将锁的<code>u32</code>的值的<code>next</code>加一了，然后保存了一个本地的副本值，<code>lockval</code>的<code>next</code>值是上一次未加一的值</p></li><li><p>然后下面有个<code>while</code>循环会去判断<code>lockval</code>的<code>owner</code>值和<code>next</code>值是否相等，如果不等，则去加载最新的<code>lock</code>的<code>owner</code>的值，上面提到如果有线程释放锁了，会去将<code>lock</code>的<code>owner</code>值加一，因此如果最新的<code>owner</code>值和本地线程维护的<code>next</code>值相等了就说明本地线程可以不用循环等待了</p></li><li><p>在循环内部会调用一个<code>wfe()</code>函数，这个函数是用于使当前的cpu处于低功耗状态，如果说其他核心上的线程还在持有锁并没有释放，我们可以让当前线程不用一直自旋，直接使其进入低功耗状态，当锁释放时再唤醒</p></li></ul><p>解锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_unlock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_unlock(lock)_raw_spin_unlock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include\linux\spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_unlock(lock) __raw_spin_unlock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_unlock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">spin_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">do_raw_spin_unlock(lock);</span><br><span class="line">preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_unlock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">releases</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">arch_spin_unlock(&amp;lock-&gt;raw_lock);</span><br><span class="line">__release(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  arch/arm/include/asm/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_spin_unlock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">smp_mb();</span><br><span class="line">lock-&gt;tickets.owner++;</span><br><span class="line">dsb_sev();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可以看见解锁操作就是将<code>owner</code>的值加一</li><li>然后唤醒，上面提到其余没有拿到锁的线程会自旋然后进入低功耗状态，调用<code>dsb_sev();</code>就可以唤醒cpu，因为此时<code>owner</code>的值加一了</li></ul><h4 id="2-2-2-ARM64和X86"><a href="#2-2-2-ARM64和X86" class="headerlink" title="2.2.2 ARM64和X86"></a>2.2.2 ARM64和X86</h4><p>在<code>ARM64</code>和<code>x86</code>平台下，先要去找<code>arch_spinlock_t</code>的定义，去<code>arch/arm64/include/asm/spinlock_types.h</code>中寻找：</p><p><img src="/2024/05/07/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20240519134302875.png" alt="image-20240519134302875"></p><p>可以看见会去包含：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/qspinlock_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/qrwlock_types.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>进入<code>/include/asm-generic/qspinlock_types.h</code>，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qspinlock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">atomic_t</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By using the whole 2nd least significant byte for the</span></span><br><span class="line"><span class="comment"> * pending bit, we can allow better optimization of the lock</span></span><br><span class="line"><span class="comment"> * acquisition for the pending bit holder.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LITTLE_ENDIAN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u8locked;</span><br><span class="line">u8pending;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u16locked_pending;</span><br><span class="line">u16tail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u16tail;</span><br><span class="line">u16locked_pending;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u8reserved[<span class="number">2</span>];</span><br><span class="line">u8pending;</span><br><span class="line">u8locked;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="type">arch_spinlock_t</span>;</span><br></pre></td></tr></table></figure><p>在这里定义了<code>arch_spinlock_t</code>，<code>__LITTLE_ENDIAN</code>用于判断大端和小端，可以看见使用了一个32位的原子变量</p><p>来看加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include\linux\spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock) __raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  include/linux/spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">acquires</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">__acquire(lock);</span><br><span class="line">arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include\asm-generic\qspinlock.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_spin_lock(l)queued_spin_lock(l)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">queued_spin_lock</span><span class="params">(<span class="keyword">struct</span> qspinlock *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 val;</span><br><span class="line"></span><br><span class="line">val = atomic_cmpxchg_acquire(&amp;lock-&gt;val, <span class="number">0</span>, _Q_LOCKED_VAL);</span><br><span class="line"><span class="keyword">if</span> (likely(val == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">queued_spin_lock_slowpath(lock, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现十分复杂，后续再分析……</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * queued_spin_lock_slowpath - acquire the queued spinlock</span></span><br><span class="line"><span class="comment"> * @lock: Pointer to queued spinlock structure</span></span><br><span class="line"><span class="comment"> * @val: Current value of the queued spinlock 32-bit word</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (queue tail, pending bit, lock value)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              fast     :    slow                                  :    unlock</span></span><br><span class="line"><span class="comment"> *                       :                                          :</span></span><br><span class="line"><span class="comment"> * uncontended  (0,0,0) -:--&gt; (0,0,1) ------------------------------:--&gt; (*,*,0)</span></span><br><span class="line"><span class="comment"> *                       :       | ^--------.------.             /  :</span></span><br><span class="line"><span class="comment"> *                       :       v           \      \            |  :</span></span><br><span class="line"><span class="comment"> * pending               :    (0,1,1) +--&gt; (0,1,0)   \           |  :</span></span><br><span class="line"><span class="comment"> *                       :       | ^--&#x27;              |           |  :</span></span><br><span class="line"><span class="comment"> *                       :       v                   |           |  :</span></span><br><span class="line"><span class="comment"> * uncontended           :    (n,x,y) +--&gt; (n,0,0) --&#x27;           |  :</span></span><br><span class="line"><span class="comment"> *   queue               :       | ^--&#x27;                          |  :</span></span><br><span class="line"><span class="comment"> *                       :       v                               |  :</span></span><br><span class="line"><span class="comment"> * contended             :    (*,x,y) +--&gt; (*,0,0) ---&gt; (*,0,1) -&#x27;  :</span></span><br><span class="line"><span class="comment"> *   queue               :         ^--&#x27;                             :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queued_spin_lock_slowpath</span><span class="params">(<span class="keyword">struct</span> qspinlock *lock, u32 val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mcs_spinlock</span> *<span class="title">prev</span>, *<span class="title">next</span>, *<span class="title">node</span>;</span></span><br><span class="line">u32 old, tail;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">BUILD_BUG_ON(CONFIG_NR_CPUS &gt;= (<span class="number">1U</span> &lt;&lt; _Q_TAIL_CPU_BITS));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pv_enabled())</span><br><span class="line"><span class="keyword">goto</span> pv_queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (virt_spin_lock(lock))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait for in-progress pending-&gt;locked hand-overs with a bounded</span></span><br><span class="line"><span class="comment"> * number of spins so that we guarantee forward progress.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,1,0 -&gt; 0,0,1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (val == _Q_PENDING_VAL) &#123;</span><br><span class="line"><span class="type">int</span> cnt = _Q_PENDING_LOOPS;</span><br><span class="line">val = atomic_cond_read_relaxed(&amp;lock-&gt;val,</span><br><span class="line">       (VAL != _Q_PENDING_VAL) || !cnt--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we observe any contention; queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (val &amp; ~_Q_LOCKED_MASK)</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * trylock || pending</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,0,0 -&gt; 0,0,1 ; trylock</span></span><br><span class="line"><span class="comment"> * 0,0,1 -&gt; 0,1,1 ; pending</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">val = queued_fetch_set_pending_acquire(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we observe any contention; undo and queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(val &amp; ~_Q_LOCKED_MASK)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(val &amp; _Q_PENDING_MASK))</span><br><span class="line">clear_pending(lock);</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We&#x27;re pending, wait for the owner to go away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,1,1 -&gt; 0,1,0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this wait loop must be a load-acquire such that we match the</span></span><br><span class="line"><span class="comment"> * store-release that clears the locked bit and create lock</span></span><br><span class="line"><span class="comment"> * sequentiality; this is because not all</span></span><br><span class="line"><span class="comment"> * clear_pending_set_locked() implementations imply full</span></span><br><span class="line"><span class="comment"> * barriers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (val &amp; _Q_LOCKED_MASK)</span><br><span class="line">atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_MASK));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * take ownership and clear the pending bit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0,1,0 -&gt; 0,0,1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clear_pending_set_locked(lock);</span><br><span class="line">qstat_inc(qstat_lock_pending, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * End of pending bit optimistic spinning and beginning of MCS</span></span><br><span class="line"><span class="comment"> * queuing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">queue</span>:</span><br><span class="line">qstat_inc(qstat_lock_slowpath, <span class="literal">true</span>);</span><br><span class="line">pv_queue:</span><br><span class="line">node = this_cpu_ptr(&amp;mcs_nodes[<span class="number">0</span>]);</span><br><span class="line">idx = node-&gt;count++;</span><br><span class="line">tail = encode_tail(smp_processor_id(), idx);</span><br><span class="line"></span><br><span class="line">node += idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure that we increment the head node-&gt;count before initialising</span></span><br><span class="line"><span class="comment"> * the actual node. If the compiler is kind enough to reorder these</span></span><br><span class="line"><span class="comment"> * stores, then an IRQ could overwrite our assignments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">barrier();</span><br><span class="line"></span><br><span class="line">node-&gt;locked = <span class="number">0</span>;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">pv_init_node(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We touched a (possibly) cold cacheline in the per-cpu queue node;</span></span><br><span class="line"><span class="comment"> * attempt the trylock once more in the hope someone let go while we</span></span><br><span class="line"><span class="comment"> * weren&#x27;t watching.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (queued_spin_trylock(lock))</span><br><span class="line"><span class="keyword">goto</span> release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure that the initialisation of @node is complete before we</span></span><br><span class="line"><span class="comment"> * publish the updated tail via xchg_tail() and potentially link</span></span><br><span class="line"><span class="comment"> * @node into the waitqueue via WRITE_ONCE(prev-&gt;next, node) below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">smp_wmb();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Publish the updated tail.</span></span><br><span class="line"><span class="comment"> * We have already touched the queueing cacheline; don&#x27;t bother with</span></span><br><span class="line"><span class="comment"> * pending stuff.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * p,*,* -&gt; n,*,*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">old = xchg_tail(lock, tail);</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * if there was a previous node; link it and wait until reaching the</span></span><br><span class="line"><span class="comment"> * head of the waitqueue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (old &amp; _Q_TAIL_MASK) &#123;</span><br><span class="line">prev = decode_tail(old);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Link @node into the waitqueue. */</span></span><br><span class="line">WRITE_ONCE(prev-&gt;next, node);</span><br><span class="line"></span><br><span class="line">pv_wait_node(node, prev);</span><br><span class="line">arch_mcs_spin_lock_contended(&amp;node-&gt;locked);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While waiting for the MCS lock, the next pointer may have</span></span><br><span class="line"><span class="comment"> * been set by another lock waiter. We optimistically load</span></span><br><span class="line"><span class="comment"> * the next pointer &amp; prefetch the cacheline for writing</span></span><br><span class="line"><span class="comment"> * to reduce latency in the upcoming MCS unlock operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">next = READ_ONCE(node-&gt;next);</span><br><span class="line"><span class="keyword">if</span> (next)</span><br><span class="line">prefetchw(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * we&#x27;re at the head of the waitqueue, wait for the owner &amp; pending to</span></span><br><span class="line"><span class="comment"> * go away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * *,x,y -&gt; *,0,0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this wait loop must use a load-acquire such that we match the</span></span><br><span class="line"><span class="comment"> * store-release that clears the locked bit and create lock</span></span><br><span class="line"><span class="comment"> * sequentiality; this is because the set_locked() function below</span></span><br><span class="line"><span class="comment"> * does not imply a full barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The PV pv_wait_head_or_lock function, if active, will acquire</span></span><br><span class="line"><span class="comment"> * the lock and return a non-zero value. So we have to skip the</span></span><br><span class="line"><span class="comment"> * atomic_cond_read_acquire() call. As the next PV queue head hasn&#x27;t</span></span><br><span class="line"><span class="comment"> * been designated yet, there is no way for the locked value to become</span></span><br><span class="line"><span class="comment"> * _Q_SLOW_VAL. So both the set_locked() and the</span></span><br><span class="line"><span class="comment"> * atomic_cmpxchg_relaxed() calls will be safe.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If PV isn&#x27;t active, 0 will be returned instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((val = pv_wait_head_or_lock(lock, node)))</span><br><span class="line"><span class="keyword">goto</span> locked;</span><br><span class="line"></span><br><span class="line">val = atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_PENDING_MASK));</span><br><span class="line"></span><br><span class="line">locked:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * claim the lock:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * n,0,0 -&gt; 0,0,1 : lock, uncontended</span></span><br><span class="line"><span class="comment"> * *,*,0 -&gt; *,*,1 : lock, contended</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the queue head is the only one in the queue (lock value == tail)</span></span><br><span class="line"><span class="comment"> * and nobody is pending, clear the tail code and grab the lock.</span></span><br><span class="line"><span class="comment"> * Otherwise, we only need to grab the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In the PV case we might already have _Q_LOCKED_VAL set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The atomic_cond_read_acquire() call above has provided the</span></span><br><span class="line"><span class="comment"> * necessary acquire semantics required for locking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (((val &amp; _Q_TAIL_MASK) == tail) &amp;&amp;</span><br><span class="line">    atomic_try_cmpxchg_relaxed(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL))</span><br><span class="line"><span class="keyword">goto</span> release; <span class="comment">/* No contention */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Either somebody is queued behind us or _Q_PENDING_VAL is set */</span></span><br><span class="line">set_locked(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * contended path; wait for next if not observed yet, release.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!next)</span><br><span class="line">next = smp_cond_load_relaxed(&amp;node-&gt;next, (VAL));</span><br><span class="line"></span><br><span class="line">arch_mcs_spin_unlock_contended(&amp;next-&gt;locked);</span><br><span class="line">pv_kick_node(lock, next);</span><br><span class="line"></span><br><span class="line">release:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * release the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__this_cpu_dec(mcs_nodes[<span class="number">0</span>].count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h2><p><code>Linux</code> 内核使用 <code>semaphore</code> 结构体来表示信号量，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;semaphore.h”文件内</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Please don&#x27;t access any members of this structure directly */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line"><span class="type">raw_spinlock_t</span>lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与信号量相关的 API 函数同样定义在 semaphore.h 文件内，部分常用 API 函数如下所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_SEAMPHORE(name)</code></td><td>定义信号量，并且设置信号量的值为 1。</td></tr><tr><td><code>void sema_init(struct semaphore *sem, int val)</code></td><td>初始化信号量 sem，设置信号量值为 val。</td></tr><tr><td><code>void down(struct semaphore *sem)</code></td><td>获取信号量，不能被中断打断，如 ctrl+c</td></tr><tr><td><code>int down_interruptible(struct semaphore *sem)</code></td><td>获取信号量，可以被中断打断，如 ctrl+c</td></tr><tr><td><code>void up(struct semaphore *sem)</code></td><td>释放信号量</td></tr><tr><td><code>int down_trylock(struct semaphore *sem);</code></td><td>尝试获取信号量，如果能获取到信号量就获取，并且返回 0</td></tr></tbody></table><p>在<code>semaphore</code> 结构体的定义中，包含一个自旋锁，一个计数的<code>count</code>值，一个双向链表</p><p>先来看定义信号量的宏以及初始化函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/semaphore.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SEMAPHORE_INITIALIZER(name, n)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">.lock= __RAW_SPIN_LOCK_UNLOCKED((name).lock),\</span></span><br><span class="line"><span class="meta">.count= n,\</span></span><br><span class="line"><span class="meta">.wait_list= LIST_HEAD_INIT((name).wait_list),\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SEMAPHORE(name)\</span></span><br><span class="line"><span class="meta">struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">*sem = (<span class="keyword">struct</span> semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">&quot;semaphore-&gt;lock&quot;</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化了自旋锁</li><li>然后初始化了<code>count</code>值</li><li>初始化了双向链表，这个链表用于挂载阻塞在此信号量上的线程的结构体指针</li></ul><p>加锁函数即<code>down</code>函数，获取一个锁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/semaphore.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">sem-&gt;count--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__down(sem);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __down(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __sched __down_common(<span class="keyword">struct</span> semaphore *sem, <span class="type">long</span> state,</span><br><span class="line"><span class="type">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"></span><br><span class="line">list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list);</span><br><span class="line">waiter.task = current;</span><br><span class="line">waiter.up = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (signal_pending_state(state, current))</span><br><span class="line"><span class="keyword">goto</span> interrupted;</span><br><span class="line"><span class="keyword">if</span> (unlikely(timeout &lt;= <span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> timed_out;</span><br><span class="line">__set_current_state(state);</span><br><span class="line">raw_spin_unlock_irq(&amp;sem-&gt;lock);</span><br><span class="line">timeout = schedule_timeout(timeout);</span><br><span class="line">raw_spin_lock_irq(&amp;sem-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (waiter.up)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> timed_out:</span><br><span class="line">list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line"> interrupted:</span><br><span class="line">list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>raw_spin_lock_irqsave</code>加锁</p></li><li><p>如果<code>count</code>的值大于0，则将信号量的<code>count</code>值减一，如果<code>count</code>的值小于等于0，则会去执行<code>__down</code>函数，最终会去调用到<code>__down_common</code>函数，传入的参数为<code>TASK_UNINTERRUPTIBLE</code>和<code>MAX_SCHEDULE_TIMEOUT</code></p><ul><li><code>TASK_UNINTERRUPTIBLE</code>：线程已经进入睡眠状态，且不可被打断</li><li><code>MAX_SCHEDULE_TIMEOUT</code>：线程调度超时时间</li></ul></li><li><p>如果进入了<code>__down_common</code>函数就说明当前的线程拿不到信号量，那么当前线程应该干嘛呢，肯定不能傻傻的干等，因此当前线程会休眠，当持有信号量的线程释放信号量后再通知阻塞在此信号量的线程从而将其唤醒去执行，<code>__down_common</code>函数就是在做这一件事情</p><ul><li><p>首先定了一个<code>semaphore_waiter</code>，包含一个链表节点和一个<code>task_struct</code>，<code>task_struct</code>可用于代表当前线程，<code>current</code>就代表了当前线程的<code>task_struct</code>的指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="type">bool</span> up;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">waiter.task = current;</span><br><span class="line">waiter.up = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后调用<code>list_add_tail(&amp;waiter.list, &amp;*sem*-&gt;wait_list);</code>将这个<code>semaphore_waiter</code>挂载在信号量的<code>wait_list</code>链表上，因此当持有信号量的线程释放后就可以通过这个等待链表去唤醒其他阻塞的线程，唤醒其实就是将这个<code>bool</code>的<code>up</code>值置为<code>true</code></p></li><li><p>在<code>for</code>循环内部，会先去调用<code>signal_pending_state</code>去检测线程在当前状态下是否有信号需要处理，我们出入的进程状态为<code>TASK_UNINTERRUPTIBLE</code>，即在此状态下有信号需要处理也需要返回。</p></li><li><p>然后由于传入的<code>MAX_SCHEDULE_TIMEOUT</code>是一个很大的值，因此<code>timed_out</code>应该也是不会超时的</p></li><li><p>调用<code>__set_current_state</code>来设置当前线程的状态</p></li><li><p><code>raw_spin_unlock_irq</code>解锁，这里为什么要先解锁呢，那是因为下面执行的<code>schedule_timeout</code>会导致当前的线程睡眠，而自旋锁保护的临界资源是不允许睡眠的，<code>schedule_timeout</code>是去执行调度切换当前线程，再次切换回来后会去执行<code>raw_spin_lock_irq</code>加锁操作，然后去判断<code>waiter.up</code>是否为<code>true</code>如果为<code>true</code>说明当前线程被唤醒否则继续执行<code>for</code>循环一直等</p></li></ul></li><li><p>调用<code>raw_spin_unlock_irqrestore</code>开锁</p></li></ul><p>解锁操作，即<code>up</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/semaphore.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list)))</span><br><span class="line">sem-&gt;count++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__up(sem);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __up(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> =</span> list_first_entry(&amp;sem-&gt;wait_list,</span><br><span class="line"><span class="keyword">struct</span> semaphore_waiter, <span class="built_in">list</span>);</span><br><span class="line">list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">waiter-&gt;up = <span class="literal">true</span>;</span><br><span class="line">wake_up_process(waiter-&gt;task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先判断信号量的等待链表是否为空，如果等待的线程为空则直接将<code>count</code>值加一</li><li>不为空去执行<code>__up</code>函数，可以看见在此函数内部就是从等待链表上先取出一个等待的线程，然后从等待链表中删除，将此线程的<code>up </code>置为<code>true</code>，最后去唤醒此线程</li></ul><p>最后说一下这里的加锁操作我们使用的是<code>raw_spin_lock_irqsave</code>，它和我们上面讲自旋锁使用的<code>spin_unlock</code>的区别就在于加了<code>irq</code>的会去禁用本地中断，我们以多核系统为例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock_irq(lock)_raw_spin_lock_irq(lock)</span></span><br><span class="line"><span class="comment">// spinlock_api_smp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock_irq(lock) __raw_spin_lock_irq(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock_irq(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">local_irq_disable();</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">acquires</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">__acquire(lock);</span><br><span class="line">arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看见只是在<code>__raw_spin_lock_irq</code>中会去调用<code>local_irq_disable();</code>禁止本地中断，然后最后会去调用<code>arch_spin_lock</code>加锁</li><li>在使用<code>spin_lock</code>时要明确知道该锁不会在中断处理程序中使用,如果在中断处理程序中也使用了&#96;&#96;spin_lock<code>就会导致死锁，在任何情况下使用</code>spin_lock_irq&#96;都是安全的。因为它既禁止本地中断，又禁止内核抢占。</li></ul><h2 id="4-互斥锁"><a href="#4-互斥锁" class="headerlink" title="4. 互斥锁"></a>4. 互斥锁</h2><p>内核中以<code>mutex</code>结构体来表示互斥体，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;mutex.h”文件中，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line"><span class="type">atomic_long_t</span>owner;</span><br><span class="line"><span class="type">spinlock_t</span>wait_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line"><span class="type">void</span>*magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span><span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>可以看见互斥锁的实现其实和信号量类似，不同的是互斥锁在任何时刻只会有一个线程可以持有锁，而信号量可以多个，在互斥锁的内部同样有一个挂载等待线程的链表<code>wait_list</code>，以及一个原子变量<code>owner</code></li><li>包含一个互斥锁用于加锁操作</li></ul><p>一些和互斥体相关的 API 函数也定义在 <code>mutex.h</code> 文件中，常用 API 函数如下所示</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_MUTEX(name)</code></td><td>定义并初始化一个 mutex 变量。</td></tr><tr><td><code>void mutex_init(mutex *lock)</code></td><td>初始化 mutex。</td></tr><tr><td><code>void mutex_lock(struct mutex *lock)</code></td><td>获取 mutex，也就是给 mutex 上锁。</td></tr><tr><td><code>void mutex_unlock(struct mutex *lock)</code></td><td>释放 mutex，也就给 mutex 解锁。</td></tr><tr><td><code>int mutex_is_locked(struct mutex *lock)</code></td><td>判断 mutex 是否被获取，如果是的话就返回1，否则返回0</td></tr></tbody></table><p>初始化和加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/mutex.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">&#123; .owner = ATOMIC_LONG_INIT(0) \</span></span><br><span class="line"><span class="meta">, .wait_lock = __SPIN_LOCK_UNLOCKED(lockname.wait_lock) \</span></span><br><span class="line"><span class="meta">, .wait_list = LIST_HEAD_INIT(lockname.wait_list) \</span></span><br><span class="line"><span class="meta">__DEBUG_MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">__DEP_MAP_MUTEX_INITIALIZER(lockname) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_MUTEX(mutexname) \</span></span><br><span class="line"><span class="meta">struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mutex_init(mutex)\</span></span><br><span class="line"><span class="meta">do &#123;\</span></span><br><span class="line"><span class="meta">static struct lock_class_key __key;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">__mutex_init((mutex), #mutex, &amp;__key);\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line"><span class="type">void</span> __mutex_init(<span class="keyword">struct</span> mutex *lock, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">atomic_long_set(&amp;lock-&gt;owner, <span class="number">0</span>);</span><br><span class="line">spin_lock_init(&amp;lock-&gt;wait_lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;lock-&gt;wait_list);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">osq_lock_init(&amp;lock-&gt;osq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">debug_mutex_init(lock, name, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DEFINE_MUTEX</code>宏会去调用<code>__MUTEX_INITIALIZER</code>来定义和初始化一个互斥锁，将互斥锁的<code>owner</code>赋值为0，初始化互斥锁和等待链表</li><li><code>mutex_init</code>宏会去调用<code>__mutex_init</code>，同样内部会先将<code>owner</code>的值设置为0，初始化互斥锁，初始化等待链表</li></ul><p>加锁操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_lock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!__mutex_trylock_fast(lock))</span><br><span class="line">__mutex_lock_slowpath(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span> __mutex_trylock_fast(<span class="keyword">struct</span> mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> curr = (<span class="type">unsigned</span> <span class="type">long</span>)current;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> zero = <span class="number">0UL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (atomic_long_try_cmpxchg_acquire(&amp;lock-&gt;owner, &amp;zero, curr))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched</span><br><span class="line">__mutex_lock_slowpath(<span class="keyword">struct</span> mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">__mutex_lock(lock, TASK_UNINTERRUPTIBLE, <span class="number">0</span>, <span class="literal">NULL</span>, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __sched</span><br><span class="line">__mutex_lock(<span class="keyword">struct</span> mutex *lock, <span class="type">long</span> state, <span class="type">unsigned</span> <span class="type">int</span> subclass,</span><br><span class="line">     <span class="keyword">struct</span> lockdep_map *nest_lock, <span class="type">unsigned</span> <span class="type">long</span> ip)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __mutex_lock_common(lock, state, subclass, nest_lock, ip, <span class="literal">NULL</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>might_sleep();</code>不用管，如果没有调试的需要(没有定义CONFIG_DEBUG_ATOMIC_SLEEP)，这个宏&#x2F;函数什么事情都不，might_sleep就是一个空函数，所以平常看code的时候可以忽略。内核只是用它来提醒开发人员，调用该函数的函数可能会sleep。</p></li><li><p>然后调用<code>__mutex_trylock_fast(*lock*)</code>去快速加锁</p><p>fast 部分的代码相对比较简单，主要是两步：</p><ul><li>获取当前进程的<code> task_stuct</code> 指针，<code>current</code>是当前线程的<code>tcb</code>指针</li><li>调用 <code>atomic_long_cmpxchg_acquire</code> 函数尝试更新<code> lock-&gt;owner</code>,这个函数是一个原子操作函数，因为 <code>lock-&gt;owner</code> 是全局变量，所以这里需要用到原子操作。这个接口的定义为：将 p1 (第一个参数)和 p2 作比较，如果相等，则 p1&#x3D;p3，返回 p2，否则不执行赋值，直接返回 p1，类似于c++的CAS操作</li></ul><p>当 <code>lock-&gt;owner</code> 为 0 时，表示既没有其它进程获取锁也没有等待者,就可以直接获取到锁并返回。否则就代表有其他线程持有锁。此时就需要加上慢锁了</p></li><li><p><code>__mutex_lock_slowpath</code>会去调用<code>__mutex_lock</code>，然后调用<code>__mutex_lock_common</code>，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock a mutex (possibly interruptible), slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> __sched</span><br><span class="line">__mutex_lock_common(<span class="keyword">struct</span> mutex *lock, <span class="type">long</span> state, <span class="type">unsigned</span> <span class="type">int</span> subclass,</span><br><span class="line">    <span class="keyword">struct</span> lockdep_map *nest_lock, <span class="type">unsigned</span> <span class="type">long</span> ip,</span><br><span class="line">    <span class="keyword">struct</span> ww_acquire_ctx *ww_ctx, <span class="type">const</span> <span class="type">bool</span> use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ww_mutex</span> *<span class="title">ww</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx)</span><br><span class="line">ww_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line">ww = container_of(lock, <span class="keyword">struct</span> ww_mutex, base);</span><br><span class="line"><span class="keyword">if</span> (ww_ctx) &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(ww_ctx == READ_ONCE(ww-&gt;ctx)))</span><br><span class="line"><span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the wounded flag after a kill. No other process can</span></span><br><span class="line"><span class="comment"> * race and wound us here since they can&#x27;t have a valid owner</span></span><br><span class="line"><span class="comment"> * pointer if we don&#x27;t have any locks held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ww_ctx-&gt;acquired == <span class="number">0</span>)</span><br><span class="line">ww_ctx-&gt;wounded = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preempt_disable();</span><br><span class="line">mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    mutex_optimistic_spin(lock, ww_ctx, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="comment">/* got the lock, yay! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">ww_mutex_set_context_fastpath(ww, ww_ctx);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After waiting to acquire the wait_lock, try again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> skip_wait;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx) &#123;</span><br><span class="line"><span class="comment">/* add waiting tasks to the end of the waitqueue (FIFO): */</span></span><br><span class="line">__mutex_add_waiter(lock, &amp;waiter, &amp;lock-&gt;wait_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">waiter.ww_ctx = MUTEX_POISON_WW_CTX;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add in stamp order, waking up waiters that must kill</span></span><br><span class="line"><span class="comment"> * themselves.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = __ww_mutex_add_waiter(&amp;waiter, lock, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_early_kill;</span><br><span class="line"></span><br><span class="line">waiter.ww_ctx = ww_ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waiter.task = current;</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">bool</span> first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Once we hold wait_lock, we&#x27;re serialized against</span></span><br><span class="line"><span class="comment"> * mutex_unlock() handing the lock off to us, do a trylock</span></span><br><span class="line"><span class="comment"> * before testing the error conditions to make sure we pick up</span></span><br><span class="line"><span class="comment"> * the handoff.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock))</span><br><span class="line"><span class="keyword">goto</span> acquired;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check for signals and kill conditions while holding</span></span><br><span class="line"><span class="comment"> * wait_lock. This ensures the lock cancellation is ordered</span></span><br><span class="line"><span class="comment"> * against mutex_unlock() and wake-ups do not go missing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal_pending_state(state, current))) &#123;</span><br><span class="line">ret = -EINTR;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx) &#123;</span><br><span class="line">ret = __ww_mutex_check_kill(lock, &amp;waiter, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line"></span><br><span class="line">first = __mutex_waiter_is_first(lock, &amp;waiter);</span><br><span class="line"><span class="keyword">if</span> (first)</span><br><span class="line">__mutex_set_flag(lock, MUTEX_FLAG_HANDOFF);</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Here we order against unlock; we must either see it change</span></span><br><span class="line"><span class="comment"> * state back to RUNNING and fall through the next schedule(),</span></span><br><span class="line"><span class="comment"> * or we must see its unlock and acquire.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    (first &amp;&amp; mutex_optimistic_spin(lock, ww_ctx, &amp;waiter)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">&#125;</span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">acquired:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wound-Wait; we stole the lock (!first_waiter), check the</span></span><br><span class="line"><span class="comment"> * waiters as anyone might want to wound us.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ww_ctx-&gt;is_wait_die &amp;&amp;</span><br><span class="line">    !__mutex_waiter_is_first(lock, &amp;waiter))</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__mutex_remove_waiter(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line"></span><br><span class="line">skip_wait:</span><br><span class="line"><span class="comment">/* got the lock - cleanup and rejoice! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">ww_mutex_lock_acquired(ww, ww_ctx);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">__mutex_remove_waiter(lock, &amp;waiter);</span><br><span class="line">err_early_kill:</span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于此函数的分析请参考如下博文，后续有时间再去看代码</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/364130923">linux同步机制 - mutex lock - 知乎 (zhihu.com)</a></p></blockquote></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://blog.csdn.net/weixin_42135087/article/details/123165545">02-Linux Kernel(armv8-aarch64)的原子操作的底层实现</a></li><li><a href="https://www.zhihu.com/tardis/zm/art/89299392?source_id=1005">读写一气呵成 - Linux中的原子操作 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/weixin_42135087/article/details/123165545">02-Linux Kernel(armv8-aarch64)的原子操作的底层实现_在aarch64多核体系结构中,以下哪一条汇编指令可以用于进行原子操作-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/115748853">Linux 单&#x2F;多处理器下的内核同步与实现—自旋锁 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/wh_19910525/article/details/11536279">Linux内核spin_lock、spin_lock_irq 和 spin_lock_irqsave 分析-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 原子变量 </tag>
            
            <tag> 自旋锁 </tag>
            
            <tag> 信号量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用原始套接字剖析TCP</title>
      <link href="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/"/>
      <url>/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络分层"><a href="#1-网络分层" class="headerlink" title="1. 网络分层"></a>1. 网络分层</h2><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/ARP%E5%8D%8F%E8%AE%AE.png" alt="ARP协议"></p><ul><li><p>按照OSI分层的话从上到下分为7层：物理层、链路层、网络层、传输层、会话层、表示层、应用层</p></li><li><p>一般来说会话层、表示层、应用层 统一称为 应用层</p></li><li><p>每张网卡都有一个唯一确定的地址，被称为<code>MAC</code>地址，通过这个全球唯一的<code>MAC</code>地址，就能标识不同的网络设备，<code>MAC</code>地址是一个<code>48bit</code>的值</p></li></ul><h2 id="2-Ethernet-封包格式"><a href="#2-Ethernet-封包格式" class="headerlink" title="2. Ethernet 封包格式"></a>2. Ethernet 封包格式</h2><h3 id="2-1-以太网封包格式"><a href="#2-1-以太网封包格式" class="headerlink" title="2.1 以太网封包格式"></a>2.1 以太网封包格式</h3><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/v2-d69f6122a8ec686cbf573d96d66b078c_r.jpg" alt="img" style="zoom:150%;"><table><thead><tr><th>字段</th><th>字段长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>前导码（preamble）</td><td>7</td><td>0和1交替变换的码流</td></tr><tr><td>帧开始符（SFD）</td><td>1</td><td>帧起始符</td></tr><tr><td>目的地址（DA）</td><td>6</td><td>目的设备的MAC物理地址</td></tr><tr><td>源地址（SA）</td><td>6</td><td>发送设备的MAC物理地址</td></tr><tr><td>长度&#x2F;类型（Length&#x2F;Type）</td><td>2</td><td>帧数据字段长度&#x2F;帧协议类型</td></tr><tr><td>数据及填充（data and pad）</td><td>46~1500</td><td>帧数据字段</td></tr><tr><td>帧校验序列（FCS）</td><td>4</td><td>数据校验字段</td></tr></tbody></table><ul><li><p>以太网帧大小必须在64-1518字节（不包含前导码和定界符），即包括目的地址（6B）、源地址（6B）、类型（2B）、数据、FCS（4B）在内，其中数据段大小在46~1500字节之间。</p></li><li><p>以太网的前导码是一串交替的0和1，用于在网络流中区分一帧帧数据，前导码的最后一个字节是帧开始定界符</p></li></ul><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221170858451.png" alt="image-20240221170858451" style="zoom: 67%;"><h3 id="2-2-IP协议封包格式"><a href="#2-2-IP协议封包格式" class="headerlink" title="2.2 IP协议封包格式"></a>2.2 IP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/IP.png" alt="IP"></p><h3 id="2-2-ARP协议封包格式"><a href="#2-2-ARP协议封包格式" class="headerlink" title="2.2 ARP协议封包格式"></a>2.2 ARP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/ARP.png" alt="ARP"></p><h3 id="2-3-TCP协议封包格式"><a href="#2-3-TCP协议封包格式" class="headerlink" title="2.3 TCP协议封包格式"></a>2.3 TCP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/tcp-170852003743213.png" alt="tcp"></p><p>在Tcp协议中，比较重要的字段有：</p><ul><li><p>源端口：表示发送端端口号，字段长 16 位，2个字节</p></li><li><p>目的端口：表示接收端端口号，字段长 16 位，2个字节</p></li><li><p>序列号（sequence number）：字段长 32 位，占4个字节，序列号的范围为 [0，4284967296]。</p><ul><li>由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号</li><li>首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号，这是随机生成的。</li><li>序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0</li></ul></li><li><p>确认序号（acknowledgement number）：占32位（4字节），表示收到的下一个报文段的第一个数据字节的序号，如果确认序号为N，序号为S，则表明到序号N-S为止的所有数据字节都已经被正确地接收到了。</p></li><li><p>8个标志位（Flag）:</p><ul><li>CWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</li><li>ECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1.；</li><li>URG：该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</li><li>ACK：该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</li><li>PSH：该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</li><li>SYN：用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</li><li>FIN：该位设为 1，表示今后不再有数据发送，希望断开连接。</li></ul></li><li><p>窗口尺寸：该字段长 16 位，表示从确认序号所指位置开始能够接收的数据大小，TCP 不允许发送超过该窗口大小的数据。</p></li></ul><h3 id="2-4-UDP协议封包格式"><a href="#2-4-UDP协议封包格式" class="headerlink" title="2.4 UDP协议封包格式"></a>2.4 UDP协议封包格式</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/udp-170852008999615.png" alt="udp"></p><h2 id="2-套接字通信"><a href="#2-套接字通信" class="headerlink" title="2.套接字通信"></a>2.套接字通信</h2><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/%E5%9B%BE%E7%89%87.png" alt="图片" style="zoom: 80%;"><ul><li>在Linux的套接字编程中分为标准套接字和原始套接字，而标准套接字又分为流式套接字和数据报套接字<ul><li>流式套接字：TCP</li><li>数据报套接字：UDP</li></ul></li></ul><h3 id="2-1-UDP编程"><a href="#2-1-UDP编程" class="headerlink" title="2.1 UDP编程"></a>2.1 UDP编程</h3><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/udp.png" alt="udp" style="zoom:80%;"><ul><li><code>sendto</code>函数是非阻塞的，<code>recvfrom</code>函数是阻塞的</li></ul><p><strong>udp客户端的实现:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//udp客户端的实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons inet_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;ip&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd; <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span> <span class="comment">//服务器网络信息结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：创建套接字</span></span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端自己指定自己的ip地址和端口号，一般不需要，系统会自动分配</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    clientaddr.sin_addr.s_addr = inet_addr(argv[<span class="number">3</span>]); <span class="comment">//客户端的ip地址</span></span><br><span class="line">    clientaddr.sin_port = htons(atoi(argv[<span class="number">4</span>])); <span class="comment">//客户端的端口号</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：填充服务器网络信息结构体</span></span><br><span class="line">    <span class="comment">//inet_addr：将点分十进制字符串ip地址转化为整形数据</span></span><br><span class="line">    <span class="comment">//htons：将主机字节序转化为网络字节序</span></span><br><span class="line">    <span class="comment">//atoi：将数字型字符串转化为整形数据</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：进行通信</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sendto(sockfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to sendto&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> text[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, text, <span class="keyword">sizeof</span>(text), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;from server: %s\n&quot;</span>, text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第四步：关闭文件描述符</span></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>udp服务器的实现:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//udp服务器的实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons inet_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;ip&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd; <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span> <span class="comment">//服务器网络信息结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：创建套接字</span></span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：填充服务器网络信息结构体</span></span><br><span class="line">    <span class="comment">//inet_addr：将点分十进制字符串ip地址转化为整形数据</span></span><br><span class="line">    <span class="comment">//htons：将主机字节序转化为网络字节序</span></span><br><span class="line">    <span class="comment">//atoi：将数字型字符串转化为整形数据</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：将套接字与服务器网络信息结构体绑定</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第四步：进行通信</span></span><br><span class="line">        <span class="type">char</span> text[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, text, <span class="keyword">sizeof</span>(text), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s - %d]: %s\n&quot;</span>, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port), text);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">strcat</span>(text, <span class="string">&quot; *_*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sendto(sockfd, text, <span class="keyword">sizeof</span>(text), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to sendto&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：关闭文件描述符</span></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-TCP编程"><a href="#2-2-TCP编程" class="headerlink" title="2.2 TCP编程"></a>2.2 TCP编程</h3><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/tcp.png" alt="tcp"></p><h2 id="3-ARP协议分析"><a href="#3-ARP协议分析" class="headerlink" title="3. ARP协议分析"></a>3. ARP协议分析</h2><p><code>ARP</code>协议是链路层的协议，用于拿到目标<code>IP</code>主机的<code>MAC</code>地址，例如假设我现在主机<code>A(192.168.1.1)</code> 向 <code>B(192.168.1.2)</code> 发送一个数据包，那么<code>A</code>必须知道<code>B</code>主机的<code>ip</code>，<code>port</code>，使用的协议(<code>TCP/UDP</code>，此外还需要<code>MAC</code>地址，在第一次发送时<code>A</code>并不知道<code>B</code>的<code>MAC</code>地址，因此需要先拿到<code>B</code>的<code>MAC</code>地址，这就需要使用到<code>ARP</code>协议</p><p>ARP（Address Resolution Protocol，地址解析协议）</p><ul><li><p>1、是 TCP&#x2F;IP 协议族中的一个</p></li><li><p>2、主要用于查询指定 ip 所对应的的 MAC</p></li><li><p>3、请求方使用广播来发送请求</p></li><li><p>4、应答方使用单播来回送数据</p></li><li><p>5、为了在发送数据的时候提高效率在计算中会有一个 ARP 缓存表，用来暂时存放 ip 所对应的 MAC，在 linux中使用 ARP 即可查看,在 xp 中使用 ARP -a</p></li></ul><p>考虑如下的局域网通信流程，各个主机通过交换机相连接</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221151031897.png" alt="image-20240221151031897"></p><p>先说一下交换机的功能：</p><ul><li>交换机中有一个缓存表，这个表中保存了每一端口相连设备的MAC地址，将端口和MAC地址相互对应好保存在这个缓存表中</li><li>当一个设备向另外一个设备发送数据时，发送的数据先到达交换机，交换机会根据发送数据包中的目标主机的MAC地址去缓存表中索引目标设备的端口，然后将数据转发给此端口</li><li>交换机一般工作在数据链路层</li></ul><p>ARP获取目标MAC的流程：</p><ul><li><p>主机A不知道B的MAC地址，那么主机A会先发送一个ARP广播，交换机第一次收到ARP广播时，会把ARP广播数据包转发给所有连接上的端口（除来源端口）；此时也会根据A发送的ARP数据去拿到A的MAC地址，将A插入的端口何其MAC地址对应起来保存到交换机自己的缓存表中</p></li><li><p>这样所有的主机拿到这个ARP广播后，会比对IP地址，判断A主机是否想要自己的MAC地址，此时B主机比对后发现是，就会将自己的MAC地址写入到回复的ARP数据包中，并以单播的形式先发送给交换机，然后交换机再转发给对应的主机。</p></li><li><p>为了避免下次A主机向B主机发送数据时还要再次去发送ARP数据包去向B主机获取它的MAC地址，因此在第一次获取到B的MAC地址后会将它放在一张表中存起来，这张表用来暂时存放 ip 所对应的 MAC，在 linux中使用 ARP 即可查看,在 xp 中使用 ARP -a</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221152640111.png" alt="image-20240221152640111"></p></li></ul><p>现在假设各主机之间通过路由器相连：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221161712911.png" alt="image-20240221161712911"></p><p>先说一下路由器的功能：</p><ul><li><p>交换机用于实现同网段之间设备的通信，路由器用于不同网段之间的设备的通信，路由器工作在网络层</p></li><li><p>路由器中存在两个网卡，一个用于内部局域网通信，一个用于和另外一个路由器建立连接</p></li><li><p>假设A主机想要向D主机发送数据，由于此时不在同一网段中，因此A主机会将数据包先发送给路由器，由路由器进行转发。而A主机是如何知道谁是路由器呢，这就到了默认网关出场了，每台主机在配置网络的时候需要将默认网关配置成连接的路由器的IP地址，比如A主机的默认网关地址就是<code>192.168.1.1</code>，D主机的默认网关地址就是<code>192.168.3.1</code></p></li><li><p>现在A发送的数据包到达了路由器，A想要向<code>192.168.3.0</code>这个网段发送数据，此时路由器会进行判断说将这个数据包转发到和他连接的哪一个路由器，因此需要去查表，这个表就叫做路由表，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Network: 192.168.3.0</span><br><span class="line">Mask: 255.255.255.0</span><br><span class="line">Next Hop: 192.168.2.3</span><br></pre></td></tr></table></figure><p>对于路由器1来说，路由表就如上，意味着如果路由器1要向<code>192.168.3.0</code>这个网段发送数据，那么它的下一跳的路由器的地址为<code>192.168.2.3</code>，可以看见<code>192.168.2.3</code>就代表了路由器2，而通过路由器2就能访问到D主机了</p></li></ul><h2 id="4-使用原始套接字进行网络数据分析"><a href="#4-使用原始套接字进行网络数据分析" class="headerlink" title="4. 使用原始套接字进行网络数据分析"></a>4. 使用原始套接字进行网络数据分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ether.h&gt;</span> <span class="comment">//ETH_P_ALL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERRLOG(errmsg) do&#123;\</span></span><br><span class="line"><span class="meta">                            perror(errmsg);\</span></span><br><span class="line"><span class="meta">                            exit(1);\</span></span><br><span class="line"><span class="meta">                        &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建原始套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;sockfd = %d\n&quot;, sockfd);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收数据并分析</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> msg[<span class="number">1600</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//recvfrom recv read 都可以使用</span></span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, msg, <span class="keyword">sizeof</span>(msg), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析接收到的数据包</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> type;</span><br><span class="line">        <span class="built_in">sprintf</span>(dst_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">0</span>], msg[<span class="number">1</span>], msg[<span class="number">2</span>], msg[<span class="number">3</span>], msg[<span class="number">4</span>], msg[<span class="number">5</span>]);</span><br><span class="line">        <span class="built_in">sprintf</span>(src_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">6</span>], msg[<span class="number">7</span>], msg[<span class="number">8</span>], msg[<span class="number">9</span>], msg[<span class="number">10</span>], msg[<span class="number">11</span>]);</span><br><span class="line">        type = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">12</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;源mac：%s --&gt; 目的mac：%s\n&quot;</span>, src_mac, dst_mac);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;type = %#x\n&quot;</span>, type);</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0x0800</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip数据报\n&quot;</span>);</span><br><span class="line">            <span class="comment">//头部长度、总长度</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_head_len;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> ip_len;</span><br><span class="line">            ((*(<span class="type">unsigned</span> <span class="type">char</span> *)(msg + <span class="number">14</span>)) &amp; <span class="number">0x0f</span>) * <span class="number">4</span>;</span><br><span class="line">            ip_len = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">16</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip头部：%d, ip数据报总长度: %d\n&quot;</span>, ip_head_len, ip_len);</span><br><span class="line">            <span class="comment">//目的ip地址、源IP地址</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> dst_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> src_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(src_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">26</span>], msg[<span class="number">27</span>], msg[<span class="number">28</span>], msg[<span class="number">29</span>]);</span><br><span class="line">            <span class="built_in">sprintf</span>(dst_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">30</span>], msg[<span class="number">31</span>], msg[<span class="number">32</span>], msg[<span class="number">33</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;源ip地址：%s --&gt; 目的ip地址：%s\n&quot;</span>, src_ip, dst_ip);</span><br><span class="line">            <span class="comment">//协议类型</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_type;</span><br><span class="line">            ip_type = *(msg + <span class="number">23</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip_type = %d\n&quot;</span>, ip_type);</span><br><span class="line">            <span class="comment">//icmp、igmp、tcp、udp</span></span><br><span class="line">            <span class="keyword">if</span>(ip_type == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;icmp报文\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;igmp报文\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;tcp报文\n&quot;</span>);</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> src_port;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> dst_port;</span><br><span class="line">                src_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">34</span>));</span><br><span class="line">                dst_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">36</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;源端口号：%d --&gt; 目的端口号: %d\n&quot;</span>, src_port, dst_port);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">17</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;udp报文\n&quot;</span>);</span><br><span class="line">                <span class="comment">//目的端口号、源端口号</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> src_port;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> dst_port;</span><br><span class="line">                src_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">34</span>));</span><br><span class="line">                dst_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">36</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;源端口号：%d --&gt; 目的端口号: %d\n&quot;</span>, src_port, dst_port);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">0x0806</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;arp数据报\n&quot;</span>);</span><br><span class="line">            <span class="comment">//源ip地址</span></span><br><span class="line">            <span class="comment">//目的ip地址</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> dst_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> src_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(src_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">28</span>], msg[<span class="number">29</span>], msg[<span class="number">30</span>], msg[<span class="number">31</span>]);</span><br><span class="line">            <span class="built_in">sprintf</span>(dst_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">38</span>], msg[<span class="number">39</span>], msg[<span class="number">40</span>], msg[<span class="number">41</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;源ip地址：%s --&gt; 目的ip地址：%s\n&quot;</span>, src_ip, dst_ip);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">0x8035</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rarp数据报\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码运行结果如下，在<code>root</code>模式下运行：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240221210039770.png" alt="image-20240221210039770"></p><h2 id="5-使用原始套接字剖析TCP协议"><a href="#5-使用原始套接字剖析TCP协议" class="headerlink" title="5. 使用原始套接字剖析TCP协议"></a>5. 使用原始套接字剖析TCP协议</h2><p>为了更好的理解TCP协议中的三次握手与四次挥手，我们使用原始套接字来抓取一下TCP数据报，逐步分析每次握手和挥手之间的TCP数据报的变化：</p><p>我现在有两台主机，主机之间通过路由器连接：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240222155851459.png" alt="image-20240222155851459"></p><ul><li>A作为客户端，IP为：192.168.3.9，端口为系统默认分配，我们将会在A主机上运行一个客户端程序使用TCP去连接B主机</li><li>B作为服务器，IP为：192.168.3.31，端口设置为<code>10000</code>，我们会在B主机上运行一个服务器程序使用TCP去监听TCP连接</li><li>额外在A主机上运行一个网络抓包程序，用来抓取A主机发送给B主机和B主机发送给A主机的TCP数据报</li></ul><p><strong>服务器代码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [ip] [port]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：创建套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：将套接字与服务器网络信息结构体绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line">    <span class="comment">//配置本地服务器的Ip和端口号</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, addrlen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：将套接字设置为被动监听状态</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd, <span class="number">10</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：阻塞等待客户端的链接请求</span></span><br><span class="line">    <span class="type">int</span> acceptfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>((acceptfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;addrlen)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印连接的客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip:%s, port:%d\n&quot;</span>, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：进行通信</span></span><br><span class="line">    <span class="comment">//tcp服务器与客户端通信时，需要使用accept函数的返回值</span></span><br><span class="line">    <span class="type">char</span> buf[N] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(recv(acceptfd, buf, N, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to recv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;from client: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(buf, <span class="string">&quot; *_*&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(send(acceptfd, buf, N, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to send&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字文件描述符</span></span><br><span class="line">    close(acceptfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [ip] [port]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;FAIL to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen =<span class="keyword">sizeof</span>(serveraddr);</span><br><span class="line"></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr ,addrlen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[N] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    fgets(buf , N ,<span class="built_in">stdin</span>);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sockfd , buf , N , <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;faild to send&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> text[N] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(recv(sockfd , text, N , <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to recv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;from server: %s\n&quot;</span>, text);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>网络抓包代码</strong>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ether.h&gt;</span> <span class="comment">//ETH_P_ALL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//htons</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERRLOG(errmsg) do&#123;\</span></span><br><span class="line"><span class="meta">                            perror(errmsg);\</span></span><br><span class="line"><span class="meta">                            exit(1);\</span></span><br><span class="line"><span class="meta">                        &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建原始套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收数据并分析</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> msg[<span class="number">1600</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//recvfrom recv read 都可以使用</span></span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sockfd, msg, <span class="keyword">sizeof</span>(msg), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(<span class="string">&quot;fail to recvfrom&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析接收到的数据包</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">18</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> type;</span><br><span class="line">        <span class="built_in">sprintf</span>(dst_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">0</span>], msg[<span class="number">1</span>], msg[<span class="number">2</span>], msg[<span class="number">3</span>], msg[<span class="number">4</span>], msg[<span class="number">5</span>]);</span><br><span class="line">        <span class="built_in">sprintf</span>(src_mac, <span class="string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>, msg[<span class="number">6</span>], msg[<span class="number">7</span>], msg[<span class="number">8</span>], msg[<span class="number">9</span>], msg[<span class="number">10</span>], msg[<span class="number">11</span>]);</span><br><span class="line">        type = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">12</span>));</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0x0800</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//头部长度、总长度</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_head_len;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> ip_len;</span><br><span class="line">            ((*(<span class="type">unsigned</span> <span class="type">char</span> *)(msg + <span class="number">14</span>)) &amp; <span class="number">0x0f</span>) * <span class="number">4</span>;</span><br><span class="line">            ip_len = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">16</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//目的ip地址、源IP地址</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> dst_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> src_ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(src_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">26</span>], msg[<span class="number">27</span>], msg[<span class="number">28</span>], msg[<span class="number">29</span>]);</span><br><span class="line">            <span class="built_in">sprintf</span>(dst_ip, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, msg[<span class="number">30</span>], msg[<span class="number">31</span>], msg[<span class="number">32</span>], msg[<span class="number">33</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//协议类型</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> ip_type;</span><br><span class="line">            ip_type = *(msg + <span class="number">23</span>);</span><br><span class="line">            <span class="keyword">if</span>(ip_type == <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> src_port;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> dst_port;</span><br><span class="line">                src_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">34</span>));</span><br><span class="line">                dst_port = ntohs(*(<span class="type">unsigned</span> <span class="type">short</span> *)(msg + <span class="number">36</span>));</span><br><span class="line">                <span class="keyword">if</span>(dst_port == <span class="number">10000</span> || src_port==<span class="number">10000</span>)&#123;</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">char</span> flag = msg[<span class="number">47</span>] &amp; <span class="number">0x3f</span>;</span><br><span class="line">                    <span class="type">int</span> ACK = flag &gt;&gt; <span class="number">4</span> &amp; <span class="number">0x1</span>; </span><br><span class="line">                    <span class="type">int</span> SYN = flag &gt;&gt; <span class="number">1</span> &amp; <span class="number">0x1</span>;</span><br><span class="line">                    <span class="type">int</span> FIN = flag &amp; <span class="number">0x1</span>;</span><br><span class="line">                    <span class="type">uint32_t</span> seq = ntohl(*(<span class="type">uint32_t</span> *)(msg + <span class="number">38</span>));</span><br><span class="line">                    <span class="type">uint32_t</span> actual_seq = ntohl(*(<span class="type">uint32_t</span> *)(msg + <span class="number">42</span>));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;----------------tcp报文----------------\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;源端口号：%d --&gt; 目的端口号: %d\n&quot;</span>, src_port, dst_port);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;源ip地址：%s --&gt; 目的ip地址：%s\n&quot;</span>, src_ip, dst_ip);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ip头部：%d, ip数据报总长度: %d\n&quot;</span>, ip_head_len, ip_len);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ACK: %d SYN: %d SEQ: %u ASEQ: %u FIN: %d\n &quot;</span>,ACK,SYN,seq ,actual_seq,FIN);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于A主机来说，我们抓取目标为目标端口为<code>10000</code>或者发送端口为<code>10000</code>的TCP数据报，其他的全部舍弃，目标端口为<code>10000</code>的TCP数据报是A发送给B的，发送端口为<code>10000</code>的是B主机发送给A的</p><p>先启动服务器程序，再启动客户端程序，三次握手的结果如下，</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240222195612633.png" alt="image-20240222195612633"></p><p>很清晰的说明了三次握手的过程：上图中的<code>ASEQ</code>就是<code>ack</code>确认序号</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240222195914907.png" alt="image-20240222195914907"></p><ul><li><p>在理解三次握手，四次挥手之前，我们先理解两个很重要的概念：</p><p>在下面这张图中代表了一帧TCP数据包</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/tcp-170852003743213.png" alt="tcp"></p><ul><li><code>seq,序列号</code>：代表了发送的数据字节数，在一帧TCP数据包中发送的每一个字节都会计数；这里的数据指的是上图中给哪个进程中的数据，不包含TCP头中的字节，在我们进行握手或者挥手时，发送的字节数据数为0，因此<code>seq</code>理论上是不会增加的，但是由于我们在握手和挥手的过程中<code>FIN</code>、<code>SYN</code>状态码是会发生改变的，因此TCP协议规定这两个状态码发生改变时就当多了一字节的数据，因此<code>seq+1</code>;<code>seq</code>代表的本机发送的字节数，<code>seq</code>的增加与否只与本机发送的数据有关，和接收到的数据无关</li><li><code>ack，确认序列号</code>：这个<code>ack</code>和状态码中全部大写的<code>ACK</code>不一样，这里代表确认号，确认号只与接收到的数据的字节数有关，如果对方发送的TCP数据包中有数据，则这个<code>ack</code>的值等于上次<code>ack</code>的值加上收到的数据的字节数，同样如果接收到的数据包的<code>FIN</code>、<code>SYN</code>状态码发生了改变<code>ack</code>会相应的加一，</li></ul></li><li><p>第一次握手：</p><ul><li>客户端请求建立连接，将<code>SYN</code>置为<code>1</code>，<code>ACK</code>为<code>0</code>，然后随机生成一个<code>seq=1490486468</code>，<code>ack=0</code></li></ul></li><li><p>第二次握手：服务器给客户端回复数据</p><ul><li>服务器在收到客户端发送的第一次握手信息后，会先检查<code>SYN</code>是否为<code>1</code>，如果为<code>1</code>，将<code>ACK=1</code>，向客户端请求建立连接，因此<code>SYN=1</code>，然后随机生成一个<code>seq=4013990024</code>，将收到的<code>seq+1</code>放在<code>ack</code>中，此时<code>ack=1490486469</code>，然后打包发给客户端</li><li>客户端检测服务器发送来的请求信息，先判断<code>ACK</code>和<code>SYN</code>是否等于1，<code>ACK=1</code>代表服务器同意了客户端的连接请求，<code>SYN=1</code>代表服务器想要同客户端建立连接。此时对于客户端来说由于上次的<code>seq=1490486468</code>，然后上次发送了<code>SYN</code>，上面提到<code>SYN</code>代表发送了一个字节，因此下次发送的序列号为<code>seq = 1490486468 + 1 = 1490486469</code>，</li></ul></li><li><p>第三次握手：客户端发送数据给服务器</p><ul><li>客户端将<code>ACK</code>标志位置为1，代表同意了服务器的连接请求，服务器发送过来的数据的<code>seq = 4013990024</code>，同样由于服务器改变了<code>SYN</code>状态码，代表发送了一个字节过来，因此客户端发送给服务器的确认码为<code>ack 4013990024+1=4013990025</code></li><li>服务器端查看ACK对应的标志位是否为1, 如果是1代表, 客户端同意了服务器的连接请求，然后校验确认序号是否等于生成的随意序号+1，然后拿到客户端的发送序号</li></ul></li></ul><p>三次握手完成之后，客户端和服务器都变成了同一种状态，这种状态叫：ESTABLISHED，表示双向连接已经建立， 可以通信了。在通过过程中，正常的通信状态就是 ESTABLISHED。在我们的程序中，客户端会先向服务器写入数据，服务器拿到数据后会回复客户端确认收到数据，然后再向客户端发送数据，发送完毕后，就直接关闭连接</p><p>观察数据发送和四次挥手我们使用<code>Wireshark</code>抓包来看一下：</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223111923750.png" alt="image-20240223111923750"></p><ul><li>前三帧数据就是三次握手的过程，然后客户端向服务器发送了数据，看第四帧的数据，发送的数据的长度为<code>128</code>，此时客户端的<code>seq = 1 ， ack = 1</code>，然后服务器接收到了数据，此时服务器接收到了发送来的<code>128</code>字节数据，</li><li><code>TCP</code>协议规定接收方在接收到数据后，需要应答发送方，发送发如果一直没收到接收方的应答，则代表此次发送数据出现了丢包，那发送方会重发数据，因此在第四帧客户端向无服务发送数据后，需要应答客户端，即第五帧数据，回复的确认号<code>ack = 128 + 1 =129</code>，发送方根据这个确认号就知道接收方成功接收到数据了</li></ul><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223115646850.png" alt="image-20240223115646850"></p><ul><li>然后第六帧数据，服务器向客户端发送数据，数据长度为128，发送给客户端后理论上客户端应该回复一帧说我已经收到了的数据包，但是由于服务器在发送完毕这128字节数据后立马执行了<code>close</code>操作去断开连接，导致了一些很奇怪的操作，因此好像看着并没有回复此帧</li></ul><p>接下来看四次挥手的过程：</p><ul><li><p>服务器和客户端都可以主动发起断开连接，在我们的代码中是服务器发起的断开连接</p></li><li><p>第一次挥手：服务器会将<code>FIN</code>置为1，然后发送给客户端去告诉客户端我想要断开连接了  </p></li><li><p>第二次挥手：客户端发现了服务器此次请求，因此<code>FIN</code>的改变占用一个字节因此回复的<code>ack = 129 + 1 = 130</code>，然后发送给服务器，服务器得到此数据包检查确认序号知道客户端同意了断开连接，进入等待</p></li><li><p>第三次挥手：客户端将<code>FIN</code>置为1去发送给服务器告诉服务器它想要断开连接</p></li><li><p>第四次挥手：服务器检查客户端发送的<code>FIN</code>的值，然后同意客户端断开连接，此时是服务器第二次发送数据因此<code>seq = 129 + 1 =130</code>，客户端的发送序号为<code>129</code>，然后客户端将<code>FIN</code>置为了1，因此此时<code>ack = 129 + 1 =130</code></p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223121923843.png" alt="image-20240223121923843"></p></li><li><p>根据<code>Wireshark</code>的抓包结果显示，最后四帧明显是四次挥手的过程，但实际上不然，我们看见似乎是少了一帧数据，三次握手三帧，客户端发送 + 服务器应答 2帧，服务器发送+客户端应答 2 帧，四次挥手四帧，总共应该是11帧，但实际上只有10帧</p></li><li><p>理论上第8帧中客户端执行第2次挥手时回复的<code>ack</code>应该是130才对，但是确回复的<code>ack</code>是<code>129 = 128 +1</code>，因此我们可以猜测第九帧实际上是用于回复上次服务器发送来的<code>128</code>自己的数据，而不是四次挥手中的第二次挥手，而客户端将第二次挥手和第三次挥手合并成了一帧数据发送，即第9帧。</p></li><li><p>这是由什么原因引起的，问题在于服务器在第6帧向客户端发送数据后，立刻执行了<code>close</code>操作，去发起断开连接，即第7帧，客户端先收到了这两帧数据，因此客户端先回复服务器收到了数据，然后再去应答断开连接的请求</p></li><li><p>我们修改一下服务器的代码，在<code>close</code>之前添加一个延时操作，再使用<code>Wireshark</code>，抓包</p><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223120541936.png" alt="image-20240223120541936"></p></li></ul><p><img src="/2024/02/21/%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%89%96%E6%9E%90TCP-UDP/image-20240223123938843.png" alt="image-20240223123938843"></p><ul><li>可以看见此时就有11帧数据了，此时是由客户端先发起的断开连接请求，因此服务器再向客户端发送数据后没有立即执行断开连接操作，因此客户端有时间去先执行应答，然后去向服务器申请断开连接</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/UDP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-对象池</title>
      <link href="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-FOR-EACH-宏实现"><a href="#1-FOR-EACH-宏实现" class="headerlink" title="1. FOR_EACH 宏实现"></a>1. FOR_EACH 宏实现</h2><p>代码目录：<code>cyber/base/for_each.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasLess, <span class="keyword">operator</span>&lt;)  <span class="comment">// NOLINT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">End</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;HasLess&lt;Value&gt;::value &amp;&amp; HasLess&lt;End&gt;::value,</span><br><span class="line">                        <span class="type">bool</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">LessThan</span><span class="params">(<span class="type">const</span> Value&amp; val, <span class="type">const</span> End&amp; end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &lt; end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">End</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasLess&lt;Value&gt;::value || !HasLess&lt;End&gt;::value,</span><br><span class="line">                        <span class="type">bool</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">LessThan</span><span class="params">(<span class="type">const</span> Value&amp; val, <span class="type">const</span> End&amp; end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val != end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR_EACH(i, begin, end)           \</span></span><br><span class="line"><span class="meta">  for (auto i = (true ? (begin) : (end)); \</span></span><br><span class="line"><span class="meta">       apollo::cyber::base::LessThan(i, (end)); ++i)</span></span><br></pre></td></tr></table></figure><p>我们先看看这个宏的用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, <span class="number">100</span>) &#123; vec.<span class="built_in">push_back</span>(i); &#125;</span><br><span class="line"><span class="built_in">FOR_EACH</span>(it, vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()) &#123; std::cout&lt;&lt;*it&lt;&lt;std::endl; &#125;</span><br></pre></td></tr></table></figure><p>简单来说就是用于对不同类型的数据进行遍历操作：</p><p><code>DEFINE_TYPE_TRAIT(HasLess, operator&lt;) </code>这个<code>trait</code>操作是保证传进来的<code>begin</code>和<code>end</code>类型重载了<code>&lt;</code>，</p><p><code>for</code>循环里会去调用<code>LessThan</code>函数，<code>LessThan</code>函数的两个模板参数就是<code>begin</code>所代表的类型和<code>End</code>所代表的类型。</p><p>当<code>HasLess&lt;Value&gt;::value &amp;&amp; HasLess&lt;End&gt;::value</code>满足时，才会走第一个模板函数，将会对<code>val</code>和<code>end</code>的值进行比较，函数返回值为<code>bool</code>类型，</p><p>当<code>Value</code>或者<code>End</code>其中任意一个类型不具有<code>&lt;</code>的重载则会走第二个模板函数，函数内部会对这两个值进行判断是否是相等</p><p>如果用户在使用时提供的类型既不支持 <code>&lt;</code> 运算符，也不支持 <code>!=</code> 运算符，那么在编译时将会导致错误。</p><h2 id="2-对象池的实现"><a href="#2-对象池的实现" class="headerlink" title="2. 对象池的实现"></a>2. 对象池的实现</h2><p>源码目录：<code>cyber/base/object_pool.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPool</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;ObjectPool&lt;T&gt;&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> InitFunc = std::function&lt;<span class="built_in">void</span>(T *)&gt;;</span><br><span class="line">  <span class="keyword">using</span> ObjectPoolPtr = std::shared_ptr&lt;ObjectPool&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ObjectPool</span><span class="params">(<span class="type">uint32_t</span> num_objects, Args &amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ObjectPool</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 拿到一个对象*/</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">GetObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T object;</span><br><span class="line">    Node *next;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/*禁用拷贝构造*/</span></span><br><span class="line">  <span class="built_in">ObjectPool</span>(ObjectPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ObjectPool &amp;<span class="keyword">operator</span>=(ObjectPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReleaseObject</span><span class="params">(T *)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> num_objects_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> *object_arena_ = <span class="literal">nullptr</span>;</span><br><span class="line">  Node *free_head_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">f</span>(obj);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::~<span class="built_in">ObjectPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">    <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object_arena_ + i * size)-&gt;object.~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(object_arena_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ObjectPool&lt;T&gt;::<span class="built_in">ReleaseObject</span>(T *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(object == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object)-&gt;next = free_head_;</span><br><span class="line">  free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ObjectPool&lt;T&gt;::<span class="built_in">GetObject</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(free_head_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> self = <span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">auto</span> obj =</span><br><span class="line">      std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="built_in">reinterpret_cast</span>&lt;T *&gt;(free_head_),</span><br><span class="line">                         [self](T *object) &#123; self-&gt;<span class="built_in">ReleaseObject</span>(object); &#125;);</span><br><span class="line">  free_head_ = free_head_-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">f</span>(obj);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::~<span class="built_in">ObjectPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">    <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object_arena_ + i * size)-&gt;object.~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(object_arena_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ObjectPool&lt;T&gt;::<span class="built_in">ReleaseObject</span>(T *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(object == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object)-&gt;next = free_head_;</span><br><span class="line">  free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ObjectPool&lt;T&gt;::<span class="built_in">GetObject</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(free_head_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> self = <span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">auto</span> obj =</span><br><span class="line">      std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="built_in">reinterpret_cast</span>&lt;T *&gt;(free_head_),</span><br><span class="line">                         [self](T *object) &#123; self-&gt;<span class="built_in">ReleaseObject</span>(object); &#125;);</span><br><span class="line">  free_head_ = free_head_-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向对象池中传递目标的类型和构建目标的参数，用<code>T</code>和<code> ... Args</code>来进行传递，在构造函数内部首先计算了一个<code>Node</code>的大小，然后分配<code>num_objects</code>个<code>node</code>大小的内存作为目标池来管理，根据这个<code>node</code>的定义我们可以知道对象池管理对象时是以链表的方式将各个链表链接起来的，再分配完毕内存后，通过<code>FOR_EACH</code>来在指定的地址处创建对象，然后让创建的这个对象的指针指向<code>free_head_</code></p><p>还有另外一个构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::<span class="built_in">ObjectPool</span>(<span class="type">uint32_t</span> num_objects, InitFunc f, Args &amp;&amp;... args)</span><br><span class="line">    : <span class="built_in">num_objects_</span>(num_objects) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">  object_arena_ = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(std::<span class="built_in">calloc</span>(num_objects_, size));</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">    T *obj = <span class="built_in">new</span> (object_arena_ + i * size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="built_in">f</span>(obj);</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj)-&gt;next = free_head_;</span><br><span class="line">    free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造和上一个的区别在于多了一个参数<code>InitFunc f</code>，允许在构造对象池的时候提供一个操作对象的函数，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> InitFunc = std::function&lt;<span class="built_in">void</span>(T *)&gt;;</span><br></pre></td></tr></table></figure><p><code>InitFunc</code>是一个可调用对象，此对象的返回值是<code>void</code>，需要的参数是<code>T *</code>类型，所以在构造对象池的时候使用<code>f(obj);</code>来操作了对象</p><p><img src="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/image-20231202110144511.png" alt="image-20231202110144511"></p><p>接着来看看释放一个对象的操作，释放对象就是将一个对象重新放入对象池中：然后更新<code>free_head</code>的值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ObjectPool&lt;T&gt;::<span class="built_in">ReleaseObject</span>(T *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(object == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object)-&gt;next = free_head_;</span><br><span class="line">  free_head_ = <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/12/01/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%B1%A0/image-20231202111140335.png" alt="image-20231202111140335"></p><p>最后是拿到一个对象的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ObjectPool&lt;T&gt;::<span class="built_in">GetObject</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cyber_unlikely</span>(free_head_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> self = <span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">auto</span> obj =</span><br><span class="line">      std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="built_in">reinterpret_cast</span>&lt;T *&gt;(free_head_),</span><br><span class="line">                         [self](T *object) &#123; self-&gt;<span class="built_in">ReleaseObject</span>(object); &#125;);</span><br><span class="line">  free_head_ = free_head_-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过<code>std::shared_ptr&lt;T&gt; ptr(pointer, deleter);</code>来得到这个<code>obj</code>，第二个参数即是智能指针管理的这个对象的引用计数归零时将要执行的操作，这里就是说当<code>obj</code>的引用计数归零时，让此对象重新返回对象池，所以传入的可调用对象的形式是一个lamada函数：<code> [self](T *object) &#123; self-&gt;ReleaseObject(object); &#125;</code>，然后更新<code>free_head_</code></p><p>所以从对象池中拿对象从<code>arena</code>的高地址处<code>free_head_</code>开始拿，释放也是如此，将一个对象插入到<code>free_head_</code>之后，然后更新<code>free_head_</code></p><p>最后是析构函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ObjectPool&lt;T&gt;::~<span class="built_in">ObjectPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (object_arena_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(Node);</span><br><span class="line">    <span class="built_in">FOR_EACH</span>(i, <span class="number">0</span>, num_objects_) &#123;</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;Node *&gt;(object_arena_ + i * size)-&gt;object.~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(object_arena_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历调用对象的自己析构函数，然后释放<code>arena</code>这块内存</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/sinat_31608641/article/details/120692775">__builtin_expect函数-CSDN博客</a></li><li><a href="https://www.cnblogs.com/-citywall123/p/12726552.html">C++对象池的实现和原理 - 知道了呀~ - 博客园 (cnblogs.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 对象池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-无锁哈希表</title>
      <link href="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h2><p>源码目录：<code>cyber/base/atomic_hash_map.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief A implementation of lock-free fixed size hash map</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @tparam K Type of key, must be integral</span></span><br><span class="line"><span class="comment"> * @tparam V Type of value</span></span><br><span class="line"><span class="comment"> * @tparam 128 Size of hash table</span></span><br><span class="line"><span class="comment"> * @tparam 0 Type traits, use for checking types of key &amp; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, std::<span class="type">size_t</span> TableSize = <span class="number">128</span>,</span><br><span class="line">          <span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;K&gt;::value &amp;&amp;</span><br><span class="line">                                      (TableSize &amp; (TableSize - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                                  <span class="type">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> AtomicHashMap &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>() : <span class="built_in">capacity_</span>(TableSize), <span class="built_in">mode_num_</span>(capacity_ - <span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  AtomicHashMap &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Has</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Get</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V *value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    V *val = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">bool</span> res = table_[index].<span class="built_in">Get</span>(key, &amp;val);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      *value = *val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, V &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, std::forward&lt;V&gt;(value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="built_in">Entry</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entry</span><span class="params">(K key)</span> : key(key) &#123;</span></span><br><span class="line">      value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(), std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entry</span>(K key, <span class="type">const</span> V &amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">      value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(value), std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entry</span>(K key, V &amp;&amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">      value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(std::forward&lt;V&gt;(value)), std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entry</span>() &#123; <span class="keyword">delete</span> value_ptr.<span class="built_in">load</span>(std::memory_order_acquire); &#125;</span><br><span class="line"></span><br><span class="line">    K key = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;V *&gt; value_ptr = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    std::atomic&lt;Entry *&gt; next = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Bucket</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bucket</span>() : <span class="built_in">head_</span>(<span class="keyword">new</span> <span class="built_in">Entry</span>()) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Bucket</span>() &#123;</span><br><span class="line">      Entry *ite = head_;</span><br><span class="line">      <span class="keyword">while</span> (ite) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = ite-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">delete</span> ite;</span><br><span class="line">        ite = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">      Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;key &lt; key) &#123;</span><br><span class="line">          m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> target-&gt;key == key;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(K key, Entry **prev_ptr, Entry **target_ptr)</span> </span>&#123;</span><br><span class="line">      Entry *prev = head_;</span><br><span class="line">      Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;key == key) &#123;</span><br><span class="line">          *prev_ptr = prev;</span><br><span class="line">          *target_ptr = target;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;key &gt; key) &#123;</span><br><span class="line">          *prev_ptr = prev;</span><br><span class="line">          *target_ptr = target;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prev = target;</span><br><span class="line">          m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      *prev_ptr = prev;</span><br><span class="line">      *target_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">      V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">          <span class="comment">// key exists, update value</span></span><br><span class="line">          <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">            new_value = <span class="keyword">new</span> <span class="built_in">V</span>(value);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                  old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">                  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">            <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_entry;</span><br><span class="line">              new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">            new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key, value);</span><br><span class="line">          &#125;</span><br><span class="line">          new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">          <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                                 std::memory_order_acq_rel,</span><br><span class="line">                                                 std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// Insert success</span></span><br><span class="line">            <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_value;</span><br><span class="line">              new_value = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key, V &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">      V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">          <span class="comment">// key exists, update value</span></span><br><span class="line">          <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">            new_value = <span class="keyword">new</span> <span class="built_in">V</span>(std::forward&lt;V&gt;(value));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                  old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">                  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">            <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_entry;</span><br><span class="line">              new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">            new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key, value);</span><br><span class="line">          &#125;</span><br><span class="line">          new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">          <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                                 std::memory_order_acq_rel,</span><br><span class="line">                                                 std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// Insert success</span></span><br><span class="line">            <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_value;</span><br><span class="line">              new_value = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">      V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">          <span class="comment">// key exists, update value</span></span><br><span class="line">          <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">            new_value = <span class="keyword">new</span> <span class="built_in">V</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">          <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                  old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">                  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">            <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_entry;</span><br><span class="line">              new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">            new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key);</span><br><span class="line">          &#125;</span><br><span class="line">          new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">          <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                                 std::memory_order_acq_rel,</span><br><span class="line">                                                 std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// Insert success</span></span><br><span class="line">            <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">              <span class="keyword">delete</span> new_value;</span><br><span class="line">              new_value = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">      Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">      Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">        *value = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry *head_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Bucket table_[TableSize];</span><br><span class="line">  <span class="type">uint64_t</span> capacity_;</span><br><span class="line">  <span class="type">uint64_t</span> mode_num_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-无锁哈希表的实现"><a href="#2-无锁哈希表的实现" class="headerlink" title="2. 无锁哈希表的实现"></a>2. 无锁哈希表的实现</h2><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在存储器存储位置的数据结构。 也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。 这个映射函数称做散列函数，存放记录的数组称做散列表。</p><p>给定一个键值<code>K</code>，通过一个函数计算出了这个<code>K</code>在内存中对应值的存储位置，那个这个函数就被称为哈希函数：</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/20210517094111543.png" alt="关键字和存储地址之间的对应关系"></p><p>这里举个例子：</p><p>假如我们一共有 50 人参加学校的数学竞赛，然后我们为每个学生分配一个编号，依次是 1 到 50.</p><p>如果我们想要快速知道编号对应学生的信息，我们就可以用一个数组来存放学生的信息，编号为 1 的放到数组下标为 1 的位置，编号为 2 的放到数组下标为 2 的位置，依次类推。</p><p>现在如果我们想知道编号为 20 的学生的信息，我们只需要把数组下标为 20 的元素取出来就可以了，时间复杂度为 O(1)，是不是效率非常高呢。</p><p>但是这些学生肯定来自不同的年级和班级，为了包含更详细的信息，我们在原来编号前边加上年级和班级的信息，比如 030211 ，03 表示年级，02 表示班级，11 原来的编号，这样我们该怎么存储学生的信息，才能够像原来一样使用下标快速查找学生的信息呢？</p><p>思路还是和原来一样，我们通过编号作为下标来储存，但是现在编号多出了年级和班级的信息怎么办呢，我们只需要截取编号的后两位作为数组下标来储存就可以了。</p><p>这个过程就是典型的散列思想。其中，参赛学生的编号我们称之为键(key)，我们用它来标识一个学生。然后我们通过一个方法（比如上边的截取编号最后两位数字）把编号转变为数组下标，这个方法叫做散列函数（哈希函数），通过散列函数得到的值叫做散列值（哈希值）</p><p>我们自己在设计散列函数的函数时应该遵循什么规则呢？</p><ol><li>得到的散列值是一个非负整数</li><li>两个相同的键，通过散列函数计算出的散列值也相同</li><li>两个不同的键，计算出的散列值不同</li></ol><p>虽然我们在设计的时候要求满足以上三条要求，但对于第三点很难保证所有不同的建都被计算出不同的散列值。有可能不同的建会计算出相同的值，这叫做哈希冲突。为了解决这个冲突，可以将散列函数计算得到相同值得<code>key</code>放到同一个链表中，这也是<code>CyberRt</code>中散列表的做法：</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130123005161.png" alt="image-20231130123005161"></p><p>因此散列表就是一个数组，只不过数组中的每个元素都是一个链表，这个链表我们称为一个<code>Bucket</code>，就是一个篮子。<code>Bucket</code>中链表的节点我们用<code>Entry</code>来进行描述。</p><p>我们先来看<code>Entry</code>的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">  <span class="built_in">Entry</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Entry</span><span class="params">(K key)</span> : key(key) &#123;</span></span><br><span class="line">    value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(), std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Entry</span>(K key, <span class="type">const</span> V &amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">    value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(value), std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Entry</span>(K key, V &amp;&amp;value) : <span class="built_in">key</span>(key) &#123;</span><br><span class="line">    value_ptr.<span class="built_in">store</span>(<span class="keyword">new</span> <span class="built_in">V</span>(std::forward&lt;V&gt;(value)), std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Entry</span>() &#123; <span class="keyword">delete</span> value_ptr.<span class="built_in">load</span>(std::memory_order_acquire); &#125;</span><br><span class="line"></span><br><span class="line">  K key = <span class="number">0</span>;</span><br><span class="line">  std::atomic&lt;V *&gt; value_ptr = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  std::atomic&lt;Entry *&gt; next = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个<code>Entry</code>存储了一个数据指针和指向下一个<code>Entry</code>的指针，他们都是原子变量，在这份源码中，定义说这个键的类型必须为整形，因此<code>K key = 0</code>，里面提供了四个构造函数。</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130125814591.png" alt="image-20231130125814591"></p><p>然后是<code>Bucket</code>的定义：<code>Bucket</code>是一个链表，对链表中的每一个节点的操作都是原子的。</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130135128856.png" alt="image-20231130135128856"></p><p>在散列表中放入键值后，散列表就长下面这样子了：哈希值相同的键放在同一个<code>Bucket</code>里，同一个<code>Bucket</code>中键的排列依次往下接就行</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130140811197.png" alt="image-20231130140811197"></p><ul><li><p>在<code>Bucket</code>中查找<code>key</code>：根据<code>key</code>挨个对<code>Entry</code>中的<code>key</code>值进行比较，如果找到了就返回<code>true</code>，没找到就返回<code>false</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">  Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;key &lt; key) &#123;</span><br><span class="line">      m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target-&gt;key == key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Bucket</code>中查找<code>key</code>对应的那个<code>Entry</code>：从头节点开始遍历，只要<code>m_target</code>不是<code>null_ptr</code>，循环就会继续执行，如果有对应的<code>key</code>值，将通过<code>prev_ptr</code>和<code>target_ptr</code>参数返回查找结果。<code>prev_ptr</code>和<code>target_ptr</code>都是二级指针，都指向了一个<code>Entry*</code>。如果<code>target</code>指向的那个<code>Entry</code>中的<code>key</code>值大于传入的这个<code>key</code>值，同时又不相等，说明这个<code>key</code>值的大小位于<code>prev</code>和<code>target</code>之间，从这里我们可以猜测，拥有相同哈希值的<code>key</code>在同一个<code>Bucket</code>中的排列是按照从小到大的顺序排的</p><p><img src="/2023/11/30/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%97%A0%E9%94%81%E5%93%88%E5%B8%8C%E8%A1%A8/image-20231130144538014.png" alt="image-20231130144538014"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(K key, Entry **prev_ptr, Entry **target_ptr)</span> </span>&#123;</span><br><span class="line">  Entry *prev = head_;</span><br><span class="line">  Entry *m_target = head_-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">while</span> (Entry *target = m_target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;key == key) &#123;</span><br><span class="line">      *prev_ptr = prev;</span><br><span class="line">      *target_ptr = target;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;key &gt; key) &#123;</span><br><span class="line">      *prev_ptr = prev;</span><br><span class="line">      *target_ptr = target;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev = target;</span><br><span class="line">      m_target = target-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *prev_ptr = prev;</span><br><span class="line">  *target_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Bucket</code>中根据键值插入对应的<code>value</code>:首先调用上面的<code>find</code>函数去查找<code>Bucket</code>中是否存在<code>key</code>，如果存在则新建一个<code>value</code>，然后通过cas操作去修改此<code>Entry</code>中的<code>value</code>值。如果在<code>Bucket</code>中没有找到这个<code>key</code>，说明需要新建一个<code>Entry</code>，需要将这个<code>new_entry</code>插入到<code>prev</code>和<code>target</code>之间，这里也是原子操作。其余两个插入函数同理，只是入参不一样。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">  Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">  Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">  Entry *new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">  V *new_value = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">      <span class="comment">// key exists, update value</span></span><br><span class="line">      <span class="keyword">if</span> (!new_value) &#123;</span><br><span class="line">        new_value = <span class="keyword">new</span> <span class="built_in">V</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">auto</span> old_val_ptr = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">      <span class="keyword">if</span> (target-&gt;value_ptr.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">              old_val_ptr, new_value, std::memory_order_acq_rel,</span><br><span class="line">              std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">delete</span> old_val_ptr;</span><br><span class="line">        <span class="keyword">if</span> (new_entry) &#123;</span><br><span class="line">          <span class="keyword">delete</span> new_entry;</span><br><span class="line">          new_entry = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">        new_entry = <span class="keyword">new</span> <span class="built_in">Entry</span>(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">      new_entry-&gt;next.<span class="built_in">store</span>(target, std::memory_order_release);</span><br><span class="line">      <span class="keyword">if</span> (prev-&gt;next.<span class="built_in">compare_exchange_strong</span>(target, new_entry,</span><br><span class="line">                                             std::memory_order_acq_rel,</span><br><span class="line">                                             std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">// Insert success</span></span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">          <span class="keyword">delete</span> new_value;</span><br><span class="line">          new_value = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// another entry has been inserted, retry</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后是根据<code>key</code>值拿到<code>value</code>的函数，也是通过<code>Find</code>函数去找，如果找到了则赋值，没找到就返回<code>false</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">  Entry *prev = <span class="literal">nullptr</span>;</span><br><span class="line">  Entry *target = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Find</span>(key, &amp;prev, &amp;target)) &#123;</span><br><span class="line">    *value = target-&gt;value_ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>有了<code>Entry</code>和<code>Bucket</code>之后我们来看一下<code>AtomicHashMap</code>的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, std::<span class="type">size_t</span> TableSize = <span class="number">128</span>,</span><br><span class="line">          <span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;K&gt;::value &amp;&amp;</span><br><span class="line">                                      (TableSize &amp; (TableSize - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                                  <span class="type">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> AtomicHashMap &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>() : <span class="built_in">capacity_</span>(TableSize), <span class="built_in">mode_num_</span>(capacity_ - <span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">AtomicHashMap</span>(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  AtomicHashMap &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AtomicHashMap &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Has</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Has</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V **value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    <span class="keyword">return</span> table_[index].<span class="built_in">Get</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(K key, V *value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    V *val = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">bool</span> res = table_[index].<span class="built_in">Get</span>(key, &amp;val);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      *value = *val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(K key, V &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> index = key &amp; mode_num_;</span><br><span class="line">    table_[index].<span class="built_in">Insert</span>(key, std::forward&lt;V&gt;(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  Bucket table_[TableSize];</span><br><span class="line">  <span class="type">uint64_t</span> capacity_;</span><br><span class="line">  <span class="type">uint64_t</span> mode_num_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先模板操作就很有意思:</p><ul><li><code>&lt;typename K, typename V, std::size_t TableSize = 128, ...&gt;</code>: 定义模板的参数列表。<code>K</code> 和 <code>V</code> 是模板的键和值类型，<code>TableSize</code> 是哈希表的大小，默认为 128。</li><li><code>typename std::enable_if&lt;...&gt;::type = 0</code>: 使用 <code>std::enable_if</code> 实现模板的部分特化。这里检查是否 <code>K</code> 是整数类型（<code>std::is_integral&lt;K&gt;::value</code>）并且 <code>TableSize</code> 是 2 的幂（<code>(TableSize &amp; (TableSize - 1)) == 0</code>）。如果条件为真，则模板参数 <code>int</code> 被设置为 0，否则，此模板不可用。</li><li>这里也是用到了c++的<code>SFINAE</code>特性</li></ul><blockquote><p><code>TableSize &amp; (TableSize - 1)</code> 是一个位运算操作，用于检查一个数是否是2的幂。</p><ul><li>如果一个数是2的幂，那么它的二进制表示中只有一个位是1，其余位都是0。</li><li>如果减去1，所有的1都变成0，而低位的0都变成1。</li></ul><p>通过使用按位与（<code>&amp;</code>）操作，只有在两个相应的位都是1时结果才是1。因此，如果 <code>TableSize</code> 是2的幂，那么 <code>TableSize &amp; (TableSize - 1)</code> 将等于0。</p><p>这个检查在哈希表的实现中经常用来确保哈希表的大小是2的幂，这有助于提高散列函数的效果，使得键在哈希表中更均匀地分布。</p></blockquote><p><code>AtomicHashMap</code>类的内部定义了一个<code>Bucket table_[TableSize]</code>的数组，哈希函数其实就是线性的取余，里面对哈希表的操作也比较简单，就是先去根据键的值取余去拿到对应的<code>Bucket</code>，然后再去<code>Buket</code>中操作</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/Peealy/article/details/116895964">一文看懂哈希表并学会使用C++ STL 中的哈希表_哈希表end函数-CSDN博客</a></li><li><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp16.html">实现线程安全的查找表 · 恋恋风辰的编程笔记 (llfc.club)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-线程池</title>
      <link href="/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h2><p>在<code>cyber/base/thread_pool.h</code>中实现了一个线程池的类，写得很高级，我们来分析一下，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(std::<span class="type">size_t</span> thread_num, std::<span class="type">size_t</span> max_task_num = <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">      -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">  BoundedQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; task_queue_;</span><br><span class="line">  std::atomic_bool stop_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数入参为 线程数量和最大任务数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(std::<span class="type">size_t</span> threads, std::<span class="type">size_t</span> max_task_num)</span></span></span><br><span class="line"><span class="function">    : stop_(false) &#123;</span></span><br><span class="line">  <span class="comment">/*创建一个BoundedQueue，采用的等待策略是阻塞策略*/</span></span><br><span class="line">  <span class="keyword">if</span> (!task_queue_.<span class="built_in">Init</span>(max_task_num, <span class="keyword">new</span> <span class="built_in">BlockWaitStrategy</span>())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue init failed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化线程池 创建空的任务，每个任务的逻辑就是 */</span></span><br><span class="line">  workers_.<span class="built_in">reserve</span>(threads);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">    workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">while</span> (!stop_) &#123;</span><br><span class="line">        <span class="comment">/*返回值为空的可调用对象*/</span></span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">if</span> (task_queue_.<span class="built_in">WaitDequeue</span>(&amp;task)) &#123;</span><br><span class="line">          <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before using the return value, you should check value.valid()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::Enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">      std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">  std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">  <span class="keyword">if</span> (stop_) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">future</span>&lt;return_type&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">Enqueue</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="comment">/* 唤醒线程池里所有线程，然后等待所有子线程执行完毕，释放资源*/</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (stop_.<span class="built_in">exchange</span>(<span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">BreakAllWait</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::thread&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-线程池的实现"><a href="#2-线程池的实现" class="headerlink" title="2. 线程池的实现"></a>2. 线程池的实现</h2><p>线程池是一种多线程处理形式，它处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。</p><p> 首先先来看一下线程池的模型：</p><p><img src="/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20231129165547298.png" alt="image-20231129165547298"></p><p>线程池中有两个队列，一个工作队列，这就是线程池维护的线程队列，另一个是任务队列，工作队列中的线程去任务队列中领取任务从而执行，空闲的线程呢则等待直到任务队列有任务可获取。</p><p>基于此我们来看<code>ThreadPool</code>类中定义的成员变量：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">BoundedQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; task_queue_;</span><br><span class="line">std::atomic_bool stop_;</span><br></pre></td></tr></table></figure><ul><li>工作队列的数据结构是<code>vector</code>类型，就是一个数组，数组中的每一个元素都是一个<code>std::thread</code></li><li>任务队列的数据结构是前面实现的<code> BoundedQueue</code>，<code> BoundedQueue</code>中的每一个元素都是c++中的一个可调用对象：<code>std::function&lt;void()&gt;</code>，是一个返回值为空，参数列表也为空的可调用对象</li><li>还有一个原子变量用于判断线程池是否还在工作</li></ul><p>然后来看线程池的构造函数：传入的参数为线程的数量和所能创建的最大的线程数量，将<code>stop_</code>标志位置为<code>false</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(std::<span class="type">size_t</span> threads, std::<span class="type">size_t</span> max_task_num)</span></span></span><br><span class="line"><span class="function">    : stop_(false) &#123;</span></span><br><span class="line">  <span class="comment">/*创建一个BoundedQueue，采用的等待策略是阻塞策略*/</span></span><br><span class="line">  <span class="keyword">if</span> (!task_queue_.<span class="built_in">Init</span>(max_task_num, <span class="keyword">new</span> <span class="built_in">BlockWaitStrategy</span>())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue init failed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化线程池 创建空的任务，每个任务都是一个while循环 */</span></span><br><span class="line">  workers_.<span class="built_in">reserve</span>(threads);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">    workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">while</span> (!stop_) &#123;</span><br><span class="line">        <span class="comment">/*返回值为空的可调用对象*/</span></span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">if</span> (task_queue_.<span class="built_in">WaitDequeue</span>(&amp;task)) &#123;</span><br><span class="line">          <span class="comment">/*如果出队成功，说明领取到了任务，则就去执行此任务*/</span></span><br><span class="line">          <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先是初始化任务队列<code>task_queue_</code>，并且采用<code>BlockWaitStrategy</code>的线程同步方式，在这种方式下，当队列中没有数据的时候，去队列取数据的线程会被阻塞，直到有线程向队列中添加元素，此时就会通过信号量机制通知阻塞的线程可以继续执行了</p></li><li><p>然后是初始化工作队列，由于<code>workers_</code>数组中的每一个元素都是一个<code>std::function&lt;void()&gt;</code>，所以在初始化的时候是通过<code>lamda</code>表达式来创建的，使用 <code>[this]</code> 捕获列表是为了能够在<code> lambda</code> 函数中访问当前类的成员变量 <code>stop_</code> 和任务队列 <code>task_queue_</code>。如果没有使用 <code>[this]</code>，那么在 <code>lambda</code> 函数中就不能直接访问当前类的成员，因为<code> lambda</code> 默认是不捕获任何外部变量的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">workers_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">     <span class="keyword">while</span> (!stop_) &#123;</span><br><span class="line">       <span class="comment">/*返回值为空的可调用对象*/</span></span><br><span class="line">       std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">       <span class="keyword">if</span> (task_queue_.<span class="built_in">WaitDequeue</span>(&amp;task)) &#123;</span><br><span class="line">         <span class="comment">/*如果出队成功，说明领取到了任务，则就去执行此任务*/</span></span><br><span class="line">         <span class="built_in">task</span>();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当执行<code>emplace_back</code>操作时此时就会创建线程，然后线程一旦创建就会开始执行，执行的操作就是上面这个<code>while</code>循环里代码，此时每个线程都会去执行这一步<code>task_queue_.WaitDequeue(&amp;task)</code>操作，但是由于任务队列中还未放入任务，所以此时创建的所有线程都会被阻塞。</p></li></ul><p>然后来看关键的向任务队列中添加任务的函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before using the return value, you should check value.valid()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::Enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">      std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">  std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">  <span class="keyword">if</span> (stop_) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">future</span>&lt;return_type&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">Enqueue</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数有两个模板参数，第一个模板函数代表一个可调用对象，这个可调用对象就可以理解成我们一个任务，我们在这个函数里会将这个可调用对象封装然后进行入队，第二个模板参数是模板参数包，用于给这个可调用对象传参。这两个模板参数都是以<code>&amp;&amp;</code>万能引用的方式传入的</p><p>函数的返回值类型是<code>std::future&lt;T&gt;</code>类型的，而这个<code>T</code>是什么类型呢：<code>std::result_of&lt;F(Args...)&gt;::type</code></p><p>通过c++11提供的<code>std::result_of</code>推导出了调用<code>F(Args)</code>后的返回值类型。</p><p>拿到这个<code>return_type</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure><p>然后是对这个传入的可调用对象的封装，通过封装使得任务队列中的每个元素都是统一类型，这样工作队列去面对的就是统一的任务类型了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">    std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br></pre></td></tr></table></figure><ul><li><p>首先<code>task</code>是一个智能指针，通过<code>std::make_shared</code>创建</p></li><li><p>指针的模板类型是<code>std::packaged_task&lt;return_type()&gt;</code>，<code>std::packaged_task</code>可以用来封装任何可以调用的目标，从而用于实现异步的调用。<code>return_type()</code>是<code>std::packaged_task</code>的模板参数，代表封装的是一个<code>return_type()</code>类型的可调用对象，这不就是我们传入的这个<code>F(Args)</code>吗，区别在于没有参数而已，这时候就轮到<code>std::bind</code>出场了</p></li><li><p>假设不用智能指针封装，那么代码该这么写：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">return_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...))</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>std::bind</code>起到的作用就是将函数和参数打包生成一个可调用对象，这个可调用对象不用传参了，c++去调用的时候函数的参数已经被打包到<code>bind</code>内部，这不就刚好满足我们上面的需求吗，经过上面一系列操作，我们的任务队列中存储的就是一个个指向具体任务的指针了。注意这里使用<code>std::forward</code>是为了对传进来的模板参数进行完美转发</p></li></ul><p>接着创建了一个<code>future</code>对象：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure><p>这个<code>future</code>对象的模板参数是<code>return_type</code>，用于和上面创建的任务队列里的<code>std::packaged_task&lt;return_type()&gt;</code>可调用对象的返回值相绑定，后续当任务执行完毕我们就可以通过<code>res.get()</code>来异步的获取任务执行后的返回值</p><p>后面就是入队操作了：再次利用<code>std::function</code>，将<code>task</code>指向的<code>std::packaged_task</code>对象取出并包装为void函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">task_queue_.<span class="built_in">Enqueue</span>([task]() &#123; (*task)(); &#125;);</span><br></pre></td></tr></table></figure><p>传入的是一个<code>lamda</code>表达式，捕获<code>task</code>，表达式内部就是去执行这个可调用对象，通过<code>(*task)()</code></p><p>在任务入队之后，还记得在之前实现<code>BoundedQueue</code>时会去执行<code>NotifyOne</code>操作，这样就会唤醒阻塞在队列上的一个工作者线程去拿到传入的这个<code>std::function&lt;void()&gt;</code>去执行。</p><p><img src="/2023/11/29/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20231129210355863.png" alt="image-20231129210355863"></p><p>最后来看析构函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (stop_.<span class="built_in">exchange</span>(<span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  task_queue_.<span class="built_in">BreakAllWait</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::thread&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将<code>stop_</code>标志位设置为<code>true</code></li><li>调用<code> task_queue_.BreakAllWait();</code>来唤醒所有的线程，等待所有线程执行完毕后销毁资源</li></ul><p>这个线程池的设计涉及到c++11很多知识点：</p><ul><li><p>左值与右值引用</p></li><li><p>引用折叠与完美转发</p></li><li><p><code>std::thread</code></p></li><li><p><code>std::future</code></p></li><li><p><code>std::bind</code></p></li><li><p><code>std::function</code></p></li><li><p><code>std::packaged_task</code></p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>[<a href="https://zhuanlan.zhihu.com/p/469607144">C++特性]对std::move和std::forward的理解 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现线程池 - 知乎 (zhihu.com)</a></li><li><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp07.html">C++ 并发三剑客future, promise和async · 恋恋风辰的编程笔记 (llfc.club)</a></li><li><a href="https://www.bilibili.com/video/BV18w411i74T/?spm_id_from=333.337.search-card.all.click&vd_source=1325a6af2d360c06e8e0c5e177802b1b">C++ 并发编程(7) 并发三剑客async,promise和future_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码分析-原子读写锁</title>
      <link href="/2023/11/25/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8E%9F%E5%AD%90%E8%AF%BB%E5%86%99%E9%94%81/"/>
      <url>/2023/11/25/CyberRt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8E%9F%E5%AD%90%E8%AF%BB%E5%86%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h2><p>在<code>cyber/base/atomic_rw_lock.h</code>中实现了一个读写锁，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicRWLock</span> &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ReadLockGuard</span>&lt;AtomicRWLock&gt;;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteLockGuard</span>&lt;AtomicRWLock&gt;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> RW_LOCK_FREE = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> WRITE_EXCLUSIVE = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> MAX_RETRY_TIMES = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">AtomicRWLock</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AtomicRWLock</span><span class="params">(<span class="type">bool</span> write_first)</span> : write_first_(write_first) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// all these function only can used by ReadLockGuard/WriteLockGuard;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReadLock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">WriteLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReadUnlock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">WriteUnlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AtomicRWLock</span>(<span class="type">const</span> AtomicRWLock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  AtomicRWLock&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AtomicRWLock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  std::atomic&lt;<span class="type">uint32_t</span>&gt; write_lock_wait_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  std::atomic&lt;<span class="type">int32_t</span>&gt; lock_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">bool</span> write_first_ = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int32_t</span> lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">  <span class="keyword">if</span> (write_first_) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE || write_lock_wait_num_.<span class="built_in">load</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int32_t</span> rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(rw_lock_free, WRITE_EXCLUSIVE,</span><br><span class="line">                                          std::memory_order_acq_rel,</span><br><span class="line">                                          std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="comment">// rw_lock_free will change after CAS fail, so init agin</span></span><br><span class="line">    rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">    <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">      <span class="comment">// saving cpu</span></span><br><span class="line">      std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">      retry_times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="2-原子读写锁的实现"><a href="#2-原子读写锁的实现" class="headerlink" title="2.原子读写锁的实现"></a>2.原子读写锁的实现</h2><p>读写锁的特性：</p><ul><li>当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会<strong>阻塞</strong>（不是失败）。</li><li>当读写锁被加了读锁时，其他线程对该锁加写锁会<strong>阻塞</strong>，加读锁会成功。</li></ul><p>简单说就是运行多个线程同时读，但是同时只能允许一个线程去写，非常适合读多少写的场景</p><p>首先<code>AtomicRWLock </code>中声明了两个友元类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ReadLockGuard</span>&lt;AtomicRWLock&gt;;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteLockGuard</span>&lt;AtomicRWLock&gt;;</span><br></pre></td></tr></table></figure><p>这两个友元类定义在<code>cyber/base/rw_lock_guard.h</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RWLock&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadLockGuard</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReadLockGuard</span><span class="params">(RWLock&amp; lock)</span> : rw_lock_(lock) &#123;</span> rw_lock_.<span class="built_in">ReadLock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReadLockGuard</span>() &#123; rw_lock_.<span class="built_in">ReadUnlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">ReadLockGuard</span>(<span class="type">const</span> ReadLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  ReadLockGuard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ReadLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  RWLock&amp; rw_lock_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RWLock&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriteLockGuard</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">WriteLockGuard</span><span class="params">(RWLock&amp; lock)</span> : rw_lock_(lock) &#123;</span></span><br><span class="line">    rw_lock_.<span class="built_in">WriteLock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">WriteLockGuard</span>() &#123; rw_lock_.<span class="built_in">WriteUnlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">WriteLockGuard</span>(<span class="type">const</span> WriteLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  WriteLockGuard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WriteLockGuard&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  RWLock&amp; rw_lock_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看见这两个类在创建的时候构造函数会去调用读写锁的读或者写操作去持有锁，在析构的时候会去解锁，这就是利用c++的RAII机制实现对加锁和开锁的封装，这样就不用用户手动去加锁和释放锁了，和c++提供的<code>std::lock_guard</code>用法类似</p><p>读写锁的操作是靠几个变量来控制的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">uint32_t</span>&gt; write_lock_wait_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int32_t</span>&gt; lock_num_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> write_first_ = <span class="literal">true</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> RW_LOCK_FREE = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> WRITE_EXCLUSIVE = <span class="number">-1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> MAX_RETRY_TIMES = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li><code>write_lock_wait_num_</code> 代表了有多少个线程等着写就是多少个线程等着持有读锁</li><li><code>lock_num_</code>代表持有锁的线程的数量，由于读锁是允许多个线程同时读的，所以</li><li><code>RW_LOCK_FREE</code>：标志位，代表此时没有线程持有锁，可读可写</li><li><code>WRITE_EXCLUSIVE</code>：标志位，代表此时锁被一个写的线程暂用</li><li><code>MAX_RETRY_TIMES</code>：尝试获取锁的时候连续尝试次数，就像自旋锁那样，连续失败MAX_RETRY_TIMES次则会让出线程的执行权</li><li><code>write_first_</code>：默认写的操作优先</li></ul><p>我们先来看读写锁的写锁：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int32_t</span> rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(rw_lock_free, WRITE_EXCLUSIVE,</span><br><span class="line">                                          std::memory_order_acq_rel,</span><br><span class="line">                                          std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="comment">// rw_lock_free will change after CAS fail, so init agin</span></span><br><span class="line">    rw_lock_free = RW_LOCK_FREE;</span><br><span class="line">    <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">      <span class="comment">// saving cpu</span></span><br><span class="line">      std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">      retry_times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  write_lock_wait_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>write_lock_wait_num_</code>记录了想要持有读锁的线程的数量，因此每次<code>WriteLock()</code>操作需要+1</li><li>接着循环会去比较<code>lock_num_</code>和<code>rw_lock_free</code>的值，会出现以下两种情况：<ul><li>1.：<code>lock_num_</code> &#x3D;  <code>rw_lock_free</code>&#x3D;&#x3D; <code>0</code>，代表此时没人用锁，则将<code>lock_num_</code>的值置为<code>WRITE_EXCLUSIVE=-1</code>,直接跳出循环，此时假设另外一个线程也来写，而<code>lock_num_=-1</code>，所以必须等待前一个持有写锁的人解锁才行，所以解锁操作也显而易见了，就是将<code>lock_num_+1</code>恢复到<code>RW_LOCK_FREE</code></li><li>2：<code>lock_num_&gt;=1</code>代表其他线程持有了读锁，或<code>lock_num_&gt;=WRITE_EXCLUSIVE</code>这种情况就是上面提到的另外一个线程持有了读锁，但是还没解锁，那么此时该线程就会去执行<code>while</code>循环里的操作，在while循环里会重置<code>rw_lock_free</code>的值，然后循环判断几次如果还在等待就执行<code>yield()</code>操作让当前线程释放cpu所有权。</li></ul></li></ul><p>再来看读写锁的读锁：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> retry_times = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int32_t</span> lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">  <span class="keyword">if</span> (write_first_) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE || write_lock_wait_num_.<span class="built_in">load</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (lock_num &lt; RW_LOCK_FREE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++retry_times == MAX_RETRY_TIMES) &#123;</span><br><span class="line">          <span class="comment">// saving cpu</span></span><br><span class="line">          std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">          retry_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_num = lock_num_.<span class="built_in">load</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!lock_num_.<span class="built_in">compare_exchange_weak</span>(lock_num, lock_num + <span class="number">1</span>,</span><br><span class="line">                                              std::memory_order_acq_rel,</span><br><span class="line">                                              std::memory_order_relaxed));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于默认写优先就是说我在写的时候是不允许读的，先进入一个分支执行<code>do</code>操作：然后去进行判断是否有线程在执行写操作，即<code>lock_num &lt; RW_LOCK_FREE || write_lock_wait_num_.load() &gt; 0</code>，则想要读的这个线程就让出cpu等着写的线程写完先，如果写完了重新加载一下<code>lock_num</code>的值，然后去执行<code>lock_num_.compare_exchange_weak</code>这个操作，这里有两种情况：</p><ul><li>1.<code>lock_num_==lock_num</code>(即大于等于0)，可能你会说这不是肯定的吗？这个还真不一定，虽然刚执行过<code>lock_num = lock_num_.load()</code>;但是<code>lock_num</code>是个多线程控制的值，随时在变。然后将<code>lock_num_</code>的值加一</li><li>2.<code>lock_num_!=lock_num  lock_num</code>赋值为<code>lock_num_</code>（无用） 重新循环 简单点来讲就是：刚刚的判断好好的，正当我要办事的时候，突然有线程偷偷改变了值，一切判断作废，重新来过</li></ul><p>最后是解锁操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::ReadUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AtomicRWLock::WriteUnlock</span><span class="params">()</span> </span>&#123; lock_num_.<span class="built_in">fetch_add</span>(<span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><p>读锁解锁就是将大于0的<code>lock_num_</code>做减1操作，写锁的解锁就是将-1转到0</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://liujiayu.blog.csdn.net/article/details/124732353">百度自动驾驶apollo源码解读1：std::atomic实现读写锁_阿波罗自动驾驶代码-CSDN博客</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/569073042">原子读写锁的实现 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://subingwen.cn/linux/thread-sync/">线程同步 | 爱编程的大丙 (subingwen.cn)</a></p></li><li><p><a href="https://blog.csdn.net/kenjianqi1647/article/details/117998175">C++11锁的用法( 多线程，并发，错误使用、std::ref用法、RAII)_c++11智能锁-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 原子读写锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-有界无锁队列</title>
      <link href="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
      <url>/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h2><p>在<code>cyber/base/bounded_queue.h</code>中实现了一个有界无锁队列的模板类，通过c++提供的原子操作来确保线程安全，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedQueue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BoundedQueue</span>() &#123;&#125;</span><br><span class="line">  BoundedQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> BoundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">BoundedQueue</span>(<span class="type">const</span> BoundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  ~<span class="built_in">BoundedQueue</span>();</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">uint64_t</span> size)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">uint64_t</span> size, WaitStrategy* strategy)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(T&amp;&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WaitEnqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WaitEnqueue</span><span class="params">(T&amp;&amp; element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T* element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WaitDequeue</span><span class="params">(T* element)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Size</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetWaitStrategy</span><span class="params">(WaitStrategy* WaitStrategy)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head_.<span class="built_in">load</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> tail_.<span class="built_in">load</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">Commit</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> commit_.<span class="built_in">load</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">GetIndex</span><span class="params">(<span class="type">uint64_t</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; head_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; tail_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; commit_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="comment">// alignas(CACHELINE_SIZE) std::atomic&lt;uint64_t&gt; size_ = &#123;0&#125;;</span></span><br><span class="line">  <span class="type">uint64_t</span> pool_size_ = <span class="number">0</span>;</span><br><span class="line">  T* pool_ = <span class="literal">nullptr</span>;</span><br><span class="line">  std::unique_ptr&lt;WaitStrategy&gt; wait_strategy_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">bool</span> break_all_wait_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BoundedQueue&lt;T&gt;::~<span class="built_in">BoundedQueue</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (wait_strategy_) &#123;</span><br><span class="line">    <span class="built_in">BreakAllWait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pool_) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">      pool_[i].~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(pool_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Init</span>(<span class="type">uint64_t</span> size) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Init</span>(size, <span class="keyword">new</span> <span class="built_in">SleepWaitStrategy</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Init</span>(<span class="type">uint64_t</span> size, WaitStrategy* strategy) &#123;</span><br><span class="line">  <span class="comment">// Head and tail each occupy a space</span></span><br><span class="line">  pool_size_ = size + <span class="number">2</span>;</span><br><span class="line">  pool_ = <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(std::<span class="built_in">calloc</span>(pool_size_, <span class="built_in">sizeof</span>(T)));</span><br><span class="line">  <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    <span class="keyword">new</span> (&amp;(pool_[i])) <span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  wait_strategy_.<span class="built_in">reset</span>(strategy);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Enqueue</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_commit = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_tail = tail_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_tail = old_tail + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetIndex</span>(new_tail) == <span class="built_in">GetIndex</span>(head_.<span class="built_in">load</span>(std::memory_order_acquire))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!tail_.<span class="built_in">compare_exchange_weak</span>(old_tail, new_tail,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  pool_[<span class="built_in">GetIndex</span>(old_tail)] = element;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old_commit = old_tail;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">      old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">      std::memory_order_relaxed)));</span><br><span class="line">  <span class="comment">//唤醒一个等待的线程，告诉它队列中已经有新的元素可以被取出或处理了。</span></span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">NotifyOne</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Enqueue</span>(T&amp;&amp; element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_commit = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_tail = tail_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_tail = old_tail + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetIndex</span>(new_tail) == <span class="built_in">GetIndex</span>(head_.<span class="built_in">load</span>(std::memory_order_acquire))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!tail_.<span class="built_in">compare_exchange_weak</span>(old_tail, new_tail,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  pool_[<span class="built_in">GetIndex</span>(old_tail)] = std::<span class="built_in">move</span>(element);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old_commit = old_tail;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">      old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">      std::memory_order_relaxed)));</span><br><span class="line">  <span class="comment">//唤醒一个等待的线程，告诉它队列中已经有新的元素可以被取出或处理了。</span></span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">NotifyOne</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Dequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_head = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_head = head_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_head = old_head + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_head == commit_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *element = pool_[<span class="built_in">GetIndex</span>(new_head)];</span><br><span class="line">  &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_weak</span>(old_head, new_head,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitEnqueue</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Enqueue</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitEnqueue</span>(T&amp;&amp; element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Enqueue</span>(std::<span class="built_in">move</span>(element))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitDequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dequeue</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint64_t</span> BoundedQueue&lt;T&gt;::<span class="built_in">Size</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> tail_ - head_ - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Empty</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Size</span>() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint64_t</span> BoundedQueue&lt;T&gt;::<span class="built_in">GetIndex</span>(<span class="type">uint64_t</span> num) &#123;</span><br><span class="line">  <span class="keyword">return</span> num - (num / pool_size_) * pool_size_;  <span class="comment">// faster than %</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> BoundedQueue&lt;T&gt;::<span class="built_in">SetWaitStrategy</span>(WaitStrategy* strategy) &#123;</span><br><span class="line">  wait_strategy_.<span class="built_in">reset</span>(strategy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> BoundedQueue&lt;T&gt;::<span class="built_in">BreakAllWait</span>() &#123;</span><br><span class="line">  break_all_wait_ = <span class="literal">true</span>;</span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">BreakAllWait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-有界无锁队列的实现"><a href="#2-有界无锁队列的实现" class="headerlink" title="2.有界无锁队列的实现"></a>2.有界无锁队列的实现</h2><p>首先来看<code>BoundedQueue</code>这个模板类拥有的数据成员：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; head_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; tail_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">alignas</span>(CACHELINE_SIZE) std::atomic&lt;<span class="type">uint64_t</span>&gt; commit_ = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// alignas(CACHELINE_SIZE) std::atomic&lt;uint64_t&gt; size_ = &#123;0&#125;;</span></span><br><span class="line"><span class="type">uint64_t</span> pool_size_ = <span class="number">0</span>;</span><br><span class="line">T* pool_ = <span class="literal">nullptr</span>;</span><br><span class="line">std::unique_ptr&lt;WaitStrategy&gt; wait_strategy_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> break_all_wait_ = <span class="literal">false</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有界的无锁队列是采用顺序存储结构来实现的，可以理解为一个数组，所以头部和尾部的描述就不是使用的链式结构的指针来维护的，直接定义为<code>u64</code>格式的索引，<code>pool_size_</code>就是这个数组的大小，<code>wait_strategy_</code>是一个<code>unique_ptr</code>，因此<code>wait_strategy_</code>指向的内容不允许被其他指针共享，<code>T* pool</code>是指针，用来指向队列数组的头，在初始化时需要为此指针分配内存大小</p><p>还定义了一个私有函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 由于是无符号整数，所以返回的是索引，类似于取余*/</span></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint64_t</span> BoundedQueue&lt;T&gt;::GetIndex(<span class="type">uint64_t</span> num) &#123;</span><br><span class="line">  <span class="keyword">return</span> num - (num / pool_size_) * pool_size_;  <span class="comment">// faster than %</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明一下上面的操作相当于取余操作，因为无符号整型的数相除，得到的值也是一个无符号数，如果相除的值小于1，则得到的值是0，所以实现了类似取余的操作。</p><p>然后看<code>init</code>函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Init</span>(<span class="type">uint64_t</span> size, WaitStrategy* strategy) &#123;</span><br><span class="line">  <span class="comment">// Head and tail each occupy a space</span></span><br><span class="line">  pool_size_ = size + <span class="number">2</span>;</span><br><span class="line">  pool_ = <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(std::<span class="built_in">calloc</span>(pool_size_, <span class="built_in">sizeof</span>(T)));</span><br><span class="line">  <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    <span class="keyword">new</span> (&amp;(pool_[i])) <span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  wait_strategy_.<span class="built_in">reset</span>(strategy);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>std::calloc(pool_size_, sizeof(T))</code>: 这部分使用了 C 标准库函数 <code>calloc</code>，该函数用于分配指定数量的元素并将它们的内存初始化为零。在这里，它分配了 <code>pool_size_</code> 个元素，每个元素的大小为 <code>sizeof(T)</code> 字节。<code>calloc</code> 与 <code>malloc</code> 不同之处在于它会将分配的内存初始化为零。</p></li><li><p><code>reinterpret_cast&lt;T*&gt;(...)</code>: 这是 C++ 中的类型转换语法，用于将 <code>calloc</code> 返回的指针从 <code>void*</code> 类型转换为 <code>T*</code> 类型。<code>reinterpret_cast</code> 表示底层的二进制表示不发生改变，这种转换通常用于进行低级别的类型转换。</p></li><li><p><code>new (&amp;(pool_[i])) T();</code> 这个用法是在指定的内存地址上调用 T 类型的构造函数。这是一个称为 “placement new” 的 C++ 特性。它允许我们在给定的内存地址上构造对象，而不是在默认的堆上分配内存。这通常用于需要对内存进行更精细控制的场景。</p></li></ul><p>在调用<code>init</code>函数后，队列的内存模型如下：</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124152948409.png" alt="image-20231124152948409"></p><p>这里其实我没想明白为啥要<code>pool_size_ = size + 2;</code>看写的注释说是<code>head_</code>和<code>tail_</code>会占空间。</p><p>接着是向队列中添加元素：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Enqueue</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_commit = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_tail = tail_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_tail = old_tail + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetIndex</span>(new_tail) == <span class="built_in">GetIndex</span>(head_.<span class="built_in">load</span>(std::memory_order_acquire))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!tail_.<span class="built_in">compare_exchange_weak</span>(old_tail, new_tail,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  pool_[<span class="built_in">GetIndex</span>(old_tail)] = element;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old_commit = old_tail;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">      old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">      std::memory_order_relaxed)));</span><br><span class="line">  wait_strategy_-&gt;<span class="built_in">NotifyOne</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是将<code>new_tail+1</code>，然后判断队列是否越界，然后调用<code>tail_.compare_exchange_weak</code>来原子的更新<code>tail</code>_的值。</p><blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  //tail_为原子变量，将当前的tail_的值和old_tail进行比较，如果相等，则tail_更新为new_tail</span><br><span class="line">  //返回true,!操作返回fasle，使得跳出循环，开始下面的入队操作</span><br><span class="line">  //否则，如果tail_的值和old_tail不相等（将old_tail更新为当前的tail_值），</span><br><span class="line">  //说明其他线程已经做了do里边的操作并且tail_值已经更新，已经抢先入队</span><br><span class="line">  //这时返回false,!操作返回true，继续下一次执行do里面的操作，等待入队的时机（或队列已满返回false）</span><br><span class="line">//在old_tail的位置入队，old_tail可能在上面的循环了进行了多次的累加</span><br><span class="line">//和程序入口的old_tail可能已经不同了</span><br></pre></td></tr></table></figure></blockquote><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124165704805.png" alt="image-20231124165704805"></p><p>上面的逻辑是当两个线程操作时，假设其中一个线程执行完毕<code>new_tail = old_tail + 1;</code>后，另外一个线程已经更新了<code>tail_</code>的值，此时就会出现第二张图的情况，<code>tail_</code>不等去当前线程获得的<code>old_tail_</code>，因此将当前线程的<code>old_tail</code>跟新为新的<code>tail_</code>，然后再返回while循环，将<code>new_tail_+1</code>，然后再进行比较发现此时的<code>tail_=old_tail_</code>了，然后再次更新<code>tail_</code>的值就成了第三幅图的样子。</p><p>然后将新加的值放入<code>pool_[GetIndex(old_tail)]</code>中</p><blockquote><p>这里使用了一个很有意思的宏<code>#define cyber_unlikely(x) (__builtin_expect((x), 0))</code></p><p>宏定义使用了 GCC 内建函数 <code>__builtin_expect</code>，它是 GCC 编译器提供的一个特殊内建函数，用于提供条件概率的提示，以帮助编译器进行更好的代码优化。</p><p>具体而言，这个宏的作用是提示编译器表达式 <code>(x)</code> 的结果是不太可能的。<code>__builtin_expect</code> 函数的参数是两个值，第一个是表达式，第二个是期望的结果。在这里，<code>0</code> 表示不太可能的分支。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  old_commit = old_tail;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">cyber_unlikely</span>(!commit_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">    old_commit, new_tail, std::memory_order_acq_rel,</span><br><span class="line">    std::memory_order_relaxed)));</span><br></pre></td></tr></table></figure><p>这里有点绕，假设只有一个线程执行入队操作，那么<code>old_commit</code>和<code>commit</code>的值是相等的，所以此时会将<code>commit_</code>的值更新到新的<code>tail_</code>的位置</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124163223274.png" alt="image-20231124163223274"></p><p>假设有两个线程操作了此队列：后修改<code>tail_</code>的那个线程就会出现如下的情况：<code>old_commit!=commit</code>，因此此线程的<code>old_commit</code>值会被更新成<code>commit</code>的值，然后在do里面<code>old_commit</code>又会被更新成<code>old_tail</code>的值，相当于它一直阻塞在这里了</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124170412439.png" alt="image-20231124170412439"></p><p>而对于先修改<code>tail_</code>的那个线程来说：<code>old_commit=commit</code>，因此会跳出do循环，同时将<code>commit_</code>的值更新成此线程的<code>new_tail</code>的值，即上面那个线程的<code>old_tail</code>的值。</p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124170550072.png" alt="image-20231124170550072"></p><p>因此commit_的值是完全根据入队的顺序进行递增的，不同线程根据入队的循序依次跳出该循环,哪个线程先完成入队操作，哪个线程先跳出该while循环。</p><blockquote><p>但我感觉这个commit的值没啥屌用阿，md还很难理解</p></blockquote><p>然后是从队列中取出元素：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">Dequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_head = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> old_head = head_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    new_head = old_head + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_head == commit_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *element = pool_[<span class="built_in">GetIndex</span>(new_head)];</span><br><span class="line">  &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_weak</span>(old_head, new_head,</span><br><span class="line">                                        std::memory_order_acq_rel,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当队列里有数据的时候，<code>head_</code>和<code>old_head</code>比较，如果相等，则更新为<code>new_head</code>并返回<code>true</code>，退出循环。如果不等，则说明其他线程已经取走了当前的<code>head</code>元素，将<code>old_head</code>更新为<code>head_</code>值并进入下一次do里面的操作，这里说明一下为什么去元素是从<code>new_head</code>处取，因为插入元素时，<code>head_</code>和<code>tail_</code>处是不会放元素的。</p><p>当队列里没数据的时候，第一次<code>do</code>的操作，会对<code>new_head</code>的值和<code>commit_</code>的值进行判断，如果这两个值相等，说明队列里没数据，则返回<code>false</code></p><p><img src="/2023/11/24/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%9C%89%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124172803708.png" alt="image-20231124172803708"></p><p>然后是实现了等待策略的插入函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitEnqueue</span>(T&amp;&amp; element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Enqueue</span>(std::<span class="built_in">move</span>(element))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现了等待机制，如果队列未满，则立马插入返回，否则进入空等状态</p><p>实现了等待策略的取出函数：如果队列中没数据则空等</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BoundedQueue&lt;T&gt;::<span class="built_in">WaitDequeue</span>(T* element) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!break_all_wait_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dequeue</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_strategy_-&gt;<span class="built_in">EmptyWait</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait timeout</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的入队操作就是往尾部添加元素，然后移动尾部指针。出队操作就是从头部取出一个元素，然后移动头部指针，虽然移动了头部指针，但是之前申请的内存是还在的，并不会释放。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/569493127">有界队列及其无锁实现 - 知乎 (zhihu.com)</a></li><li><a href="https://liujiayu.blog.csdn.net/article/details/125657500">百度自动驾驶apollo源码解读9:无锁有界队列BoundedQueue_cyberrt boundedqueue-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 无界无锁队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-无界无锁队列</title>
      <link href="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
      <url>/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h2><p>在<code>cyber/base/unbounded_queue.h</code>中实现了一个无界无锁队列的模板类，通过c++提供的原子操作来确保线程安全，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnboundedQueue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UnboundedQueue</span>() &#123; <span class="built_in">Reset</span>(); &#125;</span><br><span class="line">  UnboundedQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UnboundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">UnboundedQueue</span>(<span class="type">const</span> UnboundedQueue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">UnboundedQueue</span>() &#123; <span class="built_in">Destroy</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Destroy</span>();</span><br><span class="line">    <span class="built_in">Reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Enqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    node-&gt;data = element;</span><br><span class="line">    Node* old_tail = tail_.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tail_.<span class="built_in">compare_exchange_strong</span>(old_tail, node)) &#123;</span><br><span class="line">        old_tail-&gt;next = node;</span><br><span class="line">        old_tail-&gt;<span class="built_in">release</span>();</span><br><span class="line">        size_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T* element)</span> </span>&#123;</span><br><span class="line">    Node* old_head = head_.<span class="built_in">load</span>();</span><br><span class="line">    Node* head_next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      head_next = old_head-&gt;next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (head_next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_strong</span>(old_head, head_next));</span><br><span class="line">    *element = head_next-&gt;data;</span><br><span class="line">    size_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">    old_head-&gt;<span class="built_in">release</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_.<span class="built_in">load</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_.<span class="built_in">load</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    std::atomic&lt;<span class="type">uint32_t</span>&gt; ref_count;</span><br><span class="line">    Node* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">Node</span>() &#123; ref_count.<span class="built_in">store</span>(<span class="number">2</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (ref_count.<span class="built_in">load</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    head_.<span class="built_in">store</span>(node);</span><br><span class="line">    tail_.<span class="built_in">store</span>(node);</span><br><span class="line">    size_.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ite = head_.<span class="built_in">load</span>();</span><br><span class="line">    Node* tmp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (ite != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      tmp = ite-&gt;next;</span><br><span class="line">      <span class="keyword">delete</span> ite;</span><br><span class="line">      ite = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;Node*&gt; head_;</span><br><span class="line">  std::atomic&lt;Node*&gt; tail_;</span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-无界无锁队列的实现"><a href="#2-无界无锁队列的实现" class="headerlink" title="2.无界无锁队列的实现"></a>2.无界无锁队列的实现</h2><p>队列（queue）是只允许在一端进行插入操作，在另一端进行删除操作的线性表，简称“队”。队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾（rear），允许删除的一端称为队头(front)。向队列中插入新的数据元素称为入队，新入队的元素就成为了队列的队尾元素。从队列中删除队头元素称为出队，其后继元素成为新的队头元素。</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/20200915111440959.png" alt="img"></p><blockquote><p>队列作为一种特殊的线性表，也同样存在两种存储结构：顺序存储结构和链式存储结构，可以分别用数组和链表来实现队列。</p></blockquote><p>在cyberrt中是采用链式结构来实现的，通过链表来进行维护，看上面的代码，先看<code>Node</code>的组成：</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124115312276.png" alt="image-20231124115312276"></p><p><code>Node</code>中的成员包含一个模板类的数据<code>data</code>,一个指向下一个节点的指针和一个用于引用计数的<code>count</code>值,<code>release</code>函数用于释放此节点。</p><p><code>UnboundedQueue</code>内部有三个成员，它的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UnboundedQueue</span>() &#123; <span class="built_in">Reset</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    head_.<span class="built_in">store</span>(node);</span><br><span class="line">    tail_.<span class="built_in">store</span>(node);</span><br><span class="line">    size_.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  std::atomic&lt;Node*&gt; head_;</span><br><span class="line">  std::atomic&lt;Node*&gt; tail_;</span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; size_;</span><br></pre></td></tr></table></figure><p><code>head_</code>即是队列的头节点指针，<code>tail_</code>是队列的尾节点指针，<code>size_</code>是节点的个数，这三个变量都是原子类型，保证了在多线程时操作这三个变量时都是线程安全的。</p><p>当<code>UnboundedQueue</code>创建时会去调用<code>Reset()</code>函数，<code>Reset()</code>函数会去<code>new</code>一个<code>Node</code>对象，在<code>Node</code>的构造函数中会将<code>ref_count</code>的值设置为2，因为在队列初始化时头指针和尾指针都指向了同一个节点，所以<code>ref_count=2</code></p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124120233507.png" alt="image-20231124120233507"></p><p>再来看像队列添加元素的函数<code>void Enqueue(const T&amp; element)</code>，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Enqueue</span><span class="params">(<span class="type">const</span> T&amp; element)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">  node-&gt;data = element;</span><br><span class="line">  Node* old_tail = tail_.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail_.<span class="built_in">compare_exchange_strong</span>(old_tail, node)) &#123;</span><br><span class="line">      old_tail-&gt;next = node;</span><br><span class="line">      old_tail-&gt;<span class="built_in">release</span>();</span><br><span class="line">      size_.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先同样会新建一个<code>Node</code>，然后对新建的<code>Node</code>的<code>data</code>赋值，我们知道向队列插入元素是在尾部添加，这里使用了一个<code>compare_exchange_strong</code>函数来将<code>tail</code>与<code>old_tail</code>进行比较，如果是同一个则将tail的替换成新建的这个node，然后现在队列的尾部指针就是新建这个<code>node</code>了,这个<code>compare_exchange_strong</code>写的非常巧妙，如果没有发生多线程竞争的话，<code>compare_exchange_strong</code>返回true  ,意味着循环一次就结束，<code>tail_</code>的值被设为了<code>node</code>。因为<code>compare_exchange_strong</code>是线程安全的。</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124121117146.png" alt="image-20231124121117146"></p><p>可以看见当尾插一个新的节点后上一个节点的引用计数就变成了1，因为调用了<code>release()</code>函数，<code>release()</code>中会对节点引用计数减一，同时如果此节点的引用计数变成了0则销毁此节点释放内存</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (ref_count.<span class="built_in">load</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的整体结构如下：尾部节点的引用计数始终是2，链表里面所有成员的引用计数都是1。</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%97%A0%E7%95%8C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/image-20231124122433323.png" alt="image-20231124122433323"></p><p>然后来看从队列中取出数据的函数，取出数据时就是从头部取了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T* element)</span> </span>&#123;</span><br><span class="line">  Node* old_head = head_.<span class="built_in">load</span>();</span><br><span class="line">  Node* head_next = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    head_next = old_head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head_next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_strong</span>(old_head, head_next));</span><br><span class="line">  *element = head_next-&gt;data;</span><br><span class="line">  size_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br><span class="line">  old_head-&gt;<span class="built_in">release</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单，就是将之前的头指针指向第二个节点，同样使用了<code>compare_exchange_strong</code>来保证线程安全，取出数据后之前的头节点就没用了因此调用<code>release()</code>函数去删除这个节点。</p><p>然后最后是队列的销毁函数，这个函数就比较简单了：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ite = head_.<span class="built_in">load</span>();</span><br><span class="line">  Node* tmp = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (ite != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    tmp = ite-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> ite;</span><br><span class="line">    ite = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从头节点开始遍历，依次删除节点，直到遍历到最后一个节点，因为最后一个节点的<code>next</code>指针指向了<code>nullptr</code>，所以到此停止。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://liujiayu.blog.csdn.net/article/details/129615374">百度自动驾驶apollo源码解读13:无锁无界队列UnboundedQueue_H-KING的博客-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/599202353">C++原子变量atomic详解 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/Jacky_Feng/article/details/108595654">【数据结构】队列(顺序队列、循环队列、链队列）-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> 无界无锁队列 </tag>
            
            <tag> 原子操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-线程等待策略</title>
      <link href="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/"/>
      <url>/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程等待策略"><a href="#1-线程等待策略" class="headerlink" title="1.线程等待策略"></a>1.线程等待策略</h2><p>在<code>base/wait_strategy.h</code>这个头文件中定义了线程切换的策略类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitStrategy</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NotifyOne</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">WaitStrategy</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BlockWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyOne</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_one</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    cv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_all</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex mutex_;</span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SleepWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SleepWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepWaitStrategy</span><span class="params">(<span class="type">uint64_t</span> sleep_time_us)</span></span></span><br><span class="line"><span class="function">      : sleep_time_us_(sleep_time_us) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(sleep_time_us_));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetSleepTimeMicroSeconds</span><span class="params">(<span class="type">uint64_t</span> sleep_time_us)</span> </span>&#123;</span><br><span class="line">    sleep_time_us_ = sleep_time_us;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint64_t</span> sleep_time_us_ = <span class="number">10000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YieldWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">YieldWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BusySpinWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BusySpinWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeoutBlockWaitStrategy</span> : <span class="keyword">public</span> WaitStrategy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TimeoutBlockWaitStrategy</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TimeoutBlockWaitStrategy</span><span class="params">(<span class="type">uint64_t</span> timeout)</span></span></span><br><span class="line"><span class="function">      : time_out_(std::chrono::milliseconds(timeout)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyOne</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_one</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">EmptyWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (cv_.<span class="built_in">wait_for</span>(lock, time_out_) == std::cv_status::timeout) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BreakAllWait</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cv_.<span class="built_in">notify_all</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetTimeout</span><span class="params">(<span class="type">uint64_t</span> timeout)</span> </span>&#123;</span><br><span class="line">    time_out_ = std::chrono::<span class="built_in">milliseconds</span>(timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex mutex_;</span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line">  std::chrono::milliseconds time_out_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>WaitStrategy基类：</strong><ul><li><code>WaitStrategy</code> 是一个虚基类，定义了等待策略的基本接口。</li><li>其中包括 <code>NotifyOne()</code> 、 <code>BreakAllWait()</code> 和 <code>EmptyWait()</code> 纯虚函数。</li></ul></li><li><strong>BlockWaitStrategy类：</strong><ul><li><code>BlockWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了阻塞式等待策略。</li><li>它使用了互斥锁和条件变量，通过 <code>cv_.wait(lock)</code> 进行线程等待，通过 <code>cv_.notify_one()</code> 唤醒一个等待的线程，通过 <code>cv_.notify_all()</code> 唤醒所有等待的线程。</li><li>线程会一直阻塞在此直到另外一个线程来唤醒，当线程被唤醒后才会返回<code>true</code></li></ul></li><li><strong>SleepWaitStrategy类：</strong><ul><li><code>SleepWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了休眠式等待策略。</li><li>在 <code>EmptyWait()</code> 中，通过 <code>std::this_thread::sleep_for()</code> 函数使当前线程休眠一段时间。</li><li>线程会休眠一段时间，不会进行阻塞，睡眠时间结束后返回<code>true</code></li></ul></li><li><strong>YieldWaitStrategy类：</strong><ul><li><code>YieldWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了让出CPU时间片的等待策略。</li><li>在 <code>EmptyWait()</code> 中，通过 <code>std::this_thread::yield()</code> 函数让当前线程放弃其时间片。</li><li>线程时间片切换，返回<code>true</code></li></ul></li><li><strong>BusySpinWaitStrategy类：</strong><ul><li><code>BusySpinWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了忙等待策略。</li><li>在 <code>EmptyWait()</code> 中，直接返回 <code>true</code>，表示一直忙等。</li><li>始终返回<code>true</code>，一直等待</li></ul></li><li><strong>TimeoutBlockWaitStrategy类：</strong><ul><li><code>TimeoutBlockWaitStrategy</code> 继承自 <code>WaitStrategy</code>，实现了带有超时的阻塞等待策略。</li><li>它在 <code>EmptyWait()</code> 中，使用 <code>cv_.wait_for(lock, time_out_)</code>，允许线程等待一段时间，如果超时则返回 <code>false</code>，否则返回 <code>true</code>。</li><li>线程在超时时间内没有被唤醒，此时 <code>EmptyWait</code> 方法将返回 <code>false</code>，反映了等待过程中的超时情况。如果被唤醒，返回 <code>true</code>。线程在确定时间内为阻塞状态</li></ul></li></ol><p>uml类图如下：</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/uml.png" alt="uml"></p><h2 id="2-参考连接"><a href="#2-参考连接" class="headerlink" title="2.参考连接"></a>2.参考连接</h2><ul><li><p><a href="https://cloud.tencent.com/developer/article/2339238">C++ std::condition_variable 条件变量用法-腾讯云开发者社区-腾讯云 (tencent.com)</a></p></li><li><p><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp03.html">C++ 互斥和死锁 · 恋恋风辰的编程笔记 (llfc.club)</a></p></li><li><p><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp04.html">unique_lock，读写锁以及递归锁 · 恋恋风辰的编程笔记 (llfc.club)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/499085575">多线程不安全因素？线程安全问题分析总结 - 知乎 (zhihu.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> fastrtps </tag>
            
            <tag> 分布式通信中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberRt源码剖析-常用宏分析</title>
      <link href="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/"/>
      <url>/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从这篇blog开始，我们来分析百度CyberRt这个高性能的分布式通信中间件</p></blockquote><p>CyberRt的源码组成如下：</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/image-20231123135714615.png" alt="image-20231123135714615"></p><p><code>base</code>文件夹是Apollo开发的高性能基础库，我们先从这个文件夹里的代码看起:</p><p><img src="/2023/11/23/CyberRt%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%95%E4%BE%8B%E5%AE%8F/image-20231123202400187.png" alt="image-20231123202400187"></p><p>从文件命名中可以看见实现了与线程相关的如线程池、锁、无锁队列、哈希表等等基础组件，我们就开始从零造轮子吧</p><h2 id="1-c-前置知识"><a href="#1-c-前置知识" class="headerlink" title="1.c++前置知识"></a>1.c++前置知识</h2><h3 id="std-nothrow"><a href="#std-nothrow" class="headerlink" title="std::nothrow"></a>std::nothrow</h3><p><code>(std::nothrow)</code> 是在C++中用于进行内存分配时的一种选项。通常，当你使用 <code>new</code> 运算符创建对象时，如果内存分配失败，<code>new</code> 会抛出 <code>std::bad_alloc</code> 异常。但是，当你希望在分配失败时不抛出异常，而是返回一个空指针，你可以使用 <code>(std::nothrow)</code> 作为参数传递给 <code>new</code>。</p><p>具体来说，使用 <code>(std::nothrow)</code> 会使得 <code>new</code> 在分配失败时返回一个空指针而不是抛出异常。这样，你可以在分配失败时通过检查返回的指针是否为空来处理错误，而不必使用异常处理机制。</p><p>以下是一个示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试分配一个非常大的数组，可能导致分配失败</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="literal">nullptr</span>;</span><br><span class="line">    arr = <span class="built_in">new</span>(std::nothrow) <span class="type">int</span>[<span class="number">1000000000000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory allocation failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory allocation successful.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] arr;  <span class="comment">// 记得释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们尝试分配一个非常大的整数数组。由于这个数组可能太大而无法成功分配，我们使用 <code>(std::nothrow)</code>，这样 <code>new</code> 在分配失败时会返回一个空指针。在分配失败的情况下，我们打印一条错误消息。这样，我们可以通过检查指针是否为空来处理内存分配失败的情况，而不必处理异常。</p><h3 id="std-once-flag-amp-amp-std-call-once"><a href="#std-once-flag-amp-amp-std-call-once" class="headerlink" title="std::once_flag &amp;&amp; std::call_once"></a>std::once_flag &amp;&amp; std::call_once</h3><p>在C++中，<code>std::once_flag</code> 是一个用于确保只执行一次代码的标记。它通常与 <code>std::call_once</code> 函数一起使用，以确保其中的代码只会在多线程环境下被执行一次。</p><p>多线程环境中，多个线程可能同时尝试执行某个特定的代码块，但有些代码块可能只需要执行一次。这时，就可以使用 <code>std::once_flag</code> 和 <code>std::call_once</code> 来确保代码块只会在第一次调用时执行，而后续调用会被忽略。</p><p>在C++中，<code>std::once_flag</code> 是一个用于确保只执行一次代码的标记。它通常与 <code>std::call_once</code> 函数一起使用，以确保其中的代码只会在多线程环境下被执行一次。</p><p>多线程环境中，多个线程可能同时尝试执行某个特定的代码块，但有些代码块可能只需要执行一次。这时，就可以使用 <code>std::once_flag</code> 和 <code>std::call_once</code> 来确保代码块只会在第一次调用时执行，而后续调用会被忽略。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(flag.mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双检锁，检查是否已经被执行过</span></span><br><span class="line">    <span class="keyword">if</span> (!flag.called) &#123;</span><br><span class="line">        <span class="comment">// 调用传入的函数</span></span><br><span class="line">        <span class="built_in">func</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置标志，表示函数已经执行过</span></span><br><span class="line">        flag.called = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个简化的示例中，<code>std::once_flag</code> 包含一个互斥锁（<code>mutex</code>）和一个布尔标志（<code>called</code>）。当第一个线程调用 <code>std::call_once</code> 时，它会获得互斥锁，检查标志。如果标志为假，表示函数还没有执行过，于是调用传入的函数，然后设置标志为真，释放互斥锁。如果标志为真，说明函数已经执行过，不再重复执行。</p><p>通过使用互斥锁和双检锁的技术，<code>std::call_once</code> 在多线程环境下能够保证传入的函数只执行一次，同时尽可能地减小了锁的开销。需要注意的是，尽管双检锁可以提高性能，但也需要小心处理一些细节，以防止出现竞态条件和内存可见性的问题。在实践中，使用现代C++标准库提供的 <code>std::call_once</code> 是比手动实现更为安全和简便的选择。</p><h3 id="std-enable-if"><a href="#std-enable-if" class="headerlink" title="std::enable_if"></a>std::enable_if</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::type</span><br></pre></td></tr></table></figure><p>这行代码使用了<code>std::enable_if</code>，它是一个模板元编程工具，用于在编译时根据条件启用或禁用模板的某个部分。</p><ul><li><code>std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;</code>：这是一个模板元编程的条件，它基于 <code>HasShutdown&lt;T&gt;::value</code> 的值。如果 <code>HasShutdown&lt;T&gt;::value</code> 为 <code>true</code>，那么这个表达式的结果是 <code>std::enable_if</code> 的一个特殊的内部类型，否则没有这个内部类型。</li><li><code>typename</code>：这是告诉编译器，后面的 <code>std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::type</code> 是一个类型名，而不是一个成员变量或函数。</li></ul><p>所以，整个表达式的意思是：如果 <code>HasShutdown&lt;T&gt;::value</code> 为 <code>true</code>，则这是一个有效的类型；否则，这个表达式没有有效的类型。</p><h2 id="2-宏分析"><a href="#2-宏分析" class="headerlink" title="2.宏分析"></a>2.宏分析</h2><h3 id="2-1-特征判断宏"><a href="#2-1-特征判断宏" class="headerlink" title="2.1 特征判断宏"></a>2.1 特征判断宏</h3><p><code>DEFINE_TYPE_TRAIT</code>定义在<code>base/macros.h</code>中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TYPE_TRAIT(name, func)                     \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                           \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename Class&gt;</span>                             \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(decltype(&amp;Class::func)*) &#123; \</span></span><br><span class="line"><span class="meta">      return true;                                        \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(...) &#123;                     \</span></span><br><span class="line"><span class="meta">      return false;                                       \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">    static constexpr bool value = Test<span class="string">&lt;T&gt;</span>(nullptr);       \</span></span><br><span class="line"><span class="meta">  &#125;;                                                      \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  constexpr bool name<span class="string">&lt;T&gt;</span>::value;</span></span><br></pre></td></tr></table></figure><ol><li><p><code>DEFINE_TYPE_TRAIT(name, func)</code> 定义了一个宏，该宏接受两个参数，<code>name</code> 是要定义的类型特征结构体的名称，<code>func</code> 是要检查的成员函数的名称。这个宏在内部定义了一个名为<code>name</code>的结构体，此结构体中提供了两个函数模板。</p></li><li><p><code>template &lt;typename T&gt; struct name &#123; ... &#125;;</code> 定义了一个模板结构体，该结构体接受一个类型参数 <code>T</code>。实际上这个宏就是用来检查传入的这个<code>T</code>是否包含有<code>func</code>这个函数，借助了<code>name</code>这个结构体来实现</p></li><li><p><code>name</code>结构体的内部有一个数据成员就是<code>value</code>，<code>value</code>的类型是<code>static constexpr bool</code>，是一个静态常量，这里使用<code>constexpr</code>来声明此变量是为了让编译器在编译的时候就把<code>value</code>的值计算出来，<code>value</code>的值就代表了传入的这个<code>T</code>是否有<code>func</code>这个函数，这个值的计算是通过调用<code>Test&lt;T&gt;</code>这个函数模板来实现的，传入的参数是<code>nullptr</code></p></li><li><p><code>Test&lt;T&gt;</code>这个函数模板有一个泛化的版本和一个特化的版本，首先来看特化的版本</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Class&gt;                             \</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="keyword">decltype</span>(&amp;Class::func)*)</span> </span>&#123; \</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;                                        \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过<code>decltype</code>去识别<code>&amp;Class::func</code>，如果说<code>&amp;Class::func</code>是存在的话，那么<code>decltype(&amp;Class::func)</code>推断出的类型就是一个指向成员函数函数的指针，这就说明了<code>class </code>存在一个名为<code>func</code>的函数，后面这个<code>*</code>号我没想明白为啥要加估计是为了告诉编译器传入的参数是一个指针类型吧，如果是这样的话代码可以改成下面这个样子更具有可读性：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Class&gt;                             \</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="keyword">decltype</span>(&amp;Class::func)* ptr)</span> </span>&#123; \</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;                                        \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样也就解释了为啥后面计算<code>value</code>值得时候传入了一个<code>nullptr</code>作为参数。回到最初，假设我现在传入的这个<code>T</code>这个类没有<code>func</code>这个成员，那么编译器就会去调用下面这个泛化的版本，并且上面那个特化的版本不会报错，这叫做c++的<code>SFINAE</code>特性</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;                                   \</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(...)</span> </span>&#123;                     \</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;                                       \</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ol><p>当你想要检查一个类型是否有某个成员函数时，你可以使用这个宏。下面是一个简单的例子，假设你想检查一个类型是否有 <code>size</code> 成员函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TYPE_TRAIT(name, func)                     \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                           \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename Class&gt;</span>                             \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(decltype(&amp;Class::func)*) &#123; \</span></span><br><span class="line"><span class="meta">      return true;                                        \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">    static constexpr bool Test(...) &#123;                     \</span></span><br><span class="line"><span class="meta">      return false;                                       \</span></span><br><span class="line"><span class="meta">    &#125;                                                     \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">    static constexpr bool value = Test<span class="string">&lt;T&gt;</span>(nullptr);       \</span></span><br><span class="line"><span class="meta">  &#125;;                                                      \</span></span><br><span class="line"><span class="meta">                                                          \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename T&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">  constexpr bool name<span class="string">&lt;T&gt;</span>::value;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏定义类型特征结构体</span></span><br><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasSize, size)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个示例类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用类型特征检查类型是否有成员函数</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;HasSize for MyClass: &quot;</span> &lt;&lt; HasSize&lt;MyClass&gt;::value &lt;&lt; std::endl;  <span class="comment">// 输出 1 (true)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 另一个示例类，没有 size 成员函数</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AnotherClass</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;HasSize for AnotherClass: &quot;</span> &lt;&lt; HasSize&lt;AnotherClass&gt;::value &lt;&lt; std::endl;  <span class="comment">// 输出 0 (false)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DEFINE_TYPE_TRAIT(HasSize, size)</code> 定义了一个名为 <code>HasSize</code> 的类型特征结构体，用于检查类型是否有 <code>size</code> 成员函数。然后，通过 <code>HasSize&lt;MyClass&gt;::value</code> 和 <code>HasSize&lt;AnotherClass&gt;::value</code> 分别检查了 <code>MyClass</code> 和 <code>AnotherClass</code> 是否有 <code>size</code> 成员函数。根据定义，<code>MyClass</code> 有 <code>size</code> 成员函数，而 <code>AnotherClass</code> 没有，因此输出结果分别为 <code>1</code>（true）和 <code>0</code>（false）。</p><h3 id="2-2-单例宏"><a href="#2-2-单例宏" class="headerlink" title="2.2 单例宏"></a>2.2 单例宏</h3><p>代码在：<code>cyber/common/macros.h</code>中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasShutdown, Shutdown)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(T *instance)</span> </span>&#123;</span><br><span class="line">  instance-&gt;<span class="built_in">Shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    T *instance)</span> </span>&#123;</span><br><span class="line">  (<span class="type">void</span>)instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// There must be many copy-paste versions of these macros which are same</span></span><br><span class="line"><span class="comment">// things, undefine them to avoid conflict.</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> UNUSED</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DISALLOW_COPY_AND_ASSIGN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNUSED(param) (void)param</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line"><span class="meta">  classname(const classname &amp;) = delete;    \</span></span><br><span class="line"><span class="meta">  classname &amp;operator=(const classname &amp;) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_SINGLETON(classname)                                      \</span></span><br><span class="line"><span class="meta"> public:                                                                  \</span></span><br><span class="line"><span class="meta">  static classname *Instance(bool create_if_needed = true) &#123;              \</span></span><br><span class="line"><span class="meta">    static classname *instance = nullptr;                                 \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span></span><br><span class="line"><span class="meta">      static std::once_flag flag;                                         \</span></span><br><span class="line"><span class="meta">      std::call_once(flag,                                                \</span></span><br><span class="line"><span class="meta">                     [&amp;] &#123; instance = new (std::nothrow) classname(); &#125;); \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">    return instance;                                                      \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta">  static void CleanUp() &#123;                                                 \</span></span><br><span class="line"><span class="meta">    auto instance = Instance(false);                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (instance != nullptr) &#123;                                            \</span></span><br><span class="line"><span class="meta">      CallShutdown(instance);                                             \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta"> private:                                                                 \</span></span><br><span class="line"><span class="meta">  classname();                                                            \</span></span><br><span class="line"><span class="meta">  DISALLOW_COPY_AND_ASSIGN(classname)</span></span><br></pre></td></tr></table></figure><ol><li><p>首先定了两个很有意思的函数模板</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_TYPE_TRAIT</span>(HasShutdown, Shutdown)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(T *instance)</span> </span>&#123;</span><br><span class="line">  instance-&gt;<span class="built_in">Shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    T *instance)</span> </span>&#123;</span><br><span class="line">  (<span class="type">void</span>)instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DEFINE_TYPE_TRAIT(HasShutdown, Shutdown)</code>结合上面所讲的这个宏定义了一个名为<code>HasShutdown</code>的结构体用于判断传入的模板<code>T</code>这个类是否包含<code>Shutdown</code>这个成员函数，然后又使用了c++的<code>SFINAE</code>特性做了一个很有意思的操作</p><ul><li><p><code>typename</code>告诉了编译器后面<code>std::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::type</code>这玩意儿是一个类型，上面这两个<code>CallShutdown</code>的函数模板入参都是一样的，唯一有区别的就是这个返回值的类型。</p></li><li><p>我们来看看<code>std::enable_if</code>的源码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Primary template.</span></span><br><span class="line"><span class="comment">/// Define a member typedef @c type only if a boolean constant is true.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span>, <span class="keyword">typename</span> _Tp = <span class="type">void</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> enable_if</span><br><span class="line">  &#123; &#125;;</span><br><span class="line">     </span><br><span class="line"><span class="comment">// Partial specialization for true.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">true</span>, _Tp&gt;</span><br><span class="line">  &#123; <span class="keyword">typedef</span> _Tp type; &#125;;</span><br></pre></td></tr></table></figure><p>可以看见c++官方对<code>std::enable_if</code>做了两种定义，一个泛化版本和一个特化版本</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::enable_if&lt;<span class="literal">true</span>, T&gt; <span class="comment">//用的是偏特化的版本</span></span><br><span class="line">std::enable_if&lt;<span class="literal">false</span>, T&gt; <span class="comment">// 用的是泛化的</span></span><br></pre></td></tr></table></figure><p>假设<code>HasShutdown&lt;T&gt;::value</code>的值为<code>true</code>，那么上面两个<code>CallShutdown</code>函数就变成了如下两种情况：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::enable_if&lt;<span class="literal">true</span>&gt;::type     </span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;<span class="literal">false</span>&gt;::type</span><br></pre></td></tr></table></figure><p>很明显<code>std::enable_if&lt;false&gt;::type</code>会走泛化版本，此时<code>std::enable_if</code>内部是没有<code>type</code>这个成员的，由于<code>SFINAE</code>特性的存在，此时并不会报错，所以编译器只会去走<code>std::enable_if&lt;true, T&gt; </code>，但是这里我很奇怪的一点是<code>typename std::enable_if&lt;true&gt;::type</code>这里没有传第二模板参数呀，按我的理解是不是应该&#96;&#96;typename std::enable_if&lt;true,T&gt;::type<code>这样子用，我不是很明白，我想了一下，我先姑且认为编译器会先去做泛化版本的判断，此时由于泛化版本中</code> template&lt;bool, typename _Tp &#x3D; void&gt;<code>，第二模板参数被默认成了</code>void<code>此时编译器发现前面这个bool值为</code>true<code>然后就去走下面这个特化版本，在特化版本中就会定义</code>type<code>的值，此时就是：</code>typedef void type&#96;了。</p><p>同理假设<code>HasShutdown&lt;T&gt;::value</code>的值为<code>fasle</code>，上面两个<code>CallShutdown</code>函数就反过来了，当去调用<code>CallShutdown</code>函数时就会走下面这个版本。</p></li></ul><p>综上所述，上面这两个函数模板就是用于检测类型 <code>T</code> 具有 <code>Shutdown</code> 成员函数，那么这个函数将被启用，否则将被禁用。在启用的情况下，它调用 <code>instance-&gt;Shutdown()</code>。类型 <code>T</code> 不具有 <code>Shutdown</code> 成员函数的情况。在这种情况下，这个函数什么都不做。</p></li><li><p><code>DISALLOW_COPY_AND_ASSIGN</code> 宏用于禁止拷贝和赋值操作。它通过将拷贝构造函数和拷贝赋值操作符声明为 <code>delete</code> 来阻止对象的拷贝和赋值。这通常用于单例模式等情况，以确保对象只能有一个实例。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line"><span class="meta">  classname(const classname &amp;) = delete;    \</span></span><br><span class="line"><span class="meta">  classname &amp;operator=(const classname &amp;) = delete;</span></span><br></pre></td></tr></table></figure></li><li><p><code>DECLARE_SINGLETON</code> 宏用于声明一个单例模式的类。具体来说，它包含以下功能：</p><ul><li><code>Instance(bool create_if_needed = true)</code> 函数用于获取单例对象的实例。如果单例对象尚未创建，它将使用 <code>std::call_once</code> 和 <code>new</code> 运算符创建一个实例。这确保在多线程环境下仅执行一次对象的创建操作。</li><li><code>CleanUp()</code> 函数用于清理单例对象。它调用 <code>CallShutdown</code> 函数来执行对象的清理操作。</li><li><code>classname()</code> 构造函数声明为 <code>private</code>，确保类的实例只能通过 <code>Instance</code> 函数创建。</li><li><code>DISALLOW_COPY_AND_ASSIGN(classname)</code> 用于禁止拷贝和赋值操作，将默认构造也声明成私有的，以确保类的唯一性。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_SINGLETON(classname)                                      \</span></span><br><span class="line"><span class="meta"> public:                                                                  \</span></span><br><span class="line"><span class="meta">  static classname *Instance(bool create_if_needed = true) &#123;              \</span></span><br><span class="line"><span class="meta">    static classname *instance = nullptr;                                 \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span></span><br><span class="line"><span class="meta">      static std::once_flag flag;                                         \</span></span><br><span class="line"><span class="meta">      std::call_once(flag,                                                \</span></span><br><span class="line"><span class="meta">                     [&amp;] &#123; instance = new (std::nothrow) classname(); &#125;); \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">    return instance;                                                      \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta">  static void CleanUp() &#123;                                                 \</span></span><br><span class="line"><span class="meta">    auto instance = Instance(false);                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (instance != nullptr) &#123;                                            \</span></span><br><span class="line"><span class="meta">      CallShutdown(instance);                                             \</span></span><br><span class="line"><span class="meta">    &#125;                                                                     \</span></span><br><span class="line"><span class="meta">  &#125;                                                                       \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta"> private:                                                                 \</span></span><br><span class="line"><span class="meta">  classname();                                                            \</span></span><br><span class="line"><span class="meta">  DISALLOW_COPY_AND_ASSIGN(classname)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3.参考链接"></a>3.参考链接</h2><ul><li><a href="https://liujiayu.blog.csdn.net/article/details/130346051">百度自动驾驶apollo源码解读14:接口存在判定宏DEFINE_TYPE_TRAIT_H-KING的博客-CSDN博客</a></li><li><a href="https://liujiayu.blog.csdn.net/article/details/130367869">百度自动驾驶apollo源码解读15:懒汉式单例宏DECLARE_SINGLETON-CSDN博客</a></li><li><a href="https://www.cnblogs.com/yb-blogs/p/13702717.html">C++ enable_if 探究 - BoBro - 博客园 (cnblogs.com)</a></li><li><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/enable-if-class?view=msvc-170">enable_if 类 | Microsoft Learn</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百度Apollo CyberRt源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CyberRt </tag>
            
            <tag> c++ </tag>
            
            <tag> fastrtps </tag>
            
            <tag> 分布式通信中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>riscv编译工具链构建说明</title>
      <link href="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="riscv编译工具链构建说明"><a href="#riscv编译工具链构建说明" class="headerlink" title="riscv编译工具链构建说明"></a>riscv编译工具链构建说明</h2><p>构建<code>riscv-gnu-toolchain</code>有几种方式：</p><ul><li>第一种是直接下载源码然后本地编译，然后 <code>make install</code></li><li>第二种如果使用的是<code>ubuntu20</code>，可以直接使用 apt 安装</li><li>第三种就是下载别人已经编译好的文件，然后解压，配置一下工具链路径</li></ul><p>编译器有这几种类型，以64位的编译器为例子，三种不同类型编译器的区别后面会说明</p><ul><li>riscv64-linux-gnu-gcc</li><li>riscv64-unknown-elf-gcc</li><li>riscv64-unknown-linux-gnu-gcc</li></ul><h2 id="源码构建"><a href="#源码构建" class="headerlink" title="源码构建"></a><strong>源码构建</strong></h2><p><code>riscv-gnu-toolchain</code>的官方仓库在：<a href="https://github.com/riscv-collab/riscv-gnu-toolchain">riscv-collab&#x2F;riscv-gnu-toolchain: GNU toolchain for RISC-V, including GCC (github.com)</a>，下载上面的源码，然后按照官方提供的编译命令进行编译安装，但是绝大多数时候是编译不过的，因为官方的源码依赖种的第三方文件我们下载不下来，有一个解决办法就是去<code>gittee</code>镜像上去把对应的包下载然后放进源码种，这样编译是能成功。关于如何在<code>gittee</code>上去下载第三方依赖请各位百度。</p><p>官网提供的编译方式如下：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716140122180.png" alt="image-20230716140122180"></p><p>这里建议直接使用第三种配置编译方式，可以编译生成32位和64位的编译器：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/opt/riscv --enable-multilib</span><br></pre></td></tr></table></figure><blockquote><p>这里使用源码编译太操蛋了，我捣鼓了好久，不推荐</p></blockquote><h2 id="apt-构建"><a href="#apt-构建" class="headerlink" title="apt 构建"></a><strong>apt 构建</strong></h2><p><code>apt</code>构建会比较简单，这里只针对<code>ubuntu20.04</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libc6-riscv64-cross</span><br><span class="line">sudo apt install binutils-riscv64-linux-gnu</span><br><span class="line">sudo apt install gcc-riscv64-linux-gnu</span><br><span class="line">sudo apt install binutils-riscv64-unknown-elf</span><br><span class="line">sudo apt install gcc-riscv64-unknown-elf</span><br></pre></td></tr></table></figure><p>执行上面的命令会生成两种类型的编译器：</p><ul><li>riscv64-linux-gnu-gcc</li><li>riscv64-unknown-elf-gcc</li></ul><p>但是<code>riscv64-unknown-elf-gcc</code>这个编译器是不含c库的，比如你的代码种如果包含了<code>stdio.h</code>想使用<code>printf</code>函数就会报错。不推荐使用<code>apt install</code>安装的<code>riscv64-unknown-elf-gcc</code>编译器。</p><p><code>riscv64-linux-gnu-gcc</code>，使用这个编译器就可以使用C库了，例如我有下面这样一段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用编译器来编译：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc hello.c</span><br></pre></td></tr></table></figure><p>然后使用<code>qemu</code>来执行</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-riscv64 a.out</span><br></pre></td></tr></table></figure><p>这里应该会报一个错误：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-riscv64: Could not open <span class="string">&#x27;/lib/ld-linux-riscv64-lp64.d.so.1&#x27;</span>:No such file or direcyory</span><br></pre></td></tr></table></figure><p>没找到文件的原因是，因为文件下载的地方，和查找的地方不一样，只要把文件cp一下就可以了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /usr/riscv64-linux-gnu/lib/* /lib/</span><br></pre></td></tr></table></figure><p>然后再运行应该就没问题了。</p><h2 id="下载二进制文件构建"><a href="#下载二进制文件构建" class="headerlink" title="下载二进制文件构建"></a><strong>下载二进制文件构建</strong></h2><p>进入<code>riscv-gnu-toolchain</code>的<code>github</code>仓库，找到右边的<code>tags</code></p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143145875.png" alt="image-20230716143145875"></p><p>点击进入：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143217518.png" alt="image-20230716143217518"></p><p>可以看见这里有已经编译好的二进制文件，截至我打开的时候，最新的版本是2023.07.07，点击进入</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143310196.png" alt="image-20230716143310196"></p><p>这里有已经编译好的编译器，分别对应不同的ubuntu版本，有32位和64位两个版本的。</p><p>其中<code>riscv64-elf-ubuntu-20.04-gcc-nightly-2023.07.07-nightly.tar.gz</code>解压后的编译器就是：<code>riscv64-unknown-elf-gcc</code>，<strong>但是官方编译的版本是带C库的</strong>。</p><p><code>riscv64-glibc-ubuntu-20.04-llvm-nightly-2023.07.07-nightly.tar.gz</code>解压后的编译器是：<code>riscv64-unknown-linux-gnu-gcc</code>，假设你用这个编译器去编译上面的<code>hello.c</code>文件，编译是没问题的，但是如果你使用<code>qemu-riscv64 a.out</code>去执行，同样会报错误：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> qemu-riscv64: Could not open <span class="string">&#x27;/lib/ld-linux-riscv64-lp64.d.so.1&#x27;</span>:No such file or direcyory</span><br></pre></td></tr></table></figure><p>同样我们也想到可以将这个编译器的<code>lib</code>文件拷贝过去，但是我在它的<code>lib</code>种却找不到这个动态库，如下：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716144055264.png" alt="image-20230716144055264"></p><p>如果说你拷贝了<code>riscv64-linux-gnu-gcc</code>,那么这里执行应该不会报错。</p><blockquote><p>riscv的编译工具链真的很操蛋！！！！！！！！！！</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://blog.csdn.net/bebebug/article/details/127829361">qemu-riscv64: could not open ‘&#x2F;lib&#x2F;ld-linux-riscv64-lp64d.so.1‘_qemu-x86_64: could not open ‘&#x2F;lib64&#x2F;ld-linux-x86-6_嵌入一下？的博客-CSDN博客</a></p></li><li><p><a href="https://blog.csdn.net/Longyu_wlz/article/details/109150134">(69条消息) qemu 运行 riscv 内核失败记录_longyu_wlz的博客-CSDN博客</a></p></li><li><p><a href="https://gitee.com/unicornx/riscv-operating-system-mooc/issues/I4D6N9">stdio.h 头文件找不到 · Issue #I4D6N9 · unicornx&#x2F;riscv-operating-system-mooc - Gitee.com</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> riscv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写STL之List</title>
      <link href="/2023/06/20/%E6%89%8B%E5%86%99STL-List/"/>
      <url>/2023/06/20/%E6%89%8B%E5%86%99STL-List/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码仓库：<a href="https://github.com/yanglianoo/My_STL/tree/timer">yanglianoo&#x2F;My_STL at timer (github.com)</a></p></blockquote><h1 id="1-List概述"><a href="#1-List概述" class="headerlink" title="1.List概述"></a>1.List概述</h1><p>C++标准模板库（STL）中的<code>list</code>是一个双向链表容器，提供了在链表中高效存储和访问数据的功能。它是一个模板类具有以下特性：</p><ol><li>链表结构：<code>list</code>是由节点组成的链表，每个节点包含数据以及指向前一个节点和后一个节点的指针。这种结构使得在<code>list</code>中插入、删除和移动元素非常高效，因为不需要像动态数组那样进行内存的移动和重分配。</li><li>双向访问：<code>list</code>支持双向访问，可以从链表的开头或末尾快速访问元素。你可以使用迭代器进行正向或反向遍历，也可以使用<code>front()</code>和<code>back()</code>函数访问第一个和最后一个元素。</li><li>动态大小：<code>list</code>的大小可以动态增长或缩小，无需预先分配固定大小的内存。</li><li>插入和删除：在<code>list</code>中插入和删除元素非常高效。通过使用迭代器，可以在常数时间内在任意位置插入或删除元素。</li><li>不支持随机访问：<code>list</code>不支持通过索引进行随机访问，这意味着不能像数组那样使用索引来访问元素。如果需要随机访问，<code>vector</code>可能更适合。</li><li>没有连续存储：由于<code>list</code>是一个链表，它的元素在内存中不是连续存储的，这可能会对缓存性能产生一些影响。</li><li>不支持快速的随机访问、排序和二分查找：由于没有随机访问，对<code>list</code>进行排序和二分查找会比较低效。如果需要这些功能，你可以考虑使用<code>vector</code>或<code>deque</code>容器。</li></ol><p><code>STL</code>库中<code>list</code>的定义如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Allocator</span> = std::allocator&lt;T&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> list;</span><br></pre></td></tr></table></figure><table><thead><tr><th>T</th><th>元素的类型。<code>T</code> 必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>Allocator</th><th>用于获取&#x2F;释放内存及构造&#x2F;析构内存中元素的分配器。类型必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/Allocator"><em>分配器</em> <em>(Allocator)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>成员函数</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/list">(构造函数)</a></td><td>构造 <code>list</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/~list">(析构函数)</a></td><td>析构 <code>list</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/operator%3D">operator&#x3D;</a></td><td>赋值给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/assign">assign</a></td><td>将值赋给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/get_allocator">get_allocator</a></td><td>返回相关的分配器 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/push_front">push_front</a></td><td>插入元素到容器起始 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace_front">emplace_front</a>(C++11)</td><td>在容器头部原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/pop_front">pop_front</a></td><td>移除首元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/swap">swap</a></td><td>交换内容 (公开成员函数)</td></tr></tbody></table><blockquote><p>参考链接：<a href="https://zh.cppreference.com/w/cpp/container/list">std::list - cppreference.com</a></p></blockquote><h1 id="2-构造节点"><a href="#2-构造节点" class="headerlink" title="2. 构造节点"></a>2. 构造节点</h1><p>list的数据结构有两种，一种是双向链表，结构如下：</p><p><img src="/2023/06/20/%E6%89%8B%E5%86%99STL-List/1632118785.jpg" alt="图解几种常见的线性表 - 命中水"></p><p>在双向链表中，每一个节点为一个node，node包含一个指向上一个节点的prev指针和指向下一个节点的next指针，头节点的prev指针指向nullptr，尾节点的next指针指向nullptr。</p><p>一种是双向循环链表，和双向链表不同的就是，双向循环链表头节点的prev指针指向了尾节点，尾节点的next指针指向了头节点，由此组成了一个循环。</p><p><img src="/2023/06/20/%E6%89%8B%E5%86%99STL-List/3650507100.jpg" alt="图解几种常见的线性表 - 命中水"></p><p>我们实现的list是基于双向链表的，list是一个C++的类，由很多个节点构成，因此先来定义一下节点的数据结构，node节点由两个指针和存储的数据组成，是一个模板类，定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">list_node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    list_node&lt;T&gt;* prev;</span><br><span class="line">    list_node&lt;T&gt;* next;</span><br><span class="line">    <span class="built_in">list_node</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">            :<span class="built_in">next</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            ,<span class="built_in">prev</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            ,<span class="built_in">data</span>(value)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-构造迭代器"><a href="#3-构造迭代器" class="headerlink" title="3.构造迭代器"></a>3.构造迭代器</h1><p>在list的使用种，用两种类型的迭代器，一种是普通的<code>iterator</code>，还有一种就是不可修改的<code>const_iterator</code>，这里的不可修改是指节点的数据不可修改，迭代器构造如下，和vector的迭代器类似，需要去重载不同的操作符。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, Ref, ptr&gt; self;</span><br><span class="line"><span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">list_iterator</span>(Node* node)</span><br><span class="line">:_node(node)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//拷贝构造、赋值重载，默认浅拷贝即可</span></span><br><span class="line"><span class="comment">//析构函数，指针指向的节点不属于迭代器的，无需自己销毁</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//解引用,*it = it.operator*()</span></span><br><span class="line">Ref&amp; <span class="keyword">operator</span>* ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line">ptr <span class="keyword">operator</span>-&gt; () <span class="comment">//本来调用为it-&gt;-&gt;_value,编译器通过处理省略了一个-&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_node-&gt;_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置--</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置--</span></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != it._node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node == it._node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>list_iterator</code>内部维护了一个<code>list_node&lt;T&gt;*</code>类型的指针，用来指向<code>list</code>的每一个节点，这里解释一下为啥<code>list_iterator</code>模板类为啥有三个模板参数，那是为了方便通过typedef来定义<code>iterator</code>和<code>const_iterator</code>，在后面list类中可以如下定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br></pre></td></tr></table></figure><h1 id="4-构造list类"><a href="#4-构造list类" class="headerlink" title="4.构造list类"></a>4.构造list类</h1><p>首先list类中包含了如下的成员变量，除了一个node类型的指针还维护了一个_size，当对list容器进行操作时，需要对_size实现增减操作。由于采用循环链表实现，所以当初始化链表时只需要定义一个头节点，让<code>head</code>节点的<code>prev</code>和<code>next</code>指针都指向自己就可以了.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">list</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, T&amp;, T*&gt; iterator; <span class="comment">//普通迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator; <span class="comment">//const迭代器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* _head;</span><br><span class="line">    <span class="type">size_t</span> _size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty_initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="built_in">T</span>());</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line"></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义默认构造函数</span></span><br><span class="line">   <span class="built_in">list</span>()&#123; <span class="built_in">empty_initialize</span>(); &#125;</span><br><span class="line">    <span class="comment">//定义析构函数</span></span><br><span class="line">   ~<span class="built_in">list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span>[] _head;</span><br><span class="line">        _head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后我们来定义一些和迭代器有关的函数，首先是<code>begin()</code>和<code>end()</code>，用来返回头节点指针和尾节点指针，这里我们定义<code>_head-&gt;next</code>为<code>begin</code>，<code>end</code>为<code>_head</code>，然后有两个重载版本。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(_head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-容量"><a href="#2-1-容量" class="headerlink" title="2.1 容量"></a>2.1 容量</h2><p>和容量相关的接口比较简单，这里不赘述，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-修改器"><a href="#2-2-修改器" class="headerlink" title="2.2 修改器"></a>2.2 修改器</h2><p>在实现其他修改器之前，可先定义<code>insert</code>和<code>erase</code>函数,代码逻辑并不复杂，实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//往pos位置插入元素T</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node* cur = pos._node;</span><br><span class="line">        Node* prev = cur-&gt;_prev;</span><br><span class="line"></span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">        new_node-&gt;_prev = prev;</span><br><span class="line">        new_node-&gt;_next = cur;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        prev-&gt;_next = new_node;</span><br><span class="line">        cur-&gt;_prev = new_node;</span><br><span class="line"></span><br><span class="line">        _size++;</span><br><span class="line">        <span class="comment">//隐式转换为iterator</span></span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//删除pos位置的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(pos != <span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        Node* cur = pos._node;</span><br><span class="line">        Node* prev = cur-&gt;_prev;</span><br><span class="line">        Node* next = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        prev-&gt;_next = next;</span><br><span class="line">        next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line">        _size--;</span><br><span class="line">        <span class="keyword">delete</span> [] cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除范围为 [first, last) 的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator first, iterator last )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == last) &#123; <span class="keyword">return</span> last;&#125;</span><br><span class="line"></span><br><span class="line">        Node* first_node = first._node;</span><br><span class="line">        Node* last_node = last._node;</span><br><span class="line"></span><br><span class="line">        Node* prev = first_node-&gt;_prev;</span><br><span class="line">        Node* next = last_node;</span><br><span class="line"></span><br><span class="line">        prev-&gt;_next = next;</span><br><span class="line">        next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (first_node != last_node)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* cur = first_node;</span><br><span class="line">            first_node = first_node-&gt;_next;</span><br><span class="line">            <span class="keyword">delete</span> [] cur;</span><br><span class="line">            count++; </span><br><span class="line">        &#125;</span><br><span class="line">        _size-=count;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他的修改器就可基于insert和erase函数来实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>(),<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">begin</span>(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-元素访问"><a href="#2-3-元素访问" class="headerlink" title="2.3 元素访问"></a>2.3 元素访问</h2><p>提供了访问头节点和尾节点数据的接口：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(--<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-其他构造函数"><a href="#2-4-其他构造函数" class="headerlink" title="2.4 其他构造函数"></a>2.4 其他构造函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>(<span class="type">size_t</span> count, <span class="type">const</span> T&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(<span class="type">size_t</span> count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(<span class="built_in">T</span>());</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt&gt;</span><br><span class="line">    <span class="built_in">list</span>(InputIt first, InputIt last) : <span class="built_in">list</span>() </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">while</span> (first != last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">push_back</span>(*first);</span><br><span class="line">++first;</span><br><span class="line">            _size++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(<span class="type">const</span> list&amp; other): <span class="built_in">list</span>() </span><br><span class="line">    &#123;</span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">tmp</span><span class="params">(other.begin(), other.end())</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(_head, tmp._head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(std::initializer_list&lt;T&gt; init) : <span class="built_in">list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> T&amp; value : init) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list&lt;T&gt; &amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> T&amp; value : other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;T&gt;&amp; <span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> T&amp; value : ilist) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h1><p>list已完成，未进行测试，list是比较简单的，当然我们还有一些机制没有实现，比如逆向迭代器，assign函数等，不过核心的接口都已经实现，后续可完善。</p>]]></content>
      
      
      <categories>
          
          <category> 手写STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础-存储访问</title>
      <link href="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/"/>
      <url>/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-存储器使用场景"><a href="#1-存储器使用场景" class="headerlink" title="1.存储器使用场景"></a>1.存储器使用场景</h1><p>先来看如下这一张图，CPU运行程序的流程如下：</p><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614133226741.png" alt="image-20230614133226741"></p><p>1：假设我现在在电脑上编译了一个<code>hello.c</code>的程序，编译完成后为<code>hello.bin</code>的一个二进制文件，此时这个程序还存储在我们电脑的硬盘上，这个硬盘可能是机械硬盘也可能是固态硬盘，这些都是外存储器。</p><p>2：将<code>hello.bin</code>装载进内存，这里的内存就是插在电脑上的内存条，<code>hello.bin</code>包含了cpu要执行的指令和运行所需要的数据。</p><p>3：CPU从内存中逐条读取指令及相关指令，然后依次执行完成对数据的处理。</p><p>4：将处理结果送回内存保存，然后再将处理结果送到外存储器。</p><p>所以其实在CPU运行的过程中主要是分为两类存储器：</p><ul><li><p>内存储器</p><p>存取速度快 </p><p>成本高、容量相对较小 </p><p>直接与CPU连接，CPU对内存 中可直接进行读、写操作 </p><p>属于易失性存储器(volatile)， 用于临时存放正在运行的程序和数据，掉电就没了数据。</p></li><li><p>外存储器（简称外存或辅存）</p><p>– 存取速度慢 – 成本低、容量很大 </p><p>– 不与CPU直接连接，先传送到内 存，然后才能被CPU使用。</p><p> – 属于非易失性存储器，用于长久存放系统中几乎所有的信息</p></li></ul><blockquote><p>这里可能会有个疑问，CPU访问内存的方式是通过地址总线来访问的，CPU是如何访问外存的呢：</p><p>CPU访问外部存储器（外存）的方式通常是通过输入输出（I&#x2F;O）指令和I&#x2F;O总线来实现的。外存通常指的是硬盘、固态硬盘（SSD）、光盘、磁带等非易失性存储介质。</p><p>与内存访问不同，外存的访问速度相对较慢，因此CPU在执行指令时通常不直接与外存进行交互，而是通过操作系统和设备控制器等中间层来实现。以下是CPU访问外存的一般过程：</p><ol><li>CPU发送I&#x2F;O指令：当需要读取或写入外存中的数据时，CPU会发出相应的I&#x2F;O指令，这些指令通常包括读取（IN）和写入（OUT）操作。</li><li>I&#x2F;O总线传输：CPU将I&#x2F;O指令发送到I&#x2F;O总线上。I&#x2F;O总线是一种特殊的总线，用于传输CPU和外部设备之间的数据和控制信号。</li><li>设备控制器响应：I&#x2F;O总线上连接着各种外部设备控制器，如硬盘控制器或磁带控制器。当设备控制器接收到CPU发送的I&#x2F;O指令时，它会解析指令并准备执行相应的读取或写入操作。</li><li>数据传输：设备控制器根据指令从外存读取数据或将数据写入外存。这个过程涉及到设备控制器与外存之间的数据传输，可能需要通过外存总线或其他特定接口进行。</li><li>完成操作：设备控制器完成读取或写入操作后，将状态信息返回给CPU，指示操作是否成功或是否有错误发生。</li></ol></blockquote><p>主存的结构如下：</p><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614140500484.png" alt="image-20230614140500484"></p><p>一个存储单元为一个bit，按字节编址的话一个地址对应的就是8个字节，数据总线读取一个地址的数据就一次性读取8个bit，这8个bit的地址都是一样的</p><p>如果CPU的数据总线是64位，则一次性最大可以读取64bit的数据也就是8个字节。</p><p>地址线为36位，则可以寻址的范围是0~2^36-1，即主存地址空间为64GB。</p><h1 id="2-存储器分类"><a href="#2-存储器分类" class="headerlink" title="2.存储器分类"></a>2.存储器分类</h1><h2 id="2-1-RAM"><a href="#2-1-RAM" class="headerlink" title="2.1 RAM"></a>2.1 RAM</h2><p>内存（主存，RAM，Random Access Memory）：</p><ol><li>主存是CPU直接访问的存储器，用于存储当前执行的程序、数据和临时计算结果。</li><li>分类：<ul><li>随机访问存储器（RAM）：包括动态随机访问存储器（DRAM）和静态随机访问存储器（SRAM）。DRAM存储器成本较低，容量较大，但读写速度相对较慢；SRAM存储器读写速度快，但成本较高。</li><li>缓存（Cache）：用于在CPU和主存之间提供快速数据访问，减少CPU等待数据的时间。根据接近CPU的级别不同，可以分为一级缓存（L1 Cache）、二级缓存（L2 Cache）等多级别缓存。</li></ul></li><li>应用场景：<ul><li>执行指令和存储数据：CPU从内存中读取指令和数据进行运算和处理。</li><li>运行操作系统和应用程序：操作系统和应用程序加载到内存中运行，提供计算、存储和交互功能。</li></ul></li></ol><h2 id="2-2-ROM"><a href="#2-2-ROM" class="headerlink" title="2.2 ROM"></a>2.2 ROM</h2><p>ROM是只读存储器（Read-Only Memory）的缩写，它是一种用于存储固定数据的存储器类型。与可写的存储器（如RAM）不同，ROM中的数据在制造或编程之后就无法被修改。</p><p>以下是一些关键特点和应用场景，以帮助更好理解ROM：</p><p>特点：</p><ol><li>只读性质：ROM中的数据在制造或编程之后就无法被修改或擦除。</li><li>非易失性：与RAM不同，ROM中的数据在断电或重新启动后仍然保持不变。</li><li>持久存储：ROM用于存储固定的数据，如固件、引导程序、不经常更改的配置信息等。</li></ol><p>应用场景：</p><ol><li>固件：ROM常用于存储计算机系统或电子设备的固件，包括BIOS（基本输入&#x2F;输出系统）、固件程序和引导加载器等。</li><li>引导程序：计算机启动时，ROM中的引导程序负责初始化硬件和加载操作系统。</li><li>芯片固化数据：ROM用于存储芯片的校准数据、配置信息和厂商特定的数据，以便在设备制造后使用。</li><li>只读存储媒体：一些光盘和芯片类型，如CD-ROM、DVD-ROM、Blu-ray Disc、EPROM（可擦除可编程只读存储器）等，被设计为只读存储介质。</li></ol><p>需要注意的是，不同类型的ROM可以具有不同的特性。例如，EPROM是一种可擦除可编程只读存储器，允许通过特殊操作将其中的数据擦除并重新编程，而普通的ROM则不具备这种功能。此外，还有一些衍生类型的ROM，如EEPROM（可擦除可编程只读存储器）、Flash存储器等，它们具有一定的可擦除和可重新编程的能力。</p><h2 id="2-3-储存器功能分类"><a href="#2-3-储存器功能分类" class="headerlink" title="2.3 储存器功能分类"></a>2.3 储存器功能分类</h2><ul><li>寄存器(Register) <ul><li>封装在CPU内，用于存放当前正在执行的指令和使用的数据 </li><li>用触发器实现，速度快，容量小（几~几十个）</li></ul></li><li>高速缓存(Cache) </li><li>位于CPU内部或附近，用来存放当前要执行的局部程序段和数据 </li><li>-用SRAM实现，速度可与CPU匹配，容量小（几MB） </li><li>内存储器MM（主存储器Main (Primary) Memory）<ul><li>位于CPU之外，用来存放已被启动的程序及所用的数据 </li><li>用DRAM实现，速度较快，容量较大（几GB）</li></ul></li><li>外存储器AM (辅助存储器Auxiliary &#x2F; Secondary Storage) <ul><li>位于主机之外，用来存放暂不运行的程序、数据或存档文件</li><li>用磁盘、SSD等实现，容量大而速度慢</li></ul></li></ul><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614140240489.png" alt="image-20230614140240489"></p><h1 id="3-嵌入式存储实例"><a href="#3-嵌入式存储实例" class="headerlink" title="3.嵌入式存储实例"></a>3.嵌入式存储实例</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器 </tag>
            
            <tag> 计算机系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树详解</title>
      <link href="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-设备树简介"><a href="#1-设备树简介" class="headerlink" title="1.设备树简介"></a>1.设备树简介</h1><p>传统上，操作系统内核会直接编译进所有支持的硬件设备的驱动程序。但是，随着硬件设备的不断增多和变化，这种方法变得不够灵活。设备树的引入解决了这个问题。设备树将硬件的描述信息以一种结构化的方式存储在单独的文件中，然后在引导过程中由操作系统内核加载和解析。</p><p>设备树文件使用一种称为”Device Tree Source”（DTS）的语言编写，它是一种人类可读的文本格式。该文件描述了硬件设备的层次结构、寄存器地址、中断线路、DMA通道和其他相关属性。这些信息对于内核来说非常重要，因为它们允许内核正确地初始化和配置硬件设备。</p><p>设备树文件经过<code>DTC</code>编译后会生成一种称为”Device Tree Blob”（DTB）的二进制格式。DTB文件在引导过程中由引导加载程序（Bootloader）提供给内核。内核会解析DTB文件，根据其中的描述信息初始化硬件设备，并加载相应的驱动程序。</p><p>设备树的作用在于用来描述一个具体的硬件平台的硬件资源，如果没有设备树，当我有一个新的硬件平台时，在移植操作系统时需要去修改源码去适配这个具体的硬件平台。有了设备树之后，bootloader就能直接从设备树中获取硬件信息，而不需要去修改源码，使得Linux内核的兼容性和可移植性大大增强。</p><ul><li><p><code>DTS：</code>Device Tree Source，<code>.dts</code>格式的文件，是一种<code>ASII </code>文本格式的设备树描述，也是我们要编写的设备树源码，一般一个<code>.dts</code>文件对应一个硬件平台，位于Linux源码的<code>/arch/***/boot/dts”</code>目录下。</p></li><li><p><code>DTC：</code>Device Tree Compiler，是指编译设备树源码的工具，一般情况下我们需要手动安装这个编译工具。</p></li><li><p><code>DTB </code>：是设备树源码编译生成的文件，类似于我们C语言中“.C”文件编译生成“.bin”文件</p></li></ul><img src="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/1503563-20200915000144208-924995757.png" alt="Linux驱动之设备树的基础知识 - 山无言 - 博客园" style="zoom:67%;"><blockquote><p>参考链接：<a href="https://doc.embedfire.com/linux/imx6/base/zh/latest/linux_driver/driver_tree.html">doc.embedfire.com&#x2F;linux&#x2F;imx6&#x2F;base&#x2F;zh&#x2F;latest&#x2F;linux_driver&#x2F;driver_tree.html</a></p></blockquote><h1 id="2-设备树基本语法架构分析"><a href="#2-设备树基本语法架构分析" class="headerlink" title="2.设备树基本语法架构分析"></a>2.设备树基本语法架构分析</h1><h2 id="2-1-dts基本框架"><a href="#2-1-dts基本框架" class="headerlink" title="2.1 dts基本框架"></a>2.1 dts基本框架</h2><p><code>1.头文件</code>：设备树是可以像C语言那样使用“#include”引用“.h”后缀的头文件，也可以引用设备树“.dtsi”后缀的头文件。因此这里<code>k210.dts</code>引用了<code>k210.dtsi</code>中的文件</p><p><code>2.设备树节点</code>：每一个<code>&#123; &#125;</code>都是一个节点，<code>/ &#123;…&#125;</code>表示“根节点”， 在根节点内部的“aliases {…}”、“chosen {…}”、“memory {…}”等字符，都是根节点的子节点。</p><p><code>3.设备树节点追加内容</code>：向已经存在的子节点追加数据，这些已经存在的节点可能定义在<code>.dts</code>文件里，也可能定义在<code>.dtsi</code>文件里，这些节点比根节点下的子节点多了一个<code>&amp;</code>。</p><p>设备树由一个根节点和众多子节点组成，子节点也可以继续包含其他节点，也就是子节点的子节点。</p><h3 id="2-1-1节点基本格式"><a href="#2-1-1节点基本格式" class="headerlink" title="2.1.1节点基本格式"></a>2.1.1节点基本格式</h3><p>设备树中的每个节点都按照以下约定命名：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">node-name@unit-address<span class="punctuation">&#123;</span></span><br><span class="line">    属性<span class="number">1</span> = …</span><br><span class="line">    属性<span class="number">2</span> = …</span><br><span class="line">    属性<span class="number">3</span> = …</span><br><span class="line">    子节点…</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>节点格式中的<code> node-name</code> 用于指定节点的名称。 它的长度为1至31个字符，只能由如下字符组成:</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>0-9</td><td>数字</td></tr><tr><td>a-z</td><td>小写字母</td></tr><tr><td>A-Z</td><td>大写字母</td></tr><tr><td>,</td><td>英文逗号</td></tr><tr><td>.</td><td>英文句号</td></tr><tr><td>_</td><td>下划线</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>-</td><td>减号</td></tr></tbody></table><blockquote><p>注意：根节点没有节点名，它直接使用“&#x2F;”指代这是一个根节点。</p></blockquote><p><code>@unit-address</code> ：其中的符号“@”可以理解为是一个分割符，“unit-address”用于指定“单元地址”， 它的值要和节点“reg”属性的第一个地址一致。如果节点没有“reg”属性值，可以直接省略“@unit-address”， 不过要注意这时要求同级别的设备树下（相同级别的子节点）节点名唯一,从这个侧面也可以了解到， 同级别的子节点的节点名可以相同，但是要求“单元地址”不同，node-name@unit-address 的整体要求同级唯一。</p><h3 id="2-1-2-节点标签"><a href="#2-1-2-节点标签" class="headerlink" title="2.1.2 节点标签"></a>2.1.2 节点标签</h3><p>例如：</p><pre><code>sysctl: sysctl@50440000 &#123;        compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;;        reg = &lt;0x50440000 0x1000&gt;;        #clock-cells = &lt;1&gt;;&#125;;</code></pre><p>则<code>sysctl</code>就代表了<code>sysctl@50440000</code>这个节点的标签，用<code>:</code>来指明。通常节点标签是节点名的简写，所以它的作用是当其它位置需要引用时可以使用节点标签来向该节点中追加内容。</p><h3 id="2-1-3-节点路径"><a href="#2-1-3-节点路径" class="headerlink" title="2.1.3 节点路径"></a>2.1.3 节点路径</h3><p>通过指定从根节点到所需节点的完整路径，可以唯一地标识设备树中的节点，<code>不同层次的设备树节点名字可以相同，同层次的设备树节点要唯一</code>。 这有点类似于我们Windows上的文件，一个路径唯一标识一个文件或文件夹，不同目录下的文件文件名可以相同。</p><h3 id="2-1-4-节点属性"><a href="#2-1-4-节点属性" class="headerlink" title="2.1.4 节点属性"></a>2.1.4 节点属性</h3><ul><li><p><strong>compatible属性</strong>：属性值类型：字符串</p><p>compatible属性值由一个或多个字符串组成，有多个字符串时使用“,”分隔开。设备树中的每一个代表了一个设备的节点都要有一个compatible属性。 compatible是系统用来决定绑定到设备的设备驱动的关键。 compatible属性是用来查找节点的方法之一，另外还可以通过节点名或节点路径查找指定节点。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>model属性</strong>：属性值类型：字符串</p><p>model属性用于指定设备的制造商和型号，推荐使用“制造商, 型号”的格式，当然也可以自定义。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;Kendryte K210 generic&quot;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>status属性</strong></p><p>状态属性用于指示设备的“操作状态”，通过status可以去禁止设备或者启用设备，可用的操作状态如下表。默认情况下不设置status属性设备是使能的。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* External sound card */</span></span><br><span class="line"><span class="symbol">sound:</span> <span class="title class_">sound</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>reg属性</strong></p><p>reg属性描述设备资源在其父总线定义的地址空间内的地址。通常情况下用于表示一块内存的起始地址（偏移地址）和长度， 在特定情况下也有不同的含义。 ret属性的书写格式为reg &#x3D; &lt; cells cells cells cells cells cells…&gt;，长度根据实际情况而定， 这些数据分为地址数据（地址字段），长度数据（大小字段）</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure><p>这里描述了三段内存：起始地址为0x80000000，大小为0x400000；起始地址为：0x80400000 ，0x200000；起始地址为：0x80600000，大小为：0x200000。每一个cells都是32位的，如果想要描述一个64位的地址，需要先设置#address-cells 和 #size-cells属性的值。</p></li><li><p><strong>#address-cells 和 #size-cells</strong></p><p>#address-cells，用于指定子节点reg属性“地址字段”所占的长度（单元格cells的个数）。</p><p> #size-cells，用于指定子节点reg属性“大小字段”所占的长度（单元格cells的个数）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line">    ocrams: sram@900000 &#123;</span><br><span class="line">            compatible = &quot;fsl,lpm-sram&quot;;</span><br><span class="line">            reg = &lt;0x900000 0x4000&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如当#address-cells&#x3D;2，#address-cells&#x3D;1，则reg内的数据含义为<code>reg = &lt;address address size address address size&gt;</code>，这样就可以来描述一个64位的地址了。</p></li><li><p><strong>device_type</strong></p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">    <span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;arm,cortex-a7&quot;</span><span class="punctuation">;</span></span><br><span class="line">        device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>device_type属性也是一个很少用的属性，只用在CPU和内存的节点上。 如上例中所示，device_type用在了CPU节点。</p></li><li><p><strong>ranges</strong></p></li></ul><h3 id="2-1-5-特殊节点"><a href="#2-1-5-特殊节点" class="headerlink" title="2.1.5 特殊节点"></a>2.1.5 特殊节点</h3><ul><li><code>aliases</code>子节点：aliases子节点的作用就是为其他节点起一个别名，如下所示。</li></ul><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">    can0 = <span class="variable">&amp;flexcan1</span><span class="punctuation">;</span></span><br><span class="line">    can1 = <span class="variable">&amp;flexcan2</span><span class="punctuation">;</span></span><br><span class="line">    ethernet0 = <span class="variable">&amp;fec1</span><span class="punctuation">;</span></span><br><span class="line">    ethernet1 = <span class="variable">&amp;fec2</span><span class="punctuation">;</span></span><br><span class="line">    gpio0 = <span class="variable">&amp;gpio1</span><span class="punctuation">;</span></span><br><span class="line">    gpio1 = <span class="variable">&amp;gpio2</span><span class="punctuation">;</span></span><br><span class="line">    gpio2 = <span class="variable">&amp;gpio3</span><span class="punctuation">;</span></span><br><span class="line">    gpio3 = <span class="variable">&amp;gpio4</span><span class="punctuation">;</span></span><br><span class="line">    gpio4 = <span class="variable">&amp;gpio5</span><span class="punctuation">;</span></span><br><span class="line">    i2c0 = <span class="variable">&amp;i2c1</span><span class="punctuation">;</span></span><br><span class="line">    i2c1 = <span class="variable">&amp;i2c2</span><span class="punctuation">;</span></span><br><span class="line">    <span class="comment">/*----------- 以下省略------------*/</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以“can0 &#x3D; &amp;flexcan1;”为例。“flexcan1”是一个节点的名字， 设置别名后我们可以使用“can0”来指代flexcan1节点，与节点标签类似。 在设备树中更多的是为节点添加标签，没有使用节点别名，别名的作用是“快速找到设备树节点”。 在驱动中如果要查找一个节点，通常情况下我们可以使用“节点路径”一步步找到节点。 也可以使用别名“一步到位”找到节点。</p><ul><li><code>chosen子节点</code>：chosen子节点位于根节点下，如下所示</li></ul><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">stdout-path</span> <span class="operator">=</span> <span class="variable">&amp;uart1</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>chosen子节点不代表实际硬件，它主要用于给内核传递参数。 这里只设置了“stdout-path &#x3D;&amp;uart1;”一条属性，表示系统标准输出stdout使用串口uart1。 此外这个节点还用作uboot向linux内核传递配置参数的“通道”， 我们在Uboot中设置的参数就是通过这个节点传递到内核的， 这部分内容是uboot和内核自动完成的。</p><h1 id="3-Linux内核中K210设备树分析"><a href="#3-Linux内核中K210设备树分析" class="headerlink" title="3.Linux内核中K210设备树分析"></a>3.Linux内核中K210设备树分析</h1><p>从Linux 5.7 开始，Linux内核开始支持国产 RISC-V 芯片 K210，在本地的linux5.10版本中的<code>/arch/riscv/boot/dts</code>文件夹中可以找到kendryte的K210设备树文件，我们以此为例子，来分析设备树的语法与语义</p><p><img src="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/image-20230611222950267.png" alt="image-20230611222950267"></p><h2 id="3-1-k210-dts分析"><a href="#3-1-k210-dts分析" class="headerlink" title="3.1 k210.dts分析"></a>3.1 k210.dts分析</h2><p>其中<code>k210.dts</code>的文件如下：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;k210.dtsi&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">//设置节点基本属性</span></span><br><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;Kendryte K210 generic&quot;</span><span class="punctuation">;</span>  <span class="comment">//指定为嘉楠的K210</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span>     <span class="comment">//设置compatible属性</span></span><br><span class="line"><span class="comment">// 设置chosen特殊节点，</span></span><br><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">bootargs</span> <span class="operator">=</span> <span class="string">&quot;earlycon console=ttySIF0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">stdout-path</span> <span class="operator">=</span> <span class="string">&quot;serial0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;uarths0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li>第一行：引用头文件，<code>k210.dts</code>引用了<code>k210.dtsi</code>中的文件</li><li>3~12行：k210的根节点，每一个设备树只有一个根节点。 如果打开<code>k210.dtsi</code>文件可以发现它也有一个根节点，虽然<code>k210.dts</code>引用了<code>k210.dtsi</code>文件， 但这并不代表设备树有两个根节点，因为不同文件的根节点最终会合并为一个。<ul><li><code>bootargs = &quot;earlycon console=ttySIF0&quot;;</code> 是 “chosen” 节点的属性之一。它用于指定系统引导过程中传递给内核的启动参数（boot arguments）。在这里，设置的启动参数是 “earlycon console&#x3D;ttySIF0”，表示使用早期控制台（early console）并将其输出重定向到名为 “ttySIF0” 的串口设备。</li><li><code>stdout-path = &quot;serial0&quot;;</code> 是 “chosen” 节点的另一个属性。它用于指定标准输出（stdout）的路径。在这里，标准输出被设置为名为 “serial0” 的设备。</li></ul></li><li>13~15行：设备树增加内容。向<code>uarths0</code>子节点添加了一个属性，<code>status = &quot;okay&quot;;</code> 在这里，状态被设置为 “okay”，表示<code>uarths0</code>设备节点处于可用状态，可以正常使用。</li></ul><h2 id="3-2-k210-dtsi分析"><a href="#3-2-k210-dtsi分析" class="headerlink" title="3.2 k210.dtsi分析"></a>3.2 k210.dtsi分析</h2><h3 id="3-2-1-根节点"><a href="#3-2-1-根节点" class="headerlink" title="3.2.1 根节点"></a>3.2.1 根节点</h3><p><code>k210.dtsi</code>的文件如下：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dt-bindings/clock/k210-clk.h&gt;</span></span></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Although the K210 is a 64-bit CPU, the address bus is only 32-bits</span></span><br><span class="line"><span class="comment"> * wide, and the upper half of all addresses is ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">serial0 = <span class="variable">&amp;uarths0</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The K210 has an sv39 MMU following the priviledge specification v1.9.</span></span><br><span class="line"><span class="comment"> * Since this is a non-ratified draft specification, the kernel does not</span></span><br><span class="line"><span class="comment"> * support it and the K210 support enabled only for the !MMU case.</span></span><br><span class="line"><span class="comment"> * Be consistent with this by setting the CPUs MMU type to &quot;none&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">timebase-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7800000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="title class_">cpu@1</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu1_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">sram:</span> <span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-names</span> <span class="operator">=</span> <span class="string">&quot;sram0&quot;</span>, <span class="string">&quot;sram1&quot;</span>, <span class="string">&quot;aisram&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">clocks</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">in0:</span> <span class="title class_">oscillator</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fixed-clock&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">26000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">soc</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-soc&quot;</span>, <span class="string">&quot;simple-bus&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">ranges</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;plic0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">sysctl:</span> <span class="title class_">sysctl@50440000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-sysctl&quot;</span>, <span class="string">&quot;simple-mfd&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x50440000</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">clint0:</span> <span class="title class_">clint@2000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,clint0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x2000000</span> <span class="number">0xC000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span>  <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">3</span> <span class="variable">&amp;cpu0_intc</span> <span class="number">7</span></span></span><br><span class="line"><span class="params"><span class="variable">&amp;cpu1_intc</span> <span class="number">3</span> <span class="variable">&amp;cpu1_intc</span> <span class="number">7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_ACLK&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">plic0:</span> <span class="title class_">interrupt-controller@c000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-plic0&quot;</span>, <span class="string">&quot;riscv,plic0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xC000000</span> <span class="number">0x4000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">11</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">0xffffffff</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="variable">&amp;cpu1_intc</span> <span class="number">11</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cpu1_intc</span> <span class="number">0xffffffff</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,ndev</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">65</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,max-priority</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">uarths0:</span> <span class="title class_">serial@38000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-uarths&quot;</span>, <span class="string">&quot;sifive,uart0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x38000000</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">33</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>在第一行中包含了一个c语言中的头文件<code>#include &lt;dt-bindings/clock/k210-clk.h&gt;</code>，这个文件位于<code>linux-5.10.99/include/dt-bindings/clock</code>下，打开此文件如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> K210_CLK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Arbitrary identifiers for clocks.</span></span><br><span class="line"><span class="comment"> * The structure is: in0 -&gt; pll0 -&gt; aclk -&gt; cpu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since we use the hardware defaults for now, set all these to the same clock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_PLL0   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_PLL1   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_ACLK   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_CPU    0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* K210_CLK_H */</span></span></span><br></pre></td></tr></table></figure><p>可以看到，只是定义了一些宏定义，后续可能用到</p><p><code>7~13</code>行</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">serial0 = <span class="variable">&amp;uarths0</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>#address-cells = &lt;1&gt;;</code> 指定了设备树中地址单元的数量，这里设置为 1。</li><li><code>#size-cells = &lt;1&gt;;</code> 指定了设备树中大小单元的数量，这里也设置为 1。</li><li><code>compatible = &quot;kendryte,k210&quot;;</code> 表示设备树描述的硬件与 Kendryte K210 SoC 兼容。这个属性用于标识设备树所描述的硬件平台或设备的兼容性。</li><li><code>aliases</code>：定义了一个别名 <code>serial0</code>，它指向名为 <code>uarths0</code> 的设备。</li></ul><h3 id="3-2-2-cpu节点"><a href="#3-2-2-cpu节点" class="headerlink" title="3.2.2 cpu节点"></a>3.2.2 cpu节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;    <span class="comment">// 地址单元为1</span></span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;        <span class="comment">// 大小单元为0</span></span></span><br><span class="line"><span class="attr">timebase-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7800000</span>&gt;</span><span class="punctuation">;</span>  <span class="comment">//指定cpu时钟基准频率7800000hz</span></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="title class_">cpu@1</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu1_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>cpu单元定义了两个核心分别为cpu0和cpu1，两个cpu核心的配置差不都，下面依次描述一下具体描述了哪些信息，这里以cpu0为例子：</p><ul><li><p>device_type &#x3D; “cpu”：表示此节点为cpu。</p></li><li><p>reg &#x3D; &lt;0&gt;：标明这是0号处理器。</p></li><li><p>compatible &#x3D; “kendryte,k210”, “sifive,rocket0”, “riscv”：指定cpu的标识。</p></li><li><p>riscv,isa &#x3D; “rv64imafdc”：表明该cpu为rv64imafdc架构。</p></li><li><p>mmu-type &#x3D; “none”：cpu不启用mmu，未开启虚拟内存功能。</p></li><li><p>i-cache-size &#x3D; &lt;0x8000&gt;：指令缓存的大小为 0x8000，即 32768 字节（或 32 KB）。</p></li><li><p>i-cache-block-size &#x3D; &lt;64&gt;：指令缓存的块大小为 64 字节。</p></li><li><p>d-cache-size &#x3D; &lt;0x8000&gt;：数据缓存（Data Cache）的大小为 0x8000，即 32768 字节（或 32 KB）。</p></li><li><p>d-cache-block-size &#x3D; &lt;64&gt;：数据缓存的块大小为 64 字节。</p></li><li><p>clocks &#x3D; &lt;&amp;sysctl K210_CLK_CPU&gt;：指向设备树中名为 <code>sysctl</code> 的节点， <code>sysctl</code> 定义在下面的<code>soc</code>节点中,并使用 K210_CLK_CPU 作为其子节点，K210_CLK_CPU这个宏定义在<code>k210-clk.h</code>中，值为：0。表明cpu0的时钟是 <code>sysctl</code> 节点中的0号子时钟</p></li><li><p>clock-frequency &#x3D; &lt;390000000&gt;：指定时钟的频率为390MHZ</p></li><li><p>cpu0_intc：中断控制器节点，用于处理与 CPU 0 相关的中断。</p><ul><li><code>#interrupt-cells = &lt;1&gt;</code>：指定了中断单元的数量，即中断号码的位数。在这种情况下，每个中断使用一个单元（一个整数值）来表示。</li><li><code>interrupt-controller</code>：表示该节点是中断控制器。</li><li><code>compatible = &quot;riscv,cpu-intc&quot;</code>：指定了该中断控制器节点与 RISC-V 架构的 CPU 中断控制器兼容。</li></ul></li></ul><h3 id="3-2-3-SRAM节点"><a href="#3-2-3-SRAM节点" class="headerlink" title="3.2.3 SRAM节点"></a>3.2.3 SRAM节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sram:</span> <span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-names</span> <span class="operator">=</span> <span class="string">&quot;sram0&quot;</span>, <span class="string">&quot;sram1&quot;</span>, <span class="string">&quot;aisram&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>memory@80000000</code>：指定了 SRAM 的基地址为 <code>0x80000000</code>。</li><li><code>device_type = &quot;memory&quot;</code>：指定了设备类型为内存。</li><li><code>reg</code>：指定了 SRAM 的物理地址范围。在这种情况下，SRAM 被划分为三个连续的地址范围：<ul><li><code>&lt;0x80000000 0x400000&gt;</code>：<code>sram0</code> 的地址范围为从 <code>0x80000000</code> 到 <code>0x803FFFFF</code>，大小为 4 MB。</li><li><code>&lt;0x80400000 0x200000&gt;</code>：<code>sram1</code> 的地址范围为从 <code>0x80400000</code> 到 <code>0x805FFFFF</code>，大小为 2 MB。</li><li><code>&lt;0x80600000 0x200000&gt;</code>：<code>aisram</code> 的地址范围为从 <code>0x80600000</code> 到 <code>0x807FFFFF</code>，大小为 2 MB。</li></ul></li><li><code>reg-names = &quot;sram0&quot;, &quot;sram1&quot;, &quot;aisram&quot;</code>：指定了对应于每个地址范围的名称</li></ul><h3 id="3-2-4-clocks节点"><a href="#3-2-4-clocks节点" class="headerlink" title="3.2.4 clocks节点"></a>3.2.4 clocks节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">clocks</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">in0:</span> <span class="title class_">oscillator</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fixed-clock&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">26000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>该设备树中的 <code>clocks</code> 节点定义了一个名为 <code>in0</code> 的时钟，具体如下：</p><ul><li><code>in0</code>：时钟的名称为 <code>in0</code>。</li><li><code>oscillator</code>：指定了该时钟源为一个振荡器。</li><li><code>compatible = &quot;fixed-clock&quot;</code>：指定了时钟的类型为固定频率时钟。</li><li><code>#clock-cells = &lt;0&gt;</code>：表示该时钟节点不需要附加的时钟单元属性。</li><li><code>clock-frequency = &lt;26000000&gt;</code>：指定了时钟的频率为 26 MHz。</li></ul><h3 id="3-2-5-soc节点"><a href="#3-2-5-soc节点" class="headerlink" title="3.2.5 soc节点"></a>3.2.5 soc节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;kendryte,k210-soc&quot;, &quot;simple-bus&quot;;</span><br><span class="line">ranges;  //省略ranges属性，不存在地址映射</span><br><span class="line">interrupt-parent = &lt;&amp;plic0&gt;;   </span><br><span class="line"></span><br><span class="line">sysctl: sysctl@50440000 &#123;</span><br><span class="line">compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;;</span><br><span class="line">reg = &lt;0x50440000 0x1000&gt;;</span><br><span class="line">#clock-cells = &lt;1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">clint0: clint@2000000 &#123;</span><br><span class="line">#interrupt-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;riscv,clint0&quot;;</span><br><span class="line">reg = &lt;0x2000000 0xC000&gt;;</span><br><span class="line">interrupts-extended =  &lt;&amp;cpu0_intc 3 &amp;cpu0_intc 7</span><br><span class="line">&amp;cpu1_intc 3 &amp;cpu1_intc 7&gt;;</span><br><span class="line">clocks = &lt;&amp;sysctl K210_CLK_ACLK&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">plic0: interrupt-controller@c000000 &#123;</span><br><span class="line">#interrupt-cells = &lt;1&gt;;</span><br><span class="line">interrupt-controller;</span><br><span class="line">compatible = &quot;kendryte,k210-plic0&quot;, &quot;riscv,plic0&quot;;</span><br><span class="line">reg = &lt;0xC000000 0x4000000&gt;;</span><br><span class="line">interrupts-extended = &lt;&amp;cpu0_intc 11&gt;, &lt;&amp;cpu0_intc 0xffffffff&gt;,</span><br><span class="line">      &lt;&amp;cpu1_intc 11&gt;, &lt;&amp;cpu1_intc 0xffffffff&gt;;</span><br><span class="line">riscv,ndev = &lt;65&gt;;</span><br><span class="line">riscv,max-priority = &lt;7&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uarths0: serial@38000000 &#123;</span><br><span class="line">compatible = &quot;kendryte,k210-uarths&quot;, &quot;sifive,uart0&quot;;</span><br><span class="line">reg = &lt;0x38000000 0x1000&gt;;</span><br><span class="line">interrupts = &lt;33&gt;;</span><br><span class="line">clocks = &lt;&amp;sysctl K210_CLK_CPU&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>interrupt-parent = &lt;&amp;plic0&gt;</code>：指定了中断控制器的父节点，这里使用的是 plic0 中断控制器的引用。</p></li><li><p><code>sysctl: sysctl@50440000</code>：这是一个子节点，描述了系统控制器 (sysctl)。它有以下属性：</p><ul><li><code>compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;</code>：指定了系统控制器的兼容性标识符，表示该节点描述的是 Kendryte K210 SoC 的系统控制器，并且它是一个多功能设备。</li><li><code>reg = &lt;0x50440000 0x1000&gt;</code>：指定了系统控制器在内存中的地址范围。</li><li><code>#clock-cells = &lt;1&gt;</code>：指定了该节点使用的时钟单元数。</li></ul></li><li><p><code>clint0: clint@2000000</code>：这是另一个子节点，描述了 CLINT (Core Local Interruptor)。它有以下属性：</p><ul><li><code>compatible = &quot;riscv,clint0&quot;</code>：指定了 CLINT 的兼容性标识符。</li><li><code>reg = &lt;0x2000000 0xC000&gt;</code>：指定了 CLINT 在内存中的地址范围。</li><li><code>interrupts-extended</code>：指定了 CLINT 支持的中断引脚，这里使用的是 <code>cpu0_intc</code> 和 <code>cpu1_intc</code> 的引用。</li><li><code>clocks = &lt;&amp;sysctl K210_CLK_ACLK&gt;</code>：指定了 CLINT 使用的时钟源，这里使用的是 <code>sysctl</code> 节点中的 <code>K210_CLK_ACLK</code> 时钟。</li></ul></li><li><p><code>plic0: interrupt-controller@c000000</code>：这是另一个子节点，描述了 PLIC (Platform-Level Interrupt Controller)。它有以下属性：</p><ul><li><code>compatible = &quot;kendryte,k210-plic0&quot;, &quot;riscv,plic0&quot;</code>：指定了 PLIC 的兼容性标识符。</li><li><code>reg = &lt;0xC000000 0x4000000&gt;</code>：指定了 PLIC 在内存中的地址范围。</li><li><code>interrupts-extended</code>：指定了 PLIC 支持的中断引脚，这里使用的是 <code>cpu0_intc</code> 和 <code>cpu1_intc</code> 的引用。</li><li><code>riscv,ndev = &lt;65&gt;</code>：指定了 PLIC 支持的设备数量。</li><li><code>riscv,max-priority = &lt;7&gt;</code>：指定了 PLIC 支持的最大优先级</li></ul></li><li><p><code>uarths0: serial@38000000</code>：这是串口设备的节点定义，名称为 <code>uarths0</code>，描述了串口在内存中的地址范围。</p><ul><li><code>compatible = &quot;kendryte,k210-uarths&quot;, &quot;sifive,uart0&quot;</code>：指定了串口设备的兼容性标识符，表示该节点描述的是 Kendryte K210 SoC 的 <code>uarths0</code> 串口，并且它兼容 SiFive 的 UART0 设备。</li><li><code>reg = &lt;0x38000000 0x1000&gt;</code>：指定了串口设备在内存中的地址范围。</li><li><code>interrupts = &lt;33&gt;</code>：指定了串口设备的中断引脚，这里使用的是中断号 33。</li><li><code>clocks = &lt;&amp;sysctl K210_CLK_CPU&gt;</code>：指定了串口设备使用的时钟源，这里使用的是 <code>sysctl</code> 节点中的 <code>K210_CLK_CPU</code> 时钟。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 设备树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源码构建Qemu</title>
      <link href="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/"/>
      <url>/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Qemu介绍"><a href="#1-Qemu介绍" class="headerlink" title="1.Qemu介绍"></a>1.Qemu介绍</h1><p>QEMU（Quick Emulator）是一个开源的虚拟化软件，它可以模拟多个硬件平台，包括处理器和外设，从而允许在一个平台上运行多个不同的操作系统。QEMU可以运行在多个主机平台上，包括Linux、Windows、macOS等。</p><p>QEMU的主要功能是模拟一个完整的计算机系统，包括处理器、内存、存储器、网络接口等，它可以将客户操作系统（例如Linux、Windows等）当作应用程序运行在主机操作系统之上，从而实现虚拟化。QEMU还支持通过二进制代码转换的方式实现虚拟化加速，例如使用KVM（Kernel-based Virtual Machine）模块加速虚拟机的运行。</p><p>QEMU可以用于多种用途，包括：</p><ol><li>系统仿真：可以模拟不同的处理器架构（如x86、ARM等）来运行和测试操作系统和应用程序，方便开发人员进行交叉平台开发和调试。</li><li>虚拟机：可以在一个物理机上运行多个虚拟机实例，每个虚拟机可以运行不同的操作系统，实现资源的隔离和共享，提供虚拟化环境。</li><li>可移植性：QEMU可以将一个操作系统或应用程序打包成一个虚拟机镜像，这个镜像可以在不同的平台上运行，提供了一种便携式的软件分发方式。</li></ol><blockquote><p>官方源码地址：<a href="https://github.com/qemu/qemu">Qemu的github源码</a></p><p>官网地址：<a href="https://www.qemu.org/">QEMU</a></p><p>qemu的文档地址：<a href="https://www.qemu.org/docs/master/">Welcome to QEMU’s documentation! — QEMU documentation</a></p></blockquote><h1 id="2-源码下载"><a href="#2-源码下载" class="headerlink" title="2.源码下载"></a>2.源码下载</h1><p>在笔者下载源码的时间，目前<code>qemu</code>的版本已经更新到了<code>8.0.2</code>，我的ubuntu环境为：<code>WSL2 ubuntu20.04.05</code></p><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611160604923.png" alt="image-20230611160604923"></p><p>安装所需编译环境：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install ninja-build pkg-config libglib2.0-dev libpixman-1-dev libgtk-3-dev libcap-ng-dev libattr1-dev libsdl2-dev device-tree-compiler bison flex gperf intltool mtd-utils libslirp-dev</span><br></pre></td></tr></table></figure><p>源码下载与编译：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~$ <span class="built_in">mkdir</span> qemu</span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ <span class="built_in">cd</span> qemu/</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ wget https://download.qemu.org/qemu-8.0.2.tar.xz</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ tar xvJf qemu-8.0.2.tar.xz</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ <span class="built_in">cd</span> qemu-8.0.2/</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ ./configure</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ make -j8</span><br></pre></td></tr></table></figure><p>编译完成后会生成一个<code>./build</code>目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ <span class="built_in">cd</span> build/</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由于我之前使用package的方式在本地安装了一个qemu，因此先将其卸载</span></span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ sudo apt-get remove --auto-remove qemu-system-x86</span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ sudo apt-get purge --auto-remove qemu-system-x86</span><br><span class="line"><span class="comment">#卸载完成后进入build目录执行安装命令，需要sudo不然会报错</span></span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2/build$ sudo make install</span><br></pre></td></tr></table></figure><p>测试，查看<code>qemu</code>版本号，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-img -V</span><br></pre></td></tr></table></figure><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611164450596.png" alt="image-20230611164450596"></p><p>启动qemu，这里以riscv64为例：<code>qemu-system-riscv64</code></p><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611164621585.png" alt="image-20230611164621585"></p><p>大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> Qemu&amp;虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-3.实模式</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-X86cpu工作原理"><a href="#1-X86cpu工作原理" class="headerlink" title="1. X86cpu工作原理"></a>1. X86cpu工作原理</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611121633671.png" alt="image-20230611121633671"></p><p>程序计数器<code>PC</code>存储了下一条要运行的指定的地址，在x86cpu上，<code>PC</code>就是：<code>cs：ip</code>，控制单元读取<code>ip</code>寄存器中的地址后，将此地址送上地址总线，<code>cpu</code>由此得到了要执行的指令，然后将指令存入指令寄存器<code>IR</code>中。下一步指令译码器将此指令解码，解码后得到了操作数和操作码，于是操作控制器<code>OC</code>就给运算单元下令，运算单元就开始执行指令。<code>ip</code>寄存器的值被加上当前指令的大小，由此循环。</p><p>IA32的指令格式如下：</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611123557111.png" alt="image-20230611123557111"></p><h2 id="2-实模式的寻址"><a href="#2-实模式的寻址" class="headerlink" title="2. 实模式的寻址"></a>2. 实模式的寻址</h2><p>8086的地址总线是20位宽，意味着寻址范围为：<code>2^20=1MB</code>，但内部寄存器都是16位的，若采用单一寄存器来寻址只能访问：<code>2^16=64KB</code>空间。</p><p>为了解决16位寄存器不能寻址20位的问题，因此通过先把16位的段基址左移四位变成20位后，在加上段内偏移地址，这样就形成了20位地址，只要保证了段基址是20位的，偏移地址是多少位就不用关心了。</p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU3RyaXZlIGZvciB0aGUgYmVzdO-8gQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="3.操作系统——CPU的实模式、保护模式和长模式_Strive for the best！的博客-CSDN博客" style="zoom: 50%;"><p>下面列举一下寻址实例：所有的利用寄存器寻址的方式，每个寄存器都有对应的段基址，寄存器的默认段基址见上一章</p><ol><li><p>直接寻址（Direct addressing）：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> AX, [<span class="number">0x1234</span>]</span><br><span class="line"><span class="keyword">mov</span> ax, [fs:<span class="number">0x5678</span>]</span><br></pre></td></tr></table></figure><p>0x1234是段内偏移地址，默认的段地址是DS，这一条指令是将内存地址<code>DS:0x1234</code>处的值写入<code>ax</code>寄存器。</p><p>第二条指定显示指定段基址为<code>fs</code>,因此是将内存地址<code>FS:0x5678</code>处的值写入<code>ax</code>寄存器。</p><p>注意：段基址都需要先左移4位再与段内偏移相加</p></li><li><p>基址寻址（Base addressing）：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> AX, [BX + <span class="number">0x10</span>]</span><br></pre></td></tr></table></figure><p>这个例子中，将从BX寄存器所指定的内存地址加上偏移量0x10处读取一个字（16位）的数据，并将其存储在AX寄存器中。bx默认的段寄存器为DS，因此实际的寻址地址为：<code>DS:bx+0x10</code></p></li></ol><h2 id="3-栈的布局"><a href="#3-栈的布局" class="headerlink" title="3.栈的布局"></a>3.栈的布局</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611131141910.png" alt="image-20230611131141910"></p><p>栈空间也是内存中一段区域，我们程序员可以自由分配，SS栈段寄存器左移4位指向栈底，栈的生长是向低地址方向发展，sp指向了栈顶。</p><p>在进行函数调用时，例如使用call指令，需要将PC压栈，然后跳转。</p>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-2.X86寄存器详解</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是寄存器"><a href="#1-什么是寄存器" class="headerlink" title="1.什么是寄存器"></a>1.什么是寄存器</h1><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果以及一些CPU运行需要的信息</p><p>x86架构CPU走的是<code>复杂指令集（CISC）</code> 路线，提供了丰富的指令来实现强大的功能，与此同时也提供了大量寄存器来辅助功能实现。寄存器分为两类，一类对程序员不可见，这一类寄存器用于支撑CPU内部运行，程序员无法操作。一类对程序员可见，在进行汇编编写程序时，能够直接操作。</p><ul><li>通用寄存器：<code>EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP</code></li><li>标志寄存器：<code>EFLAGS</code></li><li>指令寄存器：<code>EIP</code></li><li>段寄存器：<code>CS、DS、ES、FS、GS、SS</code></li><li>控制寄存器：<code>CR0、CR1、CR2、CR3、CR4</code></li><li>调试寄存器：<code>DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7</code></li><li>描述符寄存器：<code>GDTR、IDTR、LDTR、TR</code></li></ul><h1 id="2-实模式下寄存器（16bit）"><a href="#2-实模式下寄存器（16bit）" class="headerlink" title="2.实模式下寄存器（16bit）"></a>2.实模式下寄存器（16bit）</h1><p>在x86架构下，实模式可以使用的通用寄存器有 <code>AX、BX、CX、DX、SI、DI、BP</code> 和 <code>SP</code>。这些寄存器都是16位的，可以分为两个8位的寄存器来使用。</p><p>此外，还有一些特殊用途的寄存器，包括：</p><ul><li><code>IP</code>（指令指针寄存器）：保存当前执行的指令地址。</li><li><code>CS</code>（代码段寄存器）：保存代码段的起始地址。</li><li><code>DS</code>（数据段寄存器）：保存数据段的起始地址。</li><li><code>ES</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>GS</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>FS</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>SS</code>（堆栈段寄存器）：保存堆栈段的起始地址。</li><li><code>FLAGS</code>（标志寄存器）：包含各种标志位，如零标志、进位标志、符号标志等</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230611122704382.png" alt="image-20230611122704382"></p><p>其中<code>FS</code>,<code>GS</code>附加段寄存器是在32位CPU中增加的，但是在32位CPU中在实模式下同样可以使用，因为32位CPU兼容16位CPU的特性。</p><table><thead><tr><th>16位寄存器</th><th>功能</th><th>高8位</th><th>低8位</th></tr></thead><tbody><tr><td><code>AX</code></td><td>累加寄存器，常用于算术运算，保存与外设输入输出的数据</td><td><code>AH</code></td><td><code>AL</code></td></tr><tr><td><code>CX</code></td><td>计数寄存器，常用于循环指令中的循环次数</td><td><code>CH</code></td><td><code>CL</code></td></tr><tr><td><code>DX</code></td><td>数据寄存器，通常情况下只用于保存外设控制器的端口号地址</td><td><code>DH</code></td><td><code>DL</code></td></tr><tr><td><code>BX</code></td><td>基址寄存器，来存储内存地址，段基址为DS</td><td><code>BH</code></td><td><code>BL</code></td></tr><tr><td><code>SP</code></td><td>栈指针寄存器，段基址为SS，用来指向栈顶</td><td></td><td></td></tr><tr><td><code>BP</code></td><td>栈帧的基址寄存器，段基址为SS</td><td></td><td></td></tr><tr><td><code>SI</code></td><td>源变址寄存器，存储数据源地址,段基址为DS</td><td></td><td></td></tr><tr><td><code>DI</code></td><td>目的变址寄存器，存储数据目的地址,段基址为DS</td><td></td><td></td></tr></tbody></table><blockquote><p>BP指向栈底，SP指向栈顶，两者共同维护了栈空间。<code>push</code> 和 <code>pop</code> 可更改<code>SP</code>的值,<code>sp</code>指针的值会自动更新</p></blockquote><h2 id="2-1-寄存器用法举例"><a href="#2-1-寄存器用法举例" class="headerlink" title="2.1 寄存器用法举例"></a>2.1 寄存器用法举例</h2><ul><li><p><code>SI、DI</code></p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">mov</span> ecx, <span class="number">10</span>  <span class="comment">; 设置循环计数为10</span></span><br><span class="line">    <span class="keyword">mov</span> esi, <span class="number">0</span>  <span class="comment">; 设置SI寄存器为0作为初始值</span></span><br><span class="line">    <span class="keyword">mov</span> edi, <span class="number">100</span>  <span class="comment">; 设置DI寄存器为100作为初始值</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">loop_start:</span></span><br><span class="line">    <span class="keyword">mov</span> eax, [esi]  <span class="comment">; 从源地址(SI)读取数据到EAX寄存器</span></span><br><span class="line">    <span class="keyword">mov</span> [edi], eax  <span class="comment">; 将数据存储到目的地址(DI)</span></span><br><span class="line">    <span class="keyword">add</span> esi, <span class="number">4</span>  <span class="comment">; 增加SI的值，以便读取下一个双字</span></span><br><span class="line">    <span class="keyword">add</span> edi, <span class="number">4</span>  <span class="comment">; 增加DI的值，以便存储到下一个地址</span></span><br><span class="line">    loop loop_start  <span class="comment">; 循环，减少ECX计数，直到为零</span></span><br></pre></td></tr></table></figure><p>在这个例子中，SI和DI寄存器用作源地址和目的地址。循环从源地址读取数据，然后将其存储到目的地址，然后递增SI和DI以访问下一个元素。通过loop指令和ECX计数器，循环执行直到计数为零。</p></li><li><p><code>BP、SP</code></p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">push</span> ebp         <span class="comment">; 保存当前函数的旧的基址到堆栈中</span></span><br><span class="line"><span class="keyword">mov</span> ebp, esp     <span class="comment">; 将当前堆栈指针存储到基址指针寄存器BP中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sub</span> esp, <span class="number">16</span>      <span class="comment">; 分配16字节的局部变量空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> dword ptr [ebp<span class="number">-4</span>], <span class="number">10</span>   <span class="comment">; 将值10存储到基址指针寄存器BP-4指向的位置（局部变量）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> eax, dword ptr [ebp<span class="number">-4</span>]  <span class="comment">; 从基址指针寄存器BP-4指向的位置读取值到EAX寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> esp, <span class="number">16</span>      <span class="comment">; 释放局部变量空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pop</span> ebp          <span class="comment">; 恢复旧的基址到基址指针寄存器BP中</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-保护模式下寄存器（32bit）"><a href="#3-保护模式下寄存器（32bit）" class="headerlink" title="3.保护模式下寄存器（32bit）"></a>3.保护模式下寄存器（32bit）</h1><h2 id="3-1-保护模式寄存器介绍"><a href="#3-1-保护模式寄存器介绍" class="headerlink" title="3.1 保护模式寄存器介绍"></a>3.1 保护模式寄存器介绍</h2><p>在32位保护模式下，x86架构提供了更多的通用寄存器以及扩展功能。以下是32位保护模式下可以使用的寄存器：</p><ol><li>通用寄存器（General Purpose Registers）：<ul><li><code>EAX</code>：累加器寄存器（Accumulator Register）。</li><li><code>EBX</code>：基址寄存器（Base Register）。</li><li><code>ECX</code>：计数寄存器（Counter Register）。</li><li><code>EDX</code>：数据寄存器（Data Register）。</li><li><code>ESI</code>：源索引寄存器（Source Index Register）。</li><li><code>EDI</code>：目的索引寄存器（Destination Index Register）。</li><li><code>EBP</code>：基址指针寄存器（Base Pointer Register）。</li><li><code>ESP</code>：堆栈指针寄存器（Stack Pointer Register）。</li></ul></li><li>扩展通用寄存器：<ul><li><code>EIP</code>：指令指针寄存器（Instruction Pointer Register）。</li><li><code>EFLAGS</code>：标志寄存器（Flags Register），用于存储各种标志位，如零标志、进位标志、符号标志等。</li></ul></li><li>段寄存器（Segment Registers）：<ul><li><code>CS</code>：代码段寄存器（Code Segment Register）。</li><li><code>DS</code>：数据段寄存器（Data Segment Register）。</li><li><code>ES</code>：附加段寄存器（Extra Segment Register）。</li><li><code>FS、GS、SS</code>：附加段寄存器，用于访问额外的数据段。</li></ul></li><li>控制寄存器（Control Registers）：<ul><li><code>CR0、CR2、CR3、CR4</code>：用于控制和管理保护模式的特性，如分页机制、特权级等。</li></ul></li><li>段描述符寄存器（Descriptor Registers）：<ul><li><code>GDTR</code>：全局描述符表寄存器（Global Descriptor Table Register）。</li><li><code>IDTR</code>：中断描述符表寄存器（Interrupt Descriptor Table Register）。</li><li><code>LDTR</code>：局部描述符表寄存器（Local Descriptor Table Register）。</li><li><code>TR</code>：任务寄存器（Task Register）。</li></ul></li></ol><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230128173803324.png" alt="image-20230128173803324" style="zoom: 80%;"><h2 id="3-2-控制寄存器"><a href="#3-2-控制寄存器" class="headerlink" title="3.2 控制寄存器"></a>3.2 控制寄存器</h2><h3 id="3-2-1-CR0寄存器"><a href="#3-2-1-CR0寄存器" class="headerlink" title="3.2.1 CR0寄存器"></a>3.2.1 <code>CR0</code>寄存器</h3><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230609214128132.png" alt="image-20230609214128132"></p><ul><li><p><code>PE: Protection Enble </code></p><p>当此位为0，代表在CPU处在实模式，此位为1，表示CPU处在保护模式；从实模式切换到保护模式时需要将此位置为1.</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="meta">#进入保护模式</span></span><br><span class="line"><span class="keyword">mov</span> eax, cr0</span><br><span class="line"><span class="keyword">or</span> eax, <span class="number">0x00000001</span></span><br><span class="line"><span class="keyword">mov</span> cr0, eax</span><br></pre></td></tr></table></figure></li><li><p><code>TS：Task Switched</code></p></li><li><p><code>WP：Write Protect</code></p><p>对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志。当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作；当该位复位时则反之。该标志有利于UNIX类操作系统在创建进程时实现写时复制（Copy on Write）技术。</p></li><li><p><code>AM：Alignment Mask</code></p></li><li><p><code>NW：Not Writethrough</code></p></li><li><p><code>CD：Cache Disable</code></p></li><li><p><code>PG：Paging</code></p><p>是否启动分页机制的位，只有在保护模式以上才能开启分页机制。PG位为1开启分页机制，PG位为0关闭分页机制</p></li></ul><p>在CPU刚上电时，处理器被复位成PE&#x3D;0,PG&#x3D;0。</p><h3 id="3-2-2-CR2寄存器"><a href="#3-2-2-CR2寄存器" class="headerlink" title="3.2.2 CR2寄存器"></a>3.2.2 <code>CR2</code>寄存器</h3><h3 id="3-2-3-CR3寄存器"><a href="#3-2-3-CR3寄存器" class="headerlink" title="3.2.3 CR3寄存器"></a>3.2.3 <code>CR3</code>寄存器</h3><h3 id="3-2-4-CR4寄存器"><a href="#3-2-4-CR4寄存器" class="headerlink" title="3.2.4 CR4寄存器"></a>3.2.4 <code>CR4</code>寄存器</h3><h2 id="3-3-EFLAGS寄存器"><a href="#3-3-EFLAGS寄存器" class="headerlink" title="3.3 EFLAGS寄存器"></a>3.3 <code>EFLAGS</code>寄存器</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230611124419683.png" alt="image-20230611124419683"></p><ul><li>CF：进位标志</li><li>PF：奇偶位标志</li><li>AF：辅助进位标志</li><li>ZF：零标志位</li><li>SF：符号标注位</li><li>TF：陷阱标志位</li><li>IF：中断标志位。若IF为1，表示中断开启；若为0，表示中断关闭</li><li>DF：方向标志位。</li><li>OF：溢出标志位。</li><li>IOPL：特权级标志位，占2个bit，标志了4个特权级</li><li>NT：任务嵌套标志位</li><li>RF：恢复标志位</li><li>VM：虚拟8086模式</li><li>AC：对齐检查</li><li>VIF：虚拟中断标志位</li><li>VIP：虚拟中断挂起标志位</li><li>ID：识别标志位</li><li>22~31：没有实际用途，占位用，为了将来拓展</li></ul><h2 id="3-4-段描述符寄存器"><a href="#3-4-段描述符寄存器" class="headerlink" title="3.4 段描述符寄存器"></a>3.4 段描述符寄存器</h2><h3 id="3-4-1-GDTR寄存器"><a href="#3-4-1-GDTR寄存器" class="headerlink" title="3.4.1 GDTR寄存器"></a>3.4.1 <code>GDTR</code>寄存器</h3><p>GDTR是个48位的寄存器，专门用来储存GDT的内存地址和大小</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626124256061.png" alt="image-20230626124256061"></p><p>GDT：Global Descriptor Table，全局段描述符，在保护模式下，GDT在内存中有且只有一个，GDT的数据结构如下，每个描述符8个字节，64个bit，可以存放在内存当中任意位置，addr相当于GDT的内存起始地址，GDT的总长度就就是GDT界限</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/20201026145225176.png" alt="在这里插入图片描述"></p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626124507958.png" alt="image-20230626124507958"></p><p>段描述符的主要属性都在高32位：</p><ul><li><p>0~7位：段基址的16-23</p></li><li><p>24~31位：段基址的24-31</p></li><li><p>8~11位：type字段，共四位，用来指定本描述符的类型</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626132808111.png" alt="image-20230626132808111"></p></li><li><p>12位：S字段，用于指示系统是否是系统段。S为0表示系统段，S为1表示数据段，type字段要和S字段配合在一起才能确定段描述符的确切类型。</p></li><li><p>15位：Present，即段是否存在。如果段存在于内存中，P为1，否则为0</p></li><li><p>16~19位：段界限的16-19位</p></li><li><p>20位：AVL，随便用，操作系统可以随便用这一位</p></li><li><p>21位：L字段，用来设置是否是64位代码段。L为1表示64位代码段，否则表示32位代码段。</p></li><li><p>22位：D&#x2F;B字段</p></li><li><p>23位：G字段，用来设置段界限的单位大小，若G为0，表示段界限的单位是4KB，若界为1，表示段界限的单位是4KB</p></li><li><p>24~31位：段基址的最后8位</p></li></ul><p>在实模式下，段寄存器中存储的是段基地址，即内存段的起始地址，而在保护模式下，由于段基址已经存入了段描述符中，所以段寄存器不再存放段基址，而是存放一个叫选择子的东西，选择子用来在段描述符表中索引相应的段描述符，数据结构如下：</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626133735851.png" alt="image-20230626133735851"></p><ul><li>0~1位：RPL，存储请求特权级，总共有0、1、2、3四个特权级</li><li>2位：TI，用来表示是GDT还是LDT，TI为0表示在GDT中索引描述符，TI为1表示在LDT中索引描述符</li></ul><p>在代码中我们可以定义对应的结构体来定义GDT和选择子以及全局描述符表指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">descriptor_t</span> /* 共 8 个字节 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> limit_low;      <span class="comment">// 段界限 0 ~ 15 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> base_low : <span class="number">24</span>;    <span class="comment">// 基地址 0 ~ 23 位 16M</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> type : <span class="number">4</span>;        <span class="comment">// 段类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> segment : <span class="number">1</span>;     <span class="comment">// 1 表示代码段或数据段即非系统段，0 表示系统段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> DPL : <span class="number">2</span>;         <span class="comment">// Descriptor Privilege Level 描述符特权等级 0 ~ 3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> present : <span class="number">1</span>;     <span class="comment">// 存在位，1 在内存中，0 在磁盘上</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> limit_high : <span class="number">4</span>;  <span class="comment">// 段界限 16 ~ 19;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> available : <span class="number">1</span>;   <span class="comment">// 该安排的都安排了，送给操作系统吧</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> long_mode : <span class="number">1</span>;   <span class="comment">// 64 位扩展标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> big : <span class="number">1</span>;         <span class="comment">// 32 位 还是 16 位;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> granularity : <span class="number">1</span>; <span class="comment">// 粒度 4KB 或 1B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base_high;       <span class="comment">// 基地址 24 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">descriptor_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 段选择子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">selector_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u8 RPL : <span class="number">2</span>; <span class="comment">// Request Privilege Level</span></span><br><span class="line">    u8 TI : <span class="number">1</span>;  <span class="comment">// Table Indicator</span></span><br><span class="line">    u16 index : <span class="number">13</span>;</span><br><span class="line">&#125; <span class="type">selector_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pointer_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 limit;</span><br><span class="line">    u32 base;</span><br><span class="line">&#125; _packed <span class="type">pointer_t</span>;</span><br></pre></td></tr></table></figure><p>下一步就是填充GDT和GDT_PTR</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充GDT</span></span><br><span class="line"><span class="type">descriptor_t</span> gdt[GDT_SIZE]; <span class="comment">//内核全局描述符表</span></span><br><span class="line">    <span class="built_in">memset</span>(gdt, <span class="number">0</span>, <span class="keyword">sizeof</span>(gdt));</span><br><span class="line"></span><br><span class="line">    <span class="type">descriptor_t</span> *desc;</span><br><span class="line">    desc = gdt + KERNEL_CODE_IDX;</span><br><span class="line">    descriptor_init(desc, <span class="number">0</span>, <span class="number">0xFFFFF</span>);</span><br><span class="line">    desc-&gt;segment = <span class="number">1</span>;     <span class="comment">// 代码段</span></span><br><span class="line">    desc-&gt;granularity = <span class="number">1</span>; <span class="comment">// 4K</span></span><br><span class="line">    desc-&gt;big = <span class="number">1</span>;         <span class="comment">// 32 位</span></span><br><span class="line">    desc-&gt;long_mode = <span class="number">0</span>;   <span class="comment">// 不是 64 位</span></span><br><span class="line">    desc-&gt;present = <span class="number">1</span>;     <span class="comment">// 在内存中</span></span><br><span class="line">    desc-&gt;DPL = <span class="number">0</span>;         <span class="comment">// 内核特权级</span></span><br><span class="line">    desc-&gt;type = <span class="number">0b1010</span>;   <span class="comment">// 代码 / 非依从 / 可读 / 没有被访问过</span></span><br><span class="line"><span class="comment">//填充 gdt_ptr</span></span><br><span class="line">    gdt_ptr.base = (u32)&amp;gdt;</span><br><span class="line">    gdt_ptr.limit = <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>然后使用lgdt命令将全局描述符表指针加载到GDTR寄存器中:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">lgdt [gdt_ptr]</span><br></pre></td></tr></table></figure><h3 id="3-4-2-IDTR寄存器"><a href="#3-4-2-IDTR寄存器" class="headerlink" title="3.4.2 IDTR寄存器"></a>3.4.2 <code>IDTR</code>寄存器</h3><p>idtr寄存器用于存储中断描述符表的地址和表界限</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626145545075.png" alt="image-20230626145545075"></p><p>在中断描述符表中可以存储的是中断描述符，这里的中断描述符分为四类，以不同门的叫法来描述，在上面描述GDT的时候，提到S字段和type字段一起决定了这个描述符是什么，对于GDT来说，我们设置S位为1，代表非系统段，对于中断描述符来说需要将S位设为0，由此延申出了四种描述符：</p><ul><li>任务门描述符</li></ul><p>​任务门和任务状态段 (Task Status Segment，TSS) 是Intel处理器在硬件一级提供的任务切换机制，所以任务门需要和TSS配合在一起使用，在任务门中记录的是TSS选择子，偏移量未使用。任务门可以存在于全局描述符表GDT、局部描述符表LDT、中断描述符表IDT中。描述符中任务门的type值为二进制0101，其结构如下图所示。顺便说一句大多数操作系统 (包括Linux) 都未用TSS实现任务切换</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150722494.png" alt="image-20230626150722494"></p><ul><li>中断门描述符</li></ul><p>​中断门包含了中断处理程序所在段的段选择子和段内偏移地址。当通过此方式进入中断后，标志寄存器eflags中的IF位自动置0，也就是在进入中断后，自动把中断关闭，避免中断嵌套。Linux就是利用中断门实现的系统调用，就是那个著名的int0x80。中断门只允许存在于IDT中。描述符中中断门的type值为二进制1110，其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150752429.png" alt="image-20230626150752429"></p><ul><li>陷阱门描述符</li></ul><p>​陷阱门和中断门非常相似，区别是由陷阱门进入中断后，标志寄存器eflags中的IF位不会自动置0。陷阱门只允许存在于IDT中。描述符中陷阱门的type值为二进制1111。其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150816386.png" alt="image-20230626150816386"></p><ul><li>调用门描述符</li></ul><p>​调用门是提供给用户进程进入特权0级的方式，其DPL为3。调用门中记录例程的地址，它不能用int指令调用，只能用call和imp指令。调用门可以安装在GDT和LDT中。描述符中调用门的type值为二进制1100。其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150841553.png" alt="image-20230626150841553"></p><p>同样我们可以使用一个结构体来描述中断描述符：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 offset0;     <span class="comment">//段内偏移 0 ~ 15位</span></span><br><span class="line">    u16 selector;    <span class="comment">//代码段选择子</span></span><br><span class="line">    u8 reserved;     <span class="comment">//保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;     <span class="comment">//任务们/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>;  <span class="comment">//segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;      <span class="comment">//使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>;  <span class="comment">//是否有效</span></span><br><span class="line">    u16 offset1;     <span class="comment">//段内偏移 16 ~ 31位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br></pre></td></tr></table></figure><p>然后填充中断描述符和中断</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="type">void</span>* <span class="type">handler_t</span>; <span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="comment">//定义idt</span></span><br><span class="line">   <span class="type">gate_t</span> idt[IDT_SIZE];</span><br><span class="line"><span class="comment">//中断处理程序段内偏移</span></span><br><span class="line">   <span class="keyword">extern</span> <span class="type">handler_t</span> handler_entry_table[ENTRY_SIZE];</span><br><span class="line"><span class="comment">//初始化中断描述符表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; IDT_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line">        <span class="type">handler_t</span> handler = handler_entry_table[i];</span><br><span class="line">        gate-&gt;offset0 = (u32)handler &amp; <span class="number">0xffff</span>;         <span class="comment">//段内偏移 0 ~ 15位</span></span><br><span class="line">        gate-&gt;offset1 = ((u32)handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>; <span class="comment">//段内偏移 16 ~ 31位</span></span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;    <span class="comment">//代码段选择子</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;         <span class="comment">//保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;        </span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;              <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;          <span class="comment">// 是否有效</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后将idt_ptr填充进IDTR寄存器中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载中断描述符表</span></span><br><span class="line">idt_ptr.base = (u32)idt;</span><br><span class="line">idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-LDTR寄存器"><a href="#3-4-3-LDTR寄存器" class="headerlink" title="3.4.3 LDTR寄存器"></a>3.4.3 <code>LDTR</code>寄存器</h3><h3 id="3-4-4-TR寄存器"><a href="#3-4-4-TR寄存器" class="headerlink" title="3.4.4 TR寄存器"></a>3.4.4 <code>TR</code>寄存器</h3><h1 id="4-长模式下寄存器（64bit）"><a href="#4-长模式下寄存器（64bit）" class="headerlink" title="4.长模式下寄存器（64bit）"></a>4.长模式下寄存器（64bit）</h1><p>在长模式下，也称为64位保护模式（64-bit Protected Mode）或x86-64架构，x86处理器提供了更广泛的寄存器集合。以下是长模式下可以使用的寄存器：</p><ol><li>通用寄存器（General Purpose Registers）：<ul><li><code>RAX</code>：累加器寄存器（Accumulator Register）。</li><li><code>RBX</code>：基址寄存器（Base Register）。</li><li><code>RCX</code>：计数寄存器（Counter Register）。</li><li><code>RDX</code>：数据寄存器（Data Register）。</li><li><code>RSI</code>：源索引寄存器（Source Index Register）。</li><li><code>RDI</code>：目的索引寄存器（Destination Index Register）。</li><li><code>RBP</code>：基址指针寄存器（Base Pointer Register）。</li><li><code>RSP</code>：堆栈指针寄存器（Stack Pointer Register）。</li><li><code>R8-R15</code>：扩展的通用寄存器。</li></ul></li><li>扩展通用寄存器：<ul><li><code>RIP</code>：指令指针寄存器（Instruction Pointer Register）。</li><li><code>RFLAGS</code>：标志寄存器（Flags Register），包含各种标志位。</li></ul></li><li>段寄存器（Segment Registers）：<ul><li><code>CS</code>：代码段寄存器（Code Segment Register）。</li><li><code>DS</code>：数据段寄存器（Data Segment Register）。</li><li><code>ES</code>：附加段寄存器（Extra Segment Register）。</li><li><code>FS、GS、SS</code>：附加段寄存器，用于访问额外的数据段。</li></ul></li><li>控制寄存器（Control Registers）：<ul><li><code>CR0、CR2、CR3、CR4、CR8</code>：用于控制和管理保护模式的特性，如分页机制、特权级等。</li></ul></li><li>段描述符寄存器（Descriptor Registers）：<ul><li><code>GDTR</code>：全局描述符表寄存器（Global Descriptor Table Register）。</li><li><code>IDTR</code>：中断描述符表寄存器（Interrupt Descriptor Table Register）。</li><li><code>LDTR</code>：局部描述符表寄存器（Local Descriptor Table Register）。</li><li><code>TR</code>：任务寄存器（Task Register）。</li></ul></li><li>XMM寄存器（SSE寄存器）：<ul><li><code>XMM0-XMM15</code>：128位的向量寄存器，用于执行SSE（Streaming SIMD Extensions）指令集中的向量运算。</li></ul></li><li>YMM寄存器（AVX寄存器）：<ul><li><code>YMM0-YMM15</code>：256位的向量寄存器，用于执行AVX（Advanced Vector Extensions）指令集中的向量运算。</li></ul></li><li>ZMM寄存器（AVX-512寄存器）：<ul><li><code>ZMM0-ZMM31</code>：512位的向量寄存器，用于执行AVX-512指令集中的向量运算。</li></ul></li></ol><h1 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5. 参考链接"></a>5. 参考链接</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/400007642">中断描述符表 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://blog.csdn.net/abc123lzf/article/details/109289567">(67条消息) x86保护模式——全局描述符表GDT详解_gdt全局描述符表_A__Plus的博客-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-1.概述</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h2><ul><li><p>开发环境：</p><ul><li><code>ubuntu20.04.5 WSL</code></li><li><code>sudo apt install nasm</code>: 安装汇编编译器 nasm</li><li><code>sudo apt install bochs-x</code>: 安装虚拟机 bochs</li><li><code>sudo apt-get install qemu-system</code> ：下载安装可以模拟全部硬件的qemu</li><li><code>sudo apt install gdb</code> ：安装gdb调试器</li><li><code>sudo apt-get install gcc-multilib</code>&amp;&amp;<code>sudo apt-get install g++-multilib</code>： 安装在64位的机器上产生32位的程序</li></ul></li><li><p>参考书籍:</p><ul><li>操作系统真相还原</li><li>30天自制操作系统</li><li>Orange’S:一个操作系统的实现</li></ul></li></ul><blockquote><p>源码地址：<a href="https://github.com/yanglianoo/Onix">yanglianoo&#x2F;Onix: 基于X86的操作系统，C语言 (github.com)</a></p></blockquote><h2 id="2-操作系统大纲"><a href="#2-操作系统大纲" class="headerlink" title="2.操作系统大纲"></a>2.操作系统大纲</h2><ul><li>系统引导<ul><li>自写bootloader</li><li>grub 引导</li></ul></li><li>硬件及驱动<ul><li>CPU : 32位X86架构</li><li>显示器：VGA</li><li>中断控制器：8259A</li><li>键盘</li><li>硬盘</li><li>时钟：内部时钟，外部时钟</li><li>网卡</li></ul></li><li>任务调度：内核进程，用户态线程</li><li>中断系统：外部中断、软中断、异常</li><li>内存管理</li><li>文件系统</li><li>系统调用</li><li>shell</li><li>网络</li></ul><h2 id="3-计算机组成概述"><a href="#3-计算机组成概述" class="headerlink" title="3.计算机组成概述"></a>3.计算机组成概述</h2><p>通常，计算机由以下几部分组成：</p><ul><li>负责计算和处理数据的 CPU</li><li>负责存储程序和数据的存储器</li><li>和外部进行数据交换的 I&#x2F;O（Input&#x2F;Output，输入输出装置）。</li></ul><p>各部分<code>通过总线连接</code>就构成了一台计算机</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.001-16862005447604.png" alt="img"></p><p>CPU在运行程序的逻辑如下：</p><ul><li><p><code>1.将磁盘上的程序加载到内存中</code></p></li><li><p><code>2.读取内存中的指令</code></p><p>首先，CPU 要把即将执行的指令从内存中读取出来。CPU 中有个 PC（Program Counter，程序计数器）寄存器，其中保存着即将执行的指令的地址。指令的读取是通过将 PC 寄存器的值输出给内存，由内存返回该值对应地址中的指令</p></li><li><p><code>3.对指令进行解码</code></p><p>然后，CPU 对读取的指令所对应的操作进行解码。指令有很多种，有进行各种运算的指令、控制下一条命令的指令、对内存和 I&#x2F;O 进行读写的指令，还有对 CPU 进行控制的指令。这些指令由 CPU 中被称为指令解码器的模块进行解码。可以用来保存地址和运算结果的寄存器称为通用寄存器（General Purpose Register）</p></li><li><p><code>4.执行指令</code></p><p>最后，CPU 对解码器确定的操作进行处理。CPU 可以从内部存储装置——寄存器或外部的内存读取数据并处理，然后将结果写回寄存器或内存。</p></li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.004.png" alt="img"></p><p>CPU 执行的指令，由代表操作种类的<code>操作码</code>和代表操作对象的<code>操作数</code>两部分组成。指令本身用特定的二进制序列来表示，这种二进制序列称为机器语言。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.005.png" alt="img"></p><blockquote><p>操作数：通常为寄存器地址、内存地址、立即数等</p><p>操作码：对应为cpu具体的操作，如加法、减法等</p></blockquote><p>根据执行的指令的特征，CPU 分为 <code>RISC</code>（Reduced Instruction Set Computer，精简指令集计算机）和 <code>CISC</code>（Complex Instruction Set Computer，复杂指令集计算机）两种</p><h3 id="3-1-内存和地址"><a href="#3-1-内存和地址" class="headerlink" title="3.1 内存和地址"></a>3.1 内存和地址</h3><p>所有能够存储数据的存储器都可称为内存，内存是用来存放运行时指令（程序）和数据的存储器。</p><p>我们一般说的电脑的内存条为DRAM，就是用来保存<code>程序运行</code>时的指令和数据。像固态硬盘、机械硬盘等存储介质也可用于存储指令和数据，但由于其访问速度实在是太慢，因此适用于计算机<code>长期保存数据和程序</code>的存储器。</p><p>内存使用地址的概念来管理存储的数据。地址表示的是数据存储的位置，如同数据的住所一样。每个数据单元都有一个地址。大多情况下数据单元是一个字节（8 位）长度。这种方式称为字节编址。不同架构的CPU有不同的编址方式。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.006.png" alt="img"></p><p>如上图，CPU可通过总线寻址找到内存空间每个数据单元，并从中取出每个数据单元存储的数据。</p><p>内存等存储器的特点是速度越快成本越高。因此通常使用“高速小容量”、“中速中等容量”到“低速大容量”等多种存储器组合的混合型架构。这种构造称为存储器层级。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.007.png" alt="img"></p><p>在存储层面，速度最快的是 CPU 中的寄存器。CPU 比内存速度快很多，由 CPU 直 接访问内存效率较低。为了提高内存访问速度，在 CPU 和内存间增加了被称为缓存的高速小容量存储器。</p><p>缓存可以暂时性地缓冲存储从内存中读取的数据。CPU 在访问内存时，如果需要的数据已经保存在缓存中，则可直接从缓存中读取，以提高访问效率。根据容量和速度的不同，缓存也分为多个层级，通常为一级缓存、二级缓存等多个级别。</p><h3 id="3-2-IO"><a href="#3-2-IO" class="headerlink" title="3.2 IO"></a>3.2 IO</h3><p>I&#x2F;O（Input&#x2F;Output）是进行数据输入输出的装置。计算机通过 I&#x2F;O 和外部实现数据交换。计算机的处理操作按照从外部读取数据、在内部处理数据、再向外部输出结果的顺序进行。以个人电脑为例，如下图所示，它从鼠标或键盘输入数据，处理器根据程序处理数据，通过显示器等向外部输出结果。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.009.png" alt="img"></p><p>访问 I&#x2F;O 的方式大致分为<code>存储器映射 I/O</code> 和<code>端口映射 I/O </code>两种。</p><ul><li><code>存储器映射 I/O</code> :存储器映射 I&#x2F;O 方式中，I&#x2F;O 也和内存一样使用地址进行管理，可以和访问内存一样的方式进行访问</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.010.png" alt="img"></p><ul><li><code>端口映射访问</code>:端口映射 I&#x2F;O 方式中，CPU 含有支持访问 I&#x2F;O 的专用指令。</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.011.png" alt="img"></p><h3 id="3-3-字节序"><a href="#3-3-字节序" class="headerlink" title="3.3 字节序"></a>3.3 字节序</h3><p>将多字节数据存储在内存中时，各字节的存储顺序称为字节序。比如，将 4 字节数据 0x12345678 放入内存时，地址 0 中放 0x12、地址 1 中放 0x34、地址 2 中放 0x56、地址 3 中放 0x78 的方式，称为大端序。相对地，地址 0 中放 0x78、地址 1 中放 0x56、地址 2 中放 0x34、地址 3 中放 0x12 的方式，称为小端序。不同CPU采用的字节序不尽相同</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.008.png" alt="img"></p><h3 id="3-4-总线"><a href="#3-4-总线" class="headerlink" title="3.4 总线"></a>3.4 总线</h3><p>总线是 CPU、内存和 I&#x2F;O 之间交换数据的共同通道。总线将一根信号线在多个模块间共享进行通信。</p><p>总线包括<code>地址总线、数据总线、控制总线、IO总线</code>，顾名思义数据线是用于数据读取、地址总线用于地址寻址、控制总线用于控制cpu行为。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.012.png" alt="img"></p><p>当计算机中的各个组件之间需要进行数据传输和控制信号传递时，总线起到了关键的作用。下面是对四种主要总线的简要介绍：</p><ol><li>地址总线（Address Bus）：<ul><li>作用：地址总线用于传输CPU或其他设备发出的内存或外设的地址信息。</li><li>功能：它决定了CPU或其他设备要访问的内存单元或外设的位置。地址总线的宽度决定了系统能够寻址的内存空间大小。例如，32位地址总线可以寻址的内存空间大小为2^32个字节（4GB）。</li></ul></li><li>数据总线（Data Bus）：<ul><li>作用：数据总线用于传输CPU或其他设备之间的数据。</li><li>功能：数据总线承载着实际的数据传输，包括指令、操作数、计算结果等。数据总线的宽度决定了一次可以传输的数据位数，例如，32位数据总线可以一次传输32位（4字节）的数据。</li></ul></li><li>控制总线（Control Bus）：<ul><li>作用：控制总线用于传输各种控制信号，包括指令控制、时序控制和状态信号等。</li><li>功能：控制总线通过不同的信号线传递各种控制信号，例如，读取（Read）和写入（Write）信号用于指示数据传输的方向，时钟信号用于同步操作，中断信号用于通知CPU有外部事件需要处理等。</li></ul></li><li>I&#x2F;O总线（I&#x2F;O Bus）：<ul><li>作用：I&#x2F;O总线用于连接CPU和外部设备之间进行输入输出操作。</li><li>功能：I&#x2F;O总线是一种专门用于输入输出的总线，它提供了一种通信通道，使得CPU能够与外部设备进行数据交换。通过I&#x2F;O总线，CPU可以发送读取（IN）和写入（OUT）指令来控制外部设备的数据读取和写入。</li></ul></li></ol><p>这四种总线相互配合，构成了计算机系统中各个组件之间的连接和通信桥梁。它们共同工作，使得CPU能够与内存和外设进行数据传输、控制信号传递和输入输出操作，实现计算机的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写STL之Vector</title>
      <link href="/2023/06/07/%E6%89%8B%E5%86%99STL-Vector/"/>
      <url>/2023/06/07/%E6%89%8B%E5%86%99STL-Vector/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码仓库：<a href="https://github.com/yanglianoo/My_STL/tree/timer">yanglianoo&#x2F;My_STL at timer (github.com)</a></p></blockquote><h2 id="1-Vector-概述"><a href="#1-Vector-概述" class="headerlink" title="1.Vector 概述"></a>1.Vector 概述</h2><p>在C++ STL（标准模板库）中，<code>vector</code> 是一个动态数组容器，它是一个模板类具有以下特性：</p><ol><li><strong>动态大小</strong>: <code>vector</code> 的大小可以根据需要动态增长或缩小。它可以自动调整内部存储空间，以适应容器中元素的数量。</li><li><strong>连续存储</strong>: <code>vector</code> 中的元素在内存中是连续存储的，这使得对元素的随机访问变得高效。</li><li><strong>快速插入和删除</strong>: 在 <code>vector</code> 的末尾插入或删除元素是高效的，时间复杂度为常数。但在中间或开头插入或删除元素的操作可能会导致元素的移动，时间复杂度为线性。</li><li><strong>随机访问</strong>: <code>vector</code> 支持通过索引进行随机访问。可以使用下标运算符 <code>[]</code> 或 <code>at()</code> 函数来访问特定位置的元素。</li><li><strong>动态调整内存</strong>: 当 <code>vector</code> 的大小超过当前分配的内存空间时，它会重新分配更大的内存块，并将现有元素移动到新的内存中。这可以确保容器始终具有足够的内存来存储元素。</li><li><strong>元素访问</strong>: 可以使用迭代器来遍历 <code>vector</code> 中的元素。可以使用 <code>begin()</code> 和 <code>end()</code> 成员函数获取指向容器开头和结尾的迭代器。</li><li><strong>容器操作</strong>: <code>vector</code> 支持许多常见的容器操作，如排序、查找、插入和删除元素。它还提供了与其他容器兼容的接口，例如迭代器、范围构造函数和算法函数。</li></ol><p><code>STL</code>库中<code>vector</code>的定义如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Allocator</span> = std::allocator&lt;T&gt;&gt; </span><br><span class="line">    <span class="keyword">class</span> vector;</span><br></pre></td></tr></table></figure><table><thead><tr><th>T</th><th>元素的类型。<code>T</code> 必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>Allocator</th><th>用于获取&#x2F;释放内存及构造&#x2F;析构内存中元素的分配器。类型必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/Allocator"><em>分配器</em> <em>(Allocator)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>成员函数</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/vector">(构造函数)</a></td><td>构造 <code>vector</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/~vector">(析构函数)</a></td><td>析构 <code>vector</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/operator%3D">operator&#x3D;</a></td><td>赋值给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/assign">assign</a></td><td>将值赋给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/get_allocator">get_allocator</a></td><td>返回相关的分配器 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/at">at</a></td><td>访问指定的元素，同时进行越界检查 (公开成员函数)</td></tr><tr><td>operator[]</td><td>访问指定的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/data">data</a></td><td>直接访问底层数组 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/reserve">reserve</a></td><td>预留存储空间 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/capacity">capacity</a></td><td>返回当前存储空间能够容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/shrink_to_fit">shrink_to_fit</a></td><td>通过释放未使用的内存减少内存的使用 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/swap">swap</a></td><td>交换内容</td></tr></tbody></table><blockquote><p>参考链接: <a href="https://zh.cppreference.com/w/cpp/container/vector">std::vector - cppreference.com</a></p></blockquote><h2 id="2-构造Vector"><a href="#2-构造Vector" class="headerlink" title="2.构造Vector"></a>2.构造Vector</h2><p>自己手写<code>vector</code>时，迭代器不是通用的<code>Allocator</code>类型，需要在<code>vector</code>内部实现一个自定义的迭代器</p><p>vector模板类定义如下，需要维护三个私有的成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;    <span class="comment">//实际数组大小</span></span><br><span class="line">    <span class="type">int</span> _capacity;<span class="comment">//最大容量</span></span><br><span class="line">    T* _elem;     <span class="comment">//数据区指针  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：模板类的实现和声明不能分离编译，因此最好将模板类的声明和实现都放在头文件中<br>参考链接：<a href="https://blog.csdn.net/u011201045/article/details/38679417">(64条消息) C++中模板类的编译过程_c++模板编译_jiazhucai的博客-CSDN博客</a></p></blockquote><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>构造函数定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>();   <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(std::initiallizer_list&lt;T&gt; init) <span class="comment">// c++11 列表初始化</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other); <span class="comment">//用另外一个vector来构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other,<span class="type">int</span> left,<span class="type">int</span> right); <span class="comment">//用另外一个vector区间构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">size_t</span> count, T&amp; value); <span class="comment">//初始化为count个 value</span></span><br></pre></td></tr></table></figure><h4 id="2-1-1-辅助函数"><a href="#2-1-1-辅助函数" class="headerlink" title="2.1.1 辅助函数"></a>2.1.1 辅助函数</h4><p>在定义构造函数具体实现时需要定义几个辅助函数:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span>; <span class="comment">//空间不足时扩容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink</span><span class="params">()</span></span>; <span class="comment">//装填因子过小时压缩</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyFrom</span> <span class="params">( T <span class="type">const</span>* A, <span class="type">int</span> left, <span class="type">int</span> right )</span></span>; <span class="comment">//复制数组区间 A[left, right]</span></span><br></pre></td></tr></table></figure><ul><li>内存扩充函数<code>expand()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_CAPACITY 3 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">expand</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_size &lt;= _capacity) <span class="keyword">return</span>;  <span class="comment">//当size 小于等于 capacity 时 不需要扩容</span></span><br><span class="line">    <span class="keyword">if</span>(_capacity &lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY; <span class="comment">//当capacity小于最小大小，更改capacity为最小大小</span></span><br><span class="line">    <span class="comment">/* 反复翻倍，直到 _capacity &gt; _size*/</span></span><br><span class="line">    <span class="keyword">while</span> (_capacity &lt; _size)</span><br><span class="line">    &#123;</span><br><span class="line">        _capacity *=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T* old_data = _data;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity &lt;&lt; <span class="number">1</span>];  <span class="comment">//capacity 增大一倍，重新 new 内存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;_size; i++)       <span class="comment">//赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = old_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] old_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内存缩小函数<code>shrink()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">shrink</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capacity &lt; DEFAULT_CAPACITY &lt;&lt; <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//不致收缩倒DEFAULT_CAPACITY以下</span></span><br><span class="line">    <span class="keyword">if</span>(_size &lt;&lt; <span class="number">2</span> &gt; _capacity) <span class="keyword">return</span>;  <span class="comment">//以 25% 为边界</span></span><br><span class="line"></span><br><span class="line">    T* old_data = _data;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = old_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] old_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>区间复制函数<code>copyFrom ( T const* A, int left, int right )</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">copyFrom</span> ( T <span class="type">const</span>* A, <span class="type">int</span> left, <span class="type">int</span> right )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _capacity = (right - left) * <span class="number">2</span>;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[_size] = A[left];</span><br><span class="line">        _size++;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-构造函数实现"><a href="#2-2-2-构造函数实现" class="headerlink" title="2.2.2 构造函数实现"></a>2.2.2 构造函数实现</h4><ul><li><code>vector()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*构造函数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>():_data(<span class="literal">nullptr</span>),_capacity(<span class="number">0</span>),_size(<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(const vector&lt;T&gt;&amp; *other*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">copyFrom</span>(other._data,<span class="number">0</span>,other._size); <span class="comment">//直接调用 copyFrom 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(std::initializer_list&lt;T&gt; *init*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* c++11 列表初始化 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(std::initializer_list&lt;T&gt; init)</span><br><span class="line">&#123;</span><br><span class="line">    _size = init.<span class="built_in">size</span>();</span><br><span class="line">    _capacity = _size * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; elem : init)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(int *count*, T&amp; *value*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(<span class="type">size_t</span> count, T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    _size = count;</span><br><span class="line">    _capacity = <span class="number">2</span> * _size;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i =<span class="number">0</span>; i&lt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-析构函数"><a href="#2-2-析构函数" class="headerlink" title="2.2 析构函数"></a>2.2 析构函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::~<span class="built_in">vector</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-赋值"><a href="#3-赋值" class="headerlink" title="3.赋值"></a>3.赋值</h2><p>实现的成员函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//成员函数</span></span><br><span class="line">    vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector&amp; other);</span><br><span class="line">    vector&amp; <span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">size_t</span> count,<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>vector&amp; operator=(const vector&amp; other)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;&amp; vector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> vector&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">copyFrom</span>(other._data,<span class="number">0</span>,other._size);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector&lt;T&gt;::operator=( std::initializer_list&lt;T&gt; *ilist* )</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;&amp; vector&lt;T&gt;::<span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = ilist.<span class="built_in">size</span>();</span><br><span class="line">    _capacity = _size * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; elem : ilist)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-元素访问"><a href="#4-元素访问" class="headerlink" title="4.元素访问"></a>4.元素访问</h2><p>元素访问的接口有如下这些：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//元素访问</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);</span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">data</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;<span class="number">0</span> || index &gt;= _size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data[_size<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* vector&lt;T&gt;::<span class="built_in">data</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h2><h3 id="5-1-迭代器使用实例"><a href="#5-1-迭代器使用实例" class="headerlink" title="5.1 迭代器使用实例"></a>5.1 迭代器使用实例</h3><p>在构建迭代器之前，先看看迭代器的用法，一般用于遍历容器中的各个元素</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 1. 使用迭代器进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1. Iterate using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 使用auto关键字进行简化</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2. Iterate using auto keyword: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 使用范围基于循环 (range-based loop)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3. Iterate using range-based loop: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 修改容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4. Modify elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        *it = *it * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 插入元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5. Insert elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> insertPos = vec.<span class="built_in">begin</span>() + <span class="number">2</span>; <span class="comment">// 在索引2的位置之后插入元素</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(insertPos, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 删除元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;6. Erase elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> erasePos = vec.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 删除索引1的元素</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(erasePos);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-迭代器类实现"><a href="#5-2-迭代器类实现" class="headerlink" title="5.2 迭代器类实现"></a>5.2 迭代器类实现</h3><p><code>iterrator</code>是一个类，在内部维护了一个指针，需要对其进行各种操作符重载，<code>iterrator</code>的具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterrator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            T * m_pointer;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Iterrator</span>():<span class="built_in">m_pointer</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">            <span class="built_in">Iterrator</span>(T * pointer) : <span class="built_in">m_pointer</span>(pointer) &#123;&#125;</span><br><span class="line">            ~<span class="built_in">Iterrator</span>() &#123;&#125;</span><br><span class="line">        <span class="comment">/* 判断两个迭代器是否相等 */</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Iterrator &amp; other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer == other.m_pointer;   </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* 迭代器赋值 */</span></span><br><span class="line">        Iterrator <span class="keyword">operator</span> = (<span class="type">const</span> Iterrator&amp; other)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer = other.m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 前缀递增*/</span></span><br><span class="line">        Iterrator &amp; <span class="keyword">operator</span> ++ ()</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer +=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 后缀递增 */</span></span><br><span class="line">        Iterrator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            ++(*<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> + (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            it.m_pointer += i;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterrator <span class="keyword">operator</span> += (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer += i;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> -= (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer -= i;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> - (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            it.m_pointer -= i;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="keyword">operator</span> - (<span class="type">const</span> Iterrator&amp; other) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer - other.m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T &amp; <span class="keyword">operator</span> * ()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T * <span class="keyword">operator</span> -&gt; ()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>记录：在对<code>Iterrator</code>前++和后++重载时，如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前缀递增*/</span></span><br><span class="line">Iterrator &amp; <span class="keyword">operator</span> ++ ()</span><br><span class="line">&#123;</span><br><span class="line">m_pointer +=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/* 后缀递增 */</span></span><br><span class="line">Iterrator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">     Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">     ++(*<span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中，后缀递增操作符(it++)可以通过接受一个额外的int参数进行区分，这是由C++语言规范所定义的。根据规范，后缀递增操作符的函数参数列表中必须有一个int类型的参数，尽管在函数体内并没有使用该参数。</p><p>这种设计是为了在语法上能够区分前缀递增和后缀递增操作。当编译器遇到<code>it++</code>表达式时，它会根据后缀递增操作符的函数参数列表中是否存在一个额外的int参数来决定使用后缀递增操作符的重载函数。</p><p>编译器会将后缀递增操作符的调用转换为对重载的后缀递增操作符函数的调用，并传递一个编译器生成的临时整数参数（通常是0）。</p><p>请注意，这个整数参数的名称在函数体内并没有使用，因为它的存在只是为了与前缀递增操作符进行区分，而不是为了实际使用。</p></blockquote><h3 id="5-3-迭代器操作函数实现"><a href="#5-3-迭代器操作函数实现" class="headerlink" title="5.3 迭代器操作函数实现"></a>5.3 迭代器操作函数实现</h3><p><code>begin</code>用于获取头指针，<code>end</code>用于获取尾指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//迭代器操作函数</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">begin</span>()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(_data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">end</span>()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(_data + _size)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要使用<code>typename</code>显示的告诉编译器<code>vector&lt;T&gt;::Iterator</code>是一个类型</p><h2 id="6-容量"><a href="#6-容量" class="headerlink" title="6.容量"></a>6.容量</h2><p>和容量相关的接口函数比较简单，实现的接口如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//容量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//判断容器是否为空</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//获取容器元素个数</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//获取容器最大存储个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> new_cap)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> vector&lt;T&gt;::<span class="built_in">empty</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _size==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">max_size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">capacity</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 重置容器大小 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">reserve</span>(<span class="type">size_t</span> new_cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capacity &gt;= new_cap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _size += new_cap;</span><br><span class="line">        <span class="built_in">expand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果 _capacity 过大则缩减*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">shrink_to_fit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shrink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-修改器"><a href="#7-修改器" class="headerlink" title="7.修改器"></a>7.修改器</h2><p>和修改容器有关的接口函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//修改器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> Iterator it ,<span class="type">const</span> T &amp; value)</span></span>;  </span><br><span class="line">    <span class="function">Iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> Iterator it ,<span class="type">int</span> n,<span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">erase</span><span class="params">(<span class="type">const</span> Iterator it)</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">erase</span><span class="params">(<span class="type">const</span> Iterator first,<span class="type">const</span> Iterator last)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector &amp; other)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>clear()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* clear操作，直接将 _size 清零*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator insert(const Iterator it ,int n,const T &amp; value)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在 it 的位置插入 n 个 T 元素*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Iterator it ,<span class="type">int</span> n,<span class="type">const</span> T &amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = it - <span class="built_in">begin</span>();</span><br><span class="line">    _size += n;</span><br><span class="line">    <span class="comment">//如果有需要，则扩容</span></span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=_size; i&gt;size;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i+n<span class="number">-1</span>] = _data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[size+i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;T&gt;::<span class="built_in">Iterator</span>(_data + size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator insert(const Iterator it ,const T &amp; value) </code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在 it 位置插入 1 个元素 value*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Iterator it ,<span class="type">const</span> T &amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    _size+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">    <span class="built_in">insert</span>(it,<span class="number">1</span>,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator erase(const Iterator it)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除 it 位置的元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Iterator it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">end</span>() - it == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _size -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = it - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = count; i &lt; _size <span class="number">-1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = _data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    _size -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator erase(const Iterator first,const Iterator last)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 区间删除 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Iterator first,<span class="type">const</span> Iterator last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( first == last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> first;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> f = first - <span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> l = last - <span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> ( l &lt; _size) <span class="comment">// [last,_szie) 顺次前移 l - f 个单元</span></span><br><span class="line">        &#123;</span><br><span class="line">            _data[f++] = _data[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        _size = f;  <span class="comment">//更新规模</span></span><br><span class="line">        <span class="built_in">shrink</span>(); <span class="comment">//若有必要则缩容</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void push_back(const T &amp; value)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在尾部插入一个元素value */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size &lt; _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[_size] = value; </span><br><span class="line">        _size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _size++;</span><br><span class="line">        <span class="built_in">expand</span>();</span><br><span class="line">        <span class="type">int</span> index = _size - <span class="number">1</span>;</span><br><span class="line">        _data[index] = value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void pop_back()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 弹出最后一个元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void resize(size_t size)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">resize</span>(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size &gt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        _size = size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i= _size; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _data[i] = <span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _size = size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = size;</span><br><span class="line">    <span class="built_in">expand</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void swap(vector &amp; other)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 两个 vector 交换*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">swap</span>(vector &amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    T * data = other._data;</span><br><span class="line">    <span class="type">int</span> size = other._size;</span><br><span class="line">    <span class="type">int</span> capacity = other._capacity;</span><br><span class="line"></span><br><span class="line">    other._data = _data;</span><br><span class="line">    other._size = _size;</span><br><span class="line">    other._capacity = _capacity;</span><br><span class="line"></span><br><span class="line">    _data = data;</span><br><span class="line">    _size = size;</span><br><span class="line">    _capacity = capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>至此，<code>vector</code> 构造完毕，未进行测试，不知道是否有<code>bug</code></p>]]></content>
      
      
      <categories>
          
          <category> 手写STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
