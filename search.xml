<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开启调试功能</title>
      <link href="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="1-bug修改"><a href="#1-bug修改" class="headerlink" title="1. bug修改"></a>1. bug修改</h1><p> 之前的代码中留下了一个<code>bug</code>，在<code>app.c</code>中，通过<code>sys_gettime</code>的系统调用来获取时间，这里是有问题的，从内核返回的值不知道为啥不对，问题出在<code>syscall</code>函数上，以前的写法是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">uintptr_t</span> arg1, <span class="type">uintptr_t</span> arg2, <span class="type">uintptr_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// Move syscall id to a0 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// Move args[0] to a1 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// Move args[1] to a2 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// Move args[2] to a3 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// Perform syscall</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// Move return value to &#x27;ret&#x27; variable</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道为啥这样写就有问题，好像这个<code>ret</code>定义了就会导致返回的值不对，从内核返回的值是放在<code>a0</code>寄存器中，把上面的代码替换了一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a0 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a0&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg1);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a1 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a1&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg2);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a2 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a2&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg3);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uintptr_t</span> a7 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a7&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ecall&quot;</span></span></span><br><span class="line"><span class="params">      : <span class="string">&quot;+r&quot;</span> (a0)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;r&quot;</span> (a1), <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a7)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样内核的返回值就没问题了，来测试一下<code>sys_gettime()</code>系统调用，在<code>task3</code>中调用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task3 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> current_timer = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> wait_for = current_timer + <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       current_timer = sys_gettime();</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;current_timer:%d\n&quot;</span>,current_timer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/GIFtime.gif" alt="GIFtime"></p><p>时间打印成功，由于定时中断的分频系数被修改成了500，所以这里是以2us为单位返回时间。</p><h1 id="2-开启调试功能"><a href="#2-开启调试功能" class="headerlink" title="2.开启调试功能"></a>2.开启调试功能</h1><p>之前在调试内核的时候，我一直没使用gdb去调试程序，因为代码不算困难，我用printf去打印调试也花费不了太多时间，最近在倒腾mmu，我觉得有必要用gdb去调试了，再vscode中调试是非常方便的，当然也可以直接在终端中调试。</p><h2 id="2-1-终端使用GDB调试"><a href="#2-1-终端使用GDB调试" class="headerlink" title="2.1 终端使用GDB调试"></a>2.1 终端使用GDB调试</h2><p>在os的makefile中添加调试选项：</p><ul><li>编译时需要生成调试信息，添加 <code>-g</code>的编译选项</li></ul><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = -nostdlib -fno-builtin -mcmodel=medany -g</span><br></pre></td></tr></table></figure><ul><li>指定调试器，这里的调试器需要使用riscv编译工具链中提供的<code>riscv64-unknown-elf-gdb</code>，当然还有一个<code>gdb-multiarch</code>也是可以的，但是联合vscode时不知道为啥不能检测寄存器的值</li></ul><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">GDB = riscv64-unknown-elf-gdb</span><br></pre></td></tr></table></figure><ul><li>配置调试选项，新建一个<code>gdbinit</code>文件，<code>gdb</code>调试qemu程序时，需要将端口映射到<code>1234</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> disassemble-next-line on</span><br><span class="line">b _start</span><br><span class="line">target remote : <span class="number">1234</span></span><br><span class="line">c</span><br></pre></td></tr></table></figure><ul><li>修改<code>run.sh</code>，添加如下选项就可启动调试了，此时<code>qemu</code>会作为<code>gdb</code>的服务端，端口号为<code>1234</code></li></ul><p><img src="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/image-20230904195304055.png" alt="image-20230904195304055"></p><ul><li>开启调试，这样make clean时不会删除<code>os.elf</code>文件，在启动qemu后就可通过<code>make debug</code>来开启调试了</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.PHONY : debug</span><br><span class="line">debug: </span><br><span class="line">@echo <span class="string">&quot;os debug start...&quot;</span></span><br><span class="line">@$&#123;GDB&#125; os.elf -q -x ./gdbinit</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean:</span><br><span class="line">rm -rf *.o *.bin </span><br></pre></td></tr></table></figure><p><img src="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/image-20230904195427526.png" alt="image-20230904195427526"></p><p>这样就可以在终端中调试了。</p><h2 id="2-2-GDB-Vscode调试"><a href="#2-2-GDB-Vscode调试" class="headerlink" title="2.2 GDB+Vscode调试"></a>2.2 GDB+Vscode调试</h2><p>新建<code>.vscode</code>文件夹，在此文件夹中新建两个文件</p><p><img src="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/image-20230904195603498.png" alt="image-20230904195603498"></p><ul><li><code>launch.json</code>，需要将调试器指定为<code>riscv64-unknown-elf-gdb</code>，需要指定为你自己电脑上的编译工具链的gdb的位置，然后调试的<code>program</code>指定为：<code>os.elf</code></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;timeros - Build and debug kernel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/os/os.elf&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/os/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build  timeros&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/timer/riscv/riscv64-elf/bin/riscv64-unknown-elf-gdb&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>task.json</code>就是用来运行<code>build.sh</code></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build  timeros&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build.sh &quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Task generated by Debugger.&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>launch.json</code>设置官方文档：<a href="https://code.visualstudio.com/docs/cpp/launch-json-reference">Configure launch.json for C&#x2F;C++ debugging in Visual Studio Code</a></p><p><code>tasks.json</code>设置官方文档：<a href="https://code.visualstudio.com/Docs/editor/tasks">Tasks in Visual Studio Code</a></p><blockquote><p><code>launch.json</code>文件是VSCode<strong>启动程序</strong>的配置文件，<code>task.json</code>就是用于定义前置任务。若在<code>launch.json</code>中指定了<code>preLaunchTask</code>参数，则会去执行<code>task.json</code>中指定的命令。</p><ul><li><code>$&#123;workspaceFolder&#125;</code>：项目文件夹在 VS Code 中打开的路径</li><li><code>$&#123;file&#125;</code>：当前开打开（激活）的文件</li><li><code>$&#123;relativeFile&#125;</code>：相对于 <code>&#123;workspaceFolder&#125;</code> 的文件路径</li><li><code>$&#123;fileBasename&#125;</code>：当前打开文件的名称</li><li><code>$&#123;fileBasenameNoExtension&#125;</code>：当前打开文件的名称，不带扩展名的</li><li><code>$&#123;fileExtname&#125;</code>：当前打开文件的扩展名</li><li><code>$&#123;fileDirname&#125;</code>：当前打开文件的文件夹名称</li></ul></blockquote><p><img src="/2023/09/04/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/image-20230904200407996.png" alt="image-20230904200407996"></p><p>这样就可以在<code>vscode</code>中调试内核了</p>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现timeros的内存映射机制</title>
      <link href="/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-页表操作"><a href="#1-页表操作" class="headerlink" title="1. 页表操作"></a>1. 页表操作</h1><h2 id="1-1-页表项定义"><a href="#1-1-页表项定义" class="headerlink" title="1.1 页表项定义"></a>1.1 页表项定义</h2><p>在上一篇博客中：<a href="https://yanglianoo.github.io/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">用户态printf以及物理内存管理 | TimerのBlog (yanglianoo.github.io)</a>已经展示了页表项的组成：</p><p><img src="/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/image-20230831125451059.png" alt="image-20230831125451059"></p><p><strong>页表项</strong> (PTE, Page Table Entry)是一个<code>64bit</code>的数据，其中低10位存储的是下级物理页的属性的标志位；<code>10~54</code>这44位存储的是下级页表的物理页号。</p><p>具体定义如下：在address.h中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义页表项 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> bits;</span><br><span class="line">&#125;PageTableEntry;</span><br></pre></td></tr></table></figure><p>然后定义标志位：定义在address.h中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义位掩码常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1 &lt;&lt; 0)   <span class="comment">//有效位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1 &lt;&lt; 1)   <span class="comment">//可读属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1 &lt;&lt; 2)   <span class="comment">//可写属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1 &lt;&lt; 3)   <span class="comment">//可执行属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1 &lt;&lt; 4)   <span class="comment">//用户访问模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_G (1 &lt;&lt; 5)   <span class="comment">//全局映射</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1 &lt;&lt; 6)   <span class="comment">//访问标志位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_D (1 &lt;&lt; 7)   <span class="comment">//脏位</span></span></span><br></pre></td></tr></table></figure><p>然后定义一些操作<code>PTE</code>的函数：在address.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 新建一个页表项 */</span></span><br><span class="line">PageTableEntry <span class="title function_">PageTableEntry_new</span><span class="params">(PhysPageNum ppn, <span class="type">uint8_t</span> PTEFlags)</span> &#123;</span><br><span class="line">    PageTableEntry entry;</span><br><span class="line">    entry.bits = (ppn.value &lt;&lt; <span class="number">10</span>) | PTEFlags;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断页表项是否为空 */</span></span><br><span class="line">PageTableEntry <span class="title function_">PageTableEntry_empty</span><span class="params">()</span> &#123;</span><br><span class="line">    PageTableEntry entry;</span><br><span class="line">    entry.bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取下级页表的物理页号 */</span></span><br><span class="line">PhysPageNum <span class="title function_">PageTableEntry_ppn</span><span class="params">(PageTableEntry *entry)</span> &#123;</span><br><span class="line">    PhysPageNum ppn;</span><br><span class="line">    ppn.value = (entry-&gt;bits &gt;&gt; <span class="number">10</span>) &amp; ((<span class="number">1ul</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ppn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取页表项的标志位 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">PageTableEntry_flags</span><span class="params">(PageTableEntry *entry)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> entry-&gt;bits &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断页表项是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PageTableEntry_is_valid</span><span class="params">(PageTableEntry *entry)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> entryFlags = PageTableEntry_flags(entry);</span><br><span class="line">    <span class="keyword">return</span> (entryFlags &amp; PTE_V) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-构造物理页帧的访问方法"><a href="#1-2-构造物理页帧的访问方法" class="headerlink" title="1.2 构造物理页帧的访问方法"></a>1.2 构造物理页帧的访问方法</h2><p>假设我现在已经根据PTE拿到了物理页号，我要去访问此物理页号对应的物理帧的内存数据，因此需要定义了两个个辅助函数：</p><ul><li>首先是以一个字节作为单位访问数据，拿到物理页号之后转换为对应的物理地址，得到的物理地址是此物理帧的开头，将其转换为一个<code>uint8_t*</code>类型的指针，这样根据此指针就可操作这一页的4096个字节了</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span>* <span class="title function_">get_bytes_array</span><span class="params">(PhysPageNum ppn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先从物理页号转换为物理地址</span></span><br><span class="line">    PhysAddr addr = phys_addr_from_phys_page_num(ppn);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>*) addr.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后假设物理页帧中存储的是一个个PTE，我现在需要去访问这一个个PTE。同样需要先拿到物理页号之后转换为对应的物理地址，然后将其转换为<code>PageTableEntry*</code>的指针就可以了</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PageTableEntry* <span class="title function_">get_pte_array</span><span class="params">(PhysPageNum ppn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先从物理页号转换为物理地址</span></span><br><span class="line">    PhysAddr addr = phys_addr_from_phys_page_num(ppn);</span><br><span class="line">    <span class="keyword">return</span> (PageTableEntry*) addr.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-虚实地址映射"><a href="#2-虚实地址映射" class="headerlink" title="2.虚实地址映射"></a>2.虚实地址映射</h1><h2 id="2-1-rCore的内存映射实现"><a href="#2-1-rCore的内存映射实现" class="headerlink" title="2.1 rCore的内存映射实现"></a>2.1 rCore的内存映射实现</h2><p><img src="/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/sv39-full.png" alt="../_images/sv39-full.png"></p><p>MMU在寻址时的流程如上图，先要拿到<code>Virtual address</code>的三级页号索引，定义如下的辅助函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 拿到虚拟页号的三级索引，按照从高到低的顺序返回 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">indexes</span><span class="params">(VirtPageNum vpn, <span class="type">size_t</span>* result)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> idx[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        idx[i] = vpn.value &amp; <span class="number">0x1ff</span>;   <span class="comment">// 1_1111_1111 = 0x1ff</span></span><br><span class="line">        vpn.value &gt;&gt;= <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        result[i] = idx[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要根据拿到的虚拟地址的三级页号索引来查找页表项，当然在最开始的时候多级页表的页表项里是没有数据的，这就需要我们去进行填充。</p><p>在这之前需要定义一个管理页表的结构体：每个应用的地址空间都对应一个不同的多级页表，这也就意味这不同页表的起始地址（即页表根节点的地址）是不一样的。因此 <code>PageTable</code> 要保存它根节点的物理页号 <code>root_ppn</code> 作为页表唯一的区分标志。此外，向量 <code>frames</code>保存了页表所有的节点（包括根节点）所在的物理页帧。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义页表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PhysPageNum root_ppn; <span class="comment">//根节点</span></span><br><span class="line">    Stack frames;         <span class="comment">//页帧</span></span><br><span class="line">&#125;PageTable;</span><br></pre></td></tr></table></figure><p>然后在来看查找页表项，填充页表项的操作：传入一个<code>PageTable</code>，根据此页表的根节点开始遍历，根节点的物理页号是保存在<code>satp</code>寄存器中的，从页表中根据虚拟地址的页表项索引来取出具体的页表项，如果此页表项为空，则分配一页内存，然后新建一个页表项进行填充。直到三级页表索引完毕，会返回虚拟地址最终对应的三级页表的页表项，此时三级页表的页表项是空的，在进行map时只需要对此页表项赋值就行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PageTableEntry* <span class="title function_">find_pte_create</span><span class="params">(PageTable* pt,VirtPageNum vpn)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到虚拟页号的三级索引，保存到idx数组中</span></span><br><span class="line">    <span class="type">size_t</span>* idx;</span><br><span class="line">    indexes(vpn, idx); </span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    PhysPageNum ppn = pt-&gt;root_ppn;</span><br><span class="line">    <span class="comment">//从根节点开始遍历，如果没有pte，就分配一页内存，然后创建一个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到具体的页表项</span></span><br><span class="line">        PageTableEntry* pte =  &amp;get_pte_array(ppn)[idx[i]];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> pte;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果此项页表为空</span></span><br><span class="line">            <span class="keyword">if</span> (!PageTableEntry_is_valid(pte)) &#123;</span><br><span class="line">                <span class="comment">//分配一页物理内存</span></span><br><span class="line">                PhysPageNum frame =  StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">               <span class="comment">//新建一个页表项</span></span><br><span class="line">               *pte =  PageTableEntry_new(frame,PTE_V);</span><br><span class="line">               <span class="comment">//压入栈中</span></span><br><span class="line">                push(&amp;pt-&gt;frames,frame.value);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//取出进入下级页表的物理页号</span></span><br><span class="line">        ppn = PageTableEntry_ppn(pte);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PageTableEntry* <span class="title function_">find_pte</span><span class="params">(PageTable* pt, VirtPageNum vpn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拿到虚拟页号的三级索引，保存到idx数组中</span></span><br><span class="line">    <span class="type">size_t</span>* idx;</span><br><span class="line">    indexes(vpn, idx); </span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    PhysPageNum ppn = pt-&gt;root_ppn;</span><br><span class="line">    <span class="comment">//从根节点开始遍历，如果没有pte，就分配一页内存，然后创建一个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到具体的页表项</span></span><br><span class="line">        PageTableEntry* pte =  &amp;get_pte_array(ppn)[idx[i]];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> pte;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果此项页表为空</span></span><br><span class="line">            <span class="keyword">if</span> (!PageTableEntry_is_valid(pte)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//取出进入下级页表的物理页号</span></span><br><span class="line">        ppn = PageTableEntry_ppn(pte);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>find_pte_create</code> 和<code>find_pte</code>基本一样，区别在于<code>find_pte</code>只会去查找页表项不会去创建。</p><p>有了上面这个函数，我们就可以建立虚实隐射关系了：只需要将你需要映射的物理页号与虚拟地址索引的三级页表中的页表项对应起来即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PageTable_map</span><span class="params">(PageTable* pt,VirtPageNum vpn, PhysPageNum ppn, <span class="type">uint8_t</span> pteflgs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PageTableEntry* pte = find_pte_create(pt,vpn);</span><br><span class="line">    assert(!PageTableEntry_is_valid(pte));</span><br><span class="line">    *pte = PageTableEntry_new(ppn,PTE_V | pteflgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后还需一个解除映射的函数：先查找页表项，如果找到了就将其设为空就行了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PageTable_unmap</span><span class="params">(PageTable* pt, VirtPageNum vpn)</span></span><br><span class="line">&#123;</span><br><span class="line">    PageTableEntry* pte = find_pte(pt,vpn);</span><br><span class="line">    assert(!PageTableEntry_is_valid(pte));</span><br><span class="line">    *pte = PageTableEntry_empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按逻辑上来说这里如果解除映射之后，应该需要释放掉对应的页内存才对</p></blockquote><p>上面用到了一个<code>assert</code>函数，这是断言的宏，具体的实现如下，新增了一个<code>assert.c</code>和<code>assert.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TOS_ASSERT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOS_ASSERT_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assertion_failure</span><span class="params">(<span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">char</span> *file, <span class="type">char</span> *base, <span class="type">int</span> line)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">__FILE__是一个预定义的宏，在C语言中表示当前源文件的文件名。</span></span><br><span class="line"><span class="comment">在预处理阶段，编译器会将所有的__FILE__宏替换为当前源文件的文件名字符串。</span></span><br><span class="line"><span class="comment">__BASE_FILE__是一个预定义的宏，在某些编译器中用于表示当前编译单元的顶层源文件的文件名，</span></span><br><span class="line"><span class="comment">即当前源文件所属的工程或者库的主文件名。</span></span><br><span class="line"><span class="comment">__LINE__是一个预定义的宏，在C语言中表示当前代码所在的行号。</span></span><br><span class="line"><span class="comment">在预处理阶段，编译器会将所有的__LINE__宏替换为当前代码所在的行号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(exp) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (exp)        \</span></span><br><span class="line"><span class="meta">        ;           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>            \</span></span><br><span class="line"><span class="meta">        assertion_failure(#exp, __FILE__, __BASE_FILE__, __LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制阻塞</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">spin</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;spinning in %s ...\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//提示报错信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assertion_failure</span><span class="params">(<span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">char</span> *file, <span class="type">char</span> *base, <span class="type">int</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(</span><br><span class="line">        <span class="string">&quot;\n--&gt; assert(%s) failed!!!\n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; file: %s \n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; base: %s \n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; line: %d \n&quot;</span>,</span><br><span class="line">        <span class="built_in">exp</span>, file, base, line);</span><br><span class="line"></span><br><span class="line">    spin(<span class="string">&quot;assertion_failure()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-xv6的内存映射实现"><a href="#2-2-xv6的内存映射实现" class="headerlink" title="2.2 xv6的内存映射实现"></a>2.2 xv6的内存映射实现</h2><p>xv6的内存映射代码实现在这里：<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c">xv6-riscv&#x2F;kernel&#x2F;vm.c at riscv · mit-pdos&#x2F;xv6-riscv (github.com)</a></p><ul><li>首先来看第一个函数<code>kvmmake</code>，在这个函数里先创建了一个根页表，为其分配一页内存，然后调用<code>kvmmap</code>函数来进行内存映射。这里建立的是恒等映射关系，把<code>PHYSTOP</code>以下的内存全部映射了，使用一个多级页表将内核的内存全部映射了。</li></ul><p><img src="/2023/08/31/%E5%AE%9E%E7%8E%B0timeros%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/v2-9c287c7d7384525eae9a37022322fd78_720w.png" alt="img"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  c(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后我们来看一下<code>kvmmap</code>的实现，它实际上会去调<code>mappages</code>函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继续看<code>mappages</code>函数，此函数有五个参数，分别是：三级页表地址，需要建立映射的虚拟地址和物理地址，映射的内存大小，映射的内存的属性。这个函数干的事情就是根据虚拟地址遍历三级页表，如果没有映射就新建页表项填充，最后返回一级页表的页表项指针，最后对其赋值就完成了映射操作，这个函数就对应着在上面rCore中实现的map函数的逻辑，区别在于这里由于传入了一个映射内存的长度，所以在映射完一页内存后，虚拟地址和需要映射的物理内存地址都将向上增长一页继续映射，直到全部映射完成。查找和建立页表项的操作是在<code>walk</code>函数中完成的</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="comment">//如果映射的大小为0，则panic</span></span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 按页对齐 */</span></span><br><span class="line">  a = PGROUNDDOWN(va); </span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//遍历三级页表，分配物理页帧，建立映射关系，第一级页表中指定虚拟地址 va 对应的页表项的指针</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 如果已经被映射过了，则panic</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    <span class="comment">//设置pte</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 一页一页映射</span></span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>walk</code>函数其实就对应着上面实现的<code>find_pte_create</code>函数，实现逻辑一摸一样</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">//如果已经映射到一个下一级页表，则将 pagetable 更新为下一级页表的物理地址。</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回第一级页表中指定虚拟地址 va 对应的页表项的指针</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="https://blog.csdn.net/lhwhit/article/details/119998259">xv6–内存管理_panic remap_lhw—9999的博客-CSDN博客</a></p></li><li><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/4sv39-implementation-2.html">管理 SV39 多级页表 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户态printf以及物理内存管理</title>
      <link href="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-os文件架构修改"><a href="#1-os文件架构修改" class="headerlink" title="1. os文件架构修改"></a>1. os文件架构修改</h1><p> 在开始启用<code>mmu</code>之前我对<code>os</code>的文件编译体系进行了修改，如下：</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230830204941589.png" alt="image-20230830204941589"></p><p>将头文件全部放在了<code>include/timeros</code>下，内核的源码放在了<code>src</code>目录下，<code>lib</code>目录下放的是一些通用的函数库，比如之前的<code>string.c</code>，以及马上要新增的和<code>printf</code>相关的代码。</p><p>所有的头文件都被修改成了这种形式：添加了一个<code>TOS</code>的前缀</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TOS_OS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOS_OS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改了<code>makefile</code></p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230830205303783.png" alt="image-20230830205303783"></p><p>修改的地方用红色方框圈了起来，主要就是用于调整文件结构后的编译。</p><h1 id="2-用户态的printf实现"><a href="#2-用户态的printf实现" class="headerlink" title="2. 用户态的printf实现"></a>2. 用户态的<code>printf</code>实现</h1><p>在之前的应用程序中，我们一直使用<code>sys_write</code>的系统调用来向串口输出数据，这样及其不方便，因此需要实现一个用户态的<code>printf</code>函数。实现方式和之前的内核实现的基本一样。</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230830205658123.png" alt="image-20230830205658123"></p><p>差别就在于需要把上面这个<code>uart_puts</code>函数换成<code>sys_write</code>就行了。</p><p>我首先把之前实现的<code>printf</code>函数名改成了<code>printk</code>，这是内核专属的，在S态用到的<code>printf</code>都要更改成<code>printk</code>,</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230830205850660.png" alt="image-20230830205850660"></p><p>然后在<code>lib</code>目录下新增<code>printf.c</code>和<code>vsprintf.c</code>,其中<code>vsprintf.c</code>的内容就是把之前的<code>_vsnprintf</code>函数移动到了此文件而已，然后<code>printf.c</code>如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> out_buf[<span class="number">1000</span>]; <span class="comment">// buffer for vprintf()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br><span class="line">_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br><span class="line">sys_write(<span class="built_in">stdout</span>,out_buf,res + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">va_list vl;</span><br><span class="line">va_start(vl, s);</span><br><span class="line">res = <span class="built_in">vprintf</span>(s, vl);</span><br><span class="line">va_end(vl);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见和<code>printk</code>的实现一模一样，只是使用了<code>sys_write(stdout,out_buf,res + 1);</code>来输出数据，<code>_vsnprintf</code>函数作为<code>printf</code>和<code>printk</code>公用函数。同时新增了一个头文件<code>stdio.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _vsnprintf(<span class="type">char</span> * out, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span>* s, va_list vl);</span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件描述符 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">std_fd_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">stdin</span>,  </span><br><span class="line">    <span class="built_in">stdout</span>,</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">&#125; <span class="type">std_fd_t</span>;</span><br></pre></td></tr></table></figure><h1 id="3-riscv的分页机制"><a href="#3-riscv的分页机制" class="headerlink" title="3. riscv的分页机制"></a>3. riscv的分页机制</h1><p>在<code>riscv</code>体系中，有三种地址转换机制：</p><ul><li>Sv32：仅支持32位riscv处理器，是一个二级页表结构，支持32位虚拟地址转换</li><li>Sv39：支持64位riscv处理器，是一个三级页表结构，支持39位虚拟地址转换</li><li>Sv48：支持64位riscv处理器，是一个四级页表结构，支持48位虚拟地址转换</li></ul><p>目前RISCV体系通常支持4KB大小的页面粒度，也支持2MB，1GB大小的块粒度。在我们的操作系统中用到的是Sv39页表映射，关于Sv39的具体内容本博客不做解释，主要是写起来他麻烦了哈哈，网上有很多资料：</p><p>首先先来看一下<code>satp</code>寄存器，这是一个S特权级的控制寄存器</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230831124613425.png" alt="image-20230831124613425"></p><ul><li><code>MODE</code> 控制 CPU 使用哪种页表实现；当 <code>MODE</code> 设置为 0 的时候，代表所有访存都被视为物理地址；而设置为 8 的时候，SV39 分页机制被启用，所有 S&#x2F;U 特权级的访存被视为一个 39 位的虚拟地址，它们需要先经过 MMU 的地址转换流程，如果顺利的话，则会变成一个 56 位的物理地址来访问物理内存；否则则会触发异常。</li><li><code>ASID</code> 表示地址空间标识符，这里还没有涉及到进程的概念，我们不需要管这个地方；</li><li><code>PPN</code> 存的是根页表所在的物理页号。这样，给定一个虚拟页号，CPU 就可以从三级页表的根页表开始一步步的将其映射到一个物理页号。</li></ul><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Sv39.png" alt="img"></p><ul><li><p>首先从<code>satp</code>寄存器的低44位取出一级页表的物理页号，乘以 PAGESIZE (4 KiB) 后，得到 3 级页表地址，取出虚拟地址的<code>VPN[2]</code>,去3级页表中寻找对应的页表项。</p></li><li><p>然后从三级页表中得到的页表项中存储了二级页表的物理页号，乘以 PAGESIZE (4 KiB) 后，得到 2级页表地址，取出虚拟地址的<code>VPN[1]</code>,去2级页表中寻找对应的页表项。</p></li><li><p>然后从二级页表中得到的页表项中存储了1级页表的物理页号，乘以 PAGESIZE (4 KiB) 后，得到 1级页表地址，取出虚拟地址的<code>VPN[0]</code>,去1级页表中寻找对应的页表项。</p></li><li><p>将1级页表中得到的页表项中存储了虚拟地址的物理页号，乘以 PAGESIZE (4 KiB) 后，得到实际的物理页号，然后再加上虚拟地址的最后12位offset就最终得到了物理地址。</p></li></ul><p>页表项的最后10bit代表的是页表项的属性：</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230831125451059.png" alt="image-20230831125451059"></p><ul><li>V(Valid)：仅当位 V 为 1 时，页表项才是合法的；</li><li>R(Read)&#x2F;W(Write)&#x2F;X(eXecute)：分别控制索引到这个页表项的对应虚拟页面是否允许读&#x2F;写&#x2F;执行；</li><li>U(User)：控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；</li><li>G：暂且不理会；</li><li>A(Accessed)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；</li><li>D(Dirty)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过</li><li>RSW：预留位</li></ul><table><thead><tr><th align="center">X</th><th align="center">W</th><th align="center">R</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="left">Pointer to next level of page table.</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="left">Read-only page.</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="left"><em>Reserved for future use.</em></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="left">Read-write page.</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="left">Execute-only page.</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="left">Read-execute page.</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="left"><em>Reserved for future use.</em></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="left">Read-write-execute page.</td></tr></tbody></table><h1 id="4-物理内存管理"><a href="#4-物理内存管理" class="headerlink" title="4. 物理内存管理"></a>4. 物理内存管理</h1><p>要开启mmu之前，内核需要对拥有的物理内存进行分配管理，对物理内存一页为单位进行分配和释放。</p><h2 id="4-1-xv6-riscv的物理内存管理"><a href="#4-1-xv6-riscv的物理内存管理" class="headerlink" title="4.1 xv6-riscv的物理内存管理"></a>4.1 xv6-riscv的物理内存管理</h2><p>首先先来看，<code>xv6</code>是如何管理的，代码在这里：<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c">xv6-riscv&#x2F;kernel&#x2F;kalloc.c at riscv · mit-pdos&#x2F;xv6-riscv (github.com)</a></p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/v2-9c287c7d7384525eae9a37022322fd78_720w.png" alt="img"></p><p>xv6内核的起始地址是从<code>KERNBASE=0x80000000</code>开始，结束的地方是<code>PHYSTOP=0x88000000</code>，这之间128M的地方，其中内核的代码段是可读可执行的，内核数据段代码是可读可写的。所以我们实际可以分配和管理的地址是从内核段的代码结束的地方开始的，在xv6的链接文件中指明了空闲物理内存开始的地方：</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230831153446728.png" alt="image-20230831153446728"></p><p>所以现在来看xv6的<code>kalloc.c</code>:</p><ul><li>首先就是拿到了<code>end</code>所代表的地址</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[]; <span class="comment">// first address after kernel.</span></span><br><span class="line">                   <span class="comment">// defined by kernel.ld.</span></span><br></pre></td></tr></table></figure><ul><li>然后定义了一个数据结构<code>kmem</code>，这个数据结构包含一个锁和一个链表，这就是xv6管理物理内存的核心数据结构，我们可以先忽略掉锁</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><ul><li>然后定义了<code>kinit()</code>函数，这个函数用来扫描从<code>end~PHYSTOP</code>之间可用的物理内存页，将可用的物理内存页通过<code>kmem</code>维护起来，同时将可用的空闲物理页中的每个字节的数据进行填充，这是用于初始化的时候</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>freerange</code>就是用来扫描内存的，可以看见从物理内存开始位置到结束，<code>freerange</code>会以页为单位来释放内存，其中会去调用<code>kfree</code>这个函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<code>kfree</code>中，对此页内存进行数据填充，然后将指向此页内存的指针放到<code>kmem</code>的链表头部，然后再让链表头指针前移</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与<code>kfree</code>与之对应的就是分配一页内存的函数<code>kalloc</code>函数，此函数将返回分配的物理内存页的指针。发配的逻辑就是从<code>kmemd</code>的链表头部取出一个空闲页块的指针，然后将链表头指针后移</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最后空闲链表就把空闲的物理内存串了起来：</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/v2-7286c486abbfbf8a98218e97e1e19b09_720w.png" alt="img"></p><p>可以看见xv6对空闲物理内存的管理十分的简洁明了。</p><h2 id="4-2-rCore的物理内存管理"><a href="#4-2-rCore的物理内存管理" class="headerlink" title="4.2 rCore的物理内存管理"></a>4.2 rCore的物理内存管理</h2><p>接下来我们再来看看操蛋的rCore，不知道是不是因为为了使用rust的语法特性，<code>rCore</code>的物理内存管理搞得我迷迷糊糊，绕过来绕过去。</p><p><code>rCore</code>采用的是栈式物理页帧管理策略，核心的数据结构如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,  <span class="comment">//空闲内存的起始物理页号</span></span><br><span class="line">    end: <span class="type">usize</span>,      <span class="comment">//空闲内存的结束物理页号</span></span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中各字段的含义是：物理页号区间 [ <code>current</code> , <code>end</code> ) 此前均 <em>从未</em> 被分配出去过，而向量 <code>recycled</code> 以后入先出的方式保存了被回收的物理页号。</p><p>因此为了实现这种栈式的管理，我们先得来实现一个栈的数据结构，在rust&#x2F;c++中倒是有方便的vector可以使用，但是我们使用的是c，所以有点麻烦，在<code>lib</code>目录下新建了一个<code>stack.c</code>的文件，在<code>timeros</code>目录下新建了<code>stack.h</code>的头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/stack.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, u64 value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Stack overflow\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈操作</span></span><br><span class="line">u64 <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Stack underflow\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 表示栈为空或操作失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line">u64 <span class="title function_">top</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 表示栈为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TOS_STACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOS_STACK_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u64 data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">// 不能定义成无符号类型，不然会导致 -1 &gt; 0</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, u64 value)</span>;</span><br><span class="line">u64 <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line">u64 <span class="title function_">top</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>stack的数据结构代码还是比较简单的，这里有一点说明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u64 data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">// 不能定义成无符号类型，不然会导致 -1 &gt; 0</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure><p>栈顶需要定义成int类型，不能定义成无符号类型，因为对栈初始化时，top的值被设置为-1，但是后面会让top和0进行大小比较，如果设置成无符号会导致结果出错。第二个就是data是一个u64的数组，因为栈中维护的是物理页号，物理页号是u64类型的。</p><p>在<code>src</code>目录下新建一个<code>address.c</code>，<code>timeros</code>目录下新建了<code>address.h</code>的头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TOS_ADDRESS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOS_ADDRESS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/os.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/stack.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timeros/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000      <span class="comment">// 4kb  一页的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE_BITS   0xc  <span class="comment">// 12   页内偏移地址长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA_WIDTH_SV39 56      <span class="comment">//物理地址长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_WIDTH_SV39 39      <span class="comment">//虚拟地址长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPN_WIDTH_SV39 (PA_WIDTH_SV39 - PAGE_SIZE_BITS)  <span class="comment">// 物理页号 44位 [55:12]</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VPN_WIDTH_SV39 (VA_WIDTH_SV39 - PAGE_SIZE_BITS)  <span class="comment">// 虚拟页号 27位 [38:12]</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_END 0x80800000    <span class="comment">// 0x80200000 ~ 0x80800000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_START 0x80400000  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理地址 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value; </span><br><span class="line">&#125; PhysAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 虚拟地址 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value;</span><br><span class="line">&#125; VirtAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理页号 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value;</span><br><span class="line">&#125; PhysPageNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 虚拟页号 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value;</span><br><span class="line">&#125; VirtPageNum;</span><br></pre></td></tr></table></figure><p><code>address.h</code>中定义了<code>PhysAddr、VirtAddr、PhysPageNum、VirtPageNum</code>，全部定义成结构体的类型，在rCore中可以为这些结构体实现操作函数，但是c语言没有面向对象的特性，因此就只有一个手动实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个u64 转换为PhysAddr */</span></span><br><span class="line">PhysAddr <span class="title function_">phys_addr_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    PhysAddr addr;</span><br><span class="line">    addr.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; PA_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给定一个u64 转换为PhysPageNum */</span></span><br><span class="line">PhysPageNum <span class="title function_">phys_page_num_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    PhysPageNum pageNum;</span><br><span class="line">    pageNum.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; PPN_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pageNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个PhysAddr转换为u64 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_phys_addr</span><span class="params">(PhysAddr v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个PhysPageNum 转换为u64 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_phys_page_num</span><span class="params">(PhysPageNum v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从物理页号转换为实际物理地址 */</span></span><br><span class="line">PhysAddr <span class="title function_">phys_addr_from_phys_page_num</span><span class="params">(PhysPageNum ppn)</span></span><br><span class="line">&#123;</span><br><span class="line">    PhysAddr addr;</span><br><span class="line">    addr.value = ppn.value &lt;&lt; PAGE_SIZE_BITS ;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个u64 转换为VirtAddr  */</span></span><br><span class="line">VirtAddr <span class="title function_">virt_addr_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    VirtAddr addr;</span><br><span class="line">    addr.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; VA_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个u64 转换为VirtPageNum  */</span></span><br><span class="line">VirtPageNum <span class="title function_">virt_page_num_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    VirtPageNum pageNum;</span><br><span class="line">    pageNum.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; VPN_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pageNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给定一个VirtAddr 转换为一个u64 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_virt_addr</span><span class="params">(VirtAddr v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v.value &gt;= (<span class="number">1ULL</span> &lt;&lt; (VA_WIDTH_SV39 - <span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> v.value | ~((<span class="number">1ULL</span> &lt;&lt; VA_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个VirtPageNum 转换为 u64*/</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_virt_page_num</span><span class="params">(VirtPageNum v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理地址向下取整 */</span></span><br><span class="line">PhysPageNum <span class="title function_">floor_phys</span><span class="params">(PhysAddr phys_addr)</span> &#123;</span><br><span class="line">    PhysPageNum phys_page_num;</span><br><span class="line">    phys_page_num.value = phys_addr.value / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> phys_page_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理地址向上取整 */</span></span><br><span class="line">PhysPageNum <span class="title function_">ceil_phys</span><span class="params">(PhysAddr phys_addr)</span> &#123;</span><br><span class="line">    PhysPageNum phys_page_num;</span><br><span class="line">    phys_page_num.value = (phys_addr.value + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> phys_page_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把虚拟地址转换为虚拟页号 */</span></span><br><span class="line">VirtPageNum <span class="title function_">virt_page_num_from_virt_addr</span><span class="params">(VirtAddr virt_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtPageNum vpn;</span><br><span class="line">    vpn.value =  virt_addr.value / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> vpn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数都是做一些转换工作，然后我们来定义栈式的内存管理数据结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> current;   <span class="comment">//空闲内存的起始物理页号</span></span><br><span class="line">    <span class="type">uint64_t</span>  end;      <span class="comment">//空闲内存的结束物理页号</span></span><br><span class="line">    Stack recycled;     <span class="comment">// </span></span><br><span class="line">&#125;StackFrameAllocator;</span><br></pre></td></tr></table></figure><p>首先是第一个new函数，用于创建<code>FrameAllocator</code>的实例：只需将区间两端均设为 0 ，然后创建一个初始化栈；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackFrameAllocator_new</span><span class="params">(StackFrameAllocator* allocator)</span> &#123;</span><br><span class="line">    allocator-&gt;current = <span class="number">0</span>;</span><br><span class="line">    allocator-&gt;end = <span class="number">0</span>;</span><br><span class="line">    initStack(&amp;allocator-&gt;recycled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>init</code>函数，用于将自身的<code> [current,end)</code> 初始化为可用物理页号区间：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackFrameAllocator_init</span><span class="params">(StackFrameAllocator *allocator, PhysPageNum l, PhysPageNum r)</span> &#123;</span><br><span class="line">    allocator-&gt;current = l.value;</span><br><span class="line">    allocator-&gt;end = r.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是物理页帧的分配和实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PhysPageNum <span class="title function_">StackFrameAllocator_alloc</span><span class="params">(StackFrameAllocator *allocator)</span> &#123;</span><br><span class="line">    PhysPageNum ppn;</span><br><span class="line">    <span class="keyword">if</span> (allocator-&gt;recycled.top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ppn.value = pop(&amp;(allocator-&gt;recycled));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (allocator-&gt;current == allocator-&gt;end) &#123;</span><br><span class="line">            ppn.value = <span class="number">0</span>; <span class="comment">// Return 0 as None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ppn.value = allocator-&gt;current++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清空此页内存 ： 注意不能覆盖内核代码区，分配的内存只能是未使用部分*/</span></span><br><span class="line">    PhysAddr addr = phys_addr_from_phys_page_num(ppn);</span><br><span class="line">    <span class="built_in">memset</span>(addr.value,<span class="number">0</span>,PAGE_SIZE);</span><br><span class="line">    <span class="keyword">return</span> ppn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在分配 <code>alloc</code> 的时候，首先会检查栈 <code>recycled</code> 内有没有之前回收的物理页号，如果有的话直接弹出栈顶并返回；否则的话我们只能从之前从未分配过的物理页号区间 [ <code>current</code> , <code>end</code> ) 上进行分配，我们分配它的左端点 <code>current</code> ，同时将管理器内部维护的 <code>current</code> 加 <code>1</code> 代表 <code>current</code> 已被分配了。然后清空此页内存，全部初始化为0，最后返回分配的页的物理页号。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackFrameAllocator_dealloc</span><span class="params">(StackFrameAllocator *allocator, PhysPageNum ppn)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> ppnValue = ppn.value;</span><br><span class="line">    <span class="comment">// 检查回收的页面之前一定被分配出去过</span></span><br><span class="line">    <span class="keyword">if</span> (ppnValue &gt;= allocator-&gt;current) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Frame ppn=%lx has not been allocated!\n&quot;</span>, ppnValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查未在回收列表中</span></span><br><span class="line">    <span class="keyword">if</span>(allocator-&gt;recycled.top&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= allocator-&gt;recycled.top; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ppnValue ==allocator-&gt;recycled.data[i] )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回收物理内存页号</span></span><br><span class="line">    push(&amp;(allocator-&gt;recycled), ppnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回收 <code>dealloc</code> 的时候，我们需要检查回收页面的合法性，然后将其压入 <code>recycled</code> 栈中。回收页面合法有两个条件：</p><ul><li>该页面之前一定被分配出去过，因此它的物理页号一定 &lt; <code>current</code> ；</li><li>该页面没有正处在回收状态，即它的物理页号不能在栈 <code>recycled</code> 中找到。</li></ul><p>在上面的代码中用到了一个<code>memset</code>函数，这个函数实现在<code>string.c</code>中:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复制字符 ch（一个无符号字符）到参数 dest 所指向的字符串的前 n 个字符。</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">memset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">int</span> ch, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr = dest;</span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line">    &#123;</span><br><span class="line">        *ptr++ = ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来编写测试代码测试一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> StackFrameAllocator FrameAllocatorImpl;</span><br><span class="line"><span class="type">void</span> <span class="title function_">frame_allocator_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    StackFrameAllocator_new(&amp;FrameAllocatorImpl);</span><br><span class="line">    StackFrameAllocator_init(&amp;FrameAllocatorImpl, \</span><br><span class="line">            floor_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_START)), \</span><br><span class="line">            ceil_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_END)));</span><br><span class="line">    printk(<span class="string">&quot;Memoery start:%d\n&quot;</span>,floor_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_START)));</span><br><span class="line">    printk(<span class="string">&quot;Memoery end:%d\n&quot;</span>,ceil_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_END)));</span><br><span class="line">    PhysPageNum frame[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         frame[i] = StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">         printk(<span class="string">&quot;frame id:%d\n&quot;</span>,frame[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        StackFrameAllocator_dealloc(&amp;FrameAllocatorImpl,frame[i]);</span><br><span class="line">        printk(<span class="string">&quot;allocator-&gt;recycled.data.value:%d\n&quot;</span>,FrameAllocatorImpl.recycled.data[i]);</span><br><span class="line">        printk(<span class="string">&quot;frame id:%d\n&quot;</span>,frame[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">    PhysPageNum frame_test[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         frame[i] = StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">        printk(<span class="string">&quot;frame id:%d\n&quot;</span>,frame[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的测试函数一次调用了<code>new，init</code> ，然后尝试分配五页内存，并打印五页内存的物理页号，然后将分配的五页内存释放掉，此时这五页内存应该会全部被压入<code>recycled</code>栈中，然后再次分配五页内存，此时分配的话就是从<code>recycled</code>中<code>pop</code>的内存了。强调一下在<code>StackFrameAllocator_init</code>函数中传入的起始物理内存的地址和上面xv6的一样，必须在内核代码段之上，在头文件中进行了定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_END 0x80800000    <span class="comment">// 0x80200000 ~ 0x80800000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_START 0x80400000  </span></span><br></pre></td></tr></table></figure><p>来编译测试一下：修改一下main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">frame_allocator_test</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   printk(<span class="string">&quot;hello timer os!\n&quot;</span>);</span><br><span class="line">   frame_allocator_test();</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// trap_init();</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// task_init();</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// timer_init();</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// run_first_task();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下</p><p><img src="/2023/08/30/%E7%94%A8%E6%88%B7%E6%80%81printf%E4%BB%A5%E5%8F%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230831162651340.png" alt="image-20230831162651340"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/4sv39-implementation-2.html">管理 SV39 多级页表 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li><li><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html">SV39 多级页表的硬件机制 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/643749962">xv6 物理内存管理 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sec:sv32">The RISC-V Instruction Set Manual, Volume II: Privileged Architecture | Five EmbedDev (five-embeddev.com)</a></p></li><li><p><a href="https://dingfen.github.io/risc-v/2020/08/29/riscv-from-scratch-7.html">RISC-V from Scratch 7 - 峰子的乐园 (dingfen.github.io)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分时多任务系统与抢占式调度</title>
      <link href="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/"/>
      <url>/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="分时多任务系统"><a href="#分时多任务系统" class="headerlink" title="分时多任务系统"></a>分时多任务系统</h1><p>在上一章中我们实现了一个协作式的调度方案，用户程序通过调用<code>sys_yield</code>的系统调用来主动放弃cpu的使用权，然后内核使用轮转调度的方式切换至下一个任务。何为分时多任务系统呢，任务的切换不是通过用户程序来自行放弃cpu的使用权作为前提的，而是内核自己来决定何时切换任务，这个切换的原则就是每个任务一次只能运行一段时间，时间一到就会被操作系统强制切换到下一个任务执行，这就需要内核有一个定时器的东西，这个定时器是通过硬件提供的时钟中断来实现的。</p><h2 id="riscv的时钟中断"><a href="#riscv的时钟中断" class="headerlink" title="riscv的时钟中断"></a>riscv的时钟中断</h2><p>RISC-V 的中断可以分成三类：</p><ul><li><strong>软件中断</strong> (Software Interrupt)：由软件控制发出的中断</li><li><strong>时钟中断</strong> (Timer Interrupt)：由时钟电路发出的中断</li><li><strong>外部中断</strong> (External Interrupt)：由外设发出的中断</li></ul><p>在介绍trap机制时我们用到了<code>scause</code>寄存器，<code>scause</code>最高位为1时代表此次触发的异常为中断类型：</p><table><thead><tr><th>Interrupt</th><th>Exception Code</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>Supervisor software interrupt</td></tr><tr><td>1</td><td>3</td><td>Machine software interrupt</td></tr><tr><td>1</td><td>5</td><td>Supervisor timer interrupt</td></tr><tr><td>1</td><td>7</td><td>Machine timer interrupt</td></tr><tr><td>1</td><td>9</td><td>Supervisor external interrupt</td></tr><tr><td>1</td><td>11</td><td>Machine external interrupt</td></tr></tbody></table><p>可以看到这三种中断每一个都有 M&#x2F;S 特权级两个版本。中断的特权级可以决定该中断是否会被屏蔽，以及需要 Trap 到 CPU 的哪个特权级进行处理。我们的目标是在S态使用时钟中断，这涉及到两个个在S态控制中断的寄存器<code>sstatus</code>,<code>sie</code></p><p><code>sstatus</code>的<code>bit[2]</code>用来使能S态模式下的所有中断</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820114526155.png" alt="image-20230820114526155"></p><p><code>sie</code>的<code>bit[5]</code>用来专门使能S态的时钟中断</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820113357943.png" alt="image-20230820113357943"></p><p>当设置<code>STIE</code>位为1时代表启动S态的时钟中断。</p><p><code>sstatus</code> 的 <code>sie</code> 为 S 特权级的中断使能，能够同时控制三种中断，如果将其清零则会将它们全部屏蔽。即使 <code>sstatus.sie</code> 置 1 ，还要看 <code>sie</code> 这个 CSR，它的三个字段 <code>ssie/stie/seie</code> 分别控制 S 特权级的软件中断、时钟中断和外部中断的中断使能。比如对于 S 态时钟中断来说，如果 CPU 不高于 S 特权级，需要 <code>sstatus.sie</code> 和 <code>sie.stie</code> 均为 1 该中断才不会被屏蔽；如果 CPU 当前特权级高于 S 特权级，则该中断一定会被屏蔽。</p><p>由于软件（特别是操作系统）需要一种计时机制，RISC-V 架构要求处理器要有一个内置时钟，其频率一般低于 CPU 主频。此外，还有一个计数器用来统计处理器自上电以来经过了多少个内置时钟的时钟周期。在 RISC-V 64 架构上，该计数器保存在一个 64 位的 CSR <code>mtime</code> 中，我们无需担心它的溢出问题，在内核运行全程可以认为它是一直递增的。这个计数器一般我们叫做RTC。另外一个 64 位的 CSR <code>mtimecmp</code> 的作用是：一旦计数器 <code>mtime</code> 的值超过了 <code>mtimecmp</code>，就会触发一次时钟中断。</p><p>所以我们现在来设置时钟中断，在os目录下新建一个<code>timer.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCK_FREQ 10000000 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TICKS_PER_SEC 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置下次时钟中断的cnt值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_next_trigger</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sbi_set_timer(r_mtime() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开启S模式下的时钟中断 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">reg_t</span> sstatus =r_sstatus();</span><br><span class="line">   sstatus |= (<span class="number">1L</span> &lt;&lt; <span class="number">1</span>) ;</span><br><span class="line">   w_sstatus(sstatus);</span><br><span class="line">   <span class="type">reg_t</span> sie = r_sie();</span><br><span class="line">   sie |= SIE_STIE;</span><br><span class="line">   w_sie(sie);</span><br><span class="line">   set_next_trigger();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 以us为单位返回时间 */</span></span><br><span class="line"><span class="comment">/* 以us为单位返回时间 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">get_time_us</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> time =  r_mtime() / (CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>timer_init()</code>函数中，分别将<code>sstatus.sie</code> 置 1 和<code>sie.stie</code> ，操作<code>sie</code>寄存器的代码放在<code>riscv.h</code>中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Supervisor Interrupt Enable</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_SEIE (1L &lt;&lt; 9) <span class="comment">// external</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_STIE (1L &lt;&lt; 5) <span class="comment">// timer</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_SSIE (1L &lt;&lt; 1) <span class="comment">// software</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_sie</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sie&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sie</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sie, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了设置时钟中断的频率我们需要先读到<code>mtime</code>的值，然后设置<code>mtimecmp</code>，这两个寄存器都是m模式下的，在S模式下不能直接访问，可惜的是在<code>opensbi</code>中只提供了设置<code>mtimecmp</code>的接口，因此需要想办法在S态下获取<code>mtime</code>的值，经过查找，有两种方式可以去得到<code>mtime</code>的值：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_mtime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;rdtime %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(x))</span>;</span><br><span class="line">  <span class="comment">// asm volatime(&quot;csrr %0, 0x0C01&quot; : &quot;=r&quot; (x) )</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种是使用<code>rdtime</code>这个伪指令，这里是在哪里找的呢，在<code>opensbi</code>的源码中，在<code>lib/sbi/sbi_timer.c</code>有这么一个函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64 <span class="title function_">sbi_timer_value</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (get_time_val)</span><br><span class="line"><span class="keyword">return</span> get_time_val();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>opensbi</code>用此函数来获取时间，<code>opensbi</code>在进行时钟初始化时，在<code>sbi_timer_init</code>函数中，对<code>sbi_timer_value</code>进行了赋值，所以在<code>opensbi</code>中实际是通过<code>get_ticks</code>函数来获取时间的</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820120641356.png" alt="image-20230820120641356"></p><p><code>get_ticks</code>定义如下:</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820120859926.png" alt="image-20230820120859926"></p><p>第二种方式是<code>asm volatime(&quot;csrr %0, 0x0C01&quot; : &quot;=r&quot; (x) )</code>来读取，<code>mtime</code>这个寄存器通过<code>MMIO</code>映射到了一个确定的地址，这个地址和平台有关，在<code>opensbi</code>源码的<code>sbi_emulate_csr.c</code>中，<code>opensbi</code>将<code>mtime</code>的值映射到了<code>0xc01</code>的地方，这是<code>opensbi</code>做了二次映射，用于S态的程序来读取，实际<code>mtime</code>的映射地址应该由<code>qemu</code>来做的，具体的映射方式我也不太清楚……，看下面代码实际上<code>opensbi</code>也是通过<code>rdtime</code>去读取的该值：</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820122507968.png" alt="image-20230820122507968"></p><p>所以我也不知道<code>rdtime</code>如何与<code>rtc</code>关联上的，疑惑…….</p><p>总之得到了<code>mtime</code>的值。<code>mtimecmp</code>的值可以通过<code>opensbi</code>提供的接口来设置：在<code>sbi.c</code>中定义如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_set_timer() - Program the timer for next timer event.</span></span><br><span class="line"><span class="comment"> * @stime_value: The value after which next timer event should fire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_set_timer</span><span class="params">(<span class="type">uint64_t</span> stime_value)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_TIME, SBI_FID_SET_TIMER, stime_value,</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820123213958.png" alt="image-20230820123213958"></p><p>调用号为<code>0x54494D45</code>，定义在<code>sbi.h</code>中。</p><p>在<code>qemu</code>中<code>rtc</code>的频率为<code>10mhz</code>，即10^7，在上面的代码中，我将1s分成了1000个时间片，即每隔1us触发一次时钟中断，因此每次触发时钟中断设置的<code>mtimecmp</code>值为：<code>r_mtime() + CLOCK_FREQ / TICKS_PER_SEC</code>。这个频率应该是和设备树中的保持一致的</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/image-20230820142830588.png" alt="image-20230820142830588"></p><p><code>0x986980</code>换算成10进制就是<code>10mhz</code></p><h2 id="分时多任务"><a href="#分时多任务" class="headerlink" title="分时多任务"></a>分时多任务</h2><p>有了时钟中断后，切换任务就简单许多了，只需要在时钟中断到来时，设置下一次时钟中断的<code>mtimecmp</code>的值，并切换一次任务。因此对<code>trap.c</code>修改如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TrapContext* <span class="title function_">trap_handler</span><span class="params">(TrapContext* cx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> scause = r_scause();</span><br><span class="line"><span class="type">reg_t</span> cause_code = scause &amp; <span class="number">0xfff</span>;</span><br><span class="line"><span class="keyword">if</span>(scause &amp; <span class="number">0x8000000000000000</span>)  <span class="comment">// 1 &lt;&lt; 63 = 0x8000000000000000</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (cause_code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* rtc 中断*/</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">set_next_trigger();</span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;undfined interrrupt scause:%x\n&quot;</span>,scause);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (cause_code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* U模式下的syscall */</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">cx-&gt;a0 = __SYSCALL(cx-&gt;a7,cx-&gt;a0,cx-&gt;a1,cx-&gt;a2);</span><br><span class="line">cx-&gt;sepc += <span class="number">8</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;undfined exception scause:%x\n&quot;</span>,scause);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scause</code>最高位为1时代表为中断则进入中断的判断分支，否则进入异常的处理分支。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>app.c</code>修改:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task1 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task2 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task3 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (sys_gettime() &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在三个任务中注释掉了<code>sys_yield()</code>，我们让内核自主来进行任务切换，</p><p>编译测试：<code>./build.sh , ./run.sh</code>，测试的时候发现<code>#define TICKS_PER_SEC 1000</code>这里切换频率太高会触发一个异常，暂时不知道如何引起的，因此降低一下频率为500，测试成功。</p><p><img src="/2023/08/20/%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/GIF-fre.gif" alt="GIF-fre"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/456568228">操作系统lab2时钟中断处理 - 知乎 (zhihu.com)</a></p></li><li><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/4time-sharing-system.html">分时多任务系统与抢占式调度 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p></li><li><p><a href="https://github.com/LiuJiLan/RVOS_On_VisionFive2">LiuJiLan&#x2F;RVOS_On_VisionFive2: RVOS在VisionFive2开发板上的移植。 (github.com)</a></p></li><li><p><a href="https://five-embeddev.com/baremetal/timer/">Timer | Five EmbedDev (five-embeddev.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协作式多任务调度</title>
      <link href="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
      <url>/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-代码的一些修改"><a href="#1-代码的一些修改" class="headerlink" title="1. 代码的一些修改"></a>1. 代码的一些修改</h1><h2 id="1-1-trap的bug修改"><a href="#1-1-trap的bug修改" class="headerlink" title="1.1 trap的bug修改"></a>1.1 trap的bug修改</h2><p>在上一节实现U模式的trap机制时，我在<code>trap_handler</code>函数中，在函数最后通过<code>__restore(cx)</code>来切换回用户态，这里实际是不用的，我就说为啥我在用户程序里为啥不加一个while循环卡在那儿就会报奇怪的错误。</p><p>原因在于当程序从<code>trap_handler</code> 返回之后会从调用 <code>trap_handler</code> 的下一条指令开始执行：</p><p><img src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20230810215940227.png" alt="image-20230810215940227"></p><p><code>call trap_handler</code> 实际的汇编会被转换一条<code>jal</code>的跳转指令:</p><p><img src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20230810220243193.png" alt="image-20230810220243193"></p><p><code>jal ra,1876</code>会做两个操作，一是将当前<code>PC+8</code>存到<code>ra</code>寄存器中，然后跳转到和当前地址相差1876的地方执行即<code>0x802007ba</code>，而<code>0x802007ba</code>就是<code>trap_handler</code>函数的地址，各个函数的地址可以在生成的<code>os.map</code>中找到。因此在执行完毕<code>trap_handler</code>函数后就会跳转到<code>call trap_handler</code> 的下一条指令，这下一条指令就是<code>_restore</code>的第一条指令，编译器在编译时是这样编译的。所以直接将<code>trap_handler</code>函数的<code>__restore(cx)</code>干掉。</p><h2 id="1-2-实现sys-write"><a href="#1-2-实现sys-write" class="headerlink" title="1.2 实现sys_write"></a>1.2 实现sys_write</h2><p>我再<code>os</code>目录下新建了一个<code>app.c</code>，上一节的<code>batch.c</code>在本章内容中可以干掉，在<code>app.c</code>中首先了实现了用户态的<code>sys_write</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// Move syscall id to a7 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// Move args[0] to a1 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// Move args[1] to a2 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// Move args[2] to a3 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// Perform syscall</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// Move return value to &#x27;ret&#x27; variable</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">sys_wirte</span><span class="params">(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(__NR_write,fd,buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write</code>的系统调用号是64定义在<code>os.h</code>中，然后需要修改内核的<code>trap_handler</code>函数，对系统调用号进行分发：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TrapContext* <span class="title function_">trap_handler</span><span class="params">(TrapContext* cx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> scause = r_scause();</span><br><span class="line"><span class="keyword">switch</span> (scause)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">__SYSCALL(cx-&gt;a7,cx-&gt;a0,cx-&gt;a1,cx-&gt;a2);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;undfined scause:%d\n&quot;</span>,scause);</span><br><span class="line"><span class="comment">//panic(&quot;error!&quot;);</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cx-&gt;sepc += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__SYSCALL</code>函数定义在<code>syscall.c</code>中，需要新建<code>syscall.c</code>，可以看见其实调用内核的<code>printf</code>函数去输出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* syscall.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __SYSCALL(<span class="type">size_t</span> syscall_id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (syscall_id)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> __NR_write:</span><br><span class="line">            __sys_write(arg1, arg2, arg3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unsupported syscall id:%d\n&quot;</span>,syscall_id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sys_write(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd ==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;Unsupported fd in sys_write!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>sys_wirte</code>的其中一个参数是字符串的长度，需要调用<code>strlen</code>去计算，如果我们调用编译器的标准库会产生重定义错误，因此我们自己来实现一个，新建一个<code>string.c</code>，实现了两个辅助函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* string.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="comment">//计算字符串的长度 </span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr = (<span class="type">char</span> *)str;</span><br><span class="line">    <span class="keyword">while</span> (*ptr != EOS)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr - str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从存储区 src 复制 n 个字节到存储区 dest。</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr = dest;</span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line">    &#123;</span><br><span class="line">        *ptr++ = *((<span class="type">char</span> *)(src++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，现在就可以在用户态的程序调用<code>sys_write</code>来实现串口输出数据了。</p><h1 id="2-协作式多任务"><a href="#2-协作式多任务" class="headerlink" title="2. 协作式多任务"></a>2. 协作式多任务</h1><h2 id="2-1-任务的切换"><a href="#2-1-任务的切换" class="headerlink" title="2.1 任务的切换"></a>2.1 任务的切换</h2><p>在上一节中我们可以编写一个应用程序让它运行下去，运行完毕后可以让CPU接着运行下一个程序，这叫做批处理系统，cpu可以按照顺序依次运行用户程序。什么是协作式多任务呢就是如果一个用户程序在做一些等待的事情的时候比如等待外设响应而不需要占用cpu计算资源的时候可以让出cpu的使用权让下一个用户程序执行，当外设响应完毕后重新拿到cpu使用权继续执行，这大大的提高了cpu的执行效率。从一个程序的任务切换到另外一个程序的任务称为 任务切换 。为了确保切换后的任务能够正确继续执行，操作系统需要支持让任务的执行“暂停”和“继续”。</p><p>和<code>trap</code>一样从用户态切换到内核态时需要保存用户态的执行状态，同样从一个任务切换到另一个任务也需要保存当前任务的执行状态，该任务重新拿到<code>cpu</code>使用权后能够恢复执行状态继续执行。</p><p>实现协作式多任务的关键在于任务主动放弃<code>cpu</code>执行权，用户态的程序会去调用一个<code>sys_yield</code>的系统调用来告诉操作系统我要放弃<code>cpu</code>使用权了，然后操作系统就可以进行任务切换了，所以任务的切换是发生在S态的，任务在操作系统切换完毕后，同样通过<code>_restore</code>回到用户态执行程序，不过此时已经进行了任务切换，所以<code>_restore</code>回到的是切换后的任务。</p><p>所以，任务切换其实是来自两个不同应用在内核中的 <code>Trap</code> 控制流之间的切换。当一个应用 Trap 到 S 模式的操作系统内核中进行进一步处理的时候，我们可以设计一个函数来给Trap 控制流调用，从而进行任务切换。这个函数我们定义为<code>__switch</code></p><p>这个函数表面上就是一个普通的函数调用：在 <code>__switch</code> 返回之后，将继续从调用该函数的位置继续向下执行。但是其间却隐藏着复杂的控制流切换过程。具体来说，调用 <code>__switch</code> 之后直到它返回前的这段时间，原 Trap 控制流 A 会先被暂停并被切换出去， CPU 转而运行另一个应用在内核中的 Trap 控制流 B 。然后在某个合适的时机，原 Trap 控制流 A 才会从某一条 Trap 控制流 C （很有可能不是它之前切换到的 B ）切换回来继续执行并最终返回。</p><p>同样在内核进行切换时我们需要保存任务在内核执行trap时的执行状态，任务从用户态通过trap进入内核态后，内核栈上首先保存了用户态的trap上下文，然后会保存内核在对Trap处理过程中留下的调用栈信息，如下图所示：</p><p><img src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20230811144230318.png" alt="image-20230811144230318"></p><p>任务在切换后还需要回来继续执行，因此需要在执行<code>__switch</code> 函数时保存当前任务的CPU寄存器的信息，这里我们称为任务上下文(<code>Task Context</code>)。每个任务都有自己的任务上下文，每个任务也有自己的内核栈和用户栈空间，所以我们首先需要为每个任务定义内核栈和用户栈。新建一个<code>task.c</code>文件:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TASKS 10   <span class="comment">/* 操作系统支持的最大任务数量 */</span></span></span><br><span class="line"><span class="type">uint8_t</span> KernelStack[MAX_TASKS][KERNEL_STACK_SIZE]; <span class="comment">/* 任务内核栈 */</span></span><br><span class="line"><span class="type">uint8_t</span> UserStack[MAX_TASKS][USER_STACK_SIZE];    <span class="comment">/* 任务用户栈 */</span></span><br></pre></td></tr></table></figure><p>接下来我们来定义<code>TaskContext</code>，在<code>context.h</code>新增如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* S模式的任务上下文 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">reg_t</span> ra;</span><br><span class="line"><span class="type">reg_t</span> sp;</span><br><span class="line"><span class="type">reg_t</span> s0;</span><br><span class="line"><span class="type">reg_t</span> s1;</span><br><span class="line"><span class="type">reg_t</span> s2;</span><br><span class="line"><span class="type">reg_t</span> s3;</span><br><span class="line"><span class="type">reg_t</span> s4;</span><br><span class="line"><span class="type">reg_t</span> s5;</span><br><span class="line"><span class="type">reg_t</span> s6;</span><br><span class="line"><span class="type">reg_t</span> s7;</span><br><span class="line"><span class="type">reg_t</span> s8;</span><br><span class="line"><span class="type">reg_t</span> s9;</span><br><span class="line"><span class="type">reg_t</span> s10;</span><br><span class="line"><span class="type">reg_t</span> s11;</span><br><span class="line">&#125;TaskContext;</span><br></pre></td></tr></table></figure><p>可以看见需要保存的寄存器包括<code>ra</code>寄存器，<code>sp</code>寄存器，<code>s0~s11</code>寄存器，，因为从本质上来讲<code>__switch</code>属于一个函数调用，我们需要遵守riscv的函数调用规范：</p><table><thead><tr><th>寄存器组</th><th>保存者</th><th>功能</th></tr></thead><tbody><tr><td>a0<del>a7（ &#96;x10</del>x17&#96; ）</td><td>调用者保存</td><td>用来传递输入参数。其中的 a0 和 a1 还用来保存返回值。</td></tr><tr><td>t0<del>t6( &#96;x5</del>x7,x28~x31&#96; )</td><td>调用者保存</td><td>作为临时寄存器使用，在被调函数中可以随意使用无需保存。</td></tr><tr><td>s0<del>s11( &#96;x8</del>x9,x18~x27&#96; )</td><td>被调用者保存</td><td>作为临时寄存器使用，被调函数保存后才能在被调函数中使用。</td></tr></tbody></table><p> <code>ra</code> 很重要，它记录了 <code>__switch</code> 函数返回之后应该跳转到哪里继续执行，从而在任务切换完成并 <code>ret</code> 之后能到正确的位置。对于一般的函数而言，Rust&#x2F;C 编译器会在函数的起始位置自动生成代码来保存 <code>s0~s11</code> 这些被调用者保存的寄存器。但 <code>__switch</code> 是一个用汇编代码写的特殊函数，它不会被 Rust&#x2F;C 编译器处理，所以我们需要在 <code>__switch</code> 中手动编写保存 <code>s0~s11</code> 的汇编代码。 不用保存其它寄存器是因为：其它寄存器中，属于调用者保存的寄存器是由编译器在高级语言编写的调用函数中自动生成的代码来完成保存的；还有一些寄存器属于临时寄存器，不需要保存和恢复。</p><p>所以在调用<code>__switch</code>函数进行任务切换时，我们需要将当前任务的这些寄存器保存，然后将下一个要切换的任务的寄存器从拿出来然后完成寄存器替换。</p><p>因此每个任务都有一个保存自己任务上下文的地方，这个地方我们定义为<code>TaskControlBlock</code>，在<code>TaskControlBlock</code>不止可以保存任务的上下文信息，还可以保存任务的运行状态，在新建一个<code>task.h</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TASK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">TaskState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">UnInit, <span class="comment">// 未初始化</span></span><br><span class="line">    Ready, <span class="comment">// 准备运行</span></span><br><span class="line">    Running, <span class="comment">// 正在运行</span></span><br><span class="line">    Exited, <span class="comment">// 已退出</span></span><br><span class="line">&#125;TaskState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TaskState task_state; </span><br><span class="line">    TaskContext task_context; </span><br><span class="line">&#125;TaskControlBlock;</span><br></pre></td></tr></table></figure><p>在task.h文件中我定义了一个<code>TaskControlBlock</code>来保存任务的信息，一个任务的信息包括这个任务的状态和任务上下文的信息，然后在t<code>ask.c</code>中定义一个数组，由此每个任务都有保存自己任务上下文的地方了。任务的状态有4钟：未初始化、准备执行、正在执行、已退出。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span> <span class="title">tasks</span>[<span class="title">MAX_TASKS</span>];</span></span><br></pre></td></tr></table></figure><p>对于当前正在执行的任务的 <code>Trap</code> 控制流，我们用一个名为 <code>current_task_cx_ptr </code>的变量来保存放置当前任务上下文的地址；而用<code>next_task_cx_ptr</code>的变量来保存放置下一个要执行任务的上下文的地址。利用 C 语言的引用来描述的话就是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskContext *current_task_cx_ptr = &amp;tasks[current].task_cx;</span><br><span class="line">TaskContext *next_task_cx_ptr    = &amp;tasks[next].task_cx;</span><br></pre></td></tr></table></figure><p>接下来我们从栈上内容的角度来看<code>__switch</code>的整体流程：</p><p><img src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20230811150744675.png" alt="image-20230811150744675"></p><p>Trap 控制流在调用 <code>__switch</code> 之前就需要明确知道即将切换到哪一条目前正处于暂停状态的 Trap 控制流，因此 <code>__switch</code> 有两个参数，第一个参数代表它自己，第二个参数则代表即将切换到的那条 Trap 控制流。这里我们用上面提到过的 <code>current_task_cx_ptr</code> 和 <code>next_task_cx_ptr</code> 作为代表。在上图中我们假设某次 <code>__switch</code> 调用要从 Trap 控制流 A 切换到 B，一共可以分为四个阶段，在每个阶段中我们都给出了 A 和 B 内核栈上的内容。</p><ul><li>阶段 [1]：在 Trap 控制流 A 调用 <code>__switch</code> 之前，A 的内核栈上只有 Trap 上下文和 Trap 处理函数的调用栈信息，而 B 是之前被切换出去的；</li><li>阶段 [2]：A 在 A 任务上下文空间在里面保存 CPU 当前的寄存器快照；</li><li>阶段 [3]：这一步极为关键，读取 <code>next_task_cx_ptr</code> 指向的 B 任务上下文，根据 B 任务上下文保存的内容来恢复 <code>ra</code> 寄存器、<code>s0~s11</code> 寄存器以及 <code>sp</code> 寄存器。只有这一步做完后， <code>__switch</code> 才能做到一个函数跨两条控制流执行，即 <em>通过换栈也就实现了控制流的切换</em> 。</li><li>阶段 [4]：上一步寄存器恢复完成后，可以看到通过恢复 <code>sp</code> 寄存器换到了任务 B 的内核栈上，进而实现了控制流的切换。这就是为什么 <code>__switch</code> 能做到一个函数跨两条控制流执行。此后，当 CPU 执行 <code>ret</code> 汇编伪指令完成 <code>__switch</code> 函数返回后，任务 B 可以从调用 <code>__switch</code> 的位置继续向下执行。</li></ul><p>从结果来看，我们看到 A 控制流 和 B 控制流的状态发生了互换， A 在保存任务上下文之后进入暂停状态，而 B 则恢复了上下文并在 CPU 上继续执行。</p><p>所以<code>__switch</code>的实现代码如下，新建一个<code>switch.S</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_SN n</span><br><span class="line">    sd s\n, (\n+2)*8(a0)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_SN n</span><br><span class="line">    ld s\n, (\n+2)*8(a1)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __switch</span><br><span class="line">__switch:</span><br><span class="line">    # 阶段 [1]</span><br><span class="line">    # __switch(</span><br><span class="line">    #     current_task_cx_ptr</span><br><span class="line">    #     next_task_cx_ptr</span><br><span class="line">    # )</span><br><span class="line">    # 阶段 [2]</span><br><span class="line">    # save kernel stack of current task</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    # save ra &amp; s0~s11 of current execution</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        SAVE_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # 阶段 [3]</span><br><span class="line">    # restore ra &amp; s0~s11 of next execution</span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        LOAD_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # restore kernel stack of next task</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    # 阶段 [4]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>综上所述，<code>__switch</code>进行了一个换栈的操作，在内核态悄悄地把寄存器地执行状态全部修改了，再次回到用户态执行时，执行的就是另外一个用户程序了。</p><h2 id="2-2-协作式调度"><a href="#2-2-协作式调度" class="headerlink" title="2.2 协作式调度"></a>2.2 协作式调度</h2><p>首先在<code>app.c</code>中封装一下<code>sys_yield()</code>函数:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">sys_yield</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(__NR_sched_yield,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改一下内核的<code>__SYSCALL</code>分发函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __SYSCALL(<span class="type">size_t</span> syscall_id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (syscall_id)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> __NR_write:</span><br><span class="line">            __sys_write(arg1, arg2, arg3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __NR_sched_yield:</span><br><span class="line">            __sys_yield();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unsupported syscall id:%d\n&quot;</span>,syscall_id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sys_yield()</span><br><span class="line">&#123;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__NR_sched_yield</code>定义在<code>os.h</code>中：<code>#define __NR_sched_yield 124</code></p><p>可以看见当用户态程序调用<code>sys_yield()</code>来手动放弃cpu使用权时，内核会去调用一个<code>schedule();</code>的函数来完成任务切换，这个函数我是定义在<code>task.c</code>中的</p><p>来看一下<code>task.c</code>中做了哪些修改：</p><ul><li>首先定义了两个变量，一个用来表示当前的执行的任务号，一个用来表示用户常见的任务数量。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _current = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _top = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>然后定义了一个<code>task_create(void (*task_entry)(void))</code>函数来创建任务，此函数传入的参数为一个函数指针，即用户态的应用程序的地址。在创建任务时我们首先需要为每个任务先构造该任务的trap上下文，包括入口地址和用户栈指针，并将其压入到内核栈顶，然后设置<code>sepc、sstatus、sp</code>寄存器的值。这一步和上一章一样，下一步就是需要为每一个任务构造一个初始的内核的任务上下文，这里会调用一个<code>tcx_init</code>的函数，在这个函数里面我们会初始化任务的任务上下文。再完成<code>trap</code>上下文和任务上下文的构造后会将<code>_top</code>的值加一代表多了一个任务</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_create</span><span class="params">(<span class="type">void</span> (*task_entry)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_top &lt; MAX_TASKS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 对于每个任务先构造该任务的trap上下文，包括入口地址和用户栈指针，并将其压入到内核栈顶*/</span></span><br><span class="line">        TrapContext* cx_ptr = &amp;KernelStack[_top] + KERNEL_STACK_SIZE - <span class="keyword">sizeof</span>(TrapContext);</span><br><span class="line">        <span class="type">reg_t</span> user_sp = &amp;UserStack[_top] + USER_STACK_SIZE;</span><br><span class="line">        <span class="type">reg_t</span> sstatus = r_sstatus();</span><br><span class="line">        <span class="comment">// 设置 sstatus 寄存器第8位即SPP位为0 表示为U模式</span></span><br><span class="line">        sstatus &amp;= (<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        w_sstatus(sstatus);</span><br><span class="line">        <span class="comment">/* 设置用户程序内核栈 ，填充用户栈指针*/</span></span><br><span class="line">        cx_ptr-&gt;sepc = (<span class="type">reg_t</span>)task_entry;</span><br><span class="line">        cx_ptr-&gt;sstatus = sstatus; </span><br><span class="line">        cx_ptr-&gt;sp = user_sp;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 构造每个任务任务控制块中的任务上下文，设置 ra 寄存器为 __restore 的入口地址*/</span></span><br><span class="line">        tasks[_top].task_context = tcx_init((<span class="type">reg_t</span>)cx_ptr);</span><br><span class="line">        <span class="comment">// 初始化 TaskStatus 字段为 Ready</span></span><br><span class="line">        tasks[_top].task_state = Ready;</span><br><span class="line"></span><br><span class="line">        _top++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后定义了一个<code>tcx_init</code>的函数用来初始化创建的任务的任务上下文信息，传入的参数为任务的内核栈地址，这里为啥把任务的<code>ra</code>寄存器的值设置为<code>__restore</code>，那是因为在应用真正跑起来之前，需要 CPU 第一次从内核态进入用户态。我们在上一篇文章中也介绍过实现方法，只需在内核栈上压入构造好的 Trap 上下文，然后 <code>__restore</code> 即可。但是现在我们是通过<code>__switch</code>来进行任务切换的，而<code>__switch</code>切换完成后会返回到<code>ra</code>的地方执行，我们这里第一次将<code>ra</code>设置为<code>__restore</code>，那么程序就可以从内核态切换回用户态执行了，为此我们需要定义一个<code>run_first_task()</code>的函数来完成第一次切换。可以看见在<code>run_first_task()</code>函数中，先构造了一个<code>_unused</code>的任务上下文，然后调用<code>__switch</code>函数让切换到<code>tasks[0]</code>进行执行，用于初始化时<code>tasks[0]</code>的<code>ra</code>被设置成了<code>__restore</code>的地址，所以就能去返回用户态运行<code>task0</code>了。需要注意的是， <code>__restore</code> 的实现需要做出变化：它 不再需要 在开头 <code>mv sp, a0</code> 了。因为在 <code>__switch</code> 之后，<code>sp</code> 就已经正确指向了我们需要的 <code>Trap </code>上下文地址。</li></ul><blockquote><p>这里我有个疑惑，要是正常的<code>trap</code>执行流，从<code>trap_handler</code>返回后去执行<code>__restore</code>函数，此时难道不应该需要&#96;&#96;mv sp, a0<code> 吗，还是说在</code>trap_handler<code>函数中并没有修改栈指针，从代码逻辑上来看确实不会修改栈指针的值，即使由于一些计算操作需要压栈存储局部变量的值，但是</code>trap_handler<code>执行完毕后，</code>sp&#96;会移动到原本的位置。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TaskContext <span class="title function_">tcx_init</span><span class="params">(<span class="type">reg_t</span> kstack_ptr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> <span class="title">task_ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    task_ctx.ra = __restore;</span><br><span class="line">    task_ctx.sp = kstack_ptr;</span><br><span class="line">    task_ctx.s0 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s1 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s2 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s3 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s4 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s5 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s6 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s7 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s8 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s9 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s10 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s11 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task_ctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run_first_task</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    tasks[<span class="number">0</span>].task_state = Running;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> *<span class="title">next_task_cx_ptr</span> =</span> &amp;(tasks[<span class="number">0</span>].task_context);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> _<span class="title">unused</span> ;</span></span><br><span class="line"></span><br><span class="line">    __switch(&amp;_unused,next_task_cx_ptr);</span><br><span class="line">    panic(<span class="string">&quot;unreachable in run_first_task!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后我们来看<code>schedule()</code>函数，首先判断一下创建的任务数量不为0，然后进行轮转调度，如果下一个任务的状态是<code>ready</code>，那么就切换到下一个任务执行，并且将当前任务的状态置为<code>ready</code>，这里其实应该用for循环的，但是用于我在<code>task_create</code>默认任务的状态为<code>ready</code>，所以这里就无所谓了。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_top &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">panic(<span class="string">&quot;Num of task should be greater than zero!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 轮转调度 */</span></span><br><span class="line">    <span class="type">int</span> next = _current + <span class="number">1</span>;</span><br><span class="line">    next = next % _top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tasks[next].task_state == Ready)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> *<span class="title">current_task_cx_ptr</span> =</span> &amp;(tasks[_current].task_context);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> *<span class="title">next_task_cx_ptr</span> =</span> &amp;(tasks[next].task_context);</span><br><span class="line">        tasks[next].task_state = Running;</span><br><span class="line">        tasks[_current].task_state = Ready;</span><br><span class="line">        _current = next;</span><br><span class="line">        __switch(current_task_cx_ptr,next_task_cx_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h2><p>首先在app.c中新建三个应用程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task1 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        task_delay(<span class="number">10000</span>);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task2 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        task_delay(<span class="number">10000</span>);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task3 is running!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        task_delay(<span class="number">10000</span>);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>task_delay</code>函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a very rough implementaion, just to consume the cpu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_delay</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">count *= <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">while</span> (count--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后调用<code>task_create</code>来创建任务：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">task_create(task1);</span><br><span class="line">task_create(task2);</span><br><span class="line">    task_create(task3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改main函数来执行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;hello timer os!\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   trap_init();</span><br><span class="line"><span class="comment">/* 创建任务 */</span></span><br><span class="line">   task_init();</span><br><span class="line"><span class="comment">/* 执行第一个任务 */</span></span><br><span class="line">   run_first_task();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译测试：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p><img src="/2023/08/10/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/GIF-task.gif" alt="GIF-task"></p><p>可以看见三个任务交替执行打印，没问题！</p><p>这里说一个比较难理解的点就是只有第一次执行应用程序A的时候的<code>ra</code>是<code>__restore</code>，当A任务执行完毕<code>__switch</code>后，它的<code>ra</code>就变成了<code>__switch</code>的下一条地址，就是<code>schedule()</code>函数执行完毕了。第二次B任务调用<code>__switch</code>切换回A的时候，此时就会返回到<code>__switch</code>的下一条地址执行，我们是在<code>__sys_yield()</code>中调用<code>schedule</code>的，所以会依次完成函数调用返回，从<code>schedule</code>返回到<code>__sys_yield</code>，再返回到<code>__SYSCALL</code>，最后返回到<code>trap_handler</code>，而在本文开头提到过<code>trap_handler</code>执行完毕后会去执行<code>__restore</code>，所以这样A才能返回到用户空间程序继续执行。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/2task-switching.html">任务切换 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></li><li><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/3multiprogramming.html">多道程序与协作式调度 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现U模式的trap机制</title>
      <link href="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>好久没更新了，最近在摆烂，天天打瓦洛兰特………………..瓦洛兰特是真好玩啊hhhhh</p></blockquote><h1 id="1-测试用户态的syscall"><a href="#1-测试用户态的syscall" class="headerlink" title="1. 测试用户态的syscall"></a>1. 测试用户态的syscall</h1><h2 id="1-1-riscv特权级切换"><a href="#1-1-riscv特权级切换" class="headerlink" title="1.1 riscv特权级切换"></a>1.1 riscv特权级切换</h2><p><code>RISC-V</code> 架构中一共定义了 4 种特权级：</p><table><thead><tr><th>级别</th><th>编码</th><th>名称</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>用户&#x2F;应用模式 (U, User&#x2F;Application)</td></tr><tr><td>1</td><td>01</td><td>监督模式 (S, Supervisor)</td></tr><tr><td>2</td><td>10</td><td>虚拟监督模式 (H, Hypervisor)</td></tr><tr><td>3</td><td>11</td><td>机器模式 (M, Machine)</td></tr></tbody></table><p>其中级别数值越大，特权级越高，对硬件的控制能力越强。之前移植的Opensbi运行在M模式下，S模式下的程序通过ecall指令去调用Opensbi提供的服务，U模式下的程序同样也可通过ecall指令来获取S模式下提供的服务。</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804215308995.png" alt="image-20230804215308995"></p><p>我们编写的os程序就是运行在S态的，向用户态提供的接口标准被称为ABI。用户态应用直接触发从用户态到内核态的异常的原因总体上可以分为两种：其一是用户态软件为获得内核态操作系统的服务功能而执行特殊指令；其二是在执行某条指令期间产生了错误（如执行了用户态不允许执行的指令或者其他错误）并被 CPU 检测到。特权切换的机制如下图：</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804215429736.png" alt="image-20230804215429736"></p><h2 id="1-2-riscv-系统调用简介"><a href="#1-2-riscv-系统调用简介" class="headerlink" title="1.2 riscv 系统调用简介"></a>1.2 riscv 系统调用简介</h2><p>我们知道我们在<code>linux</code>系统下编写的应用程序是去调用C库的函数去实现对应的功能，而C库呢会去使用内核提供的一组接口去访问硬件设备和操作系统资源，这组接口就被称为系统调用。</p><p>在<code>X86</code>平台上，Linux在用<code>int 0x80</code>进行系统调用时，调用号存在于<code>EAX</code>中，第一个参数存在于<code>EBX</code>，第二个参数存在于<code>ECX</code>，第三个参数存在于<code>EDX</code>。而在<code>riscv</code>平台下，系统调用是通过<code>ecall</code>指令来触发的，<code>ecall</code> 指令规范中没有其他的参数，<code>Syscall</code> 的调用参数和返回值传递通过遵循如下约定实现：</p><ul><li>调用参数<ul><li><code>a7</code> 寄存器存放系统调用号，区分是哪个<code> Syscall</code></li><li><code>a0-a5</code> 寄存器依次用来表示 <code>Syscall </code>编程接口中定义的参数</li></ul></li><li>返回值<ul><li><code>a0</code> 寄存器存放 <code>Syscall </code>的返回值</li></ul></li></ul><p><code>ecall </code>指令会根据当前所处模式触发不同的执行环境切换异常：</p><ul><li>in U-mode: environment-call-from-U-mode exception</li><li>in S-mode: environment-call-from-S-mode exception</li><li>in M-mode: environment-call-from-M-mode exception</li></ul><p><code>Syscall</code> 场景下是在 U-mode（用户模式）下执行 <code>ecall</code> 指令，主要会触发如下变更：</p><ul><li>处理器特权级别由 User-mode（用户模式）提升为 Supervisor-mode（内核模式）</li><li>当前指令地址保存到 <code>sepc</code> 特权寄存器</li><li>设置 <code>scause</code> 特权寄存器</li><li>跳转到 <code>stvec</code> 特权寄存器指向的指令地址</li></ul><h2 id="1-3-riscv-系统调用测试"><a href="#1-3-riscv-系统调用测试" class="headerlink" title="1.3 riscv 系统调用测试"></a>1.3 riscv 系统调用测试</h2><p>首先我在<code>test</code>文件夹下新建了一个<code>syscall</code>目录，里面新建了三个文件：</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804112421014.png" alt="image-20230804112421014"></p><p>首先看<code>Makefile</code>:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=riscv64-unknown-elf-gcc</span><br><span class="line"></span><br><span class="line"><span class="section">write:test_write.c syscall.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$^</span>  -o write.out</span><br></pre></td></tr></table></figure><p>很简单就是编译两个源文件，生成<code>write.out</code></p><p>然后是<code>syscall.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stddef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">uintptr_t</span> arg1, <span class="type">uintptr_t</span> arg2, <span class="type">uintptr_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// Move syscall id to a0 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// Move args[0] to a1 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// Move args[1] to a2 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// Move args[2] to a3 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// Perform syscall</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// Move return value to &#x27;ret&#x27; variable</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见在这里定义了一个<code>syscall</code>函数，传入的参数为系统调用号以及三个参数，通过内联汇编的形式将系统调用号写入了<code>a7</code>寄存器，然后将传入的三个参数分别写入了<code>a0,a1,a2</code>寄存器，然后调用<code>ecall</code>指令进入内核的异常处理程序。再调用完成后内核会将返回值放在<code>a0</code>寄存器中。</p><blockquote><p>在这段代码中，”memory” 是一种内联汇编（inline assembly）中的约束（constraint）。内联汇编是一种在C或C++代码中嵌入汇编指令的技术，它允许直接在高级语言中嵌入底层的汇编代码。</p><p>在这里，”memory” 约束告诉编译器该内联汇编代码可能会读取或修改内存中的数据，因此编译器不能对与内存访问相关的操作进行优化或重排。</p><p>为什么需要这个约束呢？因为系统调用（syscall）可能会对内存中的数据进行读取或修改，而编译器在进行代码优化时通常会假设汇编代码不会影响内存中的数据。如果没有加上 “memory” 约束，编译器可能会错误地优化掉对内存的读写操作，导致系统调用出现问题。</p></blockquote><p><code>test_write.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stddef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">uintptr_t</span> arg1, <span class="type">uintptr_t</span> arg2, <span class="type">uintptr_t</span> arg3)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, RISC-V!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="type">int</span> ret = syscall(<span class="number">0x40</span>,<span class="number">1</span>,message, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>,ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是去调用syscall函数去执行系统调用，它传递了四个参数：<code>0x40</code>代表系统调用号64，它是<code>write</code>系统调用的号码，在RISC-V下是用于输出信息到标准输出的；<code>1</code>是标准输出的文件描述符，<code>message</code>是要输出的字符串的地址，<code>len</code>是要输出的字符串的长度。</p><p>我一直想找在<code>RV64</code>的<code>linux</code>系统下的系统调用号是多少的文档，找了一圈找不到，最后没办法只有去看<code>linux</code>源码中的定义，在内核源码的<code>arch/riscv/include/uapi/asm/unistd.h</code>中，如下：</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804120542275.png" alt="image-20230804120542275"></p><p>打开上面红色箭头这个头文件就能找到系统调用号的定义：</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804120647237.png" alt="image-20230804120647237"></p><p>可以看见<code>write</code>的系统调用号是<code>64</code>即<code>0x40</code>。</p><p>编译，然后用qemu运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star/test/syscall$ make</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star/test/syscall$ qemu-riscv64 wirte.out</span><br><span class="line">Hello, RISC-V!</span><br><span class="line">ret:15</span><br></pre></td></tr></table></figure><p>可以看见输出了<code>Hello, RISC-V!</code>，系统调用成功。<code>qemu-riscv64</code>模拟了一个<code>64</code>位的<code>linux</code>系统，所以可以加载<code>elf</code>格式的可执行文件运行。</p><h1 id="2-内核trap机制简介"><a href="#2-内核trap机制简介" class="headerlink" title="2. 内核trap机制简介"></a>2. 内核trap机制简介</h1><p>首先先明确一下我们的目标是用户态的程序通过ecall指令陷入S态即我们的os，os需要对此次ecall进行处理，处理完毕后返回到用户态继续执行。应用程序被切换回来之后需要从发出系统调用请求的执行位置恢复应用程序上下文并继续执行，这需要在切换前后维持应用程序的上下文保持不变。应用程序的上下文包括通用寄存器和栈两个主要部分。由于 CPU 在不同特权级下共享一套通用寄存器，所以在运行操作系统的 Trap 处理过程中，操作系统也会用到这些寄存器，这会改变应用程序的上下文。因此，与函数调用需要保存函数调用上下文&#x2F;活动记录一样，在执行操作系统的 Trap 处理过程（会修改通用寄存器）之前，我们需要在某个地方（某内存块或内核的栈）保存这些寄存器并在 Trap 处理结束后恢复这些寄存器。这里显而易见我们会使用栈来保存相关的寄存器。</p><h2 id="2-1-与S模式相关的异常寄存器"><a href="#2-1-与S模式相关的异常寄存器" class="headerlink" title="2.1 与S模式相关的异常寄存器"></a>2.1 与S模式相关的异常寄存器</h2><p>与特权级无关的一般的指令和通用寄存器 <code>x0</code> ~ <code>x31</code> 在任何特权级都可以执行。而每个特权级都对应一些特殊指令和 <strong>控制状态寄存器</strong> (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态。当然特权指令不仅具有读写 CSR 的指令，还有其他功能的特权指令。</p><p>如果处于低特权级状态的处理器执行了高特权级的指令，会产生非法指令错误的异常。这样，位于高特权级的执行环境能够得知低特权级的软件出现了错误，这个错误一般是不可恢复的，此时执行环境会将低特权级的软件终止。</p><p>在RV64架构下，寄存器的长度是64位。</p><h3 id="2-1-1-Supervisor-Status-Register-sstatus"><a href="#2-1-1-Supervisor-Status-Register-sstatus" class="headerlink" title="2.1.1 Supervisor Status Register (sstatus)"></a>2.1.1 Supervisor Status Register (sstatus)</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804220746499.png" alt="image-20230804220746499"></p><p>这个寄存器我们主要关注的是<code>bit[8]:SPP</code>，该位表示cpu在进入S模式之前正在执行的特权级别。当接收到trap时，如果该trap来自用户模式，则SPP设置为0，否则设置为1。当执行一条SRET指令从trap处理程序返回时，如果SPP位为0，则特权级别被设置为U模式，如果SPP位为1，则特权级别被设置为S模式;SPP设置为0。</p><h3 id="2-1-2-Supervisor-Trap-Vector-Base-Address-Register-stvec"><a href="#2-1-2-Supervisor-Trap-Vector-Base-Address-Register-stvec" class="headerlink" title="2.1.2 Supervisor Trap Vector Base Address Register (stvec)"></a>2.1.2 Supervisor Trap Vector Base Address Register (<code>stvec</code>)</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804221559975.png" alt="image-20230804221559975"></p><p>stvec寄存器用于设置发生trap时，异常处理程序的地址。</p><ul><li>MODE 位于 [1:0]，长度为 2 bits；</li><li>BASE 位于 [63:2]，长度为 62 bits。</li></ul><p>当 MODE 字段为 0 的时候， <code>stvec</code> 被设置为 Direct 模式，此时进入 S 模式的 Trap 无论原因如何，处理 Trap 的入口地址都是 <code>BASE&lt;&lt;2</code> ，CPU 会跳转到这个地方进行异常处理。当 MODE 字段为 1 的时候，异常触发后会跳转到以BASE字段对应的异常向量表钟，每个向量占4个字节。</p><h3 id="2-1-3-Supervisor-Scratch-Register-sscratch"><a href="#2-1-3-Supervisor-Scratch-Register-sscratch" class="headerlink" title="2.1.3 Supervisor Scratch Register (sscratch)"></a>2.1.3 Supervisor Scratch Register (sscratch)</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804222006617.png" alt="image-20230804222006617"></p><p>sscratch寄存器是一个可读&#x2F;写的辅助寄存器，通常，在hart执行用户代码时，sscratch用于切换上下文的栈。</p><h3 id="2-1-4-Supervisor-Exception-Program-Counter-sepc"><a href="#2-1-4-Supervisor-Exception-Program-Counter-sepc" class="headerlink" title="2.1.4 Supervisor Exception Program Counter (sepc)"></a>2.1.4 Supervisor Exception Program Counter (<code>sepc</code>)</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804222155968.png" alt="image-20230804222155968"></p><p>sepc记录了 Trap 发生之前执行的最后一条指令的地址</p><h3 id="2-1-5-Supervisor-Cause-Register-scause"><a href="#2-1-5-Supervisor-Cause-Register-scause" class="headerlink" title="2.1.5 Supervisor Cause Register (scause)"></a>2.1.5 Supervisor Cause Register (<code>scause</code>)</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804222445725.png" alt="image-20230804222445725"></p><p>scause寄存器记录了S模式下异常发生的原因，最高位为<code>interrupt</code>字段，如下表所示，当<code>interrupt</code>字段为1时，代表触发的异常类型为中断类型。否则为同步类型异常。</p><table><thead><tr><th align="right">Interrupt</th><th align="right">Exception Code</th><th align="left">Description</th><th align="left"></th></tr></thead><tbody><tr><td align="right">1</td><td align="right">0</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">1</td><td align="left">Supervisor software interrupt</td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">2–4</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">5</td><td align="left">Supervisor timer interrupt</td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">6–8</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">9</td><td align="left">Supervisor external interrupt</td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">10–15</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">1</td><td align="right">≥16</td><td align="left"><em>Designated for platform use</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">0</td><td align="left">Instruction address misaligned</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">1</td><td align="left">Instruction access fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">2</td><td align="left">Illegal instruction</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">3</td><td align="left">Breakpoint</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">4</td><td align="left">Load address misaligned</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">5</td><td align="left">Load access fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">6</td><td align="left">Store&#x2F;AMO address misaligned</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">7</td><td align="left">Store&#x2F;AMO access fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">8</td><td align="left">Environment call from U-mode</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">9</td><td align="left">Environment call from S-mode</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">10–11</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">12</td><td align="left">Instruction page fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">13</td><td align="left">Load page fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">14</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">15</td><td align="left">Store&#x2F;AMO page fault</td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">16–23</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">24–31</td><td align="left"><em>Designated for custom use</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">32–47</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">48–63</td><td align="left"><em>Designated for custom use</em></td><td align="left"></td></tr><tr><td align="right">0</td><td align="right">≥64</td><td align="left"><em>Reserved</em></td><td align="left"></td></tr></tbody></table><h3 id="2-1-6-Supervisor-Trap-Value-stval-Register"><a href="#2-1-6-Supervisor-Trap-Value-stval-Register" class="headerlink" title="2.1.6 Supervisor Trap Value (stval) Register"></a>2.1.6 Supervisor Trap Value (<code>stval</code>) Register</h3><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230804223000840.png" alt="image-20230804223000840"></p><p>当处理器陷入S模式时，stval寄存器记录了发生异常的虚拟地址。</p><blockquote><p>更详细的寄存器解释可在这里看见：</p><p><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html">The RISC-V Instruction Set Manual, Volume II: Privileged Architecture | Five EmbedDev (five-embeddev.com)</a></p></blockquote><h2 id="2-2-特权级切换的软硬件控制机制"><a href="#2-2-特权级切换的软硬件控制机制" class="headerlink" title="2.2 特权级切换的软硬件控制机制"></a>2.2 特权级切换的软硬件控制机制</h2><p>当 CPU 执行完一条指令（如 ecall ）并准备从用户特权级 陷入（ Trap ）到 S 特权级的时候，硬件会自动完成如下这些事情：</p><ul><li><code>sstatus</code> 的 <code>SPP</code> 字段会被修改为 CPU 当前的特权级（U&#x2F;S）。</li><li><code>sepc</code> 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。</li><li><code>scause/stval</code> 分别会被修改成这次 Trap 的原因以及相关的附加信息。</li><li>CPU 会跳转到 <code>stvec</code> 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。这里会根据<code>scause</code>中保存的异常原因进行分发处理</li></ul><p>而当 CPU 完成 Trap 处理准备返回的时候，需要通过一条 S 特权级的特权指令 <code>sret</code> 来完成，这一条指令具体完成以下功能：</p><ul><li>CPU 会将当前的特权级按照 <code>sstatus</code> 的 <code>SPP</code> 字段设置为 U 或者 S ；</li><li>CPU 会跳转到 <code>sepc</code> 寄存器指向的那条指令，然后继续执行。</li></ul><p>在具体执行trap处理程序时，由于执行完毕后我们需要恢复到原来的地址继续执行所以我们需要保存寄存器的值，需要恢复知情trap前后的上下文信息，因此需要定义一个栈段来保存用户态的寄存器的值。所以os需要做的软件工作如下：</p><ul><li>应用程序通过 <code>ecall</code> 进入到内核状态时，操作系统保存被打断的应用程序的 Trap 上下文；</li><li>操作系统根据Trap相关的CSR寄存器内容，完成系统调用服务的分发与处理；</li><li>操作系统完成系统调用服务后，需要恢复被打断的应用程序的Trap 上下文，并通 <code>sret</code> 让应用程序继续执行。</li></ul><h1 id="3-为timer-os实现trap机制"><a href="#3-为timer-os实现trap机制" class="headerlink" title="3. 为timer_os实现trap机制"></a>3. 为timer_os实现trap机制</h1><p>我在os目录下新增了一个types.h的文件，里面声明了一些数据定义类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TYPES_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TYPES_H__</span></span><br><span class="line"><span class="comment">// 定义无符号整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RISCV64: 寄存器的大小是64位的</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> <span class="type">reg_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>rv64</code>的寄存器是<code>64</code>位的，用<code>typedef</code>定义了一个<code>reg_t</code>的类型用于定义使用的寄存器</p><h2 id="3-1-寄存器读写"><a href="#3-1-寄存器读写" class="headerlink" title="3.1 寄存器读写"></a>3.1 寄存器读写</h2><p>我在os的目录下新建了一个riscv.h的文件，此文件中定义了一些获取寄存器值的函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RISCV_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RISCV_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 读取 sepc 寄存器的值 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_sepc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sepc&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* scause 记录了异常原因 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_scause</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, scause&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// stval 记录了trap发生时的地址</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_stval</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stval&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* sstatus记录S模式下处理器内核的运行状态*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_sstatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sstatus&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>  <span class="title function_">w_sstatus</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sstatus, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* stvec寄存器 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>  <span class="title function_">w_stvec</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw stvec, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_stvec</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看见用内联汇编的方式来读写与S态相关的控制寄存器的值。</p><h2 id="3-2-用户栈和内核栈定义"><a href="#3-2-用户栈和内核栈定义" class="headerlink" title="3.2 用户栈和内核栈定义"></a>3.2 用户栈和内核栈定义</h2><p>当应用程序在用户态执行ecall指令陷入内核时，内核需要保存应用程序的各个寄存器的值，在内核中我们可以定义一个栈段来进行保存，同时为了为了安全机制，让用户程序不会干扰到内核栈，我们当用户程序在执行时专门为用户程序分配一段栈。由此需要定义一个内核栈专门给S态的内核使用，专门定义一个用户栈给用户程序使用。我在os目录下新建了一个<code>batch.c</code>的文件，在此文件中定义了<code>KernelStack</code>和<code>UserStack</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USER_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="type">uint8_t</span> KernelStack[KERNEL_STACK_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> UserStack[USER_STACK_SIZE];</span><br></pre></td></tr></table></figure><p><code>KernelStack</code>和<code>UserStack</code>的大小被定义为8kb。</p><h2 id="3-3-Trap上下文执行流定义"><a href="#3-3-Trap上下文执行流定义" class="headerlink" title="3.3 Trap上下文执行流定义"></a>3.3 Trap上下文执行流定义</h2><p>Trap上下文执行流的数据就是寄存器中的数据，有<code>x0~x31</code>总共<code>32</code>个通用寄存器以及<code>sstatus</code>和<code>sepc</code>等控制寄存器需要保存。在os目录下新建了一个<code>context.h</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CONTEXT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CONTEXT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="comment">/*S模式的trap上下文*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="type">reg_t</span> x0;</span><br><span class="line"><span class="type">reg_t</span> ra;</span><br><span class="line"><span class="type">reg_t</span> sp;</span><br><span class="line"><span class="type">reg_t</span> gp;</span><br><span class="line"><span class="type">reg_t</span> tp;</span><br><span class="line"><span class="type">reg_t</span> t0;</span><br><span class="line"><span class="type">reg_t</span> t1;</span><br><span class="line"><span class="type">reg_t</span> t2;</span><br><span class="line"><span class="type">reg_t</span> s0;</span><br><span class="line"><span class="type">reg_t</span> s1;</span><br><span class="line"><span class="type">reg_t</span> a0;</span><br><span class="line"><span class="type">reg_t</span> a1;</span><br><span class="line"><span class="type">reg_t</span> a2;</span><br><span class="line"><span class="type">reg_t</span> a3;</span><br><span class="line"><span class="type">reg_t</span> a4;</span><br><span class="line"><span class="type">reg_t</span> a5;</span><br><span class="line"><span class="type">reg_t</span> a6;</span><br><span class="line"><span class="type">reg_t</span> a7;</span><br><span class="line"><span class="type">reg_t</span> s2;</span><br><span class="line"><span class="type">reg_t</span> s3;</span><br><span class="line"><span class="type">reg_t</span> s4;</span><br><span class="line"><span class="type">reg_t</span> s5;</span><br><span class="line"><span class="type">reg_t</span> s6;</span><br><span class="line"><span class="type">reg_t</span> s7;</span><br><span class="line"><span class="type">reg_t</span> s8;</span><br><span class="line"><span class="type">reg_t</span> s9;</span><br><span class="line"><span class="type">reg_t</span> s10;</span><br><span class="line"><span class="type">reg_t</span> s11;</span><br><span class="line"><span class="type">reg_t</span> t3;</span><br><span class="line"><span class="type">reg_t</span> t4;</span><br><span class="line"><span class="type">reg_t</span> t5;</span><br><span class="line"><span class="type">reg_t</span> t6;</span><br><span class="line"><span class="comment">/* S模式下的寄存器 */</span></span><br><span class="line"><span class="type">reg_t</span> sstatus;</span><br><span class="line"><span class="type">reg_t</span> sepc;</span><br><span class="line">&#125;pt_regs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="3-4-Trap上下文的保存和恢复"><a href="#3-4-Trap上下文的保存和恢复" class="headerlink" title="3.4 Trap上下文的保存和恢复"></a>3.4 Trap上下文的保存和恢复</h2><p>在os目录下新建了一个<code>kerneltrap.S</code>的文件，此汇编文件中定义了两个函数：<code>__alltraps 、__restore</code>。</p><p>首先来看<code>__alltraps </code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl __alltraps</span><br><span class="line">.align 4</span><br><span class="line">__alltraps:</span><br><span class="line">    # 从sscratch获取S模式下的SP，把U模式下的SP保存到sscratch寄存器中</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    # allocate a TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, -34*8</span><br><span class="line">    # save general-purpose registers</span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    # skip sp(x2), we will save it later</span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    # skip tp(x4), application does not use it</span><br><span class="line">    # save x5~x31</span><br><span class="line">    sd x4, 4*8(sp)</span><br><span class="line">    sd x5, 5*8(sp)</span><br><span class="line">    sd x6, 6*8(sp)</span><br><span class="line">    sd x7, 7*8(sp)</span><br><span class="line">    sd x8, 8*8(sp)</span><br><span class="line">    sd x9, 9*8(sp)</span><br><span class="line">    sd x10,10*8(sp)</span><br><span class="line">    sd x11, 11*8(sp)</span><br><span class="line">    sd x12, 12*8(sp)</span><br><span class="line">    sd x13, 13*8(sp)</span><br><span class="line">    sd x14, 14*8(sp)</span><br><span class="line">    sd x15, 15*8(sp)</span><br><span class="line">    sd x16, 16*8(sp)</span><br><span class="line">    sd x17, 17*8(sp)</span><br><span class="line">    sd x18, 18*8(sp)</span><br><span class="line">    sd x19, 19*8(sp)</span><br><span class="line">    sd x20, 20*8(sp)</span><br><span class="line">    sd x21, 21*8(sp)</span><br><span class="line">    sd x22, 22*8(sp)</span><br><span class="line">    sd x23, 23*8(sp)</span><br><span class="line">    sd x24, 24*8(sp)</span><br><span class="line">    sd x25, 25*8(sp)</span><br><span class="line">    sd x26, 26*8(sp)</span><br><span class="line">    sd x27, 27*8(sp)</span><br><span class="line">    sd x28, 28*8(sp)</span><br><span class="line">    sd x29, 29*8(sp)</span><br><span class="line">    sd x30, 30*8(sp)</span><br><span class="line">    sd x31, 31*8(sp)</span><br><span class="line"></span><br><span class="line">    # we can use t0/t1/t2 freely, because they were saved on kernel stack</span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    # read user stack from sscratch and save it on the kernel stack</span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    # set input argument of trap_handler(TrapContext)</span><br><span class="line">    mv a0, sp</span><br><span class="line">    call trap_handler</span><br></pre></td></tr></table></figure><p><code>__alltraps </code>函数就是发生异常时的处理函数，在此函数中：</p><ul><li>第五行中将sscratch和sp的值进行了交换，在进入此函数时sp指向的是用户栈，sscratch中的值保存的是内核栈的栈顶。进行交换后，由于此时进入了S态，所以需要切换栈，由此就切换到了内核栈。</li><li>然后就是将寄存器的值保存进内核栈中，在上面上下文的定义可以看见pt_regs中定义了34个寄存器，所以通过<code>addi sp, sp, -34*8</code>指令来压栈，然后依次保存寄存器的值</li><li>最后两行将内核栈的sp保存进a0寄存器用于传参，所以将用户态寄存器保存进内核栈后，调用了<code>trap_handler</code>函数，在此函数中可通过a0传入的参数访问内核栈中储存的寄存器的值。</li></ul><p>然后是<code>__restore</code>函数，此函数需要将内核栈中的存储的寄存器的值恢复，然后通过<code>sret</code>指令返回从S态到用户态继续执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl __restore</span><br><span class="line">.align 4</span><br><span class="line">__restore:</span><br><span class="line">    # case1: start running app by __restore</span><br><span class="line">    # case2: back to U after handling trap</span><br><span class="line">    mv sp, a0</span><br><span class="line">    # now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack</span><br><span class="line">    # restore sstatus/sepc</span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    ld t2, 2*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    csrw sscratch, t2</span><br><span class="line">    # restore general-purpuse registers except sp/tp</span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    ld x4, 4*8(sp)</span><br><span class="line">    ld x5, 5*8(sp)</span><br><span class="line">    ld x6, 6*8(sp)</span><br><span class="line">    ld x7, 7*8(sp)</span><br><span class="line">    ld x8, 8*8(sp)</span><br><span class="line">    ld x9, 9*8(sp)</span><br><span class="line">    ld x10,10*8(sp)</span><br><span class="line">    ld x11, 11*8(sp)</span><br><span class="line">    ld x12, 12*8(sp)</span><br><span class="line">    ld x13, 13*8(sp)</span><br><span class="line">    ld x14, 14*8(sp)</span><br><span class="line">    ld x15, 15*8(sp)</span><br><span class="line">    ld x16, 16*8(sp)</span><br><span class="line">    ld x17, 17*8(sp)</span><br><span class="line">    ld x18, 18*8(sp)</span><br><span class="line">    ld x19, 19*8(sp)</span><br><span class="line">    ld x20, 20*8(sp)</span><br><span class="line">    ld x21, 21*8(sp)</span><br><span class="line">    ld x22, 22*8(sp)</span><br><span class="line">    ld x23, 23*8(sp)</span><br><span class="line">    ld x24, 24*8(sp)</span><br><span class="line">    ld x25, 25*8(sp)</span><br><span class="line">    ld x26, 26*8(sp)</span><br><span class="line">    ld x27, 27*8(sp)</span><br><span class="line">    ld x28, 28*8(sp)</span><br><span class="line">    ld x29, 29*8(sp)</span><br><span class="line">    ld x30, 30*8(sp)</span><br><span class="line">    ld x31, 31*8(sp)</span><br><span class="line"></span><br><span class="line">    # release TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, 34*8</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;user stack, sscratch-&gt;kernel stack</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure><ul><li><code>__restore</code>函数的定义为<code>__restore(pt_regs *next)</code>，所以在第一行传入内核栈地址，然后将内核栈中存放的寄存器的值恢复，然后切换sp，最后通过sret返回用户态继续执行</li><li>在最后两行会将<code>sp</code>指向用户栈，<code>sscratch</code>指向内核栈</li></ul><h2 id="3-5-编写应用程序测试"><a href="#3-5-编写应用程序测试" class="headerlink" title="3.5 编写应用程序测试"></a>3.5 编写应用程序测试</h2><h3 id="3-5-1-编写应用程序"><a href="#3-5-1-编写应用程序" class="headerlink" title="3.5.1 编写应用程序"></a>3.5.1 编写应用程序</h3><p>我在<code>batch.c</code>中新增了一段用户代码的程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// Move syscall id to a7 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// Move args[0] to a1 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// Move args[1] to a2 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// Move args[2] to a3 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// Perform syscall</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// Move return value to &#x27;ret&#x27; variable</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testsys</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    syscall(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    syscall(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    syscall(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见在<code>testsys()</code>函数中，调用了三次syscall函数进行测试，每一次传入的参数都不同，仅用于测试。</p><h3 id="3-5-2-trap-c"><a href="#3-5-2-trap-c" class="headerlink" title="3.5.2 trap.c"></a>3.5.2 trap.c</h3><p>在上面的<code>__alltraps</code>函数中，调用了<code>trap_handler</code>函数对异常进行处理，因此我们需要实现此函数，我在os目录下定义了一个<code>trap.c</code>的文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __alltraps(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __restore(pt_regs *next);</span><br><span class="line">pt_regs* <span class="title function_">trap_handler</span><span class="params">(pt_regs* cx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> scause = r_scause() ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cause:%x\n&quot;</span>,scause);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a0:%x\n&quot;</span>,cx-&gt;a0);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a1:%x\n&quot;</span>,cx-&gt;a1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a2:%x\n&quot;</span>,cx-&gt;a2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a7:%x\n&quot;</span>,cx-&gt;a7);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sepc:%x\n&quot;</span>,cx-&gt;sepc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sstatus:%x\n&quot;</span>,cx-&gt;sstatus);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sp:%x\n&quot;</span>,cx-&gt;sp);</span><br><span class="line"></span><br><span class="line">cx-&gt;sepc += <span class="number">8</span>;</span><br><span class="line">__restore(cx);</span><br><span class="line"><span class="keyword">return</span> cx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trap_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置 trap 时调用函数的基地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">w_stvec((<span class="type">reg_t</span>)__alltraps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了两个函数，其中<code>trap_init</code>用于设置<code>stvec</code>寄存器的值，这里是告诉cpu发生异常时处理函数的地址，将其设置为<code>__alltraps</code>的地址。</p><p><code>trap_handler</code>函数中打印了内核栈中储存的寄存器的值，在syscall中对a0,a1,a2,a7寄存器的值进行了修改，这些寄存器的值通过<code>__alltraps</code>函数会保存在内核栈中，然后将内核栈的地址放入a0寄存器中作为函数参数传了出来，因为我们可以在此来进行异常的分发，这里只是打印传入的系统调用参数来验证。在系统调用的逻辑处理完后，需要将sepc 的值+8，然后调用</p><p><code>__restore</code>函数来恢复寄存器的值，同时切换栈指针到用户栈，并通过<code>sret</code>返回到<code>sepc+8</code>的地址处继续执行代码。</p><h3 id="3-5-3-测试代码"><a href="#3-5-3-测试代码" class="headerlink" title="3.5.3 测试代码"></a>3.5.3 测试代码</h3><p>我们直接看代码，再分析逻辑，在<code>batch.c</code>中新增了如下代码：</p><p>代码测试逻辑是：伪造一个内核栈，然后通过<code>__restore</code>函数从S态返回U态进行函数执行，返回的地址设置为testsys()函数的地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __restore(pt_regs *next);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">tasks</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_init_context</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">reg_t</span> user_sp = &amp;UserStack + USER_STACK_SIZE;</span><br><span class="line"></span><br><span class="line">    trap_init();</span><br><span class="line"></span><br><span class="line">    <span class="type">reg_t</span> sstatus = r_sstatus();</span><br><span class="line">    <span class="comment">// 设置 sstatus 寄存器第8位即SPP位为0 表示为U模式</span></span><br><span class="line">    sstatus &amp;= (<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    w_sstatus(sstatus);</span><br><span class="line"></span><br><span class="line">    tasks.sepc = (<span class="type">reg_t</span>)testsys;</span><br><span class="line">    tasks.sstatus = sstatus;</span><br><span class="line">    tasks.sp = user_sp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pt_regs* cx_ptr = &amp;KernelStack[<span class="number">0</span>] + KERNEL_STACK_SIZE - <span class="keyword">sizeof</span>(pt_regs);</span><br><span class="line">    cx_ptr-&gt;sepc = tasks.sepc;</span><br><span class="line">    cx_ptr-&gt;sstatus = tasks.sstatus;</span><br><span class="line">    cx_ptr-&gt;sp = tasks.sp;</span><br><span class="line"></span><br><span class="line">    __restore(cx_ptr); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先得到了用户栈的地址，因为栈是从高地址往低地址向下增长的，所以用户栈的地址为<code>&amp;UserStack + USER_STACK_SIZE</code></li><li>然后调用<code>trap_init</code>函数来设置<code>stvec</code>寄存器的值为<code>__alltraps</code>，这里告诉cpu发生trap时去哪里执行</li><li>然后设置sstatus寄存器的SPP位为0。这是为啥呢？在上面对寄存器的介绍中提到“当执行一条SRET指令从trap处理程序返回时，如果SPP位为0，则特权级别被设置为U模式，如果SPP位为1，则特权级别被设置为S模式;”所以我们为了从S模式返回用户模式去执行testsys()中的代码，我们需要将SPP位设置为0。</li><li>然后就是事先构造一段内核栈，设置<code>sstatus</code>、<code>sepc</code>、<code>sp</code>的值，这里由于下一阶段为用户模式，所以sepc会设置成用户态程序的地址，sp设置为用户栈的地址。</li><li>设置完成后调用<code>__restore</code>函数，让其返回用户态执行程序。</li></ul><h3 id="3-5-4-编译测试"><a href="#3-5-4-编译测试" class="headerlink" title="3.5.4 编译测试"></a>3.5.4 编译测试</h3><p>在<code>main.c</code>中调用<code>app_init_context();</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;hello timer os!\n&quot;</span>);</span><br><span class="line">   app_init_context();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>Makefile</code>，添加新增的源文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SRCS_ASM = \</span><br><span class="line">entry.S \</span><br><span class="line">kerneltrap.S \</span><br><span class="line"></span><br><span class="line">SRCS_C = \</span><br><span class="line">sbi.c \</span><br><span class="line">main.c \</span><br><span class="line"><span class="built_in">printf</span>.c \</span><br><span class="line">batch.c \</span><br><span class="line">trap.c \</span><br></pre></td></tr></table></figure><p><code>Makefile</code>还修改了一个地方</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">os.elf: $&#123;OBJS&#125;</span></span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; -T os.ld -Wl,-Map=os.map -o os.elf <span class="variable">$^</span></span><br><span class="line">$&#123;OBJCOPY&#125; -O binary os.elf os.bin</span><br></pre></td></tr></table></figure><p>这里新增了<code>-Wl,-Map=os.map</code>选项，会在编译时生成一个<code>os.map</code>的符号表用于调试。</p><p>回到<code>timer@DESKTOP-JI9EVEH:~/quard-star$</code>目录，构建执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20230805152216059.png" alt="image-20230805152216059"></p><p>可以看见进行系统调用的参数都成功打印，验证成功。cause的值为8，对应上面的异常原因表可以看见是U模式的系统调用。</p><blockquote><p>但是这里有个很奇怪的点就是，每次返回的sepc都是同一个地址，我很奇怪，按道理来说每次syscall都会去调用一次ecall指令，所以sepc应该会被设置成每次syscall的ecall的地址，由于我进行了多次syscall调用sepc会不同，但是实际上每次都sepc都被设置成了同一个ecall的地址。转念一想，编译器确实在处理syscall函数时，其中ecall这条指令的地址始终是不会变的，但是我疑惑为什么将此地址+8后，就能跳到下一条正确的地址执行…………</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>说明一下，我的<code>timer_os</code>其实是在复现并修改<code>rCore</code>，<code>rCore</code>是<code>rust</code>编写的<code>os</code>，我想把它改成c语言的用于个人学习。此篇文章对应的是<code>rCore</code>第二章-批处理系统的内容</p><ul><li><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/index.html">第二章：批处理系统 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></li><li><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html">The RISC-V Instruction Set Manual, Volume II: Privileged Architecture | Five EmbedDev (five-embeddev.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>riscv编译工具链构建说明</title>
      <link href="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="riscv编译工具链构建说明"><a href="#riscv编译工具链构建说明" class="headerlink" title="riscv编译工具链构建说明"></a>riscv编译工具链构建说明</h2><p>构建<code>riscv-gnu-toolchain</code>有几种方式：</p><ul><li>第一种是直接下载源码然后本地编译，然后 <code>make install</code></li><li>第二种如果使用的是<code>ubuntu20</code>，可以直接使用 apt 安装</li><li>第三种就是下载别人已经编译好的文件，然后解压，配置一下工具链路径</li></ul><p>编译器有这几种类型，以64位的编译器为例子，三种不同类型编译器的区别后面会说明</p><ul><li>riscv64-linux-gnu-gcc</li><li>riscv64-unknown-elf-gcc</li><li>riscv64-unknown-linux-gnu-gcc</li></ul><h2 id="源码构建"><a href="#源码构建" class="headerlink" title="源码构建"></a><strong>源码构建</strong></h2><p><code>riscv-gnu-toolchain</code>的官方仓库在：<a href="https://github.com/riscv-collab/riscv-gnu-toolchain">riscv-collab&#x2F;riscv-gnu-toolchain: GNU toolchain for RISC-V, including GCC (github.com)</a>，下载上面的源码，然后按照官方提供的编译命令进行编译安装，但是绝大多数时候是编译不过的，因为官方的源码依赖种的第三方文件我们下载不下来，有一个解决办法就是去<code>gittee</code>镜像上去把对应的包下载然后放进源码种，这样编译是能成功。关于如何在<code>gittee</code>上去下载第三方依赖请各位百度。</p><p>官网提供的编译方式如下：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716140122180.png" alt="image-20230716140122180"></p><p>这里建议直接使用第三种配置编译方式，可以编译生成32位和64位的编译器：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/opt/riscv --enable-multilib</span><br></pre></td></tr></table></figure><blockquote><p>这里使用源码编译太操蛋了，我捣鼓了好久，不推荐</p></blockquote><h2 id="apt-构建"><a href="#apt-构建" class="headerlink" title="apt 构建"></a><strong>apt 构建</strong></h2><p><code>apt</code>构建会比较简单，这里只针对<code>ubuntu20.04</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libc6-riscv64-cross</span><br><span class="line">sudo apt install binutils-riscv64-linux-gnu</span><br><span class="line">sudo apt install gcc-riscv64-linux-gnu</span><br><span class="line">sudo apt install binutils-riscv64-unknown-elf</span><br><span class="line">sudo apt install gcc-riscv64-unknown-elf</span><br></pre></td></tr></table></figure><p>执行上面的命令会生成两种类型的编译器：</p><ul><li>riscv64-linux-gnu-gcc</li><li>riscv64-unknown-elf-gcc</li></ul><p>但是<code>riscv64-unknown-elf-gcc</code>这个编译器是不含c库的，比如你的代码种如果包含了<code>stdio.h</code>想使用<code>printf</code>函数就会报错。不推荐使用<code>apt install</code>安装的<code>riscv64-unknown-elf-gcc</code>编译器。</p><p><code>riscv64-linux-gnu-gcc</code>，使用这个编译器就可以使用C库了，例如我有下面这样一段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用编译器来编译：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc hello.c</span><br></pre></td></tr></table></figure><p>然后使用<code>qemu</code>来执行</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-riscv64 a.out</span><br></pre></td></tr></table></figure><p>这里应该会报一个错误：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-riscv64: Could not open <span class="string">&#x27;/lib/ld-linux-riscv64-lp64.d.so.1&#x27;</span>:No such file or direcyory</span><br></pre></td></tr></table></figure><p>没找到文件的原因是，因为文件下载的地方，和查找的地方不一样，只要把文件cp一下就可以了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /usr/riscv64-linux-gnu/lib/* /lib/</span><br></pre></td></tr></table></figure><p>然后再运行应该就没问题了。</p><h2 id="下载二进制文件构建"><a href="#下载二进制文件构建" class="headerlink" title="下载二进制文件构建"></a><strong>下载二进制文件构建</strong></h2><p>进入<code>riscv-gnu-toolchain</code>的<code>github</code>仓库，找到右边的<code>tags</code></p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143145875.png" alt="image-20230716143145875"></p><p>点击进入：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143217518.png" alt="image-20230716143217518"></p><p>可以看见这里有已经编译好的二进制文件，截至我打开的时候，最新的版本是2023.07.07，点击进入</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716143310196.png" alt="image-20230716143310196"></p><p>这里有已经编译好的编译器，分别对应不同的ubuntu版本，有32位和64位两个版本的。</p><p>其中<code>riscv64-elf-ubuntu-20.04-gcc-nightly-2023.07.07-nightly.tar.gz</code>解压后的编译器就是：<code>riscv64-unknown-elf-gcc</code>，<strong>但是官方编译的版本是带C库的</strong>。</p><p><code>riscv64-glibc-ubuntu-20.04-llvm-nightly-2023.07.07-nightly.tar.gz</code>解压后的编译器是：<code>riscv64-unknown-linux-gnu-gcc</code>，假设你用这个编译器去编译上面的<code>hello.c</code>文件，编译是没问题的，但是如果你使用<code>qemu-riscv64 a.out</code>去执行，同样会报错误：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> qemu-riscv64: Could not open <span class="string">&#x27;/lib/ld-linux-riscv64-lp64.d.so.1&#x27;</span>:No such file or direcyory</span><br></pre></td></tr></table></figure><p>同样我们也想到可以将这个编译器的<code>lib</code>文件拷贝过去，但是我在它的<code>lib</code>种却找不到这个动态库，如下：</p><p><img src="/2023/07/16/riscv%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9E%84%E5%BB%BA/image-20230716144055264.png" alt="image-20230716144055264"></p><p>如果说你拷贝了<code>riscv64-linux-gnu-gcc</code>,那么这里执行应该不会报错。</p><blockquote><p>riscv的编译工具链真的很操蛋！！！！！！！！！！</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://blog.csdn.net/bebebug/article/details/127829361">qemu-riscv64: could not open ‘&#x2F;lib&#x2F;ld-linux-riscv64-lp64d.so.1‘_qemu-x86_64: could not open ‘&#x2F;lib64&#x2F;ld-linux-x86-6_嵌入一下？的博客-CSDN博客</a></p></li><li><p><a href="https://blog.csdn.net/Longyu_wlz/article/details/109150134">(69条消息) qemu 运行 riscv 内核失败记录_longyu_wlz的博客-CSDN博客</a></p></li><li><p><a href="https://gitee.com/unicornx/riscv-operating-system-mooc/issues/I4D6N9">stdio.h 头文件找不到 · Issue #I4D6N9 · unicornx&#x2F;riscv-operating-system-mooc - Gitee.com</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> riscv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装printf函数</title>
      <link href="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/"/>
      <url>/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-可变参数"><a href="#1-可变参数" class="headerlink" title="1. 可变参数"></a>1. 可变参数</h1><h2 id="1-1-可变参数的使用"><a href="#1-1-可变参数的使用" class="headerlink" title="1.1 可变参数的使用"></a>1.1 可变参数的使用</h2><p>在实现<code>printf</code>函数之前，我们必须先了解以下在可变参数是如何实现的，在C语言标准库中，可变参数是通过如下几个函数或者宏定义来实现的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va_list；</span><br><span class="line">va_start(ap,v);</span><br><span class="line">va_arg(ap,type)</span><br><span class="line">va_end(ap)</span><br></pre></td></tr></table></figure><p>先举一个在x86架构下使用可变参数的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStrings</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* str = va_arg(args, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    printStrings(<span class="number">3</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码就会打印：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">!</span><br></pre></td></tr></table></figure><p><code>va_list</code>的使用方法：</p><ul><li><p>首先在函数中定义一个具有<code>va_list</code>型的变量，这个变量是指向参数的指针。</p></li><li><p>然后用<code>va_start</code>宏初始化变量刚定义的<code>va_list</code>变量，使其指向第一个可变参数的地址。</p></li><li><p>然后<code>va_arg</code>返回可变参数，<code>va_arg</code>的第二个参数是你要返回的参数的类型（如果多个可变参数，依次调用<code>va_arg</code>获取各个参数）。</p></li><li><p>最后使用<code>va_end</code>宏结束可变参数的获取。</p></li></ul><p>在使用<code>va_list</code>是应该注意以下问题：</p><ul><li><p>可变参数的类型和个数完全由代码控制，<strong>它并不能智能地识别不同参数的个数和类型</strong>，正因为如此所以在上面的测试打印代码中我们需要传入一个参数的count值：3</p></li><li><p>如果我们不需要一一详解每个参数，只需要将可变列表拷贝到某个缓冲区，可以用vsprintf函数。</p></li><li><p>因为编译器对可变参数的函数原型检查不够严格，对编程查错不利，不利于我们写出高质量的代码</p></li></ul><h2 id="1-2-可变参数在不同架构下的体现"><a href="#1-2-可变参数在不同架构下的体现" class="headerlink" title="1.2 可变参数在不同架构下的体现"></a>1.2 可变参数在不同架构下的体现</h2><p>首先我们来看一下在i386架构下的一个可变参数的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将可变参数全部入栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"><span class="comment">//在32位系统栈帧分配的单元大小是4字节(一个参数占4字节)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap,v) (ap = (va_list)&amp;v )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap,t) (*(t*)(ap += sizeof(t *)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap = (va_list)0)   <span class="comment">//直接将va_list 置为空指针</span></span></span><br></pre></td></tr></table></figure><p>在32位x86架构下ABI的规定中函数的参数会被依次入栈，从右往左依次压入栈中，因此可变参数的实现可以以上面的形式实现，va_start指向的是第一个参数的地址，由于参数依次排列在栈中，所以其余的参数可以依次取出来，32位的栈帧的单元大小是4字节。</p><p>所以上面的测试代码在i386架构下参数的排列方式如下：参数1就是 count：3</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714125352038.png" alt="image-20230714125352038"></p><p>我们来做个测试验证以下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">//将可变参数全部入栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* Va_list;</span><br><span class="line"><span class="comment">//在64位系统栈帧分配的单元大小是8字节(一个参数占8字节)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Va_start(ap,v) (ap = (Va_list)&amp;v )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Va_arg(ap,t) (*(t*)(ap += sizeof(t *)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Va_end(ap) (ap = (Va_list)0)   <span class="comment">//直接将Va_list 置为空指针</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_str</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1 <span class="comment">//i386</span></span></span><br><span class="line">    <span class="comment">/*这里就是复现上面可变参数的逻辑*/</span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;count;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(<span class="type">int</span> *)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// riscv64</span></span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;fmt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">int</span>*)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**) * <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s1 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span> * s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s3 = <span class="string">&quot;fuck you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s4 = <span class="string">&quot;riscv&quot;</span>;</span><br><span class="line">    print_str(s1,s2,s3,s4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后用<code>qemu-i386</code>运行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -O0 -m32   va_list.c -o i386.out</span><br><span class="line">qemu-i386 i386.out</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714130132793.png" alt="image-20230714130132793"></p><p>可以看见正常答应所有的参数，证明在i386架构下参数是依次排列在栈中的，至于我为什么要打印“fuck you riscv”等下就会知道啦哈哈哈。</p><p>所以在32为X86架构下我们可以自己实现一个可变参数宏，但是我们的quard_star是64位的riscv架构，函数参数在栈中的排布是和编译器息息相关的，为了方便测试，我们建立如下文件夹：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714130510136.png" alt="image-20230714130510136"></p><p>其中<code>va_list.c</code>做了一点修改：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_str</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;fmt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;fmt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**) * <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> * s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s3 = <span class="string">&quot;fuck you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s4 = <span class="string">&quot;riscv&quot;</span>;</span><br><span class="line">    print_str(s1,s2,s3,s4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.c先不管，<code>build.sh</code>的内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -O0 -m32   va_list.c -o i386.out</span><br><span class="line">riscv64-unknown-elf-gcc -O0 va_list.c -o riscv64.out</span><br><span class="line">riscv32-unknown-elf-gcc -O0   va_list.c -o riscv32.out</span><br><span class="line"></span><br><span class="line">objdump -D i386.out &gt; i386_debug.txt</span><br><span class="line">riscv64-unknown-elf-objdump -D riscv64.out &gt; riscv64_debug.txt</span><br><span class="line">riscv32-unknown-elf-objdump -D riscv32.out &gt; riscv32_debug.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  qemu-i386 i386.out</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  qemu-riscv64 riscv64.out</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  qemu-riscv32 riscv32.out</span></span><br></pre></td></tr></table></figure><p>可以看见会分别把<code>va_list.c</code>编译成I386架构、riscv32架构、riscv64架构的可执行程序，然后将可执行程序反汇编输出到各自的.txt文件中。</p><p>我们来<code>qemu-i386 i386.out</code>，可以看见正常输出没问题：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714132744656.png" alt="image-20230714132744656"></p><p>如果riscv64架构下编译器也把函数参数一个个依次排放在栈中，那么执行的结果肯定和i386一样，ok，我们<code>qemu-riscv64 riscv64.out</code>运行一下。</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714132823543.png" alt="image-20230714132823543"></p><p>可以看见除了第一个参数正常输出了，后面的直接报错了。这是为啥呢，我们来看一下生成的汇编代码，打开<code>riscv64_debug.txt</code>，找到<code>main</code>函数和<code>print_str</code>函数</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714133334185.png" alt="image-20230714133334185"></p><p>可以看见在main函数中将4个函数参数分别放进了a0,a1,a2,a3寄存器，这是riscv的ABI规定的：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714133447075.png" alt="image-20230714133447075"></p><p>a0~a7用于函数传参，然后我们找到<code>print_str</code>函数：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714133548385.png" alt="image-20230714133548385"></p><p>在<code>print_str</code>函数的栈帧中，可以看见编译器将a0放在了栈中一个奇怪的位置，这里的a0中存的就是第一个参数，后面三个参数的值是依次排放的，ok我们来做一下测试：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_str</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;fmt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">//riscv64</span></span></span><br><span class="line">    <span class="type">void</span>* ap = (<span class="type">void</span>*)&amp;fmt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**) * <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line">    ap += <span class="keyword">sizeof</span>(<span class="type">char</span>**);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(<span class="type">char</span>**)ap);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> * s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s3 = <span class="string">&quot;fuck you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * s4 = <span class="string">&quot;riscv&quot;</span>;</span><br><span class="line">    print_str(s1,s2,s3,s4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中我在获取第一个参数后，在获取第二个参数时：<code>ap += sizeof(char**) * 6;</code>，将偏移量乘了6，那是因为在上面汇编代码中，我们发现a0和a1在栈中的偏移量是48个字节，在64位系统中栈帧每个单元为8个字节，因此乘以六刚刚好可以访问到。运行看一下结果：</p><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714134132200.png" alt="image-20230714134132200"></p><p>正常输出没问题，因此在riscv64下编译器有自己的一套存放参数的方式，我无法自己实现一个类似i386架构下的可变参数宏，不知道写编译器的人做了哪些操作，我去看源码里riscv架构也没定义va_list宏。可以看看这篇博客：</p><p><a href="https://blog.csdn.net/guoqx/article/details/128510503">编程参考 - va_list的定义问题_va_list 头文件_夜流冰的博客-CSDN博客</a></p><h1 id="2-实现printf函数"><a href="#2-实现printf函数" class="headerlink" title="2. 实现printf函数"></a>2. 实现printf函数</h1><p>由于printf函数需要用到可变参数，但是上面的分析中不知道如何在riscv64下实现自己的va_list系列的宏，那我们就只有使用编译器提供的了</p><p>先看一下os目录下新增了哪些文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star/os$ <span class="built_in">ls</span></span><br><span class="line">Makefile  entry.S  main.c  os.h  os.ld  printf.c  sbi.c  sbi.h</span><br></pre></td></tr></table></figure><p><code>os.h</code>：用extern声明了两个函数，包含了<code>&lt;stdarg.h&gt;</code>头文件，这里有可变参数相关的宏</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OS_H__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* printf */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span>  <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __OS_H__ */</span></span></span><br></pre></td></tr></table></figure><p><code>printf.c</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_puts</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (*s) &#123;</span><br><span class="line">sbi_console_putchar(*s++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _vsnprintf(<span class="type">char</span> * out, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> format = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> longarg = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; *s; s++) &#123;</span><br><span class="line"><span class="keyword">if</span> (format) &#123;</span><br><span class="line"><span class="keyword">switch</span>(*s) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: &#123;</span><br><span class="line">longarg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: &#123;</span><br><span class="line">longarg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: &#123;</span><br><span class="line"><span class="type">long</span> num = longarg ? va_arg(vl, <span class="type">long</span>) : va_arg(vl, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> hexdigits = <span class="number">2</span>*(longarg ? <span class="keyword">sizeof</span>(<span class="type">long</span>) : <span class="keyword">sizeof</span>(<span class="type">int</span>))<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = hexdigits; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="type">int</span> d = (num &gt;&gt; (<span class="number">4</span>*i)) &amp; <span class="number">0xF</span>;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = (d &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+d : <span class="string">&#x27;a&#x27;</span>+d<span class="number">-10</span>);</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">longarg = <span class="number">0</span>;</span><br><span class="line">format = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: &#123;</span><br><span class="line"><span class="type">long</span> num = longarg ? va_arg(vl, <span class="type">long</span>) : va_arg(vl, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">num = -num;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> digits = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> nn = num; nn /= <span class="number">10</span>; digits++);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = digits<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos + i &lt; n) &#123;</span><br><span class="line">out[pos + i] = <span class="string">&#x27;0&#x27;</span> + (num % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">num /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos += digits;</span><br><span class="line">longarg = <span class="number">0</span>;</span><br><span class="line">format = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s2 = va_arg(vl, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line"><span class="keyword">while</span> (*s2) &#123;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = *s2;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">s2++;</span><br><span class="line">&#125;</span><br><span class="line">longarg = <span class="number">0</span>;</span><br><span class="line">format = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: &#123;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = (<span class="type">char</span>)va_arg(vl,<span class="type">int</span>);</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">longarg = <span class="number">0</span>;</span><br><span class="line">format = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">format = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = *s;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">out[pos] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (out &amp;&amp; n) &#123;</span><br><span class="line">out[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> out_buf[<span class="number">1000</span>]; <span class="comment">// buffer for _vprintf()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _vprintf(<span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br><span class="line"><span class="keyword">if</span> (res+<span class="number">1</span> &gt;= <span class="keyword">sizeof</span>(out_buf)) &#123;</span><br><span class="line">uart_puts(<span class="string">&quot;error: output string size overflow\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br><span class="line">uart_puts(out_buf);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">va_list vl;</span><br><span class="line">va_start(vl, s);</span><br><span class="line">res = _vprintf(s, vl);</span><br><span class="line">va_end(vl);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;panic: &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码抄的是<a href="https://github.com/plctlab/riscv-operating-system-mooc/tree/main">plctlab&#x2F;riscv-operating-system-mooc: 《从头写一个RISC-V OS》课程配套的资源 (github.com)</a>里的代码，简单说一下实现<code>printf</code>函数的逻辑，</p><p>一般来说printf函数有多个参数，其中第一个参数为一个字符串，后面的可变参数是为了对应到如<code>%d,%s,%c</code>等格式化性质，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arg1:%d arg2:%s&quot;</span>,<span class="number">5</span>,<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>所以printf函数的定义形式为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br></pre></td></tr></table></figure><p>根据上面的代码来分析，首先定义printf函数:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">va_list vl;</span><br><span class="line">va_start(vl, s);</span><br><span class="line">res = _vprintf(s, vl);</span><br><span class="line">va_end(vl);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的res实际上是第一个参数的字符串的长度，核心的函数为<code>_vprintf</code>，代码中将第一个参数的指针即<code>va_list vl;</code>和第一个参数实际的值传给了_vprintf</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> out_buf[<span class="number">1000</span>]; <span class="comment">// buffer for _vprintf()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _vprintf(<span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br><span class="line"><span class="keyword">if</span> (res+<span class="number">1</span> &gt;= <span class="keyword">sizeof</span>(out_buf)) &#123;</span><br><span class="line">uart_puts(<span class="string">&quot;error: output string size overflow\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br><span class="line">uart_puts(out_buf);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在_vprintf函数中首先先执行可一段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br></pre></td></tr></table></figure><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714153025258.png" alt="image-20230714153025258"></p><p>分析一下发现这里会返回printf函数第一个参数的长度，比如：<code>printf(&quot;arg:%s&quot;,&quot;hello&quot;)</code>,那么res的值就是<code>&quot;arg:%s&quot;</code>的长度即6。然后判断一下是否超过最大长度。然后再调用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br></pre></td></tr></table></figure><p><code>_vsnprintf</code>就是用来对字符串进行格式化的，通过判断第一个参数里<code>%</code>的个数来确定可变参数的个数，详细的实现可以看上面代码。</p><p><code>main.c</code>:比较简单，就是调用printf函数来输出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;hello timer os!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Makefile</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SRCS_C = \</span><br><span class="line">sbi.c \</span><br><span class="line">main.c \</span><br><span class="line">printf.c \</span><br><span class="line">#加一行</span><br></pre></td></tr></table></figure><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p><img src="/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/image-20230714154140591.png" alt="image-20230714154140591"></p><p>成功打印！</p><p>如果发现编译错误，在makefile里加一个编译命令：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = -nostdlib -fno-builtin -mcmodel=medany</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://blog.csdn.net/guoqx/article/details/128510503"> 编程参考 - va_list的定义问题_va_list 头文件_夜流冰的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/124197544"> riscv代码调试遇到过的问题及坑___pop_的博客-CSDN博客</a></li><li><a href="https://www.cnblogs.com/qiwu1314/p/9844039.html">va_list函数学习 - 小雨滴答 - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/119185091">risc-v与SBI与ABI_sbi 操作系统___pop_的博客-CSDN博客</a></li><li><a href="https://softwareengineering.stackexchange.com/questions/232838/what-is-the-underlying-mechanism-behind-va-list-and-where-is-it-defined">c - What is the underlying mechanism behind va_list and where is it defined? - Software Engineering Stack Exchange</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> riscv </tag>
            
            <tag> opensbi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Opensbi服务完成控制台输出</title>
      <link href="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/"/>
      <url>/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中我们移植了Opensbi，大概了解了Opensbi是用来干嘛的，这一篇文章我们来详细介绍一下RISC-V Supervisor Binary Interface，即SBI。并且开启手写操作系统之路，首先利用Opensbi提供的服务来是实现串口打印。</p><h1 id="1-RISC-V-Supervisor-Binary-Interface"><a href="#1-RISC-V-Supervisor-Binary-Interface" class="headerlink" title="1. RISC-V Supervisor Binary Interface"></a>1. RISC-V Supervisor Binary Interface</h1><p>SBI允许在所有RISC-V实现上，通过定义平台（或虚拟化管理程序）特定功能的抽象，使监管者模式（S模式或VS模式）的软件具备可移植性。简单来说就是RISCV官方定义了一个规范接口，运行在S模式或VS模式的软件如os可以使用这些标准接口使得能够在不同的硬件平台上具有良好的移植性而不用去适配。SBI有两种架构，一种是CPU未启动虚拟化拓展，一种是启动了虚拟化功能的CPU。</p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710111828688.png" alt="image-20230710111828688"></p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710111842503.png" alt="image-20230710111842503"></p><p>如上图，SBI就是M模式和S模式之间的桥梁，是一套接口规范，我们已未启动虚拟化即未支持H拓展的CPU为例子。Opensbi就是上图中的SEE，向上给OS提供了接口，这些接口可以认为是不同的SBI函数，通过ecall指令来进行调用。所有的SBI函数共享一种二进制编码方式。</p><p>sbi规范到现在已经有两个大版本：v0.1 v0.2。为了保持兼容性，SBI扩展ID（EID）和SBI函数ID（FID）被编码为有符号的32位整数。新版本为0.2，在0.2版本中，函数调用的规定如下：</p><ul><li><p>在监管者和SEE之间，使用ECALL作为控制传输指令，监管者就是S模式的软件程序</p></li><li><p>a7编码SBI扩展ID（EID）</p></li><li><p>a6编码SBI函数ID（FID），对于任何在a7中编码的SBI扩展，其定义在SBI v0.2之后。</p></li><li><p>在SBI调用期间，除了a0和a1寄存器外，所有寄存器都必须由被调用方保留。</p></li><li><p>SBI函数必须在a0和a1中返回一对值，其中a0返回错误代码。类似于返回C结构体。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">long</span> error;</span><br><span class="line"> <span class="type">long</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>错误类型</th><th>值</th></tr></thead><tbody><tr><td>SBI_SUCCESS 成功</td><td>0</td></tr><tr><td>SBI_ERR_FAILED 失败</td><td>-1</td></tr><tr><td>SBI_ERR_NOT_SUPPORTED 不支持操作</td><td>-2</td></tr><tr><td>SBI_ERR_INVALID_PARAM 非法参数</td><td>-3</td></tr><tr><td>SBI_ERR_DENIED 拒绝</td><td>-4</td></tr><tr><td>SBI_ERR_INVALID_ADDRESS 非法地址</td><td>-5</td></tr><tr><td>SBI_ERR_ALREADY_AVAILABLE (资源)已可用</td><td>-6</td></tr><tr><td>SBI_ERR_ALREADY_STARTED (操作)已启动</td><td>-7</td></tr><tr><td>SBI_ERR_ALREADY_STOPPED (操作)已停止</td><td>-8</td></tr></tbody></table><p>EID和FID共同决定了调用的函数是什么，其中基本拓展函数如下：EID都为0x10</p><table><thead><tr><th>函数名</th><th>SBI 版本</th><th>FID</th><th>EID</th><th>用途</th></tr></thead><tbody><tr><td>sbi_get_sbi_spec_version</td><td>0.2</td><td>0</td><td>0x10</td><td>获取SBI规范版本</td></tr><tr><td>sbi_get_sbi_impl_id</td><td>0.2</td><td>1</td><td>0x10</td><td>获取SBI实现标识符</td></tr><tr><td>sbi_get_sbi_impl_version</td><td>0.2</td><td>2</td><td>0x10</td><td>获取SBI实现版本</td></tr><tr><td>sbi_probe_extension</td><td>0.2</td><td>3</td><td>0x10</td><td>探测SBI扩展功能</td></tr><tr><td>sbi_get_mvendorid</td><td>0.2</td><td>4</td><td>0x10</td><td>获取机器供应商标识符</td></tr><tr><td>sbi_get_marchid</td><td>0.2</td><td>5</td><td>0x10</td><td>获取机器体系结构标识符</td></tr><tr><td>sbi_get_mimpid</td><td>0.2</td><td>6</td><td>0x10</td><td>获取机器实现标识符ID</td></tr></tbody></table><p>传统的 SBI 扩展与 SBI v0.2（或更高版本）规范相比，遵循略微不同的调用约定，其中：</p><ul><li>a6 寄存器中的 SBI 函数ID 字段被忽略，因为这些被编码为多个 SBI 扩展 ID。</li><li>a1寄存器中不返回任何值。</li><li>在 SBI 调用期间，除 a0 寄存器外的所有寄存器都必须由被调用者保留。</li><li>a0 寄存器中返回的值是特定于 SBI 传统扩展的。</li><li>SBI 实现在监管者访问内存时发生的页面和访问故障会被重定向回监管者，并且 sepc 寄存器指向故障的 ECALL指令。</li></ul><table><thead><tr><th>函数名</th><th>SBI 版本</th><th>FID</th><th>EID</th><th>替代 EID</th><th>函数用途</th></tr></thead><tbody><tr><td>sbi_set_timer</td><td>0.1</td><td>0</td><td>0x00</td><td>0x54494D45</td><td>设置时钟</td></tr><tr><td>sbi_console_putchar</td><td>0.1</td><td>0</td><td>0x01</td><td>N&#x2F;A</td><td>控制台字符输出</td></tr><tr><td>sbi_console_getchar</td><td>0.1</td><td>0</td><td>0x02</td><td>N&#x2F;A</td><td>控制台字符输入</td></tr><tr><td>sbi_clear_ipi</td><td>0.1</td><td>0</td><td>0x03</td><td>N&#x2F;A</td><td>清除IPI</td></tr><tr><td>sbi_send_ipi</td><td>0.1</td><td>0</td><td>0x04</td><td>0x735049</td><td>发送IPI</td></tr><tr><td>sbi_remote_fence_i</td><td>0.1</td><td>0</td><td>0x05</td><td>0x52464E43</td><td>远程FENCE.I</td></tr><tr><td>sbi_remote_sfence_vma</td><td>0.1</td><td>0</td><td>0x06</td><td>0x52464E43</td><td>远程SFENCE.VMA</td></tr><tr><td>sbi_remote_sfence_vma_asid</td><td>0.1</td><td>0</td><td>0x07</td><td>0x52464E43</td><td>远程SFENCE.VMA（指定地址空间标识符）</td></tr><tr><td>sbi_shutdown</td><td>0.1</td><td>0</td><td>0x08</td><td>0x53525354</td><td>系统关闭</td></tr><tr><td>保留</td><td></td><td></td><td>0x09-0x0F</td><td></td><td></td></tr></tbody></table><p>我们使用到的sbi的函数不多，初步了解这些就够了，sbi的所有的详细规范定义请参考如下文档：</p><ul><li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">riscv-sbi-doc</a></li><li><a href="https://zhuanlan.zhihu.com/p/634337322">RISC-V SBI-1.0.0版本 中文 - 知乎 (zhihu.com)</a></li></ul><h1 id="2-基于Opensbi完成控制台输出"><a href="#2-基于Opensbi完成控制台输出" class="headerlink" title="2. 基于Opensbi完成控制台输出"></a>2. 基于Opensbi完成控制台输出</h1><p>目标：在S模式下使用<code>ecall</code>指定调用<code>sbi_console_putchar</code>函数向控制台打印字符</p><h2 id="2-1-untrusted-domain-起始地址修改"><a href="#2-1-untrusted-domain-起始地址修改" class="headerlink" title="2.1 untrusted-domain 起始地址修改"></a>2.1 untrusted-domain 起始地址修改</h2><p>在上一篇文章中，我们为<code>quard_star</code>划分了<code>domain</code>，<code>opensbi</code>是运行在<code>untrusted-domain</code>中的，在<code>quard_star</code>的设备树文件中指定了两个<code>domain</code>的地址参数：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">next-arg1 = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x82200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">next-addr</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x82000000</span>&gt;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure><p>这两个参数一个是下级程序的参数，一个是下级程序的起始地址，在前面提到我们的下级程序是uboot也可以直接是内核，为了使这个项目更有意义，我们来手写一个操作系统，就不使用uboot和linux系统了，关于如何移植uboot和linux内核请按照第一篇中参考博客中的方法继续走下去。在我的代码仓库中也移植成功了，可以参考一下移植uboot的commit。</p><blockquote><p>这里需要说明一下在移植uboot时，使用riscv64-unknown-elf-gcc这个编译器是不行的，编译uboot需要riscv64-unknown-linux-gnu-gcc，关于交叉编译工具链的编译配置这里我就不详解了，网上有许多教程。我的项目中使用的uboot版本为<code>uboot-2023.04</code></p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710135412615.png" alt="image-20230710135412615"></p></blockquote><p>因此下级程序即为我们编写的OS，这里修改一下下级程序的地址和参数，将下级程序的起始地址改成了<code>0x80200000</code>，下级程序的参数随便给，这里先留着不修改吧</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next-arg1 = &lt;0x0 0x82000000&gt;; </span><br><span class="line">next-addr = &lt;0x0 0x80200000&gt;; </span><br></pre></td></tr></table></figure><h2 id="2-2-创建OS"><a href="#2-2-创建OS" class="headerlink" title="2.2 创建OS"></a>2.2 创建OS</h2><p>在quard_star目录下新建os文件夹，在此文件夹中编写我们的操作系统程序，然后新建了这些文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star/os$ <span class="built_in">ls</span></span><br><span class="line">Makefile   entry.S  main.c  os.ld  sbi.c  sbi.h</span><br></pre></td></tr></table></figure><h3 id="2-2-1-entry-S"><a href="#2-2-1-entry-S" class="headerlink" title="2.2.1 entry.S"></a>2.2.1 entry.S</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     .section .text.entry</span><br><span class="line">     .globl _start</span><br><span class="line">_start:</span><br><span class="line">    la sp, boot_stack_top</span><br><span class="line">    call os_main</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:</span><br></pre></td></tr></table></figure><p>这段代码主要就是定义了一个大小为 4096 * 16 字节 &#x3D; 64kb的连续内存空间，用作栈空间。将栈指针sp指向栈顶位置，然后调用os_main这个函数，os_main函数定义在main.c中</p><h3 id="2-2-2-sbi-c-和-sbi-h"><a href="#2-2-2-sbi-c-和-sbi-h" class="headerlink" title="2.2.2 sbi.c 和 sbi.h"></a>2.2.2 sbi.c 和 sbi.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*sbi.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SBI_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SBI_H__</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_id</span> &#123;</span></span><br><span class="line">SBI_EXT_0_1_SET_TIMER = <span class="number">0x0</span>,</span><br><span class="line">SBI_EXT_0_1_CONSOLE_PUTCHAR = <span class="number">0x1</span>,</span><br><span class="line">SBI_EXT_0_1_CONSOLE_GETCHAR = <span class="number">0x2</span>,</span><br><span class="line">SBI_EXT_0_1_CLEAR_IPI = <span class="number">0x3</span>,</span><br><span class="line">SBI_EXT_0_1_SEND_IPI = <span class="number">0x4</span>,</span><br><span class="line">SBI_EXT_0_1_REMOTE_FENCE_I = <span class="number">0x5</span>,</span><br><span class="line">SBI_EXT_0_1_REMOTE_SFENCE_VMA = <span class="number">0x6</span>,</span><br><span class="line">SBI_EXT_0_1_REMOTE_SFENCE_VMA_ASID = <span class="number">0x7</span>,</span><br><span class="line">SBI_EXT_0_1_SHUTDOWN = <span class="number">0x8</span>,</span><br><span class="line">SBI_EXT_BASE = <span class="number">0x10</span>,</span><br><span class="line">SBI_EXT_TIME = <span class="number">0x54494D45</span>,</span><br><span class="line">SBI_EXT_IPI = <span class="number">0x735049</span>,</span><br><span class="line">SBI_EXT_RFENCE = <span class="number">0x52464E43</span>,</span><br><span class="line">SBI_EXT_HSM = <span class="number">0x48534D</span>,</span><br><span class="line">SBI_EXT_SRST = <span class="number">0x53525354</span>,</span><br><span class="line">SBI_EXT_PMU = <span class="number">0x504D55</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sbi 返回结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> &#123;</span></span><br><span class="line"><span class="type">long</span> error;</span><br><span class="line"><span class="type">long</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*sbi.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> sbiret <span class="title function_">sbi_ecall</span><span class="params">(<span class="type">int</span> ext, <span class="type">int</span> fid, <span class="type">unsigned</span> <span class="type">long</span> arg0,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg1, <span class="type">unsigned</span> <span class="type">long</span> arg2,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg3, <span class="type">unsigned</span> <span class="type">long</span> arg4,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg5)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用GCC的扩展语法，用于将一个值存储到RISC-V架构中的寄存器a0中。</span></span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a0 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a0&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg0);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a1 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a1&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg1);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a2 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a2&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg2);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a3 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a3&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg3);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a4 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a4&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg4);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a5 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a5&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg5);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a6 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a6&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(fid);</span><br><span class="line"><span class="keyword">register</span> <span class="type">uintptr_t</span> a7 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a7&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(ext);</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ecall&quot;</span></span></span><br><span class="line"><span class="params">      : <span class="string">&quot;+r&quot;</span> (a0), <span class="string">&quot;+r&quot;</span> (a1)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a3), <span class="string">&quot;r&quot;</span> (a4), <span class="string">&quot;r&quot;</span> (a5), <span class="string">&quot;r&quot;</span> (a6), <span class="string">&quot;r&quot;</span> (a7)</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">ret.error = a0;</span><br><span class="line">ret.value = a1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_console_putchar() - Writes given character to the console device.</span></span><br><span class="line"><span class="comment"> * @ch: The data to be written to the console.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">sbi_ecall(SBI_EXT_0_1_CONSOLE_PUTCHAR, <span class="number">0</span>, ch, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sbi的头文件中定义了EID的枚举变量和sbi 的返回结构体，然后再sbi.c中定义了一个sbi_ecall的函数用于调用Opensbi提供的服务，最后定义了sbi_console_putchar函数传入想要输出的字符，然后传入EID和FID，去查上面的表EID&#x3D;0x01,FID&#x3D;0。</p><blockquote><p>这里的代码我是抄的uboot的，有兴趣的可以去看一下uboot的源码</p><p>参考链接：<a href="https://chsgcxy.github.io/messy_notes/riscv/opensbi.html">OpenSBI - Messy Notes (chsgcxy.github.io)</a></p></blockquote><h3 id="2-2-3-main-c"><a href="#2-2-3-main-c" class="headerlink" title="2.2.3 main.c"></a>2.2.3 main.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c定义了os_main()函数，在os_main()函数中依次打印字符输出“hello!”</p><h3 id="2-2-4-os-ld"><a href="#2-2-4-os-ld" class="headerlink" title="2.2.4 os.ld"></a>2.2.4 os.ld</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123; </span><br><span class="line">ram (rxai!w) : ORIGIN = 0x80200000, LENGTH = 128M</span><br><span class="line">&#125;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">.text : &#123;</span><br><span class="line">*(.text .text.*)</span><br><span class="line">&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">.rodata : &#123;</span><br><span class="line">*(.rodata .rodata.*)</span><br><span class="line">&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">.data : &#123;</span><br><span class="line">. = ALIGN(4096);</span><br><span class="line">*(.sdata .sdata.*)</span><br><span class="line">*(.data .data.*)</span><br><span class="line">PROVIDE(_data_end = .);</span><br><span class="line">&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">.bss :&#123;</span><br><span class="line">*(.sbss .sbss.*)</span><br><span class="line">*(.bss .bss.*)</span><br><span class="line">*(COMMON)</span><br><span class="line">&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接脚本如上，其中os的可执行文件会被链接到0x80200000的位置</p><h3 id="2-2-5-makefile"><a href="#2-2-5-makefile" class="headerlink" title="2.2.5 makefile"></a>2.2.5 makefile</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CROSS_COMPILE = riscv64-unknown-elf-</span><br><span class="line">CFLAGS = -nostdlib -fno-builtin </span><br><span class="line"></span><br><span class="line"><span class="comment"># riscv64-unknown-elf-gcc 工具链可以同时编译汇编和 C 代码</span></span><br><span class="line">CC = $&#123;CROSS_COMPILE&#125;gcc</span><br><span class="line">OBJCOPY = $&#123;CROSS_COMPILE&#125;objcopy</span><br><span class="line">OBJDUMP = $&#123;CROSS_COMPILE&#125;objdump</span><br><span class="line"></span><br><span class="line">SRCS_ASM = \</span><br><span class="line">entry.S</span><br><span class="line"></span><br><span class="line">SRCS_C = \</span><br><span class="line">sbi.c \</span><br><span class="line">main.c \</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将源文件替换为 .o 文件</span></span><br><span class="line">OBJS = $(SRCS_ASM:.S=.o)</span><br><span class="line">OBJS += $(SRCS_C:.c=.o)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">os.elf: $&#123;OBJS&#125;</span></span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; -T os.ld  -o os.elf <span class="variable">$^</span></span><br><span class="line">$&#123;OBJCOPY&#125; -O binary os.elf os.bin</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line">%.o : %.S</span><br><span class="line">$&#123;CC&#125; $&#123;CFLAGS&#125; -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o *.bin *.elf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译链接生成os.bin</p><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h1><p>首先修改一下build.sh，先编译os，新增如下内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译os</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/os&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/os</span><br><span class="line">fi</span><br><span class="line">cd $SHELL_FOLDER/os</span><br><span class="line">make</span><br><span class="line">cp $SHELL_FOLDER/os/os.bin $SHELL_FOLDER/output/os/os.bin</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>合成固件：</p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710133710167.png" alt="image-20230710133710167"></p><p>然后将修改<code>boot/start.s</code>将<code>os.bin</code>加载到<em>0x80200000</em>的位置</p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710133940156.png" alt="image-20230710133940156"></p><p>编译运行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./build.sh</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure><p>运行结果如下，可以看见成功打印“hello！”</p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710134405374.png" alt="image-20230710134405374"></p><p>现在的内存布局如下：</p><p><img src="/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/image-20230710140718546.png" alt="image-20230710140718546"></p>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> riscv </tag>
            
            <tag> opensbi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于opensbi为quard_star创建domain</title>
      <link href="/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/"/>
      <url>/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Opensbi之domain机制"><a href="#1-Opensbi之domain机制" class="headerlink" title="1. Opensbi之domain机制"></a>1. Opensbi之domain机制</h1><p>OpenSBI（Open Source Supervisor Binary Interface）的 domain 机制是一种用于管理和隔离不同软件实体（例如操作系统、虚拟机）的机制。它提供了一种在系统中划分资源和权限的方法，以确保软件实体之间的相互隔离和安全性。</p><p>在 OpenSBI 中，domain 是一种逻辑上的实体，它代表了一个软件实体，可以是一个操作系统、一个虚拟机或其他一些执行环境。每个 domain 都有自己的一组资源和权限，包括处理器（Hart）、内存、设备和中断等。domain 之间是相互隔离的，它们不能直接访问或干扰彼此的资源。</p><p>OpenSBI 的 domain 机制通过以下方式实现：</p><ol><li>Domain ID：每个 domain 都有一个唯一的标识符，称为 Domain ID。它用于区分不同的 domain。</li><li>Hart Mask：OpenSBI 使用 Hart Mask 来表示哪些处理器属于特定的 domain。Hart Mask 是一个位图，每个位代表一个处理器，可以将相应的位设置为 1 表示该处理器属于某个 domain。</li><li>SBI 接口：OpenSBI 提供了一组 SBI（Supervisor Binary Interface）接口，用于 domain 之间的通信和资源管理。这些接口包括中断处理、内存管理、设备访问等，可以由 domain 使用来请求和管理资源。</li></ol><p>通过 domain 机制，OpenSBI 可以实现不同软件实体的隔离和安全性。每个 domain 只能访问自己被授权的资源，并且不能越权访问其他 domain 的资源。这样可以确保系统的稳定性和安全性，并支持多个软件实体在同一硬件平台上共存和运行。</p><p>在opensbi的doc目录下的<code>domain_support.md</code>文档介绍了如何使用设备树来基于opensbi来划分domain，在文档中提到默认情况下，所有的 HART 都被分配给 <code>ROOT domain</code>。OpenSBI 平台支持可以通过平台特定的回调函数提供 HART 到 domain 实例的分配。同时也可以使用设备树来定义<code>domain</code>，文档中举了一个设备树的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chosen &#123;</span><br><span class="line">    opensbi-domains &#123;</span><br><span class="line">        compatible = &quot;opensbi,domain,config&quot;;</span><br><span class="line"></span><br><span class="line">        tmem: tmem &#123;</span><br><span class="line">            compatible = &quot;opensbi,domain,memregion&quot;;</span><br><span class="line">            base = &lt;0x0 0x80100000&gt;;</span><br><span class="line">            order = &lt;20&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        tuart: tuart &#123;</span><br><span class="line">            compatible = &quot;opensbi,domain,memregion&quot;;</span><br><span class="line">            base = &lt;0x0 0x10011000&gt;;</span><br><span class="line">            order = &lt;12&gt;;</span><br><span class="line">            mmio;</span><br><span class="line">            devices = &lt;&amp;uart1&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        allmem: allmem &#123;</span><br><span class="line">            compatible = &quot;opensbi,domain,memregion&quot;;</span><br><span class="line">            base = &lt;0x0 0x0&gt;;</span><br><span class="line">            order = &lt;64&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        tdomain: trusted-domain &#123;</span><br><span class="line">            compatible = &quot;opensbi,domain,instance&quot;;</span><br><span class="line">            possible-harts = &lt;&amp;cpu0&gt;;</span><br><span class="line">            regions = &lt;&amp;tmem 0x7&gt;, &lt;&amp;tuart 0x7&gt;;</span><br><span class="line">            boot-hart = &lt;&amp;cpu0&gt;;</span><br><span class="line">            next-arg1 = &lt;0x0 0x0&gt;;</span><br><span class="line">            next-addr = &lt;0x0 0x80100000&gt;;</span><br><span class="line">            next-mode = &lt;0x0&gt;;</span><br><span class="line">            system-reset-allowed;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        udomain: untrusted-domain &#123;</span><br><span class="line">            compatible = &quot;opensbi,domain,instance&quot;;</span><br><span class="line">            possible-harts = &lt;&amp;cpu1 &amp;cpu2 &amp;cpu3 &amp;cpu4&gt;;</span><br><span class="line">            regions = &lt;&amp;tmem 0x0&gt;, &lt;&amp;tuart 0x0&gt;, &lt;&amp;allmem 0x7&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpus &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;0&gt;;</span><br><span class="line">    timebase-frequency = &lt;10000000&gt;;</span><br><span class="line"></span><br><span class="line">    cpu0: cpu@0 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        reg = &lt;0x00&gt;;</span><br><span class="line">        compatible = &quot;riscv&quot;;</span><br><span class="line">        opensbi-domain = &lt;&amp;tdomain&gt;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        reg = &lt;0x01&gt;;</span><br><span class="line">        compatible = &quot;riscv&quot;;</span><br><span class="line">        opensbi-domain = &lt;&amp;udomain&gt;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu2: cpu@2 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        reg = &lt;0x02&gt;;</span><br><span class="line">        compatible = &quot;riscv&quot;;</span><br><span class="line">        opensbi-domain = &lt;&amp;udomain&gt;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu3: cpu@3 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        reg = &lt;0x03&gt;;</span><br><span class="line">        compatible = &quot;riscv&quot;;</span><br><span class="line">        opensbi-domain = &lt;&amp;udomain&gt;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu4: cpu@4 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        reg = &lt;0x04&gt;;</span><br><span class="line">        compatible = &quot;riscv&quot;;</span><br><span class="line">        opensbi-domain = &lt;&amp;udomain&gt;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uart1: serial@10011000 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这份设备树中需要定义如下三个节点：</p><ul><li><p><code>Domain Configuration Node</code></p><p>这里就是要定义compatible &#x3D; “opensbi,domain,config”;</p></li><li><p><code>Domain Memory Region Node</code></p><p>这里是定义和内存相关的节点，域内存区域设备树节点的属性如下：</p><ul><li>compatible（必选）- 域内存区域的兼容字符串。该设备树属性的值应为 “opensbi,domain,memregion”。</li><li>base（必选）- 域内存区域的基地址。该设备树属性应为2^order对齐的64位地址（即两个设备树单元）。</li><li>order（必选）- 域内存区域的阶数。该设备树属性应为32位值（即一个设备树单元），取值范围为 3 &lt;&#x3D; order &lt;&#x3D; __riscv_xlen。</li><li>mmio（可选）- 一个布尔标志，表示域内存区域是否为内存映射I&#x2F;O（MMIO）区域。</li><li>devices（可选）- 设备列表，其中包含属于此域内存区域的设备设备树节点的句柄。</li></ul></li><li><p><code>Domain Instance Node</code></p><ul><li><p><code>compatible</code>（必选）-:域实例的兼容字符串。该设备树属性的值应为 “opensbi,domain,instance”。</p></li><li><p><code>possible-harts</code>（可选）- 域实例的CPU设备树节点句柄列表。该列表表示域实例的可能HART集合。 </p></li><li><p><code>regions</code>（可选）- 域实例的域内存区域设备树节点句柄和访问权限列表。每个列表条目都是一个设备树节点句柄和访问权限的对。访问权限以32位掩码表示，具有可读（BIT[0]）、可写（BIT[1]）、可执行（BIT[2]）和M模式（BIT[3]）的位。</p></li><li><p><code>boot-hart</code>（可选）- 引导域实例的HART的设备树节点句柄。如果将冷启动HART分配给域实例，则忽略此设备树属性，并假定冷启动HART是域实例的引导HART。 </p></li><li><p><code>next-arg1</code>（可选）- 域实例的64位下一个引导阶段arg1。如果此设备树属性不可用且未将冷启动HART分配给域实例，则使用默认值0x0。如果此设备树属性不可用且将冷启动HART分配给域实例，则使用冷启动HART的下一个引导阶段arg1作为默认值。 </p></li><li><p><code>next-addr</code>（可选）- 域实例的64位下一个引导阶段地址。如果此设备树属性不可用且未将冷启动HART分配给域实例，则使用默认值0x0。如果此设备树属性不可用且将冷启动HART分配给域实例，则使用冷启动HART的下一个引导阶段地址作为默认值。</p></li><li><p><code> next-mode</code>（可选）- 域实例的32位下一个引导阶段模式。该设备树属性的可能值为：0x1（s模式）和0x0（u模式）。如果此设备树属性不可用且未将冷启动HART分配给域实例，则使用默认值0x1。如果此设备树属性不可用且将冷启动HART分配给域实例，则使用冷启动HART的下一个引导阶段模式作为默认值。</p></li><li><p><code> system-reset-allowed</code>（可选）- 一个布尔标志，表示是否允许域实例进行系统复位。</p></li></ul></li></ul><h1 id="2-为quard-star划分domain"><a href="#2-为quard-star划分domain" class="headerlink" title="2. 为quard_star划分domain"></a>2. 为quard_star划分domain</h1><h2 id="2-1-修改quard-star设备树"><a href="#2-1-修改quard-star设备树" class="headerlink" title="2.1 修改quard_star设备树"></a>2.1 修改quard_star设备树</h2><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">stdout-path</span> <span class="operator">=</span> <span class="string">&quot;/soc/uart0@10000000&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">opensbi-domains</span> <span class="punctuation">&#123;</span>  <span class="comment">/* 定义opensbi-domains描述节点 */</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,config&quot;</span><span class="punctuation">;</span> <span class="comment">/* 节点名称 */</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">           tmem:</span> <span class="title class_">tmem</span> <span class="punctuation">&#123;</span>   <span class="comment">/* 定义内存节点 */</span></span><br><span class="line">               <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,memregion&quot;</span><span class="punctuation">;</span>  <span class="comment">/* 节点名称 */</span></span><br><span class="line">               <span class="attr">base</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xb0000000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 起始地址注意64位地址哦 */</span></span><br><span class="line">               <span class="attr">order</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">28</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 内存大小即size=2^28 */</span></span><br><span class="line">           <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">           tuart:</span> <span class="title class_">tuart</span> <span class="punctuation">&#123;</span>  <span class="comment">/* 定义mmio节点 */</span></span><br><span class="line">               <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,memregion&quot;</span><span class="punctuation">;</span>  <span class="comment">/* 节点名称 */</span></span><br><span class="line">               <span class="attr">base</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x10002000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 起始地址 */</span></span><br><span class="line">               <span class="attr">order</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">8</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* size=2^8 */</span></span><br><span class="line">               <span class="attr">mmio</span><span class="punctuation">;</span>  <span class="comment">/* mmio属性 */</span></span><br><span class="line">               <span class="attr">devices</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;uart2</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 关联到设备节点上 */</span></span><br><span class="line">           <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    allmem:</span> <span class="title class_">allmem</span> <span class="punctuation">&#123;</span> <span class="comment">/* 定义内存节点，这个节点保护所有地址 */</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,memregion&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">base</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">order</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">           tdomain:</span> <span class="title class_">trusted-domain</span> <span class="punctuation">&#123;</span> <span class="comment">/* 定义domian节点 */</span></span><br><span class="line">               <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,instance&quot;</span><span class="punctuation">;</span>  <span class="comment">/* 节点名称 */</span></span><br><span class="line">               <span class="attr">possible-harts</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu7</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* dumian中允许使用的cpu core */</span></span><br><span class="line">               <span class="attr">regions</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;tmem</span> <span class="number">0x7</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;tuart</span> <span class="number">0x7</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;allmem</span> <span class="number">0x7</span>&gt;</span><span class="punctuation">;</span><span class="comment">/* 各个内存/mmio区域的权限，3bit读写运行权限 0x7拥有全部权限 */</span></span><br><span class="line">               <span class="attr">boot-hart</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu7</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* domian中用于boot的core */</span></span><br><span class="line">               next-arg1 = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x00000000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 下级程序的参数 */</span></span><br><span class="line">        <span class="attr">next-addr</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xb0000000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 下级程序的起始地址 */</span></span><br><span class="line">        <span class="attr">next-mode</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 下级程序的允许模式 0为U模式，1为S模式 */</span></span><br><span class="line">               <span class="attr">system-reset-allowed</span><span class="punctuation">;</span> <span class="comment">/* 允许复位 */</span></span><br><span class="line">           <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    udomain:</span> <span class="title class_">untrusted-domain</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;opensbi,domain,instance&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">possible-harts</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu0</span> <span class="variable">&amp;cpu1</span> <span class="variable">&amp;cpu2</span> <span class="variable">&amp;cpu3</span> <span class="variable">&amp;cpu4</span> <span class="variable">&amp;cpu5</span> <span class="variable">&amp;cpu6</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">regions</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;tmem</span> <span class="number">0x0</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;tuart</span> <span class="number">0x0</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;allmem</span> <span class="number">0x7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">boot-hart</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        next-arg1 = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x82200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">next-addr</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x82000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">next-mode</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">system-reset-allowed</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>可以看见为<code>quard_star</code>划分了两个<code>domain</code>，一个为<code>trusted-domain</code>，使用了cpu7，下级程序的起始地址为<code>0xb0000000</code>，模式为<code>U</code>模式，这个<code>domain</code>可以用来运行类似<code>freertos</code>的实时操作系统；一个domain为<code>untrusted-domain</code>，这个<code>domain</code>使用了<code>cpu0~cpu6</code>，用于运行<code>linux</code>系统，下级程序的起始地址为<code>0x82000000</code></p><h2 id="2-2-编写domain测试代码"><a href="#2-2-编写domain测试代码" class="headerlink" title="2.2 编写domain测试代码"></a>2.2 编写domain测试代码</h2><p>在quard_star目录下新建一个<code>trusted_domain</code>的文件夹，在此文件夹下新建<code>link.lds</code>和<code>startup.s</code>两个文件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star/trusted_domain$ <span class="built_in">ls</span></span><br><span class="line">link.lds  startup.s</span><br></pre></td></tr></table></figure><p><code>link.lds</code>如下，这里需要注意的是运行起始地址和设备树中的保持一致，即：<code>0xb0000000</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line"></span><br><span class="line">ENTRY( _start )</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123; </span><br><span class="line">ddr (rxai!w) : ORIGIN = 0xb0000000, LENGTH = 256M</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP(*(.text))</span><br><span class="line">  &#125; &gt;ddr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startup.s</code>如下：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">.type _start,@function</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">lit0,<span class="number">0x100</span></span><br><span class="line">sllit0,t0, <span class="number">20</span></span><br><span class="line">lit1,<span class="number">0x200</span></span><br><span class="line">sllit1,t1, <span class="number">4</span></span><br><span class="line"><span class="keyword">add</span>     t0, t0, t1</span><br><span class="line">lit1,<span class="string">&#x27;H&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;e&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;l&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;l&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;o&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;Q&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;u&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;d&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;S&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;t&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;b&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;o&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;d&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;!&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;\r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line"><span class="symbol">_loop:</span></span><br><span class="line">j_loop</span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure><p>这里需要注意的是串口的输出地址为<code>0x10002000</code>，即<code>UART2</code>的地址，和设备树中<code>tuart</code>的地址保持一致</p><p>这里需要生成<code>trusted_domain</code>的固件并将其加载到<code>0xb0000000</code>处执行，所以先修改<code>build.sh</code></p><p>先编译生成<code>trusted_domain.bin</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译trusted_domain</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/trusted_domain&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/trusted_domain</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/trusted_domain</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -x assembler-with-cpp -c startup.s -o <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/startup.o</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -nostartfiles -T./link.lds -Wl,-Map=<span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.map -Wl,--gc-sections <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/startup.o -o <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objcopy -O binary -S <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.bin</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objdump --<span class="built_in">source</span> --demangle --disassemble --reloc --wide <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf &gt; <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.lst</span></span><br></pre></td></tr></table></figure><p>然后合成<code>fw.bin</code>，新增一行如下：</p><p><img src="/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/image-20230624155945404.png" alt="image-20230624155945404"></p><p>将<code>trusted_domain.bin</code>写入到了地址偏移为：<code>0x400000</code>的地方，下一步就要将固件加载到<code>0xb0000000</code>，因此还需要修改一下boot下的<code>start.s</code>，修改如下：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">//load trusted_fw.bin</span><br><span class="line">//[<span class="number">0x20400000</span>:<span class="number">0x20800000</span>] --&gt; [<span class="number">0xb0000000</span>:<span class="number">0xb0400000</span>]</span><br><span class="line">   lia0,<span class="number">0x204</span></span><br><span class="line">sllia0,a0, <span class="number">20</span>      //a0 = <span class="number">0x20400000</span></span><br><span class="line">   lia1,<span class="number">0xb00</span></span><br><span class="line">sllia1,a1, <span class="number">20</span>      //a1 = <span class="number">0xb0000000</span></span><br><span class="line">   lia2,<span class="number">0xb04</span></span><br><span class="line">sllia2,a2, <span class="number">20</span>      //a2 = <span class="number">0xb0400000</span></span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure><h2 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h2><p><code>run.sh</code>修改：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line">DEFAULT_VC=&quot;1080x1920&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/fw/fw.bin \</span></span><br><span class="line"><span class="language-bash">-d in_asm -D qemu.log \</span></span><br><span class="line"><span class="language-bash">--serial vc:<span class="variable">$DEFAULT_VC</span> --serial vc:<span class="variable">$DEFAULT_VC</span> --serial vc:<span class="variable">$DEFAULT_VC</span> --monitor vc:<span class="variable">$DEFAULT_VC</span> --parallel none</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-nographic --parallel none \</span></span><br></pre></td></tr></table></figure><p>用<code>DEFAULT_VC</code>来指定了qemu显示的分辨率，这个分辨率我随便设置的，还需要新增三个<code>-serial</code>选项让qemu输出三个串口终端，运行结果如下：</p><p><img src="/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/GIF%202023-6-24%2016-10-13.gif" alt="GIF 2023-6-24 16-10-13"></p><p>所以现在的内存布局如下：</p><p><img src="/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/memory.png" alt="memory"></p>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> riscv </tag>
            
            <tag> opensbi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为quard-star移植opensbi-1.2</title>
      <link href="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/"/>
      <url>/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-RISCV的多级启动流程"><a href="#1-RISCV的多级启动流程" class="headerlink" title="1. RISCV的多级启动流程"></a>1. RISCV的多级启动流程</h1><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/ch5-1.png" alt="ch5-1"></p><p>​如上图RISCV的多级启动流程从ROM上的代码开始，实心黑箭头代表加载操作，虚线黑箭头代表跳转操作，因此rom上的代码负责把LOADER的代码加载到SARM上然后跳转到LOADER处执行，LOADER的代码会初始化DDR然后加载Opensbi固件到DDR，然后跳转到Opensbi处执行，或者直接加载BOOTLOADER，然后跳转到BOOTLOADER处执行，最后BOOTLOADER会加载OS然后跳转到OS处启动操作系统</p><p>第一阶段为ZSBL，运行在M模式下，对应到quard-star的ROM上的代码就是复位向量代码就是那个reset_vec里的代码，由于我们通过qemu将固件通过-drive命令直接加载到了flash的地方，所以rom上的代码不用执行load操作。</p><p>第二阶段为FSBL，运行在M模式下，对应到quard-star就是flash上的代码，在这段代码里我们需要加载Opensbi固件，加载设备树，然后跳转到Opensbi处执行</p><p>第三阶段就是Opensbi了，Opensbi是运行在M模式下的一段运行时代码</p><p>第四阶段为U-boot</p><p>第五阶段为OS</p><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/1337491-20220915202755816-964760955.png" alt="RISC-V 引导流程图"></p><h1 id="2-Opensbi简介"><a href="#2-Opensbi简介" class="headerlink" title="2. Opensbi简介"></a>2. Opensbi简介</h1><blockquote><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/578765652">OpenSBI三种固件的区别 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/YjmStr/p/16697848.html">QEMU 启动方式分析 （1）：QEMU 及 RISC-V 启动流程简介 - yjmstr - 博客园 (cnblogs.com)</a></p></blockquote><p>RISC-V 的 Runtime 通常是 OpenSBI，它是运行在 M 模式下的程序，但能够为 S 模式提供一些特定的服务，这些服务由 SBI (Supervisor Binary Interface) 规范定义。</p><p>SBI 是指 Supervisor Binary Interface，它是运行在 M 模式下的程序，操作系统通过 SBI 来调用 M 模式的硬件资源。而 OpenSBI 是指西数开发的一种开源 SBI 实现。</p><p>OpenSBI 有三种 Firmware：</p><ul><li>FW_PAYLOAD ：下一引导阶段被作为 payload 打包进来，通常是 U-Boot 或 Linux。这是兼容 Linux 的 RISC-V 硬件所使用的默认 firmware 。</li><li>FW_JUMP ：跳转到一个固定地址，该地址上需存有下一个加载器。QEMU 的早期版本曾经使用过它。</li><li>FW_DYNAMIC ：根据前一个阶段传入的信息加载下一个阶段。通常是 U-Boot SPL 使用它。现在 QEMU 默认使用 FW_DYNAMIC。</li></ul><p>下载Opensbi源码：<a href="https://github.com/riscv-software-src/opensbi/releases">Releases · riscv-software-src&#x2F;opensbi (github.com)</a></p><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/image-20230623145527293.png" alt="image-20230623145527293"></p><p>截至笔者下载的时候，最新的版本为<code>1.2</code>，不同的版本有一定的区别，<code>0.9</code>和<code>1.2</code>版本在配置方面有许多差距，下载完成源码后解压到<code>quard-star</code>目录下。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ <span class="built_in">ls</span></span><br><span class="line">README.md  boot  build.sh  dts  opensbi-1.2  output  qemu-8.0.2  qemu.log   run.sh</span><br></pre></td></tr></table></figure><h1 id="3-移植Opensbi-1-2到quard-star上"><a href="#3-移植Opensbi-1-2到quard-star上" class="headerlink" title="3. 移植Opensbi-1.2到quard-star上"></a>3. 移植Opensbi-1.2到quard-star上</h1><p>在移植之前需要明确几个东西:</p><ul><li>我们采用<code>Opensbi</code>的固件是<code>FW_JUMP </code>类型的，会被加载到DRAM处执行即<code>0x80000000</code></li><li>需要自行编写设备树编译将设备树的地址传递给<code>Opensbi</code>，<code>rom</code>上的<code>fw_dynamic_info</code>用不到</li><li>需要编写在flah上运行的代码来将opensbi的固件加载到DRAM处，然后跳转执行</li></ul><h2 id="3-1-在opensbi中新增quard-star支持"><a href="#3-1-在opensbi中新增quard-star支持" class="headerlink" title="3.1 在opensbi中新增quard-star支持"></a>3.1 在opensbi中新增quard-star支持</h2><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/image-20230623145957055.png" alt="image-20230623145957055"></p><p>可以看到opensbi的源码并不是特别多，我们先看看docs下的<code>platform_guide.md</code>，里面有这么一段话：</p><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/image-20230623150123684.png" alt="image-20230623150123684"></p><p>这里告诉了我们如何在为<code>quard_star</code>新增<code>opensbi</code>的支持，如下：</p><ul><li>在palform文件夹下新建一个名为<code>quard_star</code>的文件夹</li><li>在quard_star文件夹下新增三个文件<code>Kconfig</code>，<code>objects.mk</code>，<code>platform.c</code></li><li>在quard_satr文件夹下新增一个文件夹脚<code>configs</code>，在<code>configs</code>目录下新建一个名为<code>defconfig</code>的文件</li></ul><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/image-20230623150525508.png" alt="image-20230623150525508"></p><p>可以看到在patform文件夹下还有一些其他平台，比如<code>kendryte-k210</code>，还有一个名为<code>generic</code>的平台，这是一个通用的板级平台，我们的<code>quard_star</code>就是参考<code>generic</code>的代码实现的，还有一个叫<code>template</code>的平台，这是<code>opensbi</code>官方提供的默认工程。</p><p>Kconfig文件的内容，这里照着generci中的内容copy了过来，看样子是选择使用FDT以及支持fdt的domain配置和fdt的pmu配置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># SPDX-License-Identifier: BSD-2-Clause</span><br><span class="line"></span><br><span class="line">config PLATFORM_QUARD_STAR</span><br><span class="line">bool</span><br><span class="line">select FDT  </span><br><span class="line">select FDT_DOMAIN </span><br><span class="line">select FDT_PMU</span><br><span class="line">default y</span><br></pre></td></tr></table></figure><p>objects的内容比较简单，配置固件为JUMP类型，同时指定jump的地址</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: BSD-2-Clause</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compiler flags</span></span><br><span class="line">platform-cppflags-y =</span><br><span class="line">platform-cflags-y =</span><br><span class="line">platform-asflags-y =</span><br><span class="line">platform-ldflags-y =</span><br><span class="line"></span><br><span class="line"><span class="comment"># Objects to build</span></span><br><span class="line">platform-objs-y += platform.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># Blobs to build</span></span><br><span class="line">FW_JUMP=y</span><br><span class="line">FW_TEXT_START=0x80000000</span><br><span class="line">FW_JUMP_ADDR=0x0</span><br></pre></td></tr></table></figure><p><code>defconfig</code>的内容是指定配置支持哪些硬件，这里也是把<code>generic</code>中的内容<code>copy</code>了过来，虽然现在<code>quard_star</code>的硬件比较少，但是不管，先把所有的都添加进去</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CONFIG_PLATFORM_ALLWINNER_D1=y</span><br><span class="line">CONFIG_PLATFORM_ANDES_AE350=y</span><br><span class="line">CONFIG_PLATFORM_RENESAS_RZFIVE=y</span><br><span class="line">CONFIG_PLATFORM_SIFIVE_FU540=y</span><br><span class="line">CONFIG_PLATFORM_SIFIVE_FU740=y</span><br><span class="line">CONFIG_FDT_GPIO=y</span><br><span class="line">CONFIG_FDT_GPIO_SIFIVE=y</span><br><span class="line">CONFIG_FDT_I2C=y</span><br><span class="line">CONFIG_FDT_I2C_SIFIVE=y</span><br><span class="line">CONFIG_FDT_IPI=y</span><br><span class="line">CONFIG_FDT_IPI_MSWI=y</span><br><span class="line">CONFIG_FDT_IPI_PLICSW=y</span><br><span class="line">CONFIG_FDT_IRQCHIP=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_APLIC=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_IMSIC=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_PLIC=y</span><br><span class="line">CONFIG_FDT_RESET=y</span><br><span class="line">CONFIG_FDT_RESET_ATCWDT200=y</span><br><span class="line">CONFIG_FDT_RESET_GPIO=y</span><br><span class="line">CONFIG_FDT_RESET_HTIF=y</span><br><span class="line">CONFIG_FDT_RESET_SIFIVE_TEST=y</span><br><span class="line">CONFIG_FDT_RESET_SUNXI_WDT=y</span><br><span class="line">CONFIG_FDT_RESET_THEAD=y</span><br><span class="line">CONFIG_FDT_SERIAL=y</span><br><span class="line">CONFIG_FDT_SERIAL_CADENCE=y</span><br><span class="line">CONFIG_FDT_SERIAL_GAISLER=y</span><br><span class="line">CONFIG_FDT_SERIAL_HTIF=y</span><br><span class="line">CONFIG_FDT_SERIAL_RENESAS_SCIF=y</span><br><span class="line">CONFIG_FDT_SERIAL_SHAKTI=y</span><br><span class="line">CONFIG_FDT_SERIAL_SIFIVE=y</span><br><span class="line">CONFIG_FDT_SERIAL_LITEX=y</span><br><span class="line">CONFIG_FDT_SERIAL_UART8250=y</span><br><span class="line">CONFIG_FDT_SERIAL_XILINX_UARTLITE=y</span><br><span class="line">CONFIG_FDT_TIMER=y</span><br><span class="line">CONFIG_FDT_TIMER_MTIMER=y</span><br><span class="line">CONFIG_FDT_TIMER_PLMT=y</span><br><span class="line">CONFIG_SERIAL_SEMIHOSTING=y</span><br></pre></td></tr></table></figure><p><code>platform.c</code>:</p><p>在platform.c中第一个比较重要的函数为<code>fw_platform_init</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">fw_platform_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg0, <span class="type">unsigned</span> <span class="type">long</span> arg1,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg2, <span class="type">unsigned</span> <span class="type">long</span> arg3,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg4)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *model;</span><br><span class="line"><span class="type">void</span> *fdt = (<span class="type">void</span> *)arg1;</span><br><span class="line">u32 hartid, hart_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> rc, root_offset, cpus_offset, cpu_offset, len;</span><br><span class="line"></span><br><span class="line">root_offset = fdt_path_offset(fdt, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (root_offset &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">model = fdt_getprop(fdt, root_offset, <span class="string">&quot;model&quot;</span>, &amp;len);</span><br><span class="line"><span class="keyword">if</span> (model)</span><br><span class="line">sbi_strncpy(platform.name, model, <span class="keyword">sizeof</span>(platform.name));</span><br><span class="line"></span><br><span class="line">cpus_offset = fdt_path_offset(fdt, <span class="string">&quot;/cpus&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (cpus_offset &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">fdt_for_each_subnode(cpu_offset, fdt, cpus_offset) &#123;</span><br><span class="line">rc = fdt_parse_hart_id(fdt, cpu_offset, &amp;hartid);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SBI_HARTMASK_MAX_BITS &lt;= hartid)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">quard_star_hart_index2id[hart_count++] = hartid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">platform.hart_count = hart_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return original FDT pointer */</span></span><br><span class="line"><span class="keyword">return</span> arg1;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">wfi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的五个arg依次对应着上一启动阶段传递过来的参数，为a0~a4寄存器，其中a0中放的是hard id，a1中放的是设备树的地址，arg1 被强制转换为一个指向设备树（Device Tree）的指针，即 fdt。函数主要的逻辑如下：</p><ol><li>首先，通过解析设备树来获取平台的模型名称（”model” 属性），并将其存储在 platform.name 变量中。</li><li>接下来，在设备树的 “&#x2F;cpus” 路径下遍历处理器节点，获取每个处理器的 hartid（处理器标识符）。</li><li>根据获取的 hartid，将其存储在 quard_star_hart_index2id 数组中，并增加 hart_count 变量的计数。</li><li>最后，设置 platform.hart_count 变量为 hart_count，表示平台上处理器的数量。</li><li>函数返回 arg1，即原始的设备树指针。</li></ol><p>第二个重要的定义为<code>platform_ops</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_platform_operations</span> <span class="title">platform_ops</span> =</span> &#123;</span><br><span class="line">.early_init= quard_star_early_init,             <span class="comment">//早期初始化，不需要</span></span><br><span class="line">.final_init= quard_star_final_init,            <span class="comment">//最终初始化，需要</span></span><br><span class="line">.early_exit= quard_star_early_exit,            <span class="comment">//早期退出，不需要</span></span><br><span class="line">.final_exit= quard_star_final_exit,            <span class="comment">//最终退出，不需要</span></span><br><span class="line">.domains_init= quard_star_domains_init,      <span class="comment">//从设备树填充域，需要</span></span><br><span class="line">.console_init= fdt_serial_init,              <span class="comment">//初始化控制台</span></span><br><span class="line">.irqchip_init= fdt_irqchip_init,             <span class="comment">//初始化中断</span></span><br><span class="line">.irqchip_exit= fdt_irqchip_exit,             <span class="comment">//中断退出</span></span><br><span class="line">.ipi_init= fdt_ipi_init,                     <span class="comment">//中断通信</span></span><br><span class="line">.ipi_exit= fdt_ipi_exit,</span><br><span class="line">.pmu_init= quard_star_pmu_init,              <span class="comment">//电源配置</span></span><br><span class="line">.pmu_xlate_to_mhpmevent = quard_star_pmu_xlate_to_mhpmevent,</span><br><span class="line">.get_tlbr_flush_limit= quard_star_tlbr_flush_limit, <span class="comment">//需要</span></span><br><span class="line">.timer_init= fdt_timer_init,</span><br><span class="line">.timer_exit= fdt_timer_exit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为 “platform_ops” 的结构体变量，类型为 “const struct sbi_platform_operations”，用于指定平台相关的操作函数。</p><p>这个结构体包含了多个成员，每个成员对应一个平台相关的操作函数。以下是每个成员和对应的函数名：</p><ul><li><code>early_init</code>：quard_star_early_init</li><li><code>final_init</code>：quard_star_final_init</li><li><code>early_exit</code>：quard_star_early_exit</li><li><code>final_exit</code>：quard_star_final_exit</li><li><code>domains_init</code>：quard_star_domains_init</li><li><code>console_init</code>：fdt_serial_init</li><li><code>irqchip_init</code>：fdt_irqchip_init</li><li><code>irqchip_exit</code>：fdt_irqchip_exit</li><li><code>ipi_init</code>：fdt_ipi_init</li><li><code>ipi_exit</code>：fdt_ipi_exit</li><li><code>pmu_init</code>：quard_star_pmu_init</li><li><code>pmu_xlate_to_mhpmevent</code>：quard_star_pmu_xlate_to_mhpmevent</li><li><code>get_tlbr_flush_limit</code>：quard_star_tlbr_flush_limit</li><li><code>timer_init</code>：fdt_timer_init</li><li><code>timer_exit</code>：fdt_timer_exit</li></ul><p>这些函数是平台特定的操作函数，用于在 OpenSBI 初始化过程中进行特定的操作和配置。每个函数在相应的阶段被调用，以完成与平台相关的初始化、配置和资源管理等工作。</p><p>通过定义这个结构体并填充相应的函数指针，OpenSBI 可以根据平台的特性和需求，调用适当的操作函数，以确保其在不同平台上的正确运行和适配性。</p><p>其中这些操作函数的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_early_init</span><span class="params">(<span class="type">bool</span> cold_boot)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_final_init</span><span class="params">(<span class="type">bool</span> cold_boot)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *fdt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cold_boot)</span><br><span class="line">fdt_reset_init();</span><br><span class="line"><span class="keyword">if</span> (!cold_boot)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fdt = sbi_scratch_thishart_arg1_ptr();</span><br><span class="line"></span><br><span class="line">fdt_cpu_fixup(fdt);</span><br><span class="line">fdt_fixups(fdt);</span><br><span class="line">fdt_domain_fixup(fdt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_early_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_final_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_domains_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> fdt_domains_populate(fdt_get_address());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_pmu_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> fdt_pmu_setup(fdt_get_address());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">quard_star_pmu_xlate_to_mhpmevent</span><span class="params">(<span class="type">uint32_t</span> event_idx,</span></span><br><span class="line"><span class="params">       <span class="type">uint64_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint64_t</span> evt_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data is valid only for raw events and is equal to event selector */</span></span><br><span class="line"><span class="keyword">if</span> (event_idx == SBI_PMU_EVENT_RAW_IDX)</span><br><span class="line">evt_val = data;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic platform follows the SBI specification recommendation</span></span><br><span class="line"><span class="comment"> * i.e. zero extended event_idx is used as mhpmevent value for</span></span><br><span class="line"><span class="comment"> * hardware general/cache events if platform does&#x27;t define one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">evt_val = fdt_pmu_get_select_value(event_idx);</span><br><span class="line"><span class="keyword">if</span> (!evt_val)</span><br><span class="line">evt_val = (<span class="type">uint64_t</span>)event_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> evt_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">quard_star_tlbr_flush_limit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> SBI_PLATFORM_TLB_RANGE_FLUSH_LIMIT_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后定义了patform结构体，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbi_platform</span> <span class="title">platform</span> =</span> &#123;</span><br><span class="line">.opensbi_version= OPENSBI_VERSION,</span><br><span class="line">.platform_version= SBI_PLATFORM_VERSION(<span class="number">0x0</span>, <span class="number">0x01</span>),</span><br><span class="line">.name= <span class="string">&quot;Quard-Star&quot;</span>,</span><br><span class="line">.features= SBI_PLATFORM_DEFAULT_FEATURES,</span><br><span class="line">.hart_count= SBI_HARTMASK_MAX_BITS,</span><br><span class="line">.hart_index2id= quard_star_hart_index2id,</span><br><span class="line">.hart_stack_size= SBI_PLATFORM_DEFAULT_HART_STACK_SIZE,</span><br><span class="line">.platform_ops_addr= (<span class="type">unsigned</span> <span class="type">long</span>)&amp;platform_ops</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为 “platform” 的结构体变量，类型为 “struct sbi_platform”，用于描述平台的相关信息和配置。</p><p>这个结构体包含了多个成员，每个成员用于存储特定的平台属性和配置。以下是每个成员和对应的值或指针：</p><ul><li><code>opensbi_version</code>：OPENSBI_VERSION，指定了 OpenSBI 的版本号。</li><li><code>platform_version</code>：SBI_PLATFORM_VERSION(0x0, 0x01)，指定了平台的版本号。</li><li><code>name</code>：”Quard-Star”，指定了平台的名称。</li><li><code>features</code>：SBI_PLATFORM_DEFAULT_FEATURES，指定了平台的默认特性。</li><li><code>hart_count</code>：SBI_HARTMASK_MAX_BITS，指定了平台上处理器（Hart）的数量。</li><li><code>hart_index2id</code>：quard_star_hart_index2id，一个指向处理器标识符数组的指针，用于将处理器索引映射到唯一的处理器标识符。</li><li><code>hart_stack_size</code>：SBI_PLATFORM_DEFAULT_HART_STACK_SIZE，指定了每个处理器的默认堆栈大小。</li><li><code>platform_ops_addr</code>：(unsigned long)&amp;platform_ops，指向平台操作函数结构体的指针，用于指定平台操作函数的地址。</li></ul><p>通过定义这个结构体并填充相应的值或指针，OpenSBI 可以了解和配置特定平台的相关信息，以在运行时正确地适配和操作该平台。这些信息包括版本号、特性支持、处理器数量、堆栈大小和操作函数等。</p><h2 id="3-2-编写设备树"><a href="#3-2-编写设备树" class="headerlink" title="3.2 编写设备树"></a>3.2 编写设备树</h2><p>在<code>quard_star</code>目录下新建<code>dts</code>文件夹，在此文件夹下新建<code>quard_star_sbi.dts</code>，设备树文件如下：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">/dts-v1/</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;0x2&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0x2&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv-quard-star&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;riscv-quard-star,qemu&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">stdout-path</span> <span class="operator">=</span> <span class="string">&quot;/soc/uart0@10000000&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x80000000</span> <span class="number">0x0</span> <span class="number">0x40000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0x0&gt;;</span></span><br><span class="line"><span class="attr">timebase-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x989680</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xf</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x10</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="title class_">cpu@1</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xd</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xe</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu2:</span> <span class="title class_">cpu@2</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xb</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x2</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xc</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu3:</span> <span class="title class_">cpu@3</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x9</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xa</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu4:</span> <span class="title class_">cpu@4</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x4</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu5:</span> <span class="title class_">cpu@5</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x5</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x5</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x6</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu6:</span> <span class="title class_">cpu@6</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x6</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x4</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cpu7:</span> <span class="title class_">cpu@7</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdcsu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;riscv,sv48&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x2</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">cpu-map</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">cluster0</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xf</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core1</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xd</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core2</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xb</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core3</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x9</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core4</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core5</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x5</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core6</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">core7</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">cpu</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">soc</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;0x2&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0x2&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;simple-bus&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">ranges</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">uart0:</span> <span class="title class_">uart0@10000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xa</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x11</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x384000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x10000000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;ns16550a&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">uart1:</span> <span class="title class_">uart1@10001000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xa</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x11</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x384000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x10001000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;ns16550a&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">        uart2:</span> <span class="title class_">uart2@10002000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xa</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x11</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x384000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x10002000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;ns16550a&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">plic@c000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">phandle</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x11</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,ndev</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x35</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xc000000</span> <span class="number">0x0</span> <span class="number">0x210000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x10</span> <span class="number">0xb</span> <span class="number">0x10</span> <span class="number">0x9</span> <span class="number">0xe</span> <span class="number">0xb</span> <span class="number">0xe</span> <span class="number">0x9</span> <span class="number">0xc</span> <span class="number">0xb</span> <span class="number">0xc</span> <span class="number">0x9</span> <span class="number">0xa</span> <span class="number">0xb</span> <span class="number">0xa</span> <span class="number">0x9</span> <span class="number">0x8</span> <span class="number">0xb</span> <span class="number">0x8</span> <span class="number">0x9</span> <span class="number">0x6</span> <span class="number">0xb</span> <span class="number">0x6</span> <span class="number">0x9</span> <span class="number">0x4</span> <span class="number">0xb</span> <span class="number">0x4</span> <span class="number">0x9</span> <span class="number">0x2</span> <span class="number">0xb</span> <span class="number">0x2</span> <span class="number">0x9</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,plic0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;0x1&gt;;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;0x0&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">clint@2000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x10</span> <span class="number">0x3</span> <span class="number">0x10</span> <span class="number">0x7</span> <span class="number">0xe</span> <span class="number">0x3</span> <span class="number">0xe</span> <span class="number">0x7</span> <span class="number">0xc</span> <span class="number">0x3</span> <span class="number">0xc</span> <span class="number">0x7</span> <span class="number">0xa</span> <span class="number">0x3</span> <span class="number">0xa</span> <span class="number">0x7</span> <span class="number">0x8</span> <span class="number">0x3</span> <span class="number">0x8</span> <span class="number">0x7</span> <span class="number">0x6</span> <span class="number">0x3</span> <span class="number">0x6</span> <span class="number">0x7</span> <span class="number">0x4</span> <span class="number">0x3</span> <span class="number">0x4</span> <span class="number">0x7</span> <span class="number">0x2</span> <span class="number">0x3</span> <span class="number">0x2</span> <span class="number">0x7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x2000000</span> <span class="number">0x0</span> <span class="number">0x10000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,clint0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>关于设备树的语法和详细解释请参考我另外一篇博客：<a href="https://yanglianoo.github.io/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/">设备树详解 | TimerのBlog (yanglianoo.github.io)</a></p><h2 id="3-3-重新编写start-s"><a href="#3-3-重新编写start-s" class="headerlink" title="3.3 重新编写start.s"></a>3.3 重新编写start.s</h2><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">.macro</span> loop,cunt</span><br><span class="line">    lit1,<span class="number">0xffff</span></span><br><span class="line">    lit2,\cunt</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line">addi    t1, t1, <span class="number">-1</span></span><br><span class="line">bnet1, x0, <span class="number">1</span>b</span><br><span class="line">    lit1,<span class="number">0xffff</span></span><br><span class="line">addi    t2, t2, <span class="number">-1</span></span><br><span class="line">bnet2, x0, <span class="number">1</span>b</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line"><span class="meta">.macro</span> load_data,_src_start,_dst_start,_dst_end</span><br><span class="line">bgeu\_dst_start, \_dst_end, <span class="number">2</span>f</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">lw      t0, (\_src_start)</span><br><span class="line">sw      t0, (\_dst_start)</span><br><span class="line">addi    \_src_start, \_src_start, <span class="number">4</span></span><br><span class="line">addi    \_dst_start, \_dst_start, <span class="number">4</span></span><br><span class="line">bltu    \_dst_start, \_dst_end, <span class="number">1</span>b</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">.type _start,@function</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">//load opensbi_fw.bin </span><br><span class="line">//[<span class="number">0x20200000</span>:<span class="number">0x20400000</span>] --&gt; [<span class="number">0x80000000</span>:<span class="number">0x80200000</span>]</span><br><span class="line">    lia0,<span class="number">0x202</span></span><br><span class="line">sllia0,a0, <span class="number">20</span>      //a0 = <span class="number">0x20200000</span></span><br><span class="line">    lia1,<span class="number">0x800</span></span><br><span class="line">sllia1,a1, <span class="number">20</span>      //a1 = <span class="number">0x80000000</span></span><br><span class="line">    lia2,<span class="number">0x802</span></span><br><span class="line">sllia2,a2, <span class="number">20</span>      //a2 = <span class="number">0x80200000</span></span><br><span class="line">load_data a0,a1,a2</span><br><span class="line"></span><br><span class="line">//load qemu_sbi.dtb</span><br><span class="line">//[<span class="number">0x20080000</span>:<span class="number">0x20100000</span>] --&gt; [<span class="number">0x82200000</span>:<span class="number">0x82280000</span>]</span><br><span class="line">    lia0,<span class="number">0x2008</span></span><br><span class="line">sllia0,a0, <span class="number">16</span>       //a0 = <span class="number">0x20080000</span></span><br><span class="line">    lia1,<span class="number">0x822</span></span><br><span class="line">sllia1,a1, <span class="number">20</span>       //a1 = <span class="number">0x82200000</span></span><br><span class="line">    lia2,<span class="number">0x8228</span></span><br><span class="line">sllia2,a2, <span class="number">16</span>       //a2 = <span class="number">0x82280000</span></span><br><span class="line">load_data a0,a1,a2</span><br><span class="line"></span><br><span class="line">    csrr    a0, mhartid</span><br><span class="line">    lit0,<span class="number">0x0</span>     </span><br><span class="line">beqa0, t0, _no_wait</span><br><span class="line">loop<span class="number">0x1000</span></span><br><span class="line"><span class="symbol">_no_wait:</span></span><br><span class="line">    lia1,<span class="number">0x822</span></span><br><span class="line">sllia1,a1, <span class="number">20</span>       //a1 = <span class="number">0x82200000</span></span><br><span class="line">    li    t0,<span class="number">0x800</span></span><br><span class="line">sllit0,t0, <span class="number">20</span>       //t0 = <span class="number">0x80000000</span></span><br><span class="line">    jr      t0</span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure><p>这段代码会被加载到flash执行，主要工作是加载opensbi的固件和设备树，然后跳转到DRAM处执行<code>opensbi</code>的代码</p><ol><li>宏定义：<ul><li><code>loop,cunt</code> 宏用于执行循环，根据给定的次数进行空操作。</li><li><code>load_data</code> 宏用于从源地址加载数据，并将其存储到目标地址，直到目标地址达到结束地址。</li></ul></li><li><code>_start</code> 函数：<ul><li>加载 <code>opensbi_fw.bin</code> 文件的内容到指定内存区域 <code>[0x80000000:0x80200000]</code>。</li><li>加载 <code>qemu_sbi.dtb</code> 文件的内容到指定内存区域 <code>[0x82200000:0x82280000]</code>。</li><li>获取当前处理器的 ID，并与零进行比较。如果相等，执行 <code>_no_wait</code> 标签处的代码。</li><li><code>_no_wait</code> 标签处的代码加载一个地址到寄存器 <code>a1</code>，然后将控制权跳转到寄存器 <code>t0</code> 指向的地址。</li></ul></li></ol><p>这里固件的地址和在build.sh合成的固件的地址相关，下面就来修改build.sh</p><h2 id="3-4-合成固件"><a href="#3-4-合成固件" class="headerlink" title="3.4 合成固件"></a>3.4 合成固件</h2><p>在build.sh中新增如下代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译 opensbi</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/opensbi&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/opensbi</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/opensbi-1.2</span><br><span class="line">make CROSS_COMPILE=$CROSS_PREFIX- PLATFORM=quard_star</span><br><span class="line">cp -r $SHELL_FOLDER/opensbi-1.2/build/platform/quard_star/firmware/*.bin $SHELL_FOLDER/output/opensbi/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成sbi.dtb</span></span><br><span class="line">cd $SHELL_FOLDER/dts</span><br><span class="line">dtc -I dts -O dtb -o $SHELL_FOLDER/output/opensbi/quard_star_sbi.dtb quard_star_sbi.dts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合成firmware固件</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/fw&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/fw</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/output/fw</span><br><span class="line">rm -rf fw.bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">填充 32K的0</span></span><br><span class="line">dd of=fw.bin bs=1k count=32k if=/dev/zero   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># 写入 lowlevel_fw.bin 偏移量地址为 0</span></span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=0 if=$SHELL_FOLDER/output/lowlevelboot/lowlevel_fw.bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 quard_star_sbi.dtb 地址偏移量为 512K，因此 fdt的地址偏移量为 0x80000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=512 if=$SHELL_FOLDER/output/opensbi/quard_star_sbi.dtb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 fw_jump.bin 地址偏移量为 2K*1K= 0x2000000，因此 fw_jump.bin的地址偏移量为  0x2000000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=2k if=$SHELL_FOLDER/output/opensbi/fw_jump.bin</span><br></pre></td></tr></table></figure><ul><li><p>首先编译<code>Opensbi</code>，在编译时需要指定<code>PLATFORM=quard_star</code></p></li><li><p>然后编译生成<code>dtb</code></p></li><li><p>最后合成<code>firmware</code>固件</p></li></ul><p>根据dd命令的使用可以看见将quard_star_sbi.dtb写入到了偏移地址为0x80000的地方，用于这个固件会被加载到flash处，所以设备树的地址为：0x20080000</p><p>fw_jump.bin 地址偏移量为 2K*1K&#x3D; 0x2000000，因此 fw_jump.bin的地址偏移量为  0x2000000，所以opensbi固件的地址为：0x20200000</p><p>lowlevel_fw.bin 偏移量地址为 0，因此lowlevel_fw.bin 的地址为：0x20000000</p><p>这里要说明一下为啥要使用<code>dd of=fw.bin bs=1k count=32k if=/dev/zero   </code>来填充填充 32K的0，这是qemu使用-drive加载的固件的大小要大于等于定义的flash的大小，不然会报错。</p><h2 id="3-5-编译运行"><a href="#3-5-编译运行" class="headerlink" title="3.5 编译运行"></a>3.5 编译运行</h2><p><code>run.sh修改</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/fw/fw.bin \</span></span><br><span class="line"><span class="language-bash">-d in_asm -D qemu.log \</span></span><br><span class="line"><span class="language-bash">-nographic --parallel none \</span></span><br></pre></td></tr></table></figure><p>这里添加了一个qemu.log会生成汇编代码，可以根据这个log来查看固件是否有正确的加载、跳转。</p><p>依次执行<code>.build.sh，.run.sh</code>，出现如下就代表移植成功了：</p><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/image-20230623160359806.png" alt="image-20230623160359806"></p><p>可以看到显示Opensbi的版本为v1.2，固件的起始地址为：0x80000000，大小为252kb。</p><p>所以现在的内存布局如下：</p><p><img src="/2023/06/22/%E4%B8%BAquard-star%E7%A7%BB%E6%A4%8Dopensbi-1-2/memory.png"></p><h1 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h1><p>关于Opensbi还有很多指得学习的地方，后续有时间可深入分析其源码，这里先把它跑起来。</p>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> riscv </tag>
            
            <tag> opensbi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写STL之List</title>
      <link href="/2023/06/20/%E6%89%8B%E5%86%99STL-List/"/>
      <url>/2023/06/20/%E6%89%8B%E5%86%99STL-List/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码仓库：<a href="https://github.com/yanglianoo/My_STL/tree/timer">yanglianoo&#x2F;My_STL at timer (github.com)</a></p></blockquote><h1 id="1-List概述"><a href="#1-List概述" class="headerlink" title="1.List概述"></a>1.List概述</h1><p>C++标准模板库（STL）中的<code>list</code>是一个双向链表容器，提供了在链表中高效存储和访问数据的功能。它是一个模板类具有以下特性：</p><ol><li>链表结构：<code>list</code>是由节点组成的链表，每个节点包含数据以及指向前一个节点和后一个节点的指针。这种结构使得在<code>list</code>中插入、删除和移动元素非常高效，因为不需要像动态数组那样进行内存的移动和重分配。</li><li>双向访问：<code>list</code>支持双向访问，可以从链表的开头或末尾快速访问元素。你可以使用迭代器进行正向或反向遍历，也可以使用<code>front()</code>和<code>back()</code>函数访问第一个和最后一个元素。</li><li>动态大小：<code>list</code>的大小可以动态增长或缩小，无需预先分配固定大小的内存。</li><li>插入和删除：在<code>list</code>中插入和删除元素非常高效。通过使用迭代器，可以在常数时间内在任意位置插入或删除元素。</li><li>不支持随机访问：<code>list</code>不支持通过索引进行随机访问，这意味着不能像数组那样使用索引来访问元素。如果需要随机访问，<code>vector</code>可能更适合。</li><li>没有连续存储：由于<code>list</code>是一个链表，它的元素在内存中不是连续存储的，这可能会对缓存性能产生一些影响。</li><li>不支持快速的随机访问、排序和二分查找：由于没有随机访问，对<code>list</code>进行排序和二分查找会比较低效。如果需要这些功能，你可以考虑使用<code>vector</code>或<code>deque</code>容器。</li></ol><p><code>STL</code>库中<code>list</code>的定义如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Allocator</span> = std::allocator&lt;T&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> list;</span><br></pre></td></tr></table></figure><table><thead><tr><th>T</th><th>元素的类型。<code>T</code> 必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>Allocator</th><th>用于获取&#x2F;释放内存及构造&#x2F;析构内存中元素的分配器。类型必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/Allocator"><em>分配器</em> <em>(Allocator)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>成员函数</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/list">(构造函数)</a></td><td>构造 <code>list</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/~list">(析构函数)</a></td><td>析构 <code>list</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/operator%3D">operator&#x3D;</a></td><td>赋值给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/assign">assign</a></td><td>将值赋给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/get_allocator">get_allocator</a></td><td>返回相关的分配器 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/push_front">push_front</a></td><td>插入元素到容器起始 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace_front">emplace_front</a>(C++11)</td><td>在容器头部原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/pop_front">pop_front</a></td><td>移除首元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/swap">swap</a></td><td>交换内容 (公开成员函数)</td></tr></tbody></table><blockquote><p>参考链接：<a href="https://zh.cppreference.com/w/cpp/container/list">std::list - cppreference.com</a></p></blockquote><h1 id="2-构造节点"><a href="#2-构造节点" class="headerlink" title="2. 构造节点"></a>2. 构造节点</h1><p>list的数据结构有两种，一种是双向链表，结构如下：</p><p><img src="/2023/06/20/%E6%89%8B%E5%86%99STL-List/1632118785.jpg" alt="图解几种常见的线性表 - 命中水"></p><p>在双向链表中，每一个节点为一个node，node包含一个指向上一个节点的prev指针和指向下一个节点的next指针，头节点的prev指针指向nullptr，尾节点的next指针指向nullptr。</p><p>一种是双向循环链表，和双向链表不同的就是，双向循环链表头节点的prev指针指向了尾节点，尾节点的next指针指向了头节点，由此组成了一个循环。</p><p><img src="/2023/06/20/%E6%89%8B%E5%86%99STL-List/3650507100.jpg" alt="图解几种常见的线性表 - 命中水"></p><p>我们实现的list是基于双向链表的，list是一个C++的类，由很多个节点构成，因此先来定义一下节点的数据结构，node节点由两个指针和存储的数据组成，是一个模板类，定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">list_node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    list_node&lt;T&gt;* prev;</span><br><span class="line">    list_node&lt;T&gt;* next;</span><br><span class="line">    <span class="built_in">list_node</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">            :<span class="built_in">next</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            ,<span class="built_in">prev</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            ,<span class="built_in">data</span>(value)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-构造迭代器"><a href="#3-构造迭代器" class="headerlink" title="3.构造迭代器"></a>3.构造迭代器</h1><p>在list的使用种，用两种类型的迭代器，一种是普通的<code>iterator</code>，还有一种就是不可修改的<code>const_iterator</code>，这里的不可修改是指节点的数据不可修改，迭代器构造如下，和vector的迭代器类似，需要去重载不同的操作符。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, Ref, ptr&gt; self;</span><br><span class="line"><span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">list_iterator</span>(Node* node)</span><br><span class="line">:_node(node)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//拷贝构造、赋值重载，默认浅拷贝即可</span></span><br><span class="line"><span class="comment">//析构函数，指针指向的节点不属于迭代器的，无需自己销毁</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//解引用,*it = it.operator*()</span></span><br><span class="line">Ref&amp; <span class="keyword">operator</span>* ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line">ptr <span class="keyword">operator</span>-&gt; () <span class="comment">//本来调用为it-&gt;-&gt;_value,编译器通过处理省略了一个-&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_node-&gt;_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置--</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置--</span></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != it._node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node == it._node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>list_iterator</code>内部维护了一个<code>list_node&lt;T&gt;*</code>类型的指针，用来指向<code>list</code>的每一个节点，这里解释一下为啥<code>list_iterator</code>模板类为啥有三个模板参数，那是为了方便通过typedef来定义<code>iterator</code>和<code>const_iterator</code>，在后面list类中可以如下定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br></pre></td></tr></table></figure><h1 id="4-构造list类"><a href="#4-构造list类" class="headerlink" title="4.构造list类"></a>4.构造list类</h1><p>首先list类中包含了如下的成员变量，除了一个node类型的指针还维护了一个_size，当对list容器进行操作时，需要对_size实现增减操作。由于采用循环链表实现，所以当初始化链表时只需要定义一个头节点，让<code>head</code>节点的<code>prev</code>和<code>next</code>指针都指向自己就可以了.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">list</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, T&amp;, T*&gt; iterator; <span class="comment">//普通迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> list_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator; <span class="comment">//const迭代器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* _head;</span><br><span class="line">    <span class="type">size_t</span> _size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty_initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="built_in">T</span>());</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line"></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义默认构造函数</span></span><br><span class="line">   <span class="built_in">list</span>()&#123; <span class="built_in">empty_initialize</span>(); &#125;</span><br><span class="line">    <span class="comment">//定义析构函数</span></span><br><span class="line">   ~<span class="built_in">list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span>[] _head;</span><br><span class="line">        _head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后我们来定义一些和迭代器有关的函数，首先是<code>begin()</code>和<code>end()</code>，用来返回头节点指针和尾节点指针，这里我们定义<code>_head-&gt;next</code>为<code>begin</code>，<code>end</code>为<code>_head</code>，然后有两个重载版本。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(_head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-容量"><a href="#2-1-容量" class="headerlink" title="2.1 容量"></a>2.1 容量</h2><p>和容量相关的接口比较简单，这里不赘述，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-修改器"><a href="#2-2-修改器" class="headerlink" title="2.2 修改器"></a>2.2 修改器</h2><p>在实现其他修改器之前，可先定义<code>insert</code>和<code>erase</code>函数,代码逻辑并不复杂，实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//往pos位置插入元素T</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node* cur = pos._node;</span><br><span class="line">        Node* prev = cur-&gt;_prev;</span><br><span class="line"></span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">        new_node-&gt;_prev = prev;</span><br><span class="line">        new_node-&gt;_next = cur;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        prev-&gt;_next = new_node;</span><br><span class="line">        cur-&gt;_prev = new_node;</span><br><span class="line"></span><br><span class="line">        _size++;</span><br><span class="line">        <span class="comment">//隐式转换为iterator</span></span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//删除pos位置的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(pos != <span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        Node* cur = pos._node;</span><br><span class="line">        Node* prev = cur-&gt;_prev;</span><br><span class="line">        Node* next = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        prev-&gt;_next = next;</span><br><span class="line">        next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line">        _size--;</span><br><span class="line">        <span class="keyword">delete</span> [] cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除范围为 [first, last) 的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator first, iterator last )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == last) &#123; <span class="keyword">return</span> last;&#125;</span><br><span class="line"></span><br><span class="line">        Node* first_node = first._node;</span><br><span class="line">        Node* last_node = last._node;</span><br><span class="line"></span><br><span class="line">        Node* prev = first_node-&gt;_prev;</span><br><span class="line">        Node* next = last_node;</span><br><span class="line"></span><br><span class="line">        prev-&gt;_next = next;</span><br><span class="line">        next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (first_node != last_node)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* cur = first_node;</span><br><span class="line">            first_node = first_node-&gt;_next;</span><br><span class="line">            <span class="keyword">delete</span> [] cur;</span><br><span class="line">            count++; </span><br><span class="line">        &#125;</span><br><span class="line">        _size-=count;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他的修改器就可基于insert和erase函数来实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>(),<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">begin</span>(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-元素访问"><a href="#2-3-元素访问" class="headerlink" title="2.3 元素访问"></a>2.3 元素访问</h2><p>提供了访问头节点和尾节点数据的接口：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(--<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-其他构造函数"><a href="#2-4-其他构造函数" class="headerlink" title="2.4 其他构造函数"></a>2.4 其他构造函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>(<span class="type">size_t</span> count, <span class="type">const</span> T&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(<span class="type">size_t</span> count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(<span class="built_in">T</span>());</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt&gt;</span><br><span class="line">    <span class="built_in">list</span>(InputIt first, InputIt last) : <span class="built_in">list</span>() </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">while</span> (first != last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">push_back</span>(*first);</span><br><span class="line">++first;</span><br><span class="line">            _size++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(<span class="type">const</span> list&amp; other): <span class="built_in">list</span>() </span><br><span class="line">    &#123;</span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">tmp</span><span class="params">(other.begin(), other.end())</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(_head, tmp._head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>(std::initializer_list&lt;T&gt; init) : <span class="built_in">list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> T&amp; value : init) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list&lt;T&gt; &amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> T&amp; value : other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;T&gt;&amp; <span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> T&amp; value : ilist) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(value);</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h1><p>list已完成，未进行测试，list是比较简单的，当然我们还有一些机制没有实现，比如逆向迭代器，assign函数等，不过核心的接口都已经实现，后续可完善。</p>]]></content>
      
      
      <categories>
          
          <category> 手写STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-制作测试固件验证串口打印</title>
      <link href="/2023/06/17/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF6-%E5%88%B6%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%9B%BA%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/"/>
      <url>/2023/06/17/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF6-%E5%88%B6%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%9B%BA%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考地址：<a href="https://quard-star-tutorial.readthedocs.io/zh_CN/latest/ch4.html">基于qemu-riscv从0开始构建嵌入式linux系统ch4. 制作测试固件验证串口打印 — 主页 (quard-star-tutorial.readthedocs.io)</a></p></blockquote><ul><li>在<code>quard-star</code>目录下新建boot文件夹，在此文件夹下新建<code>boot.lds</code>和<code>start.s</code>文件，如下</li></ul><p><img src="/2023/06/17/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF6-%E5%88%B6%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%9B%BA%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/image-20230617155423292.png" alt="image-20230617155423292"></p><ul><li><code>start.s</code>文件</li></ul><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">.section .text             //定义数据段名为.text</span><br><span class="line">.globl _start              //定义全局符号_start</span><br><span class="line">.type _start,@function     //_start为函数</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span>                        //函数入口</span><br><span class="line">    csrr    a0, mhartid        //csr是riscv专有的内核私有寄存器，独立编地在<span class="number">12</span>位地址</span><br><span class="line">                               //mhartid寄存是定义了内核的hart id，这里读取到a0寄存器里</span><br><span class="line">    lit0,<span class="number">0x0</span>            //li是伪指令，加载立即数<span class="number">0</span>到t0</span><br><span class="line">beqa0, t0, _core0     //比较a0和t0,相等则跳转到_core0地址处，否则向下执行</span><br><span class="line"><span class="symbol">_loop:</span>                         //定义一个_loop符号</span><br><span class="line">j_loop              //跳转到_loop，此处形成循环，用意为如果当前cpu core不为</span><br><span class="line">                               //hart <span class="number">0</span>则循环等待，为hart <span class="number">0</span>则继续向下执行</span><br><span class="line"><span class="symbol">_core0:</span>                        //定义一个core0才能执行到此处</span><br><span class="line">lit0,<span class="number">0x100</span>          //t0 = <span class="number">0x100</span></span><br><span class="line">sllit0,t0, <span class="number">20</span>         //t0左移<span class="number">20</span>位 t0 = <span class="number">0x10000000</span></span><br><span class="line">lit1,<span class="string">&#x27;H&#x27;</span>            //t1 = <span class="string">&#x27;H&#x27;</span> 字符的ASCII码值写入t1</span><br><span class="line">sbt1, <span class="number">0</span>(t0)          //s是store写入的意思，b是byte，这里指的是写入t1</span><br><span class="line">                               //的值到t0指向的地址，即为写入<span class="number">0x10000000</span>这个寄存器</span><br><span class="line">                               //这个寄存器正是uart0的发送data寄存器，此时串口会输出<span class="string">&quot;H&quot;</span></span><br><span class="line">lit1,<span class="string">&#x27;e&#x27;</span>            //接下来都是重复内容</span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;l&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;l&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;o&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;Q&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;u&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;d&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;S&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;t&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27; &#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;b&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;o&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;r&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;d&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;!&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)</span><br><span class="line">lit1,<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">sbt1, <span class="number">0</span>(t0)          //到这里就会输出<span class="string">&quot;Hello Quard Star board!&quot;</span>  </span><br><span class="line">j_loop              //完成后进入loop</span><br><span class="line"></span><br><span class="line">    .end                       //汇编文件结束符号</span><br></pre></td></tr></table></figure><p>这里做的事情比较简单，首先读取hartid的值，如果是编号为0的hart就跳转到_core0处执行，如果不是就进入_loop循环卡住。在core0函数中就是往<code>uart0=0x10000000</code>处一个字节一个字节的写数据，数据会输出到主机的控制台上。</p><ul><li><code>boot.lds</code>文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )  /*输出可执行文件平台*/</span><br><span class="line"></span><br><span class="line">ENTRY( _start )         /*程序入口函数*/</span><br><span class="line"></span><br><span class="line">MEMORY                  /*定义内存域*/</span><br><span class="line">&#123; </span><br><span class="line">    /*定义名为flash的内存域属性以及起始地址，大小等*/</span><br><span class="line">flash (rxai!w) : ORIGIN = 0x20000000, LENGTH = 512k </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS                /*定义段域*/</span><br><span class="line">&#123;</span><br><span class="line">  .text :               /*.text段域*/</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP(*(.text))      /*将所有.text段链接在此域内，keep是保持防止优化，即无论如何都保留此段*/</span><br><span class="line">  &#125; &gt;flash              /*段域的地址(LMA和VMA相同)位于名为flash内存域*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>boot.lds</code>是给链接器传参数的，目的是为了把start.s里的代码连接到flash处。</p><ul><li><code>build.sh</code>修改</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CROSS_PREFIX=riscv64-unknown-elf</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/lowlevelboot&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/lowlevelboot</span><br><span class="line">fi  </span><br><span class="line">cd boot</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -x assembler-with-cpp -c start.s -o <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/start.o</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -nostartfiles -T./boot.lds -Wl,-Map=<span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.map -Wl,--gc-sections <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/start.o -o <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用gnu工具生成原始的程序bin文件</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objcopy -O binary -S <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.bin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用gnu工具生成反汇编文件，方便调试分析（当然我们这个代码太简单，不是很需要）</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objdump --<span class="built_in">source</span> --demangle --disassemble --reloc --wide <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf &gt; <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.lst</span></span><br><span class="line"></span><br><span class="line">cd $SHELL_FOLDER/output/lowlevelboot</span><br><span class="line">rm -rf fw.bin</span><br><span class="line">dd of=fw.bin bs=1k count=32k if=/dev/zero</span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=0 if=lowlevel_fw.bin</span><br></pre></td></tr></table></figure><p>这里需要riscv的编译器，我使用的是<code>riscv64-unknown-elf-gcc</code>，在build.sh中执行编译生成固件用于qemu启动。</p><ul><li><code>run.sh</code>修改</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"></span><br><span class="line">$SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span><br><span class="line">-M quard-star \</span><br><span class="line">-m 1G \</span><br><span class="line">-smp 8 \</span><br><span class="line">-bios none \</span><br><span class="line">#-monitor stdio \</span><br><span class="line">-drive if=pflash,bus=0,unit=0,format=raw,file=$SHELL_FOLDER/output/lowlevelboot/fw.bin \</span><br><span class="line">-nographic --parallel none</span><br></pre></td></tr></table></figure><ul><li>测试，执行 <code>./build.sh</code> 和 <code>./run.sh</code>，结果如下：可以看到在串口控制台输出了<code>Hello Quard Star board!</code></li></ul><p><img src="/2023/06/17/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF6-%E5%88%B6%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%9B%BA%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/image-20230617160911655.png" alt="image-20230617160911655"></p><ul><li>内存布局如下<img src="/2023/06/17/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF6-%E5%88%B6%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%9B%BA%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(2).png" alt="未命名文件 (2)"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 虚拟化 </tag>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.为quard-star添加RTC和UART</title>
      <link href="/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/"/>
      <url>/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/</url>
      
        <content type="html"><![CDATA[<h1 id="1-quard-star-h-修改"><a href="#1-quard-star-h-修改" class="headerlink" title="1.quard_star.h 修改"></a>1.quard_star.h 修改</h1><p><img src="/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/image-20230616181444462.png" alt="image-20230616181444462"></p><h1 id="2-quard-star-c-修改"><a href="#2-quard-star-c-修改" class="headerlink" title="2.quard_star.c 修改"></a>2.quard_star.c 修改</h1><ul><li><code>quard_star_memmap</code>修改</li></ul><p><img src="/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/image-20230616181828094.png" alt="image-20230616181828094"></p><ul><li>RTC</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_rtc_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;    </span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    sysbus_create_simple(<span class="string">&quot;goldfish_rtc&quot;</span>, quard_star_memmap[QUARD_STAR_RTC].base,</span><br><span class="line">        qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_RTC_IRQ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3路UART</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建3个 uart */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_serial_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegion *system_memory = get_system_memory();</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    </span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART0].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART0_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">0</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART1].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART1_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">1</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART2].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART2_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">2</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>machine_init</code></li></ul><p><img src="/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/image-20230616181618845.png" alt="image-20230616181618845"></p><h1 id="3-Kconfig修改"><a href="#3-Kconfig修改" class="headerlink" title="3. Kconfig修改"></a>3. Kconfig修改</h1><p>选中了RTC</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01</span><br><span class="line">    select RISCV_ACLINT</span><br><span class="line">    select RISCV_APLIC</span><br><span class="line">    select SIFIVE_PLIC</span><br><span class="line">    select GOLDFISH_RTC <span class="comment">//RTC</span></span><br></pre></td></tr></table></figure><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h1><p>在进行测试时，我们需要在<code>qemu</code>的<code>monitor</code>中使用<code>info qtree</code>来查看设备树信息，但是由于<code>qemu</code>无法滚屏，所以不能查看完整的设备树，这里修改了一下<code>run.sh</code>，将monitor映射到了控制台。<code>run.sh</code>修改如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-monitor stdio \   <span class="comment">#映射monitor</span></span></span><br></pre></td></tr></table></figure><p>执行脚本测试：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p>可以看到<code>monitor</code>中输出的内容被映射到控制台中了，且<code>RTC</code>和<code>UART</code>都挂载成功了。</p><p><img src="/2023/06/16/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF5-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0RTC%E5%92%8CUART/image-20230616182310228.png" alt="image-20230616182310228"></p><blockquote><p>代码地址：<a href="https://github.com/yanglianoo/quard-star">yanglianoo&#x2F;quard-star: 从零基于qemu创建riscv嵌入式开发板，并移植操作系统 (github.com)</a></p><p>有问题请与我联系：wechat：13699648817</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.为quard-star添加中断控制器</title>
      <link href="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-quard-star-h-修改"><a href="#1-quard-star-h-修改" class="headerlink" title="1.quard_star.h 修改"></a>1.quard_star.h 修改</h1><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616134654638.png" alt="image-20230616134654638"></p><ul><li>在QuardStarState定义了一个plic设备，为一个数组，因为有8个CPU</li><li>定义了一些与riscv中plic相关的信息</li></ul><h1 id="2-quard-star-c-修改"><a href="#2-quard-star-c-修改" class="headerlink" title="2.quard_star.c 修改"></a>2.quard_star.c 修改</h1><ul><li>修改内存映射数组，新增<code>PLIC</code>和<code>CLINT</code></li></ul><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616134912981.png" alt="image-20230616134912981"></p><ul><li>新建<code>quard_star_plic_create</code>函数，plic的创建和virt.c中保持一致，virt.c中创建plic的源码如下，调用了<code>virt_create_plic</code>函数，使用的硬件为<code>SIFIVE_PLIC</code></li></ul><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616135305524.png" alt="image-20230616135305524"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建plic */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_plic_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> socket_count = riscv_socket_count(machine);</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    <span class="type">int</span> i,hart_count,base_hartid;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; socket_count; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        hart_count = riscv_socket_hart_count(machine, i);</span><br><span class="line">        base_hartid = riscv_socket_first_hartid(machine, i);</span><br><span class="line">        <span class="type">char</span> *plic_hart_config;</span><br><span class="line">        <span class="comment">/* Per-socket PLIC hart topology configuration string */</span></span><br><span class="line">        plic_hart_config = riscv_plic_hart_config_string(machine-&gt;smp.cpus);</span><br><span class="line">        </span><br><span class="line">        s-&gt;plic[i] = sifive_plic_create(</span><br><span class="line">            quard_star_memmap[QUARD_STAR_PLIC].base + i *quard_star_memmap[QUARD_STAR_PLIC].size ,</span><br><span class="line">            plic_hart_config, hart_count , base_hartid,</span><br><span class="line">            QUARD_STAR_PLIC_NUM_SOURCES,</span><br><span class="line">            QUARD_STAR_PLIC_NUM_PRIORITIES,</span><br><span class="line">            QUARD_STAR_PLIC_PRIORITY_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_PENDING_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_ENABLE_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_ENABLE_STRIDE,</span><br><span class="line">            QUARD_STAR_PLIC_CONTEXT_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_CONTEXT_STRIDE,</span><br><span class="line">            quard_star_memmap[QUARD_STAR_PLIC].size);</span><br><span class="line">        g_free(plic_hart_config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新增<code>quard_star_aclint_create</code>函数，相比于virt简化了许多，使用的硬件是<code>SiFive CLINT</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_aclint_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i , hart_count,base_hartid;</span><br><span class="line">    <span class="type">int</span> socket_count = riscv_socket_count(machine);</span><br><span class="line">    <span class="comment">//每个CPU都需要创建 aclint</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; socket_count; i++) &#123;</span><br><span class="line"></span><br><span class="line">        base_hartid = riscv_socket_first_hartid(machine, i);</span><br><span class="line">        hart_count = riscv_socket_hart_count(machine, i);</span><br><span class="line"></span><br><span class="line">        riscv_aclint_swi_create(</span><br><span class="line">        quard_star_memmap[QUARD_STAR_CLINT].base + i *quard_star_memmap[QUARD_STAR_CLINT].size,</span><br><span class="line">        base_hartid, hart_count, <span class="literal">false</span>);</span><br><span class="line">        riscv_aclint_mtimer_create(quard_star_memmap[QUARD_STAR_CLINT].base +</span><br><span class="line">             + i *quard_star_memmap[QUARD_STAR_CLINT].size+ RISCV_ACLINT_SWI_SIZE,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_MTIMER_SIZE, base_hartid, hart_count,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_MTIMECMP, RISCV_ACLINT_DEFAULT_MTIME,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_TIMEBASE_FREQ, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>machine_init</code>函数修改，新增两个硬件</li></ul><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616135109899.png" alt="image-20230616135109899"></p><h1 id="3-Kconfig修改"><a href="#3-Kconfig修改" class="headerlink" title="3. Kconfig修改"></a>3. Kconfig修改</h1><p>新增了ACLINT和PLIC设备</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01 <span class="comment">//Pflash</span></span><br><span class="line">    select RISCV_ACLINT <span class="comment">//ACLINT</span></span><br><span class="line">    select RISCV_APLIC  <span class="comment">//APLIC</span></span><br><span class="line">    select SIFIVE_PLIC  <span class="comment">//SIFIVE_PLIC</span></span><br></pre></td></tr></table></figure><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h1><p>在进行测试时可将<code>quard_star_flash_create</code>先注释掉，一个个硬件依次测试。</p><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616140512366.png" alt="image-20230616140512366"></p><p>运行脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p>如下中断控制器添加成功：</p><p><img src="/2023/06/16/QEMU%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF4-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8/image-20230616140403678.png" alt="image-20230616140403678"></p><blockquote><p>代码地址：<a href="https://github.com/yanglianoo/quard-star">yanglianoo&#x2F;quard-star: 从零基于qemu创建riscv嵌入式开发板，并移植操作系统 (github.com)</a></p><p>有问题请与我联系：wechat：13699648817</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.为quard-star添加flash</title>
      <link href="/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/"/>
      <url>/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/</url>
      
        <content type="html"><![CDATA[<h1 id="1-quard-star-h-修改"><a href="#1-quard-star-h-修改" class="headerlink" title="1.quard_star.h 修改"></a>1.quard_star.h 修改</h1><p><img src="/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/image-20230615180235745.png" alt="image-20230615180235745"></p><h1 id="2-quard-star-c-修改"><a href="#2-quard-star-c-修改" class="headerlink" title="2.quard_star.c 修改"></a>2.quard_star.c 修改</h1><ul><li>定义flash起始地址和映射大小</li></ul><p><img src="/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/image-20230615180456071.png" alt="image-20230615180456071"></p><ul><li>创建flash并映射</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建flash并映射 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_flash_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> QUARD_STAR_FLASH_SECTOR_SIZE (256 * KiB)  <span class="comment">//0x40000 </span></span></span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    MemoryRegion *system_memory = get_system_memory();</span><br><span class="line">    DeviceState *dev = qdev_new(TYPE_PFLASH_CFI01);</span><br><span class="line"></span><br><span class="line">    qdev_prop_set_uint64(dev, <span class="string">&quot;sector-length&quot;</span>, QUARD_STAR_FLASH_SECTOR_SIZE);</span><br><span class="line">    qdev_prop_set_uint8(dev, <span class="string">&quot;width&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    qdev_prop_set_uint8(dev, <span class="string">&quot;device-width&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    qdev_prop_set_bit(dev, <span class="string">&quot;big-endian&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    qdev_prop_set_uint16(dev, <span class="string">&quot;id0&quot;</span>, <span class="number">0x89</span>);</span><br><span class="line">    qdev_prop_set_uint16(dev, <span class="string">&quot;id1&quot;</span>, <span class="number">0x18</span>);</span><br><span class="line">    qdev_prop_set_uint16(dev, <span class="string">&quot;id2&quot;</span>, <span class="number">0x00</span>);</span><br><span class="line">    qdev_prop_set_uint16(dev, <span class="string">&quot;id3&quot;</span>, <span class="number">0x00</span>);</span><br><span class="line">    qdev_prop_set_string(dev, <span class="string">&quot;name&quot;</span>,<span class="string">&quot;quard-star.flash0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    object_property_add_child(OBJECT(s), <span class="string">&quot;quard-star.flash0&quot;</span>, OBJECT(dev));</span><br><span class="line">    object_property_add_alias(OBJECT(s), <span class="string">&quot;pflash0&quot;</span>,</span><br><span class="line">                              OBJECT(dev), <span class="string">&quot;drive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s-&gt;flash = PFLASH_CFI01(dev);</span><br><span class="line">    pflash_cfi01_legacy_drive(s-&gt;flash,drive_get(IF_PFLASH, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    hwaddr flashsize = quard_star_memmap[QUARD_STAR_FLASH].size;</span><br><span class="line">    hwaddr flashbase = quard_star_memmap[QUARD_STAR_FLASH].base;</span><br><span class="line"></span><br><span class="line">    assert(QEMU_IS_ALIGNED(flashsize, QUARD_STAR_FLASH_SECTOR_SIZE));</span><br><span class="line">    assert(flashsize / QUARD_STAR_FLASH_SECTOR_SIZE &lt;= UINT32_MAX);</span><br><span class="line">    qdev_prop_set_uint32(dev, <span class="string">&quot;num-blocks&quot;</span>, flashsize / QUARD_STAR_FLASH_SECTOR_SIZE);</span><br><span class="line">    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &amp;error_fatal);</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(system_memory, flashbase,</span><br><span class="line">                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev),</span><br><span class="line">                                                       <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   quard_star_memory_create(machine);</span><br><span class="line">   <span class="comment">//创建flash</span></span><br><span class="line">   quard_star_flash_create(machine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还需要修改一下主存的代码，在第一篇博客中提到如果板子支持pflash需要修改<code>riscv_setup_rom_reset_vec</code>的入参。</li></ul><p><img src="/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/image-20230615190240109.png" alt="image-20230615190240109"></p><h1 id="3-Kconfig修改"><a href="#3-Kconfig修改" class="headerlink" title="3. Kconfig修改"></a>3. Kconfig修改</h1><p>新增PFLASH_CFI01 设备</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    bool</span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01  //选中FLASH</span><br></pre></td></tr></table></figure><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard-star$ ./run.sh</span><br></pre></td></tr></table></figure><p><img src="/2023/06/15/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF-3-%E4%B8%BAquard-star%E6%B7%BB%E5%8A%A0flash/image-20230615180850693.png" alt="image-20230615180850693"></p><p>可以看到pflash设备成功被添加，挂载在系统总线上。</p><blockquote><p>代码地址：<a href="https://github.com/yanglianoo/quard-star">yanglianoo&#x2F;quard-star: 从零基于qemu创建riscv嵌入式开发板，并移植操作系统 (github.com)</a></p><p>有问题请与我联系：wechat：13699648817</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.virt源码分析</title>
      <link href="/2023/06/14/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF2-virt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/06/14/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF2-virt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-QEMU内置开发板riscv-virt硬件介绍"><a href="#1-QEMU内置开发板riscv-virt硬件介绍" class="headerlink" title="1. QEMU内置开发板riscv-virt硬件介绍"></a>1. QEMU内置开发板riscv-virt硬件介绍</h1><p>官方介绍文档：<a href="https://www.qemu.org/docs/master/system/riscv/virt.html">‘virt’ Generic Virtual Platform (virt) — QEMU documentation</a></p><p>riscv-virt是QEMU（Quick Emulator）中提供的一块虚拟开发板，用于模拟RISC-V架构的虚拟硬件环境。</p><p>virt提供的硬件信息如下：</p><p><img src="/2023/06/14/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF2-virt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20230614164814878.png" alt="image-20230614164814878"></p><ol><li>RV32GC&#x2F;RV64GC处理器核心：<ul><li>最多支持8个通用的RV32GC或RV64GC处理器核心。</li><li>可选择性添加扩展指令集。</li></ul></li><li>Core Local Interruptor (CLINT)：<ul><li>模拟的Core Local Interruptor用于处理核心级的中断和计时器。</li></ul></li><li>Platform-Level Interrupt Controller (PLIC)：<ul><li>模拟的Platform-Level Interrupt Controller用于处理平台级的中断，分发给各个处理器核心。</li></ul></li><li>CFI并行NOR闪存存储器：<ul><li>模拟的CFI并行NOR闪存用于存储固件或其他数据。</li></ul></li><li>1个NS16550兼容串口（UART）：<ul><li>模拟的串口设备，用于与虚拟开发板进行输入输出和调试。</li></ul></li><li>1个Google Goldfish RTC：<ul><li>模拟的RTC（实时时钟）设备，用于提供计时和时间相关的功能。</li></ul></li><li>1个SiFive Test设备：<ul><li>模拟的SiFive Test设备，用于进行测试和验证。</li></ul></li><li>8个virtio-mmio传输设备：<ul><li>提供了8个virtio-mmio传输设备，用于与虚拟机中运行的客户操作系统进行通信。</li></ul></li><li>1个通用的PCIe主机桥：<ul><li>模拟的PCIe主机桥，用于支持PCIe设备的连接和通信。</li></ul></li><li>fw_cfg设备：<ul><li>提供了fw_cfg设备，允许虚拟机从QEMU获取数据。这个设备可用于传递配置信息和数据给虚拟机。</li></ul></li></ol><h1 id="2-virt源码分析"><a href="#2-virt源码分析" class="headerlink" title="2.  virt源码分析"></a>2.  virt源码分析</h1><h2 id="2-1-Kconfig"><a href="#2-1-Kconfig" class="headerlink" title="2.1 Kconfig"></a>2.1 Kconfig</h2><p>在Kconfig中关于virt的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config RISCV_VIRT</span><br><span class="line">    bool</span><br><span class="line">    imply PCI_DEVICES</span><br><span class="line">    imply VIRTIO_VGA</span><br><span class="line">    imply TEST_DEVICES</span><br><span class="line">    imply TPM_TIS_SYSBUS</span><br><span class="line">    select RISCV_NUMA</span><br><span class="line">    select GOLDFISH_RTC</span><br><span class="line">    select PCI</span><br><span class="line">    select PCI_EXPRESS_GENERIC_BRIDGE</span><br><span class="line">    select PFLASH_CFI01</span><br><span class="line">    select SERIAL</span><br><span class="line">    select RISCV_ACLINT</span><br><span class="line">    select RISCV_APLIC</span><br><span class="line">    select RISCV_IMSIC</span><br><span class="line">    select SIFIVE_PLIC</span><br><span class="line">    select SIFIVE_TEST</span><br><span class="line">    select VIRTIO_MMIO</span><br><span class="line">    select FW_CFG_DMA</span><br><span class="line">    select PLATFORM_BUS</span><br><span class="line">    select ACPI</span><br></pre></td></tr></table></figure><p>select：select关键字表示启用RISCV_VIRT选项时，会自动选择（即启用）其他相关选项。</p><ul><li><code>select RISCV_NUMA</code>：选择RISCV_NUMA选项，表示虚拟机将支持RISC-V架构的NUMA（非一致性存储访问）特性。</li><li><code>select GOLDFISH_RTC</code>：选择GOLDFISH_RTC选项，表示虚拟机将支持Google Goldfish RTC设备，用于提供计时和时间相关的功能。</li><li><code>select PCI</code>：选择PCI选项，表示虚拟机将支持PCI（Peripheral Component Interconnect）总线。</li><li><code>select PCI_EXPRESS_GENERIC_BRIDGE</code>：选择PCI_EXPRESS_GENERIC_BRIDGE选项，表示虚拟机将支持通用PCI Express桥接器。</li><li><code>select PFLASH_CFI01</code>：选择PFLASH_CFI01选项，表示虚拟机将支持CFI（Common Flash Interface）规范的并行 NOR Flash 存储器。</li><li><code>select SERIAL</code>：选择SERIAL选项，表示虚拟机将支持串口设备，用于输入输出和调试。</li><li><code>select RISCV_ACLINT</code>：选择RISCV_ACLINT选项，表示虚拟机将支持ACLINT（Architectural Core Local Interruptor）设备，用于处理核心级的中断和计时器。</li><li><code>select RISCV_APLIC</code>：选择RISCV_APLIC选项，表示虚拟机将支持APLIC（Architectural Platform-Level Interrupt Controller）设备，用于处理平台级的中断。</li><li><code>select RISCV_IMSIC</code>：选择RISCV_IMSIC选项，表示虚拟机将支持IMSIC（Interrupt-Management Standardized Interface Controller）设备。</li><li><code>select SIFIVE_PLIC</code>：选择SIFIVE_PLIC选项，表示虚拟机将支持SiFive PLIC（Platform-Level Interrupt Controller）设备。</li><li><code>select SIFIVE_TEST</code>：选择SIFIVE_TEST选项，表示虚拟机将支持SiFive Test设备，用于测试和验证。</li><li><code>select VIRTIO_MMIO</code>：选择VIRTIO_MMIO选项，表示虚拟机将支持VirtIO MMIO传输设备，用于与客户操作系统进行通信。</li><li><code>select FW_CFG_DMA</code>：选择FW_CFG_DMA选项，表示虚拟机将支持DMA（Direct Memory Access）传输，用于从QEMU获取数据。</li><li><code>select PLATFORM_BUS</code>：选择PLATFORM_BUS选项，表示虚拟机将支持平台总线，用作硬件组件之间的通信接口。</li><li><code>select ACPI</code>：选择ACPI选项，表示虚拟机将支持ACPI（Advanced Configuration and Power Interface）标准，用于管理系统配置和电源管理。</li></ul><h2 id="2-2-virt-h"><a href="#2-2-virt-h" class="headerlink" title="2.2 virt.h"></a>2.2 virt.h</h2><h3 id="2-2-1-DECLARE-INSTANCE-CHECKER"><a href="#2-2-1-DECLARE-INSTANCE-CHECKER" class="headerlink" title="2.2.1 DECLARE_INSTANCE_CHECKER"></a>2.2.1 <code>DECLARE_INSTANCE_CHECKER</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_RISCV_VIRT_MACHINE MACHINE_TYPE_NAME(<span class="string">&quot;virt&quot;</span>)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RISCVVirtState</span> <span class="title">RISCVVirtState</span>;</span>   <span class="comment">//结构体前向声明</span></span><br><span class="line">DECLARE_INSTANCE_CHECKER(RISCVVirtState, RISCV_VIRT_MACHINE,</span><br><span class="line">                         TYPE_RISCV_VIRT_MACHINE)</span><br></pre></td></tr></table></figure><p>首先调用<code>DECLARE_INSTANCE_CHECKER</code>这个宏，这个宏在qemu源码中的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span></span><br><span class="line"><span class="meta">    static inline G_GNUC_UNUSED InstanceType * \</span></span><br><span class="line"><span class="meta">    OBJ_NAME(const void *obj) \</span></span><br><span class="line"><span class="meta">    &#123; return OBJECT_CHECK(InstanceType, obj, TYPENAME); &#125;</span></span><br></pre></td></tr></table></figure><p><code>DECLARE_INSTANCE_CHECKER</code>宏用于为QOM（QEMU Object Model）类型提供实例类型转换函数。它接受三个参数：<code>InstanceType</code>表示实例结构体的名称，<code>OBJ_NAME</code>表示以大写字母和下划线分隔的对象名称，<code>TYPENAME</code>表示类型名称。</p><p>因此这里就是用来将<code>RISCVVirtState</code>转换为一个<code>QOM</code>类型的结构体，后续需要去定义这个结构体，经过这一步可以认为声明了一个名交<code>virt</code>的riscv板子。</p><h3 id="2-2-2-RISCVVirtState定义"><a href="#2-2-2-RISCVVirtState定义" class="headerlink" title="2.2.2 RISCVVirtState定义"></a>2.2.2 <code>RISCVVirtState</code>定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">RISCVVirtAIAType</span> &#123;</span></span><br><span class="line">    VIRT_AIA_TYPE_NONE = <span class="number">0</span>,</span><br><span class="line">    VIRT_AIA_TYPE_APLIC,</span><br><span class="line">    VIRT_AIA_TYPE_APLIC_IMSIC,</span><br><span class="line">&#125; RISCVVirtAIAType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RISCVVirtState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;    <span class="comment">//继承MachineState </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    Notifier machine_done;  <span class="comment">// </span></span><br><span class="line">    DeviceState *platform_bus_dev;</span><br><span class="line">    RISCVHartArrayState soc[VIRT_SOCKETS_MAX];</span><br><span class="line">    DeviceState *irqchip[VIRT_SOCKETS_MAX];</span><br><span class="line">    PFlashCFI01 *flash[<span class="number">2</span>];   <span class="comment">//flash</span></span><br><span class="line">    FWCfgState *fw_cfg;      <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fdt_size;</span><br><span class="line">    <span class="type">bool</span> have_aclint;</span><br><span class="line">    RISCVVirtAIAType aia_type;</span><br><span class="line">    <span class="type">int</span> aia_guests;</span><br><span class="line">    <span class="type">char</span> *oem_id;</span><br><span class="line">    <span class="type">char</span> *oem_table_id;</span><br><span class="line">    OnOffAuto acpi;</span><br><span class="line">    <span class="type">const</span> MemMapEntry *memmap; <span class="comment">//内存映射</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>RISCVVirtState</code>这个结构体中，定义了很多其他设备和成员变量，在qemu中各个硬件都是虚拟的，可以将一种硬件看作是一个结构体类，virt这块板子有哪些硬件就要在<code>RISCVVirtState</code>这个本体结构体中去包含这些属性，和硬件相关的设备定义基本都在<code>hw/</code>目录下。</p><h3 id="2-2-3-枚举变量"><a href="#2-2-3-枚举变量" class="headerlink" title="2.2.3 枚举变量"></a>2.2.3 枚举变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    VIRT_DEBUG,</span><br><span class="line">    VIRT_MROM,</span><br><span class="line">    VIRT_TEST,</span><br><span class="line">    VIRT_RTC,</span><br><span class="line">    VIRT_CLINT,</span><br><span class="line">    VIRT_ACLINT_SSWI,</span><br><span class="line">    VIRT_PLIC,</span><br><span class="line">    VIRT_APLIC_M,</span><br><span class="line">    VIRT_APLIC_S,</span><br><span class="line">    VIRT_UART0,</span><br><span class="line">    VIRT_VIRTIO,</span><br><span class="line">    VIRT_FW_CFG,</span><br><span class="line">    VIRT_IMSIC_M,</span><br><span class="line">    VIRT_IMSIC_S,</span><br><span class="line">    VIRT_FLASH,</span><br><span class="line">    VIRT_DRAM,</span><br><span class="line">    VIRT_PCIE_MMIO,</span><br><span class="line">    VIRT_PCIE_PIO,</span><br><span class="line">    VIRT_PLATFORM_BUS,</span><br><span class="line">    VIRT_PCIE_ECAM</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    UART0_IRQ = <span class="number">10</span>, <span class="comment">//串口中断号</span></span><br><span class="line">    RTC_IRQ = <span class="number">11</span>,   <span class="comment">// RTC 中断号</span></span><br><span class="line">    VIRTIO_IRQ = <span class="number">1</span>, <span class="comment">/* 1 to 8 */</span></span><br><span class="line">    VIRTIO_COUNT = <span class="number">8</span>,</span><br><span class="line">    PCIE_IRQ = <span class="number">0x20</span>, <span class="comment">/* 32 to 35 */</span></span><br><span class="line">    VIRT_PLATFORM_BUS_IRQ = <span class="number">64</span>, <span class="comment">/* 64 to 95 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就是使用枚举定义了一些和硬件、中断号相关的变量。</p><h3 id="2-2-4-宏定义"><a href="#2-2-4-宏定义" class="headerlink" title="2.2.4 宏定义"></a>2.2.4 宏定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLATFORM_BUS_NUM_IRQS 32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_IRQCHIP_NUM_MSIS 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_IRQCHIP_NUM_SOURCES 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_IRQCHIP_NUM_PRIO_BITS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_IRQCHIP_MAX_GUESTS_BITS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_IRQCHIP_MAX_GUESTS ((1U &lt;&lt; VIRT_IRQCHIP_MAX_GUESTS_BITS) - 1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_PRIORITY_BASE 0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_PENDING_BASE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_ENABLE_BASE 0x2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_ENABLE_STRIDE 0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_CONTEXT_BASE 0x200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_CONTEXT_STRIDE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_PLIC_SIZE(__num_context) \</span></span><br><span class="line"><span class="meta">    (VIRT_PLIC_CONTEXT_BASE + (__num_context) * VIRT_PLIC_CONTEXT_STRIDE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PCI_ADDR_CELLS    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PCI_INT_CELLS     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PLIC_ADDR_CELLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PLIC_INT_CELLS    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_APLIC_INT_CELLS   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_IMSIC_INT_CELLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAX_INT_CELLS     2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAX_INT_MAP_WIDTH (FDT_PCI_ADDR_CELLS + FDT_PCI_INT_CELLS + \</span></span><br><span class="line"><span class="meta">                                 1 + FDT_MAX_INT_CELLS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PLIC_INT_MAP_WIDTH  (FDT_PCI_ADDR_CELLS + FDT_PCI_INT_CELLS + \</span></span><br><span class="line"><span class="meta">                                 1 + FDT_PLIC_INT_CELLS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_APLIC_INT_MAP_WIDTH (FDT_PCI_ADDR_CELLS + FDT_PCI_INT_CELLS + \</span></span><br><span class="line"><span class="meta">                                 1 + FDT_APLIC_INT_CELLS)</span></span><br></pre></td></tr></table></figure><h2 id="2-3-virt-c"><a href="#2-3-virt-c" class="headerlink" title="2.3 virt.c"></a>2.3 virt.c</h2><h3 id="2-3-1-硬件内存映射定义"><a href="#2-3-1-硬件内存映射定义" class="headerlink" title="2.3.1 硬件内存映射定义"></a>2.3.1 硬件内存映射定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const MemMapEntry virt_memmap[] = &#123;</span><br><span class="line">    [VIRT_DEBUG] =        &#123;        0x0,         0x100 &#125;,</span><br><span class="line">    [VIRT_MROM] =         &#123;     0x1000,        0xf000 &#125;,</span><br><span class="line">    [VIRT_TEST] =         &#123;   0x100000,        0x1000 &#125;,</span><br><span class="line">    [VIRT_RTC] =          &#123;   0x101000,        0x1000 &#125;,</span><br><span class="line">    [VIRT_CLINT] =        &#123;  0x2000000,       0x10000 &#125;,</span><br><span class="line">    [VIRT_ACLINT_SSWI] =  &#123;  0x2F00000,        0x4000 &#125;,</span><br><span class="line">    [VIRT_PCIE_PIO] =     &#123;  0x3000000,       0x10000 &#125;,</span><br><span class="line">    [VIRT_PLATFORM_BUS] = &#123;  0x4000000,     0x2000000 &#125;,</span><br><span class="line">    [VIRT_PLIC] =         &#123;  0xc000000, VIRT_PLIC_SIZE(VIRT_CPUS_MAX * 2) &#125;,</span><br><span class="line">    [VIRT_APLIC_M] =      &#123;  0xc000000, APLIC_SIZE(VIRT_CPUS_MAX) &#125;,</span><br><span class="line">    [VIRT_APLIC_S] =      &#123;  0xd000000, APLIC_SIZE(VIRT_CPUS_MAX) &#125;,</span><br><span class="line">    [VIRT_UART0] =        &#123; 0x10000000,         0x100 &#125;,</span><br><span class="line">    [VIRT_VIRTIO] =       &#123; 0x10001000,        0x1000 &#125;,</span><br><span class="line">    [VIRT_FW_CFG] =       &#123; 0x10100000,          0x18 &#125;,</span><br><span class="line">    [VIRT_FLASH] =        &#123; 0x20000000,     0x4000000 &#125;,</span><br><span class="line">    [VIRT_IMSIC_M] =      &#123; 0x24000000, VIRT_IMSIC_MAX_SIZE &#125;,</span><br><span class="line">    [VIRT_IMSIC_S] =      &#123; 0x28000000, VIRT_IMSIC_MAX_SIZE &#125;,</span><br><span class="line">    [VIRT_PCIE_ECAM] =    &#123; 0x30000000,    0x10000000 &#125;,</span><br><span class="line">    [VIRT_PCIE_MMIO] =    &#123; 0x40000000,    0x40000000 &#125;,</span><br><span class="line">    [VIRT_DRAM] =         &#123; 0x80000000,           0x0 &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MemMapEntry 结构体定义如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemMapEntry</span> &#123;</span></span><br><span class="line">    hwaddr base;</span><br><span class="line">    hwaddr size;</span><br><span class="line">&#125; MemMapEntry;</span><br></pre></td></tr></table></figure><p>可以看到上面内存映射的第一个参数为硬件映射的地址，第二个参数为映射的内存长度。</p><h3 id="2-3-2-注册virt机器"><a href="#2-3-2-注册virt机器" class="headerlink" title="2.3.2 注册virt机器"></a>2.3.2 注册virt机器</h3><p>在virt.c代码的最下方可以看到注册相关的代码，首先需要定义一个<code>virt_machine_typeinfo</code>，然后调用<code>type_register_static</code>函数，最后调用 type_init这个宏。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo virt_machine_typeinfo = &#123;</span><br><span class="line">    .name       = MACHINE_TYPE_NAME(<span class="string">&quot;virt&quot;</span>),  <span class="comment">//注册板卡，定义名称</span></span><br><span class="line">    .parent     = TYPE_MACHINE,  <span class="comment">//父类名称</span></span><br><span class="line">    .class_init = virt_machine_class_init,    <span class="comment">// </span></span><br><span class="line">    .instance_init = virt_machine_instance_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(RISCVVirtState),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">         &#123; TYPE_HOTPLUG_HANDLER &#125;,</span><br><span class="line">         &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virt_machine_init_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;virt_machine_typeinfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(virt_machine_init_register_types)</span><br></pre></td></tr></table></figure><p>这里有几个重要的成员变量：</p><ul><li><p>@class_init: 函数指针，该函数在所有父类初始化完成后调用，允许类设置其默认的虚拟方法指针。也可以使用该函数覆盖父类的虚拟方法。</p></li><li><p>@instance_init: 函数指针，该函数用于初始化一个对象。父类已经完成初始化，因此该类型只需负责初始化自己的成员。</p></li><li><p>@instance_size: 对象的大小（派生自 #Object）。如果 @instance_size 为 0，则对象的大小将为父对象的大小。</p></li><li><p>@interfaces: 与该类型关联的接口列表。应指向以零填充的静态数组作为终止元素。</p></li></ul><p>在qemu中想要定义自己的板卡是采用类似C++中继承的方式来实现的，在virt.h中可以认为<code>RISCVVirtState</code>为一个子类，继承了qemu中的统一的machine的父类，我们需要在子类中来创建属于自己的硬件。所以下一步就需要来定义<code>virt_machine_class_init</code>和<code>virt_machine_instance_init</code>这两个函数。</p><h3 id="2-3-3-virt-machine-class-init函数定义"><a href="#2-3-3-virt-machine-class-init函数定义" class="headerlink" title="2.3.3 virt_machine_class_init函数定义"></a>2.3.3 <code>virt_machine_class_init</code>函数定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virt_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">128</span>];</span><br><span class="line">    MachineClass *mc = MACHINE_CLASS(oc);</span><br><span class="line">    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V VirtIO board&quot;</span>;</span><br><span class="line">    mc-&gt;init = virt_machine_init;</span><br><span class="line">    mc-&gt;max_cpus = VIRT_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;default_ram_id = <span class="string">&quot;riscv_virt_board.ram&quot;</span>;</span><br><span class="line">    assert(!mc-&gt;get_hotplug_handler);</span><br><span class="line">    mc-&gt;get_hotplug_handler = virt_machine_get_hotplug_handler;</span><br><span class="line"></span><br><span class="line">    hc-&gt;plug = virt_machine_device_plug_cb;</span><br><span class="line"></span><br><span class="line">    machine_class_allow_dynamic_sysbus_dev(mc, TYPE_RAMFB_DEVICE);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TPM</span></span><br><span class="line">    machine_class_allow_dynamic_sysbus_dev(mc, TYPE_TPM_TIS_SYSBUS);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    object_class_property_add_bool(oc, <span class="string">&quot;aclint&quot;</span>, virt_get_aclint,</span><br><span class="line">                                   virt_set_aclint);</span><br><span class="line">    object_class_property_set_description(oc, <span class="string">&quot;aclint&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;Set on/off to enable/disable &quot;</span></span><br><span class="line">                                          <span class="string">&quot;emulating ACLINT devices&quot;</span>);</span><br><span class="line"></span><br><span class="line">    object_class_property_add_str(oc, <span class="string">&quot;aia&quot;</span>, virt_get_aia,</span><br><span class="line">                                  virt_set_aia);</span><br><span class="line">    object_class_property_set_description(oc, <span class="string">&quot;aia&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;Set type of AIA interrupt &quot;</span></span><br><span class="line">                                          <span class="string">&quot;conttoller. Valid values are &quot;</span></span><br><span class="line">                                          <span class="string">&quot;none, aplic, and aplic-imsic.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    object_class_property_add_str(oc, <span class="string">&quot;aia-guests&quot;</span>,</span><br><span class="line">                                  virt_get_aia_guests,</span><br><span class="line">                                  virt_set_aia_guests);</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;Set number of guest MMIO pages for AIA IMSIC. Valid value &quot;</span></span><br><span class="line">                 <span class="string">&quot;should be between 0 and %d.&quot;</span>, VIRT_IRQCHIP_MAX_GUESTS);</span><br><span class="line">    object_class_property_set_description(oc, <span class="string">&quot;aia-guests&quot;</span>, str);</span><br><span class="line">    object_class_property_add(oc, <span class="string">&quot;acpi&quot;</span>, <span class="string">&quot;OnOffAuto&quot;</span>,</span><br><span class="line">                              virt_get_acpi, virt_set_acpi,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    object_class_property_set_description(oc, <span class="string">&quot;acpi&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;Enable ACPI&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-virt创建CPU"><a href="#2-3-4-virt创建CPU" class="headerlink" title="2.3.4 virt创建CPU"></a>2.3.4 virt创建CPU</h3><h3 id="2-3-5-virt创建PLIC"><a href="#2-3-5-virt创建PLIC" class="headerlink" title="2.3.5 virt创建PLIC"></a>2.3.5 virt创建PLIC</h3><h3 id="2-3-6-virt创建ACLINT"><a href="#2-3-6-virt创建ACLINT" class="headerlink" title="2.3.6 virt创建ACLINT"></a>2.3.6 virt创建ACLINT</h3>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础-存储访问</title>
      <link href="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/"/>
      <url>/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-存储器使用场景"><a href="#1-存储器使用场景" class="headerlink" title="1.存储器使用场景"></a>1.存储器使用场景</h1><p>先来看如下这一张图，CPU运行程序的流程如下：</p><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614133226741.png" alt="image-20230614133226741"></p><p>1：假设我现在在电脑上编译了一个<code>hello.c</code>的程序，编译完成后为<code>hello.bin</code>的一个二进制文件，此时这个程序还存储在我们电脑的硬盘上，这个硬盘可能是机械硬盘也可能是固态硬盘，这些都是外存储器。</p><p>2：将<code>hello.bin</code>装载进内存，这里的内存就是插在电脑上的内存条，<code>hello.bin</code>包含了cpu要执行的指令和运行所需要的数据。</p><p>3：CPU从内存中逐条读取指令及相关指令，然后依次执行完成对数据的处理。</p><p>4：将处理结果送回内存保存，然后再将处理结果送到外存储器。</p><p>所以其实在CPU运行的过程中主要是分为两类存储器：</p><ul><li><p>内存储器</p><p>存取速度快 </p><p>成本高、容量相对较小 </p><p>直接与CPU连接，CPU对内存 中可直接进行读、写操作 </p><p>属于易失性存储器(volatile)， 用于临时存放正在运行的程序和数据，掉电就没了数据。</p></li><li><p>外存储器（简称外存或辅存）</p><p>– 存取速度慢 – 成本低、容量很大 </p><p>– 不与CPU直接连接，先传送到内 存，然后才能被CPU使用。</p><p> – 属于非易失性存储器，用于长久存放系统中几乎所有的信息</p></li></ul><blockquote><p>这里可能会有个疑问，CPU访问内存的方式是通过地址总线来访问的，CPU是如何访问外存的呢：</p><p>CPU访问外部存储器（外存）的方式通常是通过输入输出（I&#x2F;O）指令和I&#x2F;O总线来实现的。外存通常指的是硬盘、固态硬盘（SSD）、光盘、磁带等非易失性存储介质。</p><p>与内存访问不同，外存的访问速度相对较慢，因此CPU在执行指令时通常不直接与外存进行交互，而是通过操作系统和设备控制器等中间层来实现。以下是CPU访问外存的一般过程：</p><ol><li>CPU发送I&#x2F;O指令：当需要读取或写入外存中的数据时，CPU会发出相应的I&#x2F;O指令，这些指令通常包括读取（IN）和写入（OUT）操作。</li><li>I&#x2F;O总线传输：CPU将I&#x2F;O指令发送到I&#x2F;O总线上。I&#x2F;O总线是一种特殊的总线，用于传输CPU和外部设备之间的数据和控制信号。</li><li>设备控制器响应：I&#x2F;O总线上连接着各种外部设备控制器，如硬盘控制器或磁带控制器。当设备控制器接收到CPU发送的I&#x2F;O指令时，它会解析指令并准备执行相应的读取或写入操作。</li><li>数据传输：设备控制器根据指令从外存读取数据或将数据写入外存。这个过程涉及到设备控制器与外存之间的数据传输，可能需要通过外存总线或其他特定接口进行。</li><li>完成操作：设备控制器完成读取或写入操作后，将状态信息返回给CPU，指示操作是否成功或是否有错误发生。</li></ol></blockquote><p>主存的结构如下：</p><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614140500484.png" alt="image-20230614140500484"></p><p>一个存储单元为一个bit，按字节编址的话一个地址对应的就是8个字节，数据总线读取一个地址的数据就一次性读取8个bit，这8个bit的地址都是一样的</p><p>如果CPU的数据总线是64位，则一次性最大可以读取64bit的数据也就是8个字节。</p><p>地址线为36位，则可以寻址的范围是0~2^36-1，即主存地址空间为64GB。</p><h1 id="2-存储器分类"><a href="#2-存储器分类" class="headerlink" title="2.存储器分类"></a>2.存储器分类</h1><h2 id="2-1-RAM"><a href="#2-1-RAM" class="headerlink" title="2.1 RAM"></a>2.1 RAM</h2><p>内存（主存，RAM，Random Access Memory）：</p><ol><li>主存是CPU直接访问的存储器，用于存储当前执行的程序、数据和临时计算结果。</li><li>分类：<ul><li>随机访问存储器（RAM）：包括动态随机访问存储器（DRAM）和静态随机访问存储器（SRAM）。DRAM存储器成本较低，容量较大，但读写速度相对较慢；SRAM存储器读写速度快，但成本较高。</li><li>缓存（Cache）：用于在CPU和主存之间提供快速数据访问，减少CPU等待数据的时间。根据接近CPU的级别不同，可以分为一级缓存（L1 Cache）、二级缓存（L2 Cache）等多级别缓存。</li></ul></li><li>应用场景：<ul><li>执行指令和存储数据：CPU从内存中读取指令和数据进行运算和处理。</li><li>运行操作系统和应用程序：操作系统和应用程序加载到内存中运行，提供计算、存储和交互功能。</li></ul></li></ol><h2 id="2-2-ROM"><a href="#2-2-ROM" class="headerlink" title="2.2 ROM"></a>2.2 ROM</h2><p>ROM是只读存储器（Read-Only Memory）的缩写，它是一种用于存储固定数据的存储器类型。与可写的存储器（如RAM）不同，ROM中的数据在制造或编程之后就无法被修改。</p><p>以下是一些关键特点和应用场景，以帮助更好理解ROM：</p><p>特点：</p><ol><li>只读性质：ROM中的数据在制造或编程之后就无法被修改或擦除。</li><li>非易失性：与RAM不同，ROM中的数据在断电或重新启动后仍然保持不变。</li><li>持久存储：ROM用于存储固定的数据，如固件、引导程序、不经常更改的配置信息等。</li></ol><p>应用场景：</p><ol><li>固件：ROM常用于存储计算机系统或电子设备的固件，包括BIOS（基本输入&#x2F;输出系统）、固件程序和引导加载器等。</li><li>引导程序：计算机启动时，ROM中的引导程序负责初始化硬件和加载操作系统。</li><li>芯片固化数据：ROM用于存储芯片的校准数据、配置信息和厂商特定的数据，以便在设备制造后使用。</li><li>只读存储媒体：一些光盘和芯片类型，如CD-ROM、DVD-ROM、Blu-ray Disc、EPROM（可擦除可编程只读存储器）等，被设计为只读存储介质。</li></ol><p>需要注意的是，不同类型的ROM可以具有不同的特性。例如，EPROM是一种可擦除可编程只读存储器，允许通过特殊操作将其中的数据擦除并重新编程，而普通的ROM则不具备这种功能。此外，还有一些衍生类型的ROM，如EEPROM（可擦除可编程只读存储器）、Flash存储器等，它们具有一定的可擦除和可重新编程的能力。</p><h2 id="2-3-储存器功能分类"><a href="#2-3-储存器功能分类" class="headerlink" title="2.3 储存器功能分类"></a>2.3 储存器功能分类</h2><ul><li>寄存器(Register) <ul><li>封装在CPU内，用于存放当前正在执行的指令和使用的数据 </li><li>用触发器实现，速度快，容量小（几~几十个）</li></ul></li><li>高速缓存(Cache) </li><li>位于CPU内部或附近，用来存放当前要执行的局部程序段和数据 </li><li>-用SRAM实现，速度可与CPU匹配，容量小（几MB） </li><li>内存储器MM（主存储器Main (Primary) Memory）<ul><li>位于CPU之外，用来存放已被启动的程序及所用的数据 </li><li>用DRAM实现，速度较快，容量较大（几GB）</li></ul></li><li>外存储器AM (辅助存储器Auxiliary &#x2F; Secondary Storage) <ul><li>位于主机之外，用来存放暂不运行的程序、数据或存档文件</li><li>用磁盘、SSD等实现，容量大而速度慢</li></ul></li></ul><p><img src="/2023/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE/image-20230614140240489.png" alt="image-20230614140240489"></p><h1 id="3-嵌入式存储实例"><a href="#3-嵌入式存储实例" class="headerlink" title="3.嵌入式存储实例"></a>3.嵌入式存储实例</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器 </tag>
            
            <tag> 计算机系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.新建quard-star开发板</title>
      <link href="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
      <url>/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-QEMU中新增虚拟开发板"><a href="#1-QEMU中新增虚拟开发板" class="headerlink" title="1. QEMU中新增虚拟开发板"></a>1. QEMU中新增虚拟开发板</h1><blockquote><p>参考链接：<a href="https://quard-star-tutorial.readthedocs.io/zh_CN/latest/ch2.html">基于qemu-riscv从0开始构建嵌入式linux系统ch2. 添加qemu仿真板——Quard-Star板 — 主页 (quard-star-tutorial.readthedocs.io)</a></p><p>本文主要参考了上面的博文，复现一下在qemu中自定义板卡的过程，用于个人学习。</p></blockquote><p>前言：qemu内置支持了一些开发板，我们可以基于这些内置的板子来做操作系统等软件的配置，但是实际市面上很多板子qemu中是没有提供支持的，要是直接在硬件中进行软件验证会十分麻烦，还好qemu中可以支持用户自定义开发板，这样就可以虚拟的对开发板进行验证了。</p><p>在向qemu中注册自定义的板子需要向qemu中添加源码，然后重新编译，qemu源码安装的编译过程我的这一篇博客：<a href="https://yanglianoo.github.io/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/">从源码构建Qemu | TimerのBlog (yanglianoo.github.io)</a></p><p>我们添加的板子cpu架构为riscv，进入qemu源码的<code>hw/riscv</code>目录下，可以看到如下图中的文件，其中qemu官方默认添加了几个riscv板子，比如：<code>virt</code>，<code>sifive</code>，其中<code>virt</code>，这块虚拟板子也是最常用的虚拟板子，常用于作为基于riscv操作系统的原型验证，比如<code>xv6，rvos</code>都是基于<code>qemu-virt</code>构建的。</p><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230612201442813.png" alt="image-20230612201442813"></p><p>再进入<code>include/hw/riscv</code>目录，这里放着虚拟板卡的头文件：</p><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230612202614817.png" alt="image-20230612202614817"></p><h1 id="2-quard-star开发板的硬件资源"><a href="#2-quard-star开发板的硬件资源" class="headerlink" title="2.quard_star开发板的硬件资源"></a>2.quard_star开发板的硬件资源</h1><p>我们将自定义的开发板名字命名为<code>quard_star</code>，理论上这块板子的硬件资源你可以随便定义，开发板的资源如下：</p><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/img3.png" alt="img3.png"></p><ul><li><p>CPU：8个64位的hart，<code>mmu</code>的虚拟地址翻译模式为<code>sv48</code></p></li><li><p>plic：平台级中断控制器</p></li><li><p>clint：内部中断控制器</p></li><li><p>mask-rom：32KB</p></li><li><p>PFLASH：32MB</p></li><li><p>DDR：1GB</p></li><li><p>NANO Flash：256MB</p></li><li><p>CAN：</p></li><li><p>DMA：</p></li><li><p>TIMER：</p></li><li><p>ETH：</p></li><li><p>USB：</p></li><li><p>SPI：</p></li><li><p>IIC：</p></li><li><p>ADC：</p></li><li><p>GPIO：</p></li><li><p>SDMMC：</p></li><li><p>UART：</p></li><li><p>RTC：</p></li><li><p>WATHDOG：</p></li></ul><p>我们的目标就是在qemu中创建这样一个开发板，需要依次在qemu中定义每一个硬件。接下来就来逐步添加每一个硬件</p><h1 id="3-添加quard-star板子"><a href="#3-添加quard-star板子" class="headerlink" title="3.添加quard-star板子"></a>3.添加quard-star板子</h1><blockquote><p>声明：以下使用的qemu源码版本均为<code>qemu-8.0.2</code>，参考代码为qemu的virt这块板子的代码，我们需要先让qemu识别到<code>quard-star</code>这块板子，然后再逐渐丰富板子的外设。</p></blockquote><p>注册<code>quard-star</code>板子需要修改如下几个文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`qemu-8.0.2/configs/devices/riscv64-softmmu/default.mak`</span><br><span class="line">`qemu-8.0.2/configs/devices/riscv32-softmmu/default.mak`</span><br><span class="line">`qemu-8.0.2/hw/riscv/meson.build`</span><br><span class="line">`qemu-8.0.2/hw/riscv/Kconfig`</span><br></pre></td></tr></table></figure><p>要在qemu中定义自己的虚拟板卡，需要在<code>hw/riscv</code>目录下增加一个和自己板子相关的<code>.c</code>文件，以及在<code>include/hw/riscv</code>目录下添加一个对应虚拟板子的<code>.h</code>文件，这里新增<code>quard_star.c</code>和<code>quard_star.h</code>文件，将其加入qemu编译体系内。</p><h2 id="3-1-文件修改"><a href="#3-1-文件修改" class="headerlink" title="3.1 文件修改"></a>3.1 文件修改</h2><ul><li><code>qemu-8.0.2/hw/riscv/meson.build</code></li></ul><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230613210722392.png" alt="image-20230613210722392"></p><ul><li><code>qemu-8.0.2/hw/riscv/Kconfig</code>：这里只暂时只选中一个串口设备。</li></ul><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230613210910355.png" alt="image-20230613210910355"></p><ul><li><code>qemu-8.0.2/configs/devices/riscv32-softmmu/default.mak</code></li></ul><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230613211119900.png" alt="image-20230613211119900"></p><ul><li><code>qemu-8.0.2/configs/devices/riscv64-softmmu/default.mak</code></li></ul><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230613215029879.png" alt="image-20230613215029879"></p><h2 id="3-2-添加源码"><a href="#3-2-添加源码" class="headerlink" title="3.2 添加源码"></a>3.2 添加源码</h2><p>这里先把源码添加上去，后续慢慢分析，源码来自于文章开头参考的项目以及<code>qemu</code>中<code>virt</code>的源码。这里只定义了和初始化了MROM、SRAM、DRAM三种硬件。</p><h3 id="3-2-1-quard-star-h"><a href="#3-2-1-quard-star-h" class="headerlink" title="3.2.1 quard_star.h"></a>3.2.1 quard_star.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HW_RISCV_QUARD_STAR__H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HW_RISCV_QUARD_STAR__H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/riscv_hart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/sysbus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qom/object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/block/flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_CPUS_MAX 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_SOCKETS_MAX 8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_RISCV_QUARD_STAR_MACHINE MACHINE_TYPE_NAME(<span class="string">&quot;quard-star&quot;</span>)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QuardStarState</span> <span class="title">QuardStarState</span>;</span></span><br><span class="line">DECLARE_INSTANCE_CHECKER(QuardStarState, RISCV_VIRT_MACHINE,</span><br><span class="line">                         TYPE_RISCV_QUARD_STAR_MACHINE)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuardStarState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_UART0_IRQ = <span class="number">10</span>,  <span class="comment">//定义了串口中断号为10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-2-1-quard-star-c"><a href="#3-2-1-quard-star-c" class="headerlink" title="3.2.1 quard_star.c"></a>3.2.1 quard_star.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/units.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/error-report.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/guest-random.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/boards.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/loader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/sysbus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-properties.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/char/serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;target/riscv/cpu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/riscv_hart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/quard_star.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/boot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/numa.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/intc/riscv_aclint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/intc/riscv_aplic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev/char.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/device_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/sysemu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/kvm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/tpm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 创建CPU */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_cpu_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, base_hartid, hart_count;</span><br><span class="line">    <span class="type">char</span> *soc_name;</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QUARD_STAR_SOCKETS_MAX &lt; riscv_socket_count(machine)) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;number of sockets/nodes should be less than %d&quot;</span>,</span><br><span class="line">            QUARD_STAR_SOCKETS_MAX);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; riscv_socket_count(machine); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!riscv_socket_check_hartids(machine, i)) &#123;</span><br><span class="line">            error_report(<span class="string">&quot;discontinuous hartids in socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        base_hartid = riscv_socket_first_hartid(machine, i);</span><br><span class="line">        <span class="keyword">if</span> (base_hartid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error_report(<span class="string">&quot;can&#x27;t find hartid base for socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hart_count = riscv_socket_hart_count(machine, i);</span><br><span class="line">        <span class="keyword">if</span> (hart_count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error_report(<span class="string">&quot;can&#x27;t find hart count for socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        soc_name = g_strdup_printf(<span class="string">&quot;soc%d&quot;</span>, i);</span><br><span class="line">        object_initialize_child(OBJECT(machine), soc_name, &amp;s-&gt;soc[i],</span><br><span class="line">                                TYPE_RISCV_HART_ARRAY);</span><br><span class="line">        g_free(soc_name);</span><br><span class="line">        object_property_set_str(OBJECT(&amp;s-&gt;soc[i]), <span class="string">&quot;cpu-type&quot;</span>,</span><br><span class="line">                                machine-&gt;cpu_type, &amp;error_abort);</span><br><span class="line">        object_property_set_int(OBJECT(&amp;s-&gt;soc[i]), <span class="string">&quot;hartid-base&quot;</span>,</span><br><span class="line">                                base_hartid, &amp;error_abort);</span><br><span class="line">        object_property_set_int(OBJECT(&amp;s-&gt;soc[i]), <span class="string">&quot;num-harts&quot;</span>,</span><br><span class="line">                                hart_count, &amp;error_abort);</span><br><span class="line">        sysbus_realize(SYS_BUS_DEVICE(&amp;s-&gt;soc[i]), &amp;error_abort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建内存 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_memory_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    MemoryRegion *system_memory = get_system_memory();</span><br><span class="line">    <span class="comment">//分配三片存储空间 dram sram mrom</span></span><br><span class="line">    MemoryRegion *dram_mem = g_new(MemoryRegion, <span class="number">1</span>);  <span class="comment">//DRAM</span></span><br><span class="line">    MemoryRegion *sram_mem = g_new(MemoryRegion, <span class="number">1</span>);  <span class="comment">//SRAM</span></span><br><span class="line">    MemoryRegion *mask_rom = g_new(MemoryRegion, <span class="number">1</span>);  <span class="comment">//MROM  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    memory_region_init_ram(dram_mem, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.dram&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_DRAM].size, &amp;error_fatal);</span><br><span class="line">    memory_region_add_subregion(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_DRAM].base, dram_mem);</span><br><span class="line"></span><br><span class="line">    memory_region_init_ram(sram_mem, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.sram&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_SRAM].size, &amp;error_fatal);</span><br><span class="line">    memory_region_add_subregion(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_SRAM].base, sram_mem);</span><br><span class="line"></span><br><span class="line">    memory_region_init_rom(mask_rom, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.mrom&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_MROM].size, &amp;error_fatal);</span><br><span class="line">    memory_region_add_subregion(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_MROM].base, mask_rom);</span><br><span class="line"></span><br><span class="line">    riscv_setup_rom_reset_vec(machine, &amp;s-&gt;soc[<span class="number">0</span>], </span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].size,</span><br><span class="line">                              <span class="number">0x0</span>, <span class="number">0x0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* quard-star 初始化各种硬件 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//创建CPU</span></span><br><span class="line">   quard_star_cpu_create(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   quard_star_memory_create(machine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建machine */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    MachineClass *mc = MACHINE_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V Quard Star board&quot;</span>;</span><br><span class="line">    mc-&gt;init = quard_star_machine_init;</span><br><span class="line">    mc-&gt;max_cpus = QUARD_STAR_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 注册 quard-star */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo quard_star_machine_typeinfo = &#123;</span><br><span class="line">    .name       = MACHINE_TYPE_NAME(<span class="string">&quot;quard-star&quot;</span>),</span><br><span class="line">    .parent     = TYPE_MACHINE,</span><br><span class="line">    .class_init = quard_star_machine_class_init,</span><br><span class="line">    .instance_init = quard_star_machine_instance_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(QuardStarState),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">         &#123; TYPE_HOTPLUG_HANDLER &#125;,</span><br><span class="line">         &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;quard_star_machine_typeinfo);</span><br><span class="line">&#125;</span><br><span class="line">type_init(quard_star_machine_init_register_types)</span><br></pre></td></tr></table></figure><h3 id="3-3-3-源码分析"><a href="#3-3-3-源码分析" class="headerlink" title="3.3.3 源码分析"></a>3.3.3 源码分析</h3><p>可以看见创建新的板子的流程为：</p><p>1.在<code>quard-star.h</code>中的<code>QuardStarState</code>结构体中为板子新建硬件，这些硬件表现在软件中为一个个的结构体，各种硬件结构体定义在<code>hw/</code>目录下，比如我现在只创建了CPU。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct QuardStarState &#123;</span><br><span class="line">    /*&lt; private &gt;*/</span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    /*&lt; public &gt;*/</span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.往<code>static const MemMapEntry quard_star_memmap[]</code>结构体数组中添加硬件的地址和映射的地址长度，注意这里的长度不能为0，不然会报错，其实这里DRAM的大小应该是qemu启动时需要用户输入的，例如<code>-m 1G</code>，这里暂不知道如何实现，所以指定了一个长度，不然会assert报错。<code>MemMapEntry </code>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemMapEntry</span> &#123;</span></span><br><span class="line">    hwaddr base; <span class="comment">//基址</span></span><br><span class="line">    hwaddr size; <span class="comment">//长度</span></span><br><span class="line">&#125; MemMapEntry;</span><br></pre></td></tr></table></figure><p>3.创建硬件，比如我这里创建并初始化了ram和rom，新建了<code>quard_star_memory_create</code>函数。在函数的最后这里调用了一个很重要的函数<code> riscv_setup_rom_reset_vec</code>，这个函数定义在<code>boot.c</code>中，函数主体如下：</p><blockquote><p>参考链接：<a href="https://github.com/wangzhou/notes/blob/master/%E5%A4%9A%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91">notes&#x2F;多核启动基本逻辑 at master · wangzhou&#x2F;notes · GitHub</a></p><p>参考链接：<a href="https://tinylab.org/qemu-riscv-zsbl/">QEMU 启动方式分析（3）: QEMU 代码与 RISCV virt 平台 ZSBL 分析 - 泰晓科技 (tinylab.org)</a></p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">riscv_setup_rom_reset_vec</span><span class="params">(MachineState *machine, RISCVHartArrayState *harts,</span></span><br><span class="line"><span class="params">                               hwaddr start_addr,</span></span><br><span class="line"><span class="params">                               hwaddr rom_base, hwaddr rom_size,</span></span><br><span class="line"><span class="params">                               <span class="type">uint64_t</span> kernel_entry,</span></span><br><span class="line"><span class="params">                               <span class="type">uint64_t</span> fdt_load_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> start_addr_hi32 = <span class="number">0x00000000</span>;</span><br><span class="line">    <span class="type">uint32_t</span> fdt_load_addr_hi32 = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!riscv_is_32bit(harts)) &#123;</span><br><span class="line">        start_addr_hi32 = start_addr &gt;&gt; <span class="number">32</span>;</span><br><span class="line">        fdt_load_addr_hi32 = fdt_load_addr &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* reset vector */</span></span><br><span class="line">    <span class="type">uint32_t</span> reset_vec[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="number">0x00000297</span>,                  <span class="comment">/* 1:  auipc  t0, %pcrel_hi(fw_dyn) */</span></span><br><span class="line">        <span class="number">0x02828613</span>,                  <span class="comment">/*     addi   a2, t0, %pcrel_lo(1b) */</span></span><br><span class="line">        <span class="number">0xf1402573</span>,                  <span class="comment">/*     csrr   a0, mhartid  */</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0x00028067</span>,                  <span class="comment">/*     jr     t0 */</span></span><br><span class="line">        start_addr,                  <span class="comment">/* start: .dword */</span></span><br><span class="line">        start_addr_hi32,</span><br><span class="line">        fdt_load_addr,               <span class="comment">/* fdt_laddr: .dword */</span></span><br><span class="line">        fdt_load_addr_hi32,</span><br><span class="line">                                     <span class="comment">/* fw_dyn: */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (riscv_is_32bit(harts)) &#123;</span><br><span class="line">        reset_vec[<span class="number">3</span>] = <span class="number">0x0202a583</span>;   <span class="comment">/*     lw     a1, 32(t0) */</span></span><br><span class="line">        reset_vec[<span class="number">4</span>] = <span class="number">0x0182a283</span>;   <span class="comment">/*     lw     t0, 24(t0) */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reset_vec[<span class="number">3</span>] = <span class="number">0x0202b583</span>;   <span class="comment">/*     ld     a1, 32(t0) */</span></span><br><span class="line">        reset_vec[<span class="number">4</span>] = <span class="number">0x0182b283</span>;   <span class="comment">/*     ld     t0, 24(t0) */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!harts-&gt;harts[<span class="number">0</span>].cfg.ext_icsr) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The Zicsr extension has been disabled, so let&#x27;s ensure we don&#x27;t</span></span><br><span class="line"><span class="comment">         * run the CSR instruction. Let&#x27;s fill the address with a non</span></span><br><span class="line"><span class="comment">         * compressed nop.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        reset_vec[<span class="number">2</span>] = <span class="number">0x00000013</span>;   <span class="comment">/*     addi   x0, x0, 0 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy in the reset vector in little_endian byte order */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(reset_vec); i++) &#123;</span><br><span class="line">        reset_vec[i] = cpu_to_le32(reset_vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rom_add_blob_fixed_as(<span class="string">&quot;mrom.reset&quot;</span>, reset_vec, <span class="keyword">sizeof</span>(reset_vec),</span><br><span class="line">                          rom_base, &amp;address_space_memory);</span><br><span class="line">    riscv_rom_copy_firmware_info(machine, rom_base, rom_size, <span class="keyword">sizeof</span>(reset_vec),</span><br><span class="line">                                 kernel_entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码执行以下操作：</p><ol><li>根据传入的参数，计算 <code>start_addr</code> 和 <code>fdt_load_addr</code> 的高 32 位（如果处理器不是 32 位的话）。</li><li>定义一个长度为 10 的 <code>reset_vec</code> 数组，用于存储复位向量的指令序列。</li><li>根据处理器是否为 32 位来设置不同的指令序列：<ul><li>如果是 32 位处理器，使用 <code>lw</code> 指令来加载 <code>a1</code> 和 <code>t0</code> 的值。</li><li>如果是 64 位处理器，使用 <code>ld</code> 指令来加载 <code>a1</code> 和 <code>t0</code> 的值。</li></ul></li><li>如果处理器的 <code>ext_icsr</code> 属性为假（即禁用了 Zicsr 扩展），则将复位向量的第 2 个指令替换为一个不压缩的 <code>nop</code> 指令（<code>addi x0, x0, 0</code>）。</li><li>将复位向量的指令按小端字节序进行拷贝。</li><li>使用 <code>rom_add_blob_fixed_as</code> 函数将复位向量的指令添加到固定地址的 ROM 中。</li><li>调用 <code>riscv_rom_copy_firmware_info</code></li></ol><p>我们先来看最后先了调用<code>rom_add_blob_fixed_as</code>函数将<code>reset_vec</code>中的代码拷贝到rom的起始位置，板子上电后最先执行的指令就是ROM起始位置处的这些指令。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rom_add_blob_fixed_as(<span class="string">&quot;mrom.reset&quot;</span>, reset_vec, <span class="keyword">sizeof</span>(reset_vec),</span><br><span class="line">                          rom_base, &amp;address_space_memory);  </span><br></pre></td></tr></table></figure><p>然后调用<code>riscv_rom_copy_firmware_info</code>，我们来看看这个函数，定义在<code>boot.c</code>中:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">riscv_rom_copy_firmware_info</span><span class="params">(MachineState *machine, hwaddr rom_base,</span></span><br><span class="line"><span class="params">                                  hwaddr rom_size, <span class="type">uint32_t</span> reset_vec_size,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint64_t</span> kernel_entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fw_dynamic_info</span> <span class="title">dinfo</span>;</span></span><br><span class="line">    <span class="type">size_t</span> dinfo_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(dinfo.magic) == <span class="number">4</span>) &#123;</span><br><span class="line">        dinfo.magic = cpu_to_le32(FW_DYNAMIC_INFO_MAGIC_VALUE);</span><br><span class="line">        dinfo.version = cpu_to_le32(FW_DYNAMIC_INFO_VERSION);</span><br><span class="line">        dinfo.next_mode = cpu_to_le32(FW_DYNAMIC_INFO_NEXT_MODE_S);</span><br><span class="line">        dinfo.next_addr = cpu_to_le32(kernel_entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dinfo.magic = cpu_to_le64(FW_DYNAMIC_INFO_MAGIC_VALUE);</span><br><span class="line">        dinfo.version = cpu_to_le64(FW_DYNAMIC_INFO_VERSION);</span><br><span class="line">        dinfo.next_mode = cpu_to_le64(FW_DYNAMIC_INFO_NEXT_MODE_S);</span><br><span class="line">        dinfo.next_addr = cpu_to_le64(kernel_entry);</span><br><span class="line">    &#125;</span><br><span class="line">    dinfo.options = <span class="number">0</span>;</span><br><span class="line">    dinfo.boot_hart = <span class="number">0</span>;</span><br><span class="line">    dinfo_len = <span class="keyword">sizeof</span>(dinfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * copy the dynamic firmware info. This information is specific to</span></span><br><span class="line"><span class="comment">     * OpenSBI but doesn&#x27;t break any other firmware as long as they don&#x27;t</span></span><br><span class="line"><span class="comment">     * expect any certain value in &quot;a2&quot; register.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dinfo_len &gt; (rom_size - reset_vec_size)) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;not enough space to store dynamic firmware info&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rom_add_blob_fixed_as(<span class="string">&quot;mrom.finfo&quot;</span>, &amp;dinfo, dinfo_len,</span><br><span class="line">                           rom_base + reset_vec_size,</span><br><span class="line">                           &amp;address_space_memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数初始化了一个<code>fw_dynamic_info</code>类型的结构体，这个结构体包含了下一阶段程序启动的地址、魔数、下一阶段CPU位于S态，初始化完毕后又调用<code>rom_add_blob_fixed_as</code>函数将<code>fw_dynamic_info</code>拷贝到rom的<code>reset_vec</code>之后，用于下一阶段的启动。在这里其实可以不用使用这个函数来传递设备树，后续需要我们自己来编写设备树然后编译，在下一阶段将固件中设备树的地址传给启动的下一阶段。</p><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p><p>所以现在再来看上面<code>reset_vec</code>的代码，将上面的代码翻译一下如下，以32位的cpu为例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reset_vec[<span class="number">0</span>] = <span class="number">0x00000297</span>;   <span class="comment">// auipc  t0, %pcrel_hi(fw_dyn)</span></span><br><span class="line">reset_vec[<span class="number">1</span>] = <span class="number">0x02828613</span>;   <span class="comment">// addi   a2, t0, %pcrel_lo(1b)</span></span><br><span class="line">reset_vec[<span class="number">2</span>] = <span class="number">0xf1402573</span>;   <span class="comment">// csrr   a0, mhartid</span></span><br><span class="line">reset_vec[<span class="number">3</span>] = <span class="number">0x0202a583</span>;   <span class="comment">// lw     a1, 32(t0)</span></span><br><span class="line">reset_vec[<span class="number">4</span>] = <span class="number">0x0182a283</span>;   <span class="comment">// lw     t0, 24(t0)</span></span><br><span class="line">reset_vec[<span class="number">5</span>] = <span class="number">0x00028067</span>;   <span class="comment">// jr     t0</span></span><br><span class="line">reset_vec[<span class="number">6</span>] = start_addr;   <span class="comment">// start: .dword (32-bit address)</span></span><br><span class="line">reset_vec[<span class="number">7</span>] = <span class="number">0</span>;            <span class="comment">// unused</span></span><br><span class="line">reset_vec[<span class="number">8</span>] = fdt_load_addr; <span class="comment">// fdt_laddr: .dword (32-bit address)</span></span><br><span class="line">reset_vec[<span class="number">9</span>] = <span class="number">0</span>;            <span class="comment">// unused</span></span><br></pre></td></tr></table></figure><p>具体来说，这段汇编代码完成了以下操作：</p><ol><li><code>auipc t0, %pcrel_hi(fw_dyn)</code>：使用当前 PC（程序计数器）的高 20 位（相对于 <code>fw_dyn</code> 标签的偏移量）来设置 <code>t0</code> 寄存器的值。这里的<code>fw_dyn</code>就是储存在<code>rom</code>的<code>fw_dynamic_info</code>的地址了，此时<code>PC=0x00000000</code>.从汇编语意上看，这句的意思是，<code>%pcrel_hi(fw_d</code>yn)表示计算<code>fw_dyn</code>这个符号相对于当前PC的偏移 的高20bit，而<code>auipc t0, imm</code>表示把<code>imm</code>和当前<code>PC</code>相加，结果保存到<code>t0</code>。所以，这条指令整体上的结果是会将<code>fw_dyn</code>相对于<code>pc</code>的高20位地址取出然后拓展为32位与pc相加，得到的结果保存到<code>t0</code>。这里执行完毕后<code>t0=0x00000000</code>。</li><li><code>addi a2, t0, %pcrel_lo(1b)</code>：使用当前 PC（相对于标签 <code>1b</code> 的偏移量）的低 12 位来设置 <code>a2</code> 寄存器的值。这个<code>1b</code>符号是啥我一直没搞懂，有没有大神告诉我，呜呜。看起来这两条指令的意思是将<code>fw_dynamic_info</code>的地址存到了<code>a2</code>中用于下一阶段启动的参数。</li><li><code>csrr a0, mhartid</code>：将处理器的硬件线程 ID（mhartid）存储到 <code>a0</code> 寄存器中。</li><li><code>lw a1, 32(t0)</code>：从 <code>t0</code> 寄存器指向的地址偏移 32 处加载一个字（32 位）的数据到 <code>a1</code> 寄存器中。<code>32(t0)</code>的地址刚好是<code>reset_vec</code>，所以fdt的地址被送到了a1寄存器中，fdt为设备树的地址，这里还没定义。</li><li><code>lw t0, 24(t0)</code>：从 <code>t0</code> 寄存器指向的地址偏移 24 处加载一个字（32 位）的数据到 <code>t0</code> 寄存器中。<code>24(t0)</code>的地址刚好是<code>reset_vec[6]</code>，存储的是<code>start_addr</code>,这了传入的参数为<code>flash</code>的地址。</li><li><code>jr t0</code>：跳转到 <code>t0</code> 寄存器中保存的地址，即跳转到了flash处开始执行下一阶段的引导程序。</li></ol><p>4.将所用创建硬件的函数用<code>static void quard_star_machine_init</code>包含起来,这里创建了CPU和主存。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* quard-star 初始化各种硬件 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//创建CPU</span></span><br><span class="line">   quard_star_cpu_create(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   quard_star_memory_create(machine);</span><br><span class="line">   <span class="comment">// 其他硬件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.注需要去初始化<code>machine</code>：创建<code>static void quard_star_machine_class_init</code>函数，并将<code>machine</code>结构体各个字段更新。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建machine */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    MachineClass *mc = MACHINE_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V Quard Star board&quot;</span>;</span><br><span class="line">    mc-&gt;init = quard_star_machine_init;</span><br><span class="line">    mc-&gt;max_cpus = QUARD_STAR_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.注册quard-star</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 注册 quard-star */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo quard_star_machine_typeinfo = &#123;</span><br><span class="line">    .name       = MACHINE_TYPE_NAME(<span class="string">&quot;quard-star&quot;</span>),</span><br><span class="line">    .parent     = TYPE_MACHINE,</span><br><span class="line">    .class_init = quard_star_machine_class_init,</span><br><span class="line">    .instance_init = quard_star_machine_instance_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(QuardStarState),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">         &#123; TYPE_HOTPLUG_HANDLER &#125;,</span><br><span class="line">         &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;quard_star_machine_typeinfo);</span><br><span class="line">&#125;</span><br><span class="line">type_init(quard_star_machine_init_register_types)</span><br></pre></td></tr></table></figure><h2 id="3-3-文件夹目录变更"><a href="#3-3-文件夹目录变更" class="headerlink" title="3.3 文件夹目录变更"></a>3.3 文件夹目录变更</h2><p>我原本qemu源码的目录为：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2/</span><br></pre></td></tr></table></figure><p>修改文件夹名变为如下：将最上层的qemu目录重命名为了quard_star</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard_star/qemu-8.0.2/</span><br></pre></td></tr></table></figure><p>然后在此目录下新建一个脚本文件用于编译qemu：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> build.sh</span><br></pre></td></tr></table></figure><p><code>build.sh</code>的内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前脚本文件所在的目录</span></span><br><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"></span><br><span class="line">cd qemu-8.0.2</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/qemu&quot; ]; then  </span><br><span class="line">./configure --prefix=$SHELL_FOLDER/output/qemu  --target-list=riscv64-softmmu --enable-gtk  --enable-virtfs --disable-gio</span><br><span class="line">fi  </span><br><span class="line">make -j16</span><br><span class="line">sudo make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><ol><li><code>cd qemu-8.0.2</code>：切换到 <code>qemu-8.0.2</code> 目录下。</li><li><code>if [ ! -d &quot;$SHELL_FOLDER/output/qemu&quot; ]; then</code>：如果目录 <code>$SHELL_FOLDER/output/qemu</code> 不存在，则执行下面的命令。</li><li><code>./configure --prefix=$SHELL_FOLDER/output/qemu --target-list=riscv64-softmmu --enable-gtk --enable-virtfs --disable-gio</code>：运行 <code>configure</code> 脚本，用于配置编译参数。这里指定了安装路径为 <code>$SHELL_FOLDER/output/qemu</code>，目标平台为 <code>riscv64-softmmu</code>，开启了 GTK 支持和 VirtFS 支持，禁用了 GIO 支持。</li><li><code>fi</code>：结束条件语句的块。</li><li><code>make -j16</code>：使用并发编译，编译生成目标文件。</li><li><code>make install</code>：将编译得到的目标文件安装到系统中。</li><li><code>cd ..</code>：切换回上一级目录。</li></ol><p>执行完build脚本后，编译完成后的qemu位于output文件夹下，再创建一个脚本文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard_star$ <span class="built_in">touch</span> run.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard_star$ <span class="built_in">chmod</span> +x run.sh</span><br></pre></td></tr></table></figure><p><code>run.sh</code>的内容如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(<span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span>;<span class="built_in">pwd</span>)</span><br><span class="line"><span class="variable">$SHELL_FOLDER</span>/output/qemu/bin/qemu-system-riscv64 \</span><br><span class="line">-M quard-star \</span><br><span class="line">-m 1G \</span><br><span class="line">-smp 8 \</span><br></pre></td></tr></table></figure><h2 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h2><p>运行脚本：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/quard_star$ ./build.sh</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/quard_star$ ./run.sh</span><br></pre></td></tr></table></figure><p>板子启动后在qemu的monitor界面输入<code>info qtree</code>就可看见<code>quard-star</code>的硬件信息，如下：</p><p><img src="/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/image-20230613213926716.png" alt="image-20230613213926716"></p><p>这里我们只为quard-star板子创建了主存。</p><blockquote><p>源码地址：<a href="https://github.com/yanglianoo/quard-star">yanglianoo&#x2F;quard-star: 从零基于qemu创建riscv嵌入式开发板，并移植操作系统 (github.com)</a></p><p>有问题请与我联系：wechat：13699648817</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基于qemu从零开始构建riscv64的嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树详解</title>
      <link href="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-设备树简介"><a href="#1-设备树简介" class="headerlink" title="1.设备树简介"></a>1.设备树简介</h1><p>传统上，操作系统内核会直接编译进所有支持的硬件设备的驱动程序。但是，随着硬件设备的不断增多和变化，这种方法变得不够灵活。设备树的引入解决了这个问题。设备树将硬件的描述信息以一种结构化的方式存储在单独的文件中，然后在引导过程中由操作系统内核加载和解析。</p><p>设备树文件使用一种称为”Device Tree Source”（DTS）的语言编写，它是一种人类可读的文本格式。该文件描述了硬件设备的层次结构、寄存器地址、中断线路、DMA通道和其他相关属性。这些信息对于内核来说非常重要，因为它们允许内核正确地初始化和配置硬件设备。</p><p>设备树文件经过<code>DTC</code>编译后会生成一种称为”Device Tree Blob”（DTB）的二进制格式。DTB文件在引导过程中由引导加载程序（Bootloader）提供给内核。内核会解析DTB文件，根据其中的描述信息初始化硬件设备，并加载相应的驱动程序。</p><p>设备树的作用在于用来描述一个具体的硬件平台的硬件资源，如果没有设备树，当我有一个新的硬件平台时，在移植操作系统时需要去修改源码去适配这个具体的硬件平台。有了设备树之后，bootloader就能直接从设备树中获取硬件信息，而不需要去修改源码，使得Linux内核的兼容性和可移植性大大增强。</p><ul><li><p><code>DTS：</code>Device Tree Source，<code>.dts</code>格式的文件，是一种<code>ASII </code>文本格式的设备树描述，也是我们要编写的设备树源码，一般一个<code>.dts</code>文件对应一个硬件平台，位于Linux源码的<code>/arch/***/boot/dts”</code>目录下。</p></li><li><p><code>DTC：</code>Device Tree Compiler，是指编译设备树源码的工具，一般情况下我们需要手动安装这个编译工具。</p></li><li><p><code>DTB </code>：是设备树源码编译生成的文件，类似于我们C语言中“.C”文件编译生成“.bin”文件</p></li></ul><img src="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/1503563-20200915000144208-924995757.png" alt="Linux驱动之设备树的基础知识 - 山无言 - 博客园" style="zoom:67%;"><blockquote><p>参考链接：<a href="https://doc.embedfire.com/linux/imx6/base/zh/latest/linux_driver/driver_tree.html">doc.embedfire.com&#x2F;linux&#x2F;imx6&#x2F;base&#x2F;zh&#x2F;latest&#x2F;linux_driver&#x2F;driver_tree.html</a></p></blockquote><h1 id="2-设备树基本语法架构分析"><a href="#2-设备树基本语法架构分析" class="headerlink" title="2.设备树基本语法架构分析"></a>2.设备树基本语法架构分析</h1><h2 id="2-1-dts基本框架"><a href="#2-1-dts基本框架" class="headerlink" title="2.1 dts基本框架"></a>2.1 dts基本框架</h2><p><code>1.头文件</code>：设备树是可以像C语言那样使用“#include”引用“.h”后缀的头文件，也可以引用设备树“.dtsi”后缀的头文件。因此这里<code>k210.dts</code>引用了<code>k210.dtsi</code>中的文件</p><p><code>2.设备树节点</code>：每一个<code>&#123; &#125;</code>都是一个节点，<code>/ &#123;…&#125;</code>表示“根节点”， 在根节点内部的“aliases {…}”、“chosen {…}”、“memory {…}”等字符，都是根节点的子节点。</p><p><code>3.设备树节点追加内容</code>：向已经存在的子节点追加数据，这些已经存在的节点可能定义在<code>.dts</code>文件里，也可能定义在<code>.dtsi</code>文件里，这些节点比根节点下的子节点多了一个<code>&amp;</code>。</p><p>设备树由一个根节点和众多子节点组成，子节点也可以继续包含其他节点，也就是子节点的子节点。</p><h3 id="2-1-1节点基本格式"><a href="#2-1-1节点基本格式" class="headerlink" title="2.1.1节点基本格式"></a>2.1.1节点基本格式</h3><p>设备树中的每个节点都按照以下约定命名：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">node-name@unit-address<span class="punctuation">&#123;</span></span><br><span class="line">    属性<span class="number">1</span> = …</span><br><span class="line">    属性<span class="number">2</span> = …</span><br><span class="line">    属性<span class="number">3</span> = …</span><br><span class="line">    子节点…</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>节点格式中的<code> node-name</code> 用于指定节点的名称。 它的长度为1至31个字符，只能由如下字符组成:</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>0-9</td><td>数字</td></tr><tr><td>a-z</td><td>小写字母</td></tr><tr><td>A-Z</td><td>大写字母</td></tr><tr><td>,</td><td>英文逗号</td></tr><tr><td>.</td><td>英文句号</td></tr><tr><td>_</td><td>下划线</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>-</td><td>减号</td></tr></tbody></table><blockquote><p>注意：根节点没有节点名，它直接使用“&#x2F;”指代这是一个根节点。</p></blockquote><p><code>@unit-address</code> ：其中的符号“@”可以理解为是一个分割符，“unit-address”用于指定“单元地址”， 它的值要和节点“reg”属性的第一个地址一致。如果节点没有“reg”属性值，可以直接省略“@unit-address”， 不过要注意这时要求同级别的设备树下（相同级别的子节点）节点名唯一,从这个侧面也可以了解到， 同级别的子节点的节点名可以相同，但是要求“单元地址”不同，node-name@unit-address 的整体要求同级唯一。</p><h3 id="2-1-2-节点标签"><a href="#2-1-2-节点标签" class="headerlink" title="2.1.2 节点标签"></a>2.1.2 节点标签</h3><p>例如：</p><pre><code>sysctl: sysctl@50440000 &#123;        compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;;        reg = &lt;0x50440000 0x1000&gt;;        #clock-cells = &lt;1&gt;;&#125;;</code></pre><p>则<code>sysctl</code>就代表了<code>sysctl@50440000</code>这个节点的标签，用<code>:</code>来指明。通常节点标签是节点名的简写，所以它的作用是当其它位置需要引用时可以使用节点标签来向该节点中追加内容。</p><h3 id="2-1-3-节点路径"><a href="#2-1-3-节点路径" class="headerlink" title="2.1.3 节点路径"></a>2.1.3 节点路径</h3><p>通过指定从根节点到所需节点的完整路径，可以唯一地标识设备树中的节点，<code>不同层次的设备树节点名字可以相同，同层次的设备树节点要唯一</code>。 这有点类似于我们Windows上的文件，一个路径唯一标识一个文件或文件夹，不同目录下的文件文件名可以相同。</p><h3 id="2-1-4-节点属性"><a href="#2-1-4-节点属性" class="headerlink" title="2.1.4 节点属性"></a>2.1.4 节点属性</h3><ul><li><p><strong>compatible属性</strong>：属性值类型：字符串</p><p>compatible属性值由一个或多个字符串组成，有多个字符串时使用“,”分隔开。设备树中的每一个代表了一个设备的节点都要有一个compatible属性。 compatible是系统用来决定绑定到设备的设备驱动的关键。 compatible属性是用来查找节点的方法之一，另外还可以通过节点名或节点路径查找指定节点。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>model属性</strong>：属性值类型：字符串</p><p>model属性用于指定设备的制造商和型号，推荐使用“制造商, 型号”的格式，当然也可以自定义。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;Kendryte K210 generic&quot;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>status属性</strong></p><p>状态属性用于指示设备的“操作状态”，通过status可以去禁止设备或者启用设备，可用的操作状态如下表。默认情况下不设置status属性设备是使能的。</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* External sound card */</span></span><br><span class="line"><span class="symbol">sound:</span> <span class="title class_">sound</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>reg属性</strong></p><p>reg属性描述设备资源在其父总线定义的地址空间内的地址。通常情况下用于表示一块内存的起始地址（偏移地址）和长度， 在特定情况下也有不同的含义。 ret属性的书写格式为reg &#x3D; &lt; cells cells cells cells cells cells…&gt;，长度根据实际情况而定， 这些数据分为地址数据（地址字段），长度数据（大小字段）</p><p>例如：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure><p>这里描述了三段内存：起始地址为0x80000000，大小为0x400000；起始地址为：0x80400000 ，0x200000；起始地址为：0x80600000，大小为：0x200000。每一个cells都是32位的，如果想要描述一个64位的地址，需要先设置#address-cells 和 #size-cells属性的值。</p></li><li><p><strong>#address-cells 和 #size-cells</strong></p><p>#address-cells，用于指定子节点reg属性“地址字段”所占的长度（单元格cells的个数）。</p><p> #size-cells，用于指定子节点reg属性“大小字段”所占的长度（单元格cells的个数）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line">    ocrams: sram@900000 &#123;</span><br><span class="line">            compatible = &quot;fsl,lpm-sram&quot;;</span><br><span class="line">            reg = &lt;0x900000 0x4000&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如当#address-cells&#x3D;2，#address-cells&#x3D;1，则reg内的数据含义为<code>reg = &lt;address address size address address size&gt;</code>，这样就可以来描述一个64位的地址了。</p></li><li><p><strong>device_type</strong></p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">    <span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;arm,cortex-a7&quot;</span><span class="punctuation">;</span></span><br><span class="line">        device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>device_type属性也是一个很少用的属性，只用在CPU和内存的节点上。 如上例中所示，device_type用在了CPU节点。</p></li><li><p><strong>ranges</strong></p></li></ul><h3 id="2-1-5-特殊节点"><a href="#2-1-5-特殊节点" class="headerlink" title="2.1.5 特殊节点"></a>2.1.5 特殊节点</h3><ul><li><code>aliases</code>子节点：aliases子节点的作用就是为其他节点起一个别名，如下所示。</li></ul><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">    can0 = <span class="variable">&amp;flexcan1</span><span class="punctuation">;</span></span><br><span class="line">    can1 = <span class="variable">&amp;flexcan2</span><span class="punctuation">;</span></span><br><span class="line">    ethernet0 = <span class="variable">&amp;fec1</span><span class="punctuation">;</span></span><br><span class="line">    ethernet1 = <span class="variable">&amp;fec2</span><span class="punctuation">;</span></span><br><span class="line">    gpio0 = <span class="variable">&amp;gpio1</span><span class="punctuation">;</span></span><br><span class="line">    gpio1 = <span class="variable">&amp;gpio2</span><span class="punctuation">;</span></span><br><span class="line">    gpio2 = <span class="variable">&amp;gpio3</span><span class="punctuation">;</span></span><br><span class="line">    gpio3 = <span class="variable">&amp;gpio4</span><span class="punctuation">;</span></span><br><span class="line">    gpio4 = <span class="variable">&amp;gpio5</span><span class="punctuation">;</span></span><br><span class="line">    i2c0 = <span class="variable">&amp;i2c1</span><span class="punctuation">;</span></span><br><span class="line">    i2c1 = <span class="variable">&amp;i2c2</span><span class="punctuation">;</span></span><br><span class="line">    <span class="comment">/*----------- 以下省略------------*/</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以“can0 &#x3D; &amp;flexcan1;”为例。“flexcan1”是一个节点的名字， 设置别名后我们可以使用“can0”来指代flexcan1节点，与节点标签类似。 在设备树中更多的是为节点添加标签，没有使用节点别名，别名的作用是“快速找到设备树节点”。 在驱动中如果要查找一个节点，通常情况下我们可以使用“节点路径”一步步找到节点。 也可以使用别名“一步到位”找到节点。</p><ul><li><code>chosen子节点</code>：chosen子节点位于根节点下，如下所示</li></ul><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">stdout-path</span> <span class="operator">=</span> <span class="variable">&amp;uart1</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>chosen子节点不代表实际硬件，它主要用于给内核传递参数。 这里只设置了“stdout-path &#x3D;&amp;uart1;”一条属性，表示系统标准输出stdout使用串口uart1。 此外这个节点还用作uboot向linux内核传递配置参数的“通道”， 我们在Uboot中设置的参数就是通过这个节点传递到内核的， 这部分内容是uboot和内核自动完成的。</p><h1 id="3-Linux内核中K210设备树分析"><a href="#3-Linux内核中K210设备树分析" class="headerlink" title="3.Linux内核中K210设备树分析"></a>3.Linux内核中K210设备树分析</h1><p>从Linux 5.7 开始，Linux内核开始支持国产 RISC-V 芯片 K210，在本地的linux5.10版本中的<code>/arch/riscv/boot/dts</code>文件夹中可以找到kendryte的K210设备树文件，我们以此为例子，来分析设备树的语法与语义</p><p><img src="/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/image-20230611222950267.png" alt="image-20230611222950267"></p><h2 id="3-1-k210-dts分析"><a href="#3-1-k210-dts分析" class="headerlink" title="3.1 k210.dts分析"></a>3.1 k210.dts分析</h2><p>其中<code>k210.dts</code>的文件如下：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;k210.dtsi&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">//设置节点基本属性</span></span><br><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;Kendryte K210 generic&quot;</span><span class="punctuation">;</span>  <span class="comment">//指定为嘉楠的K210</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span>     <span class="comment">//设置compatible属性</span></span><br><span class="line"><span class="comment">// 设置chosen特殊节点，</span></span><br><span class="line"><span class="title class_">chosen</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">bootargs</span> <span class="operator">=</span> <span class="string">&quot;earlycon console=ttySIF0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">stdout-path</span> <span class="operator">=</span> <span class="string">&quot;serial0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;uarths0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li>第一行：引用头文件，<code>k210.dts</code>引用了<code>k210.dtsi</code>中的文件</li><li>3~12行：k210的根节点，每一个设备树只有一个根节点。 如果打开<code>k210.dtsi</code>文件可以发现它也有一个根节点，虽然<code>k210.dts</code>引用了<code>k210.dtsi</code>文件， 但这并不代表设备树有两个根节点，因为不同文件的根节点最终会合并为一个。<ul><li><code>bootargs = &quot;earlycon console=ttySIF0&quot;;</code> 是 “chosen” 节点的属性之一。它用于指定系统引导过程中传递给内核的启动参数（boot arguments）。在这里，设置的启动参数是 “earlycon console&#x3D;ttySIF0”，表示使用早期控制台（early console）并将其输出重定向到名为 “ttySIF0” 的串口设备。</li><li><code>stdout-path = &quot;serial0&quot;;</code> 是 “chosen” 节点的另一个属性。它用于指定标准输出（stdout）的路径。在这里，标准输出被设置为名为 “serial0” 的设备。</li></ul></li><li>13~15行：设备树增加内容。向<code>uarths0</code>子节点添加了一个属性，<code>status = &quot;okay&quot;;</code> 在这里，状态被设置为 “okay”，表示<code>uarths0</code>设备节点处于可用状态，可以正常使用。</li></ul><h2 id="3-2-k210-dtsi分析"><a href="#3-2-k210-dtsi分析" class="headerlink" title="3.2 k210.dtsi分析"></a>3.2 k210.dtsi分析</h2><h3 id="3-2-1-根节点"><a href="#3-2-1-根节点" class="headerlink" title="3.2.1 根节点"></a>3.2.1 根节点</h3><p><code>k210.dtsi</code>的文件如下：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dt-bindings/clock/k210-clk.h&gt;</span></span></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Although the K210 is a 64-bit CPU, the address bus is only 32-bits</span></span><br><span class="line"><span class="comment"> * wide, and the upper half of all addresses is ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">serial0 = <span class="variable">&amp;uarths0</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The K210 has an sv39 MMU following the priviledge specification v1.9.</span></span><br><span class="line"><span class="comment"> * Since this is a non-ratified draft specification, the kernel does not</span></span><br><span class="line"><span class="comment"> * support it and the K210 support enabled only for the !MMU case.</span></span><br><span class="line"><span class="comment"> * Be consistent with this by setting the CPUs MMU type to &quot;none&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">timebase-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7800000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="title class_">cpu@1</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu1_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">sram:</span> <span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-names</span> <span class="operator">=</span> <span class="string">&quot;sram0&quot;</span>, <span class="string">&quot;sram1&quot;</span>, <span class="string">&quot;aisram&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">clocks</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">in0:</span> <span class="title class_">oscillator</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fixed-clock&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">26000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">soc</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-soc&quot;</span>, <span class="string">&quot;simple-bus&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">ranges</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;plic0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">sysctl:</span> <span class="title class_">sysctl@50440000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-sysctl&quot;</span>, <span class="string">&quot;simple-mfd&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x50440000</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">clint0:</span> <span class="title class_">clint@2000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,clint0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x2000000</span> <span class="number">0xC000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span>  <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">3</span> <span class="variable">&amp;cpu0_intc</span> <span class="number">7</span></span></span><br><span class="line"><span class="params"><span class="variable">&amp;cpu1_intc</span> <span class="number">3</span> <span class="variable">&amp;cpu1_intc</span> <span class="number">7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_ACLK&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">plic0:</span> <span class="title class_">interrupt-controller@c000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-plic0&quot;</span>, <span class="string">&quot;riscv,plic0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0xC000000</span> <span class="number">0x4000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-extended</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">11</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cpu0_intc</span> <span class="number">0xffffffff</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="variable">&amp;cpu1_intc</span> <span class="number">11</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cpu1_intc</span> <span class="number">0xffffffff</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,ndev</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">65</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,max-priority</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">uarths0:</span> <span class="title class_">serial@38000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210-uarths&quot;</span>, <span class="string">&quot;sifive,uart0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x38000000</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">33</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>在第一行中包含了一个c语言中的头文件<code>#include &lt;dt-bindings/clock/k210-clk.h&gt;</code>，这个文件位于<code>linux-5.10.99/include/dt-bindings/clock</code>下，打开此文件如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> K210_CLK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Arbitrary identifiers for clocks.</span></span><br><span class="line"><span class="comment"> * The structure is: in0 -&gt; pll0 -&gt; aclk -&gt; cpu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since we use the hardware defaults for now, set all these to the same clock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_PLL0   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_PLL1   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_ACLK   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K210_CLK_CPU    0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* K210_CLK_H */</span></span></span><br></pre></td></tr></table></figure><p>可以看到，只是定义了一些宏定义，后续可能用到</p><p><code>7~13</code>行</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">serial0 = <span class="variable">&amp;uarths0</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>#address-cells = &lt;1&gt;;</code> 指定了设备树中地址单元的数量，这里设置为 1。</li><li><code>#size-cells = &lt;1&gt;;</code> 指定了设备树中大小单元的数量，这里也设置为 1。</li><li><code>compatible = &quot;kendryte,k210&quot;;</code> 表示设备树描述的硬件与 Kendryte K210 SoC 兼容。这个属性用于标识设备树所描述的硬件平台或设备的兼容性。</li><li><code>aliases</code>：定义了一个别名 <code>serial0</code>，它指向名为 <code>uarths0</code> 的设备。</li></ul><h3 id="3-2-2-cpu节点"><a href="#3-2-2-cpu节点" class="headerlink" title="3.2.2 cpu节点"></a>3.2.2 cpu节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">cpus</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;    <span class="comment">// 地址单元为1</span></span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;        <span class="comment">// 大小单元为0</span></span></span><br><span class="line"><span class="attr">timebase-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">7800000</span>&gt;</span><span class="punctuation">;</span>  <span class="comment">//指定cpu时钟基准频率7800000hz</span></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="title class_">cpu@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu0_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="title class_">cpu@1</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;kendryte,k210&quot;</span>, <span class="string">&quot;sifive,rocket0&quot;</span>, <span class="string">&quot;riscv&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">riscv,isa</span> <span class="operator">=</span> <span class="string">&quot;rv64imafdc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">mmu-type</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">i-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x8000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">d-cache-block-size</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">64</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;sysctl</span> K210_CLK_CPU&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">390000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">cpu1_intc:</span> <span class="title class_">interrupt-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;riscv,cpu-intc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>cpu单元定义了两个核心分别为cpu0和cpu1，两个cpu核心的配置差不都，下面依次描述一下具体描述了哪些信息，这里以cpu0为例子：</p><ul><li><p>device_type &#x3D; “cpu”：表示此节点为cpu。</p></li><li><p>reg &#x3D; &lt;0&gt;：标明这是0号处理器。</p></li><li><p>compatible &#x3D; “kendryte,k210”, “sifive,rocket0”, “riscv”：指定cpu的标识。</p></li><li><p>riscv,isa &#x3D; “rv64imafdc”：表明该cpu为rv64imafdc架构。</p></li><li><p>mmu-type &#x3D; “none”：cpu不启用mmu，未开启虚拟内存功能。</p></li><li><p>i-cache-size &#x3D; &lt;0x8000&gt;：指令缓存的大小为 0x8000，即 32768 字节（或 32 KB）。</p></li><li><p>i-cache-block-size &#x3D; &lt;64&gt;：指令缓存的块大小为 64 字节。</p></li><li><p>d-cache-size &#x3D; &lt;0x8000&gt;：数据缓存（Data Cache）的大小为 0x8000，即 32768 字节（或 32 KB）。</p></li><li><p>d-cache-block-size &#x3D; &lt;64&gt;：数据缓存的块大小为 64 字节。</p></li><li><p>clocks &#x3D; &lt;&amp;sysctl K210_CLK_CPU&gt;：指向设备树中名为 <code>sysctl</code> 的节点， <code>sysctl</code> 定义在下面的<code>soc</code>节点中,并使用 K210_CLK_CPU 作为其子节点，K210_CLK_CPU这个宏定义在<code>k210-clk.h</code>中，值为：0。表明cpu0的时钟是 <code>sysctl</code> 节点中的0号子时钟</p></li><li><p>clock-frequency &#x3D; &lt;390000000&gt;：指定时钟的频率为390MHZ</p></li><li><p>cpu0_intc：中断控制器节点，用于处理与 CPU 0 相关的中断。</p><ul><li><code>#interrupt-cells = &lt;1&gt;</code>：指定了中断单元的数量，即中断号码的位数。在这种情况下，每个中断使用一个单元（一个整数值）来表示。</li><li><code>interrupt-controller</code>：表示该节点是中断控制器。</li><li><code>compatible = &quot;riscv,cpu-intc&quot;</code>：指定了该中断控制器节点与 RISC-V 架构的 CPU 中断控制器兼容。</li></ul></li></ul><h3 id="3-2-3-SRAM节点"><a href="#3-2-3-SRAM节点" class="headerlink" title="3.2.3 SRAM节点"></a>3.2.3 SRAM节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sram:</span> <span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x400000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80400000</span> <span class="number">0x200000</span>&gt;</span>,</span><br><span class="line">      <span class="params">&lt;<span class="number">0x80600000</span> <span class="number">0x200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-names</span> <span class="operator">=</span> <span class="string">&quot;sram0&quot;</span>, <span class="string">&quot;sram1&quot;</span>, <span class="string">&quot;aisram&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>memory@80000000</code>：指定了 SRAM 的基地址为 <code>0x80000000</code>。</li><li><code>device_type = &quot;memory&quot;</code>：指定了设备类型为内存。</li><li><code>reg</code>：指定了 SRAM 的物理地址范围。在这种情况下，SRAM 被划分为三个连续的地址范围：<ul><li><code>&lt;0x80000000 0x400000&gt;</code>：<code>sram0</code> 的地址范围为从 <code>0x80000000</code> 到 <code>0x803FFFFF</code>，大小为 4 MB。</li><li><code>&lt;0x80400000 0x200000&gt;</code>：<code>sram1</code> 的地址范围为从 <code>0x80400000</code> 到 <code>0x805FFFFF</code>，大小为 2 MB。</li><li><code>&lt;0x80600000 0x200000&gt;</code>：<code>aisram</code> 的地址范围为从 <code>0x80600000</code> 到 <code>0x807FFFFF</code>，大小为 2 MB。</li></ul></li><li><code>reg-names = &quot;sram0&quot;, &quot;sram1&quot;, &quot;aisram&quot;</code>：指定了对应于每个地址范围的名称</li></ul><h3 id="3-2-4-clocks节点"><a href="#3-2-4-clocks节点" class="headerlink" title="3.2.4 clocks节点"></a>3.2.4 clocks节点</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">clocks</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">in0:</span> <span class="title class_">oscillator</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fixed-clock&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">26000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>该设备树中的 <code>clocks</code> 节点定义了一个名为 <code>in0</code> 的时钟，具体如下：</p><ul><li><code>in0</code>：时钟的名称为 <code>in0</code>。</li><li><code>oscillator</code>：指定了该时钟源为一个振荡器。</li><li><code>compatible = &quot;fixed-clock&quot;</code>：指定了时钟的类型为固定频率时钟。</li><li><code>#clock-cells = &lt;0&gt;</code>：表示该时钟节点不需要附加的时钟单元属性。</li><li><code>clock-frequency = &lt;26000000&gt;</code>：指定了时钟的频率为 26 MHz。</li></ul><h3 id="3-2-5-soc节点"><a href="#3-2-5-soc节点" class="headerlink" title="3.2.5 soc节点"></a>3.2.5 soc节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;kendryte,k210-soc&quot;, &quot;simple-bus&quot;;</span><br><span class="line">ranges;  //省略ranges属性，不存在地址映射</span><br><span class="line">interrupt-parent = &lt;&amp;plic0&gt;;   </span><br><span class="line"></span><br><span class="line">sysctl: sysctl@50440000 &#123;</span><br><span class="line">compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;;</span><br><span class="line">reg = &lt;0x50440000 0x1000&gt;;</span><br><span class="line">#clock-cells = &lt;1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">clint0: clint@2000000 &#123;</span><br><span class="line">#interrupt-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;riscv,clint0&quot;;</span><br><span class="line">reg = &lt;0x2000000 0xC000&gt;;</span><br><span class="line">interrupts-extended =  &lt;&amp;cpu0_intc 3 &amp;cpu0_intc 7</span><br><span class="line">&amp;cpu1_intc 3 &amp;cpu1_intc 7&gt;;</span><br><span class="line">clocks = &lt;&amp;sysctl K210_CLK_ACLK&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">plic0: interrupt-controller@c000000 &#123;</span><br><span class="line">#interrupt-cells = &lt;1&gt;;</span><br><span class="line">interrupt-controller;</span><br><span class="line">compatible = &quot;kendryte,k210-plic0&quot;, &quot;riscv,plic0&quot;;</span><br><span class="line">reg = &lt;0xC000000 0x4000000&gt;;</span><br><span class="line">interrupts-extended = &lt;&amp;cpu0_intc 11&gt;, &lt;&amp;cpu0_intc 0xffffffff&gt;,</span><br><span class="line">      &lt;&amp;cpu1_intc 11&gt;, &lt;&amp;cpu1_intc 0xffffffff&gt;;</span><br><span class="line">riscv,ndev = &lt;65&gt;;</span><br><span class="line">riscv,max-priority = &lt;7&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uarths0: serial@38000000 &#123;</span><br><span class="line">compatible = &quot;kendryte,k210-uarths&quot;, &quot;sifive,uart0&quot;;</span><br><span class="line">reg = &lt;0x38000000 0x1000&gt;;</span><br><span class="line">interrupts = &lt;33&gt;;</span><br><span class="line">clocks = &lt;&amp;sysctl K210_CLK_CPU&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>interrupt-parent = &lt;&amp;plic0&gt;</code>：指定了中断控制器的父节点，这里使用的是 plic0 中断控制器的引用。</p></li><li><p><code>sysctl: sysctl@50440000</code>：这是一个子节点，描述了系统控制器 (sysctl)。它有以下属性：</p><ul><li><code>compatible = &quot;kendryte,k210-sysctl&quot;, &quot;simple-mfd&quot;</code>：指定了系统控制器的兼容性标识符，表示该节点描述的是 Kendryte K210 SoC 的系统控制器，并且它是一个多功能设备。</li><li><code>reg = &lt;0x50440000 0x1000&gt;</code>：指定了系统控制器在内存中的地址范围。</li><li><code>#clock-cells = &lt;1&gt;</code>：指定了该节点使用的时钟单元数。</li></ul></li><li><p><code>clint0: clint@2000000</code>：这是另一个子节点，描述了 CLINT (Core Local Interruptor)。它有以下属性：</p><ul><li><code>compatible = &quot;riscv,clint0&quot;</code>：指定了 CLINT 的兼容性标识符。</li><li><code>reg = &lt;0x2000000 0xC000&gt;</code>：指定了 CLINT 在内存中的地址范围。</li><li><code>interrupts-extended</code>：指定了 CLINT 支持的中断引脚，这里使用的是 <code>cpu0_intc</code> 和 <code>cpu1_intc</code> 的引用。</li><li><code>clocks = &lt;&amp;sysctl K210_CLK_ACLK&gt;</code>：指定了 CLINT 使用的时钟源，这里使用的是 <code>sysctl</code> 节点中的 <code>K210_CLK_ACLK</code> 时钟。</li></ul></li><li><p><code>plic0: interrupt-controller@c000000</code>：这是另一个子节点，描述了 PLIC (Platform-Level Interrupt Controller)。它有以下属性：</p><ul><li><code>compatible = &quot;kendryte,k210-plic0&quot;, &quot;riscv,plic0&quot;</code>：指定了 PLIC 的兼容性标识符。</li><li><code>reg = &lt;0xC000000 0x4000000&gt;</code>：指定了 PLIC 在内存中的地址范围。</li><li><code>interrupts-extended</code>：指定了 PLIC 支持的中断引脚，这里使用的是 <code>cpu0_intc</code> 和 <code>cpu1_intc</code> 的引用。</li><li><code>riscv,ndev = &lt;65&gt;</code>：指定了 PLIC 支持的设备数量。</li><li><code>riscv,max-priority = &lt;7&gt;</code>：指定了 PLIC 支持的最大优先级</li></ul></li><li><p><code>uarths0: serial@38000000</code>：这是串口设备的节点定义，名称为 <code>uarths0</code>，描述了串口在内存中的地址范围。</p><ul><li><code>compatible = &quot;kendryte,k210-uarths&quot;, &quot;sifive,uart0&quot;</code>：指定了串口设备的兼容性标识符，表示该节点描述的是 Kendryte K210 SoC 的 <code>uarths0</code> 串口，并且它兼容 SiFive 的 UART0 设备。</li><li><code>reg = &lt;0x38000000 0x1000&gt;</code>：指定了串口设备在内存中的地址范围。</li><li><code>interrupts = &lt;33&gt;</code>：指定了串口设备的中断引脚，这里使用的是中断号 33。</li><li><code>clocks = &lt;&amp;sysctl K210_CLK_CPU&gt;</code>：指定了串口设备使用的时钟源，这里使用的是 <code>sysctl</code> 节点中的 <code>K210_CLK_CPU</code> 时钟。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 设备树 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源码构建Qemu</title>
      <link href="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/"/>
      <url>/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Qemu介绍"><a href="#1-Qemu介绍" class="headerlink" title="1.Qemu介绍"></a>1.Qemu介绍</h1><p>QEMU（Quick Emulator）是一个开源的虚拟化软件，它可以模拟多个硬件平台，包括处理器和外设，从而允许在一个平台上运行多个不同的操作系统。QEMU可以运行在多个主机平台上，包括Linux、Windows、macOS等。</p><p>QEMU的主要功能是模拟一个完整的计算机系统，包括处理器、内存、存储器、网络接口等，它可以将客户操作系统（例如Linux、Windows等）当作应用程序运行在主机操作系统之上，从而实现虚拟化。QEMU还支持通过二进制代码转换的方式实现虚拟化加速，例如使用KVM（Kernel-based Virtual Machine）模块加速虚拟机的运行。</p><p>QEMU可以用于多种用途，包括：</p><ol><li>系统仿真：可以模拟不同的处理器架构（如x86、ARM等）来运行和测试操作系统和应用程序，方便开发人员进行交叉平台开发和调试。</li><li>虚拟机：可以在一个物理机上运行多个虚拟机实例，每个虚拟机可以运行不同的操作系统，实现资源的隔离和共享，提供虚拟化环境。</li><li>可移植性：QEMU可以将一个操作系统或应用程序打包成一个虚拟机镜像，这个镜像可以在不同的平台上运行，提供了一种便携式的软件分发方式。</li></ol><blockquote><p>官方源码地址：<a href="https://github.com/qemu/qemu">Qemu的github源码</a></p><p>官网地址：<a href="https://www.qemu.org/">QEMU</a></p><p>qemu的文档地址：<a href="https://www.qemu.org/docs/master/">Welcome to QEMU’s documentation! — QEMU documentation</a></p></blockquote><h1 id="2-源码下载"><a href="#2-源码下载" class="headerlink" title="2.源码下载"></a>2.源码下载</h1><p>在笔者下载源码的时间，目前<code>qemu</code>的版本已经更新到了<code>8.0.2</code>，我的ubuntu环境为：<code>WSL2 ubuntu20.04.05</code></p><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611160604923.png" alt="image-20230611160604923"></p><p>安装所需编译环境：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install ninja-build pkg-config libglib2.0-dev libpixman-1-dev libgtk-3-dev libcap-ng-dev libattr1-dev libsdl2-dev device-tree-compiler bison flex gperf intltool mtd-utils libslirp-dev</span><br></pre></td></tr></table></figure><p>源码下载与编译：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~$ <span class="built_in">mkdir</span> qemu</span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ <span class="built_in">cd</span> qemu/</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ wget https://download.qemu.org/qemu-8.0.2.tar.xz</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ tar xvJf qemu-8.0.2.tar.xz</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu$ <span class="built_in">cd</span> qemu-8.0.2/</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ ./configure</span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ make -j8</span><br></pre></td></tr></table></figure><p>编译完成后会生成一个<code>./build</code>目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2$ <span class="built_in">cd</span> build/</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由于我之前使用package的方式在本地安装了一个qemu，因此先将其卸载</span></span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ sudo apt-get remove --auto-remove qemu-system-x86</span><br><span class="line">timer@DESKTOP-JI9EVEH:~$ sudo apt-get purge --auto-remove qemu-system-x86</span><br><span class="line"><span class="comment">#卸载完成后进入build目录执行安装命令，需要sudo不然会报错</span></span><br><span class="line">timer@DESKTOP-JI9EVEH:~/qemu/qemu-8.0.2/build$ sudo make install</span><br></pre></td></tr></table></figure><p>测试，查看<code>qemu</code>版本号，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-img -V</span><br></pre></td></tr></table></figure><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611164450596.png" alt="image-20230611164450596"></p><p>启动qemu，这里以riscv64为例：<code>qemu-system-riscv64</code></p><p><img src="/2023/06/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAQemu/image-20230611164621585.png" alt="image-20230611164621585"></p><p>大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> Qemu&amp;虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-3.实模式</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-X86cpu工作原理"><a href="#1-X86cpu工作原理" class="headerlink" title="1. X86cpu工作原理"></a>1. X86cpu工作原理</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611121633671.png" alt="image-20230611121633671"></p><p>程序计数器<code>PC</code>存储了下一条要运行的指定的地址，在x86cpu上，<code>PC</code>就是：<code>cs：ip</code>，控制单元读取<code>ip</code>寄存器中的地址后，将此地址送上地址总线，<code>cpu</code>由此得到了要执行的指令，然后将指令存入指令寄存器<code>IR</code>中。下一步指令译码器将此指令解码，解码后得到了操作数和操作码，于是操作控制器<code>OC</code>就给运算单元下令，运算单元就开始执行指令。<code>ip</code>寄存器的值被加上当前指令的大小，由此循环。</p><p>IA32的指令格式如下：</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611123557111.png" alt="image-20230611123557111"></p><h2 id="2-实模式的寻址"><a href="#2-实模式的寻址" class="headerlink" title="2. 实模式的寻址"></a>2. 实模式的寻址</h2><p>8086的地址总线是20位宽，意味着寻址范围为：<code>2^20=1MB</code>，但内部寄存器都是16位的，若采用单一寄存器来寻址只能访问：<code>2^16=64KB</code>空间。</p><p>为了解决16位寄存器不能寻址20位的问题，因此通过先把16位的段基址左移四位变成20位后，在加上段内偏移地址，这样就形成了20位地址，只要保证了段基址是20位的，偏移地址是多少位就不用关心了。</p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU3RyaXZlIGZvciB0aGUgYmVzdO-8gQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="3.操作系统——CPU的实模式、保护模式和长模式_Strive for the best！的博客-CSDN博客" style="zoom: 50%;"><p>下面列举一下寻址实例：所有的利用寄存器寻址的方式，每个寄存器都有对应的段基址，寄存器的默认段基址见上一章</p><ol><li><p>直接寻址（Direct addressing）：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> AX, [<span class="number">0x1234</span>]</span><br><span class="line"><span class="keyword">mov</span> ax, [fs:<span class="number">0x5678</span>]</span><br></pre></td></tr></table></figure><p>0x1234是段内偏移地址，默认的段地址是DS，这一条指令是将内存地址<code>DS:0x1234</code>处的值写入<code>ax</code>寄存器。</p><p>第二条指定显示指定段基址为<code>fs</code>,因此是将内存地址<code>FS:0x5678</code>处的值写入<code>ax</code>寄存器。</p><p>注意：段基址都需要先左移4位再与段内偏移相加</p></li><li><p>基址寻址（Base addressing）：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> AX, [BX + <span class="number">0x10</span>]</span><br></pre></td></tr></table></figure><p>这个例子中，将从BX寄存器所指定的内存地址加上偏移量0x10处读取一个字（16位）的数据，并将其存储在AX寄存器中。bx默认的段寄存器为DS，因此实际的寻址地址为：<code>DS:bx+0x10</code></p></li></ol><h2 id="3-栈的布局"><a href="#3-栈的布局" class="headerlink" title="3.栈的布局"></a>3.栈的布局</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AE%9E%E6%A8%A1%E5%BC%8F/image-20230611131141910.png" alt="image-20230611131141910"></p><p>栈空间也是内存中一段区域，我们程序员可以自由分配，SS栈段寄存器左移4位指向栈底，栈的生长是向低地址方向发展，sp指向了栈顶。</p><p>在进行函数调用时，例如使用call指令，需要将PC压栈，然后跳转。</p>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-2.X86寄存器详解</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是寄存器"><a href="#1-什么是寄存器" class="headerlink" title="1.什么是寄存器"></a>1.什么是寄存器</h1><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果以及一些CPU运行需要的信息</p><p>x86架构CPU走的是<code>复杂指令集（CISC）</code> 路线，提供了丰富的指令来实现强大的功能，与此同时也提供了大量寄存器来辅助功能实现。寄存器分为两类，一类对程序员不可见，这一类寄存器用于支撑CPU内部运行，程序员无法操作。一类对程序员可见，在进行汇编编写程序时，能够直接操作。</p><ul><li>通用寄存器：<code>EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP</code></li><li>标志寄存器：<code>EFLAGS</code></li><li>指令寄存器：<code>EIP</code></li><li>段寄存器：<code>CS、DS、ES、FS、GS、SS</code></li><li>控制寄存器：<code>CR0、CR1、CR2、CR3、CR4</code></li><li>调试寄存器：<code>DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7</code></li><li>描述符寄存器：<code>GDTR、IDTR、LDTR、TR</code></li></ul><h1 id="2-实模式下寄存器（16bit）"><a href="#2-实模式下寄存器（16bit）" class="headerlink" title="2.实模式下寄存器（16bit）"></a>2.实模式下寄存器（16bit）</h1><p>在x86架构下，实模式可以使用的通用寄存器有 <code>AX、BX、CX、DX、SI、DI、BP</code> 和 <code>SP</code>。这些寄存器都是16位的，可以分为两个8位的寄存器来使用。</p><p>此外，还有一些特殊用途的寄存器，包括：</p><ul><li><code>IP</code>（指令指针寄存器）：保存当前执行的指令地址。</li><li><code>CS</code>（代码段寄存器）：保存代码段的起始地址。</li><li><code>DS</code>（数据段寄存器）：保存数据段的起始地址。</li><li><code>ES</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>GS</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>FS</code>（附加段寄存器）：附加数据段的起始地址。</li><li><code>SS</code>（堆栈段寄存器）：保存堆栈段的起始地址。</li><li><code>FLAGS</code>（标志寄存器）：包含各种标志位，如零标志、进位标志、符号标志等</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230611122704382.png" alt="image-20230611122704382"></p><p>其中<code>FS</code>,<code>GS</code>附加段寄存器是在32位CPU中增加的，但是在32位CPU中在实模式下同样可以使用，因为32位CPU兼容16位CPU的特性。</p><table><thead><tr><th>16位寄存器</th><th>功能</th><th>高8位</th><th>低8位</th></tr></thead><tbody><tr><td><code>AX</code></td><td>累加寄存器，常用于算术运算，保存与外设输入输出的数据</td><td><code>AH</code></td><td><code>AL</code></td></tr><tr><td><code>CX</code></td><td>计数寄存器，常用于循环指令中的循环次数</td><td><code>CH</code></td><td><code>CL</code></td></tr><tr><td><code>DX</code></td><td>数据寄存器，通常情况下只用于保存外设控制器的端口号地址</td><td><code>DH</code></td><td><code>DL</code></td></tr><tr><td><code>BX</code></td><td>基址寄存器，来存储内存地址，段基址为DS</td><td><code>BH</code></td><td><code>BL</code></td></tr><tr><td><code>SP</code></td><td>栈指针寄存器，段基址为SS，用来指向栈顶</td><td></td><td></td></tr><tr><td><code>BP</code></td><td>栈帧的基址寄存器，段基址为SS</td><td></td><td></td></tr><tr><td><code>SI</code></td><td>源变址寄存器，存储数据源地址,段基址为DS</td><td></td><td></td></tr><tr><td><code>DI</code></td><td>目的变址寄存器，存储数据目的地址,段基址为DS</td><td></td><td></td></tr></tbody></table><blockquote><p>BP指向栈底，SP指向栈顶，两者共同维护了栈空间。<code>push</code> 和 <code>pop</code> 可更改<code>SP</code>的值,<code>sp</code>指针的值会自动更新</p></blockquote><h2 id="2-1-寄存器用法举例"><a href="#2-1-寄存器用法举例" class="headerlink" title="2.1 寄存器用法举例"></a>2.1 寄存器用法举例</h2><ul><li><p><code>SI、DI</code></p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">mov</span> ecx, <span class="number">10</span>  <span class="comment">; 设置循环计数为10</span></span><br><span class="line">    <span class="keyword">mov</span> esi, <span class="number">0</span>  <span class="comment">; 设置SI寄存器为0作为初始值</span></span><br><span class="line">    <span class="keyword">mov</span> edi, <span class="number">100</span>  <span class="comment">; 设置DI寄存器为100作为初始值</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">loop_start:</span></span><br><span class="line">    <span class="keyword">mov</span> eax, [esi]  <span class="comment">; 从源地址(SI)读取数据到EAX寄存器</span></span><br><span class="line">    <span class="keyword">mov</span> [edi], eax  <span class="comment">; 将数据存储到目的地址(DI)</span></span><br><span class="line">    <span class="keyword">add</span> esi, <span class="number">4</span>  <span class="comment">; 增加SI的值，以便读取下一个双字</span></span><br><span class="line">    <span class="keyword">add</span> edi, <span class="number">4</span>  <span class="comment">; 增加DI的值，以便存储到下一个地址</span></span><br><span class="line">    loop loop_start  <span class="comment">; 循环，减少ECX计数，直到为零</span></span><br></pre></td></tr></table></figure><p>在这个例子中，SI和DI寄存器用作源地址和目的地址。循环从源地址读取数据，然后将其存储到目的地址，然后递增SI和DI以访问下一个元素。通过loop指令和ECX计数器，循环执行直到计数为零。</p></li><li><p><code>BP、SP</code></p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">push</span> ebp         <span class="comment">; 保存当前函数的旧的基址到堆栈中</span></span><br><span class="line"><span class="keyword">mov</span> ebp, esp     <span class="comment">; 将当前堆栈指针存储到基址指针寄存器BP中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sub</span> esp, <span class="number">16</span>      <span class="comment">; 分配16字节的局部变量空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> dword ptr [ebp<span class="number">-4</span>], <span class="number">10</span>   <span class="comment">; 将值10存储到基址指针寄存器BP-4指向的位置（局部变量）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> eax, dword ptr [ebp<span class="number">-4</span>]  <span class="comment">; 从基址指针寄存器BP-4指向的位置读取值到EAX寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> esp, <span class="number">16</span>      <span class="comment">; 释放局部变量空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pop</span> ebp          <span class="comment">; 恢复旧的基址到基址指针寄存器BP中</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-保护模式下寄存器（32bit）"><a href="#3-保护模式下寄存器（32bit）" class="headerlink" title="3.保护模式下寄存器（32bit）"></a>3.保护模式下寄存器（32bit）</h1><h2 id="3-1-保护模式寄存器介绍"><a href="#3-1-保护模式寄存器介绍" class="headerlink" title="3.1 保护模式寄存器介绍"></a>3.1 保护模式寄存器介绍</h2><p>在32位保护模式下，x86架构提供了更多的通用寄存器以及扩展功能。以下是32位保护模式下可以使用的寄存器：</p><ol><li>通用寄存器（General Purpose Registers）：<ul><li><code>EAX</code>：累加器寄存器（Accumulator Register）。</li><li><code>EBX</code>：基址寄存器（Base Register）。</li><li><code>ECX</code>：计数寄存器（Counter Register）。</li><li><code>EDX</code>：数据寄存器（Data Register）。</li><li><code>ESI</code>：源索引寄存器（Source Index Register）。</li><li><code>EDI</code>：目的索引寄存器（Destination Index Register）。</li><li><code>EBP</code>：基址指针寄存器（Base Pointer Register）。</li><li><code>ESP</code>：堆栈指针寄存器（Stack Pointer Register）。</li></ul></li><li>扩展通用寄存器：<ul><li><code>EIP</code>：指令指针寄存器（Instruction Pointer Register）。</li><li><code>EFLAGS</code>：标志寄存器（Flags Register），用于存储各种标志位，如零标志、进位标志、符号标志等。</li></ul></li><li>段寄存器（Segment Registers）：<ul><li><code>CS</code>：代码段寄存器（Code Segment Register）。</li><li><code>DS</code>：数据段寄存器（Data Segment Register）。</li><li><code>ES</code>：附加段寄存器（Extra Segment Register）。</li><li><code>FS、GS、SS</code>：附加段寄存器，用于访问额外的数据段。</li></ul></li><li>控制寄存器（Control Registers）：<ul><li><code>CR0、CR2、CR3、CR4</code>：用于控制和管理保护模式的特性，如分页机制、特权级等。</li></ul></li><li>段描述符寄存器（Descriptor Registers）：<ul><li><code>GDTR</code>：全局描述符表寄存器（Global Descriptor Table Register）。</li><li><code>IDTR</code>：中断描述符表寄存器（Interrupt Descriptor Table Register）。</li><li><code>LDTR</code>：局部描述符表寄存器（Local Descriptor Table Register）。</li><li><code>TR</code>：任务寄存器（Task Register）。</li></ul></li></ol><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230128173803324.png" alt="image-20230128173803324" style="zoom: 80%;"><h2 id="3-2-控制寄存器"><a href="#3-2-控制寄存器" class="headerlink" title="3.2 控制寄存器"></a>3.2 控制寄存器</h2><h3 id="3-2-1-CR0寄存器"><a href="#3-2-1-CR0寄存器" class="headerlink" title="3.2.1 CR0寄存器"></a>3.2.1 <code>CR0</code>寄存器</h3><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230609214128132.png" alt="image-20230609214128132"></p><ul><li><p><code>PE: Protection Enble </code></p><p>当此位为0，代表在CPU处在实模式，此位为1，表示CPU处在保护模式；从实模式切换到保护模式时需要将此位置为1.</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="meta">#进入保护模式</span></span><br><span class="line"><span class="keyword">mov</span> eax, cr0</span><br><span class="line"><span class="keyword">or</span> eax, <span class="number">0x00000001</span></span><br><span class="line"><span class="keyword">mov</span> cr0, eax</span><br></pre></td></tr></table></figure></li><li><p><code>TS：Task Switched</code></p></li><li><p><code>WP：Write Protect</code></p><p>对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志。当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作；当该位复位时则反之。该标志有利于UNIX类操作系统在创建进程时实现写时复制（Copy on Write）技术。</p></li><li><p><code>AM：Alignment Mask</code></p></li><li><p><code>NW：Not Writethrough</code></p></li><li><p><code>CD：Cache Disable</code></p></li><li><p><code>PG：Paging</code></p><p>是否启动分页机制的位，只有在保护模式以上才能开启分页机制。PG位为1开启分页机制，PG位为0关闭分页机制</p></li></ul><p>在CPU刚上电时，处理器被复位成PE&#x3D;0,PG&#x3D;0。</p><h3 id="3-2-2-CR2寄存器"><a href="#3-2-2-CR2寄存器" class="headerlink" title="3.2.2 CR2寄存器"></a>3.2.2 <code>CR2</code>寄存器</h3><h3 id="3-2-3-CR3寄存器"><a href="#3-2-3-CR3寄存器" class="headerlink" title="3.2.3 CR3寄存器"></a>3.2.3 <code>CR3</code>寄存器</h3><h3 id="3-2-4-CR4寄存器"><a href="#3-2-4-CR4寄存器" class="headerlink" title="3.2.4 CR4寄存器"></a>3.2.4 <code>CR4</code>寄存器</h3><h2 id="3-3-EFLAGS寄存器"><a href="#3-3-EFLAGS寄存器" class="headerlink" title="3.3 EFLAGS寄存器"></a>3.3 <code>EFLAGS</code>寄存器</h2><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230611124419683.png" alt="image-20230611124419683"></p><ul><li>CF：进位标志</li><li>PF：奇偶位标志</li><li>AF：辅助进位标志</li><li>ZF：零标志位</li><li>SF：符号标注位</li><li>TF：陷阱标志位</li><li>IF：中断标志位。若IF为1，表示中断开启；若为0，表示中断关闭</li><li>DF：方向标志位。</li><li>OF：溢出标志位。</li><li>IOPL：特权级标志位，占2个bit，标志了4个特权级</li><li>NT：任务嵌套标志位</li><li>RF：恢复标志位</li><li>VM：虚拟8086模式</li><li>AC：对齐检查</li><li>VIF：虚拟中断标志位</li><li>VIP：虚拟中断挂起标志位</li><li>ID：识别标志位</li><li>22~31：没有实际用途，占位用，为了将来拓展</li></ul><h2 id="3-4-段描述符寄存器"><a href="#3-4-段描述符寄存器" class="headerlink" title="3.4 段描述符寄存器"></a>3.4 段描述符寄存器</h2><h3 id="3-4-1-GDTR寄存器"><a href="#3-4-1-GDTR寄存器" class="headerlink" title="3.4.1 GDTR寄存器"></a>3.4.1 <code>GDTR</code>寄存器</h3><p>GDTR是个48位的寄存器，专门用来储存GDT的内存地址和大小</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626124256061.png" alt="image-20230626124256061"></p><p>GDT：Global Descriptor Table，全局段描述符，在保护模式下，GDT在内存中有且只有一个，GDT的数据结构如下，每个描述符8个字节，64个bit，可以存放在内存当中任意位置，addr相当于GDT的内存起始地址，GDT的总长度就就是GDT界限</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/20201026145225176.png" alt="在这里插入图片描述"></p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626124507958.png" alt="image-20230626124507958"></p><p>段描述符的主要属性都在高32位：</p><ul><li><p>0~7位：段基址的16-23</p></li><li><p>24~31位：段基址的24-31</p></li><li><p>8~11位：type字段，共四位，用来指定本描述符的类型</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626132808111.png" alt="image-20230626132808111"></p></li><li><p>12位：S字段，用于指示系统是否是系统段。S为0表示系统段，S为1表示数据段，type字段要和S字段配合在一起才能确定段描述符的确切类型。</p></li><li><p>15位：Present，即段是否存在。如果段存在于内存中，P为1，否则为0</p></li><li><p>16~19位：段界限的16-19位</p></li><li><p>20位：AVL，随便用，操作系统可以随便用这一位</p></li><li><p>21位：L字段，用来设置是否是64位代码段。L为1表示64位代码段，否则表示32位代码段。</p></li><li><p>22位：D&#x2F;B字段</p></li><li><p>23位：G字段，用来设置段界限的单位大小，若G为0，表示段界限的单位是4KB，若界为1，表示段界限的单位是4KB</p></li><li><p>24~31位：段基址的最后8位</p></li></ul><p>在实模式下，段寄存器中存储的是段基地址，即内存段的起始地址，而在保护模式下，由于段基址已经存入了段描述符中，所以段寄存器不再存放段基址，而是存放一个叫选择子的东西，选择子用来在段描述符表中索引相应的段描述符，数据结构如下：</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626133735851.png" alt="image-20230626133735851"></p><ul><li>0~1位：RPL，存储请求特权级，总共有0、1、2、3四个特权级</li><li>2位：TI，用来表示是GDT还是LDT，TI为0表示在GDT中索引描述符，TI为1表示在LDT中索引描述符</li></ul><p>在代码中我们可以定义对应的结构体来定义GDT和选择子以及全局描述符表指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">descriptor_t</span> /* 共 8 个字节 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> limit_low;      <span class="comment">// 段界限 0 ~ 15 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> base_low : <span class="number">24</span>;    <span class="comment">// 基地址 0 ~ 23 位 16M</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> type : <span class="number">4</span>;        <span class="comment">// 段类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> segment : <span class="number">1</span>;     <span class="comment">// 1 表示代码段或数据段即非系统段，0 表示系统段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> DPL : <span class="number">2</span>;         <span class="comment">// Descriptor Privilege Level 描述符特权等级 0 ~ 3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> present : <span class="number">1</span>;     <span class="comment">// 存在位，1 在内存中，0 在磁盘上</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> limit_high : <span class="number">4</span>;  <span class="comment">// 段界限 16 ~ 19;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> available : <span class="number">1</span>;   <span class="comment">// 该安排的都安排了，送给操作系统吧</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> long_mode : <span class="number">1</span>;   <span class="comment">// 64 位扩展标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> big : <span class="number">1</span>;         <span class="comment">// 32 位 还是 16 位;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> granularity : <span class="number">1</span>; <span class="comment">// 粒度 4KB 或 1B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base_high;       <span class="comment">// 基地址 24 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">descriptor_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 段选择子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">selector_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u8 RPL : <span class="number">2</span>; <span class="comment">// Request Privilege Level</span></span><br><span class="line">    u8 TI : <span class="number">1</span>;  <span class="comment">// Table Indicator</span></span><br><span class="line">    u16 index : <span class="number">13</span>;</span><br><span class="line">&#125; <span class="type">selector_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pointer_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 limit;</span><br><span class="line">    u32 base;</span><br><span class="line">&#125; _packed <span class="type">pointer_t</span>;</span><br></pre></td></tr></table></figure><p>下一步就是填充GDT和GDT_PTR</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充GDT</span></span><br><span class="line"><span class="type">descriptor_t</span> gdt[GDT_SIZE]; <span class="comment">//内核全局描述符表</span></span><br><span class="line">    <span class="built_in">memset</span>(gdt, <span class="number">0</span>, <span class="keyword">sizeof</span>(gdt));</span><br><span class="line"></span><br><span class="line">    <span class="type">descriptor_t</span> *desc;</span><br><span class="line">    desc = gdt + KERNEL_CODE_IDX;</span><br><span class="line">    descriptor_init(desc, <span class="number">0</span>, <span class="number">0xFFFFF</span>);</span><br><span class="line">    desc-&gt;segment = <span class="number">1</span>;     <span class="comment">// 代码段</span></span><br><span class="line">    desc-&gt;granularity = <span class="number">1</span>; <span class="comment">// 4K</span></span><br><span class="line">    desc-&gt;big = <span class="number">1</span>;         <span class="comment">// 32 位</span></span><br><span class="line">    desc-&gt;long_mode = <span class="number">0</span>;   <span class="comment">// 不是 64 位</span></span><br><span class="line">    desc-&gt;present = <span class="number">1</span>;     <span class="comment">// 在内存中</span></span><br><span class="line">    desc-&gt;DPL = <span class="number">0</span>;         <span class="comment">// 内核特权级</span></span><br><span class="line">    desc-&gt;type = <span class="number">0b1010</span>;   <span class="comment">// 代码 / 非依从 / 可读 / 没有被访问过</span></span><br><span class="line"><span class="comment">//填充 gdt_ptr</span></span><br><span class="line">    gdt_ptr.base = (u32)&amp;gdt;</span><br><span class="line">    gdt_ptr.limit = <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>然后使用lgdt命令将全局描述符表指针加载到GDTR寄存器中:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">lgdt [gdt_ptr]</span><br></pre></td></tr></table></figure><h3 id="3-4-2-IDTR寄存器"><a href="#3-4-2-IDTR寄存器" class="headerlink" title="3.4.2 IDTR寄存器"></a>3.4.2 <code>IDTR</code>寄存器</h3><p>idtr寄存器用于存储中断描述符表的地址和表界限</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626145545075.png" alt="image-20230626145545075"></p><p>在中断描述符表中可以存储的是中断描述符，这里的中断描述符分为四类，以不同门的叫法来描述，在上面描述GDT的时候，提到S字段和type字段一起决定了这个描述符是什么，对于GDT来说，我们设置S位为1，代表非系统段，对于中断描述符来说需要将S位设为0，由此延申出了四种描述符：</p><ul><li>任务门描述符</li></ul><p>​任务门和任务状态段 (Task Status Segment，TSS) 是Intel处理器在硬件一级提供的任务切换机制，所以任务门需要和TSS配合在一起使用，在任务门中记录的是TSS选择子，偏移量未使用。任务门可以存在于全局描述符表GDT、局部描述符表LDT、中断描述符表IDT中。描述符中任务门的type值为二进制0101，其结构如下图所示。顺便说一句大多数操作系统 (包括Linux) 都未用TSS实现任务切换</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150722494.png" alt="image-20230626150722494"></p><ul><li>中断门描述符</li></ul><p>​中断门包含了中断处理程序所在段的段选择子和段内偏移地址。当通过此方式进入中断后，标志寄存器eflags中的IF位自动置0，也就是在进入中断后，自动把中断关闭，避免中断嵌套。Linux就是利用中断门实现的系统调用，就是那个著名的int0x80。中断门只允许存在于IDT中。描述符中中断门的type值为二进制1110，其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150752429.png" alt="image-20230626150752429"></p><ul><li>陷阱门描述符</li></ul><p>​陷阱门和中断门非常相似，区别是由陷阱门进入中断后，标志寄存器eflags中的IF位不会自动置0。陷阱门只允许存在于IDT中。描述符中陷阱门的type值为二进制1111。其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150816386.png" alt="image-20230626150816386"></p><ul><li>调用门描述符</li></ul><p>​调用门是提供给用户进程进入特权0级的方式，其DPL为3。调用门中记录例程的地址，它不能用int指令调用，只能用call和imp指令。调用门可以安装在GDT和LDT中。描述符中调用门的type值为二进制1100。其结构如下图所示</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.X86%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20230626150841553.png" alt="image-20230626150841553"></p><p>同样我们可以使用一个结构体来描述中断描述符：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 offset0;     <span class="comment">//段内偏移 0 ~ 15位</span></span><br><span class="line">    u16 selector;    <span class="comment">//代码段选择子</span></span><br><span class="line">    u8 reserved;     <span class="comment">//保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;     <span class="comment">//任务们/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>;  <span class="comment">//segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;      <span class="comment">//使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>;  <span class="comment">//是否有效</span></span><br><span class="line">    u16 offset1;     <span class="comment">//段内偏移 16 ~ 31位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br></pre></td></tr></table></figure><p>然后填充中断描述符和中断</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="type">void</span>* <span class="type">handler_t</span>; <span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="comment">//定义idt</span></span><br><span class="line">   <span class="type">gate_t</span> idt[IDT_SIZE];</span><br><span class="line"><span class="comment">//中断处理程序段内偏移</span></span><br><span class="line">   <span class="keyword">extern</span> <span class="type">handler_t</span> handler_entry_table[ENTRY_SIZE];</span><br><span class="line"><span class="comment">//初始化中断描述符表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; IDT_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line">        <span class="type">handler_t</span> handler = handler_entry_table[i];</span><br><span class="line">        gate-&gt;offset0 = (u32)handler &amp; <span class="number">0xffff</span>;         <span class="comment">//段内偏移 0 ~ 15位</span></span><br><span class="line">        gate-&gt;offset1 = ((u32)handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>; <span class="comment">//段内偏移 16 ~ 31位</span></span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;    <span class="comment">//代码段选择子</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;         <span class="comment">//保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;        </span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;              <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;          <span class="comment">// 是否有效</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后将idt_ptr填充进IDTR寄存器中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载中断描述符表</span></span><br><span class="line">idt_ptr.base = (u32)idt;</span><br><span class="line">idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-LDTR寄存器"><a href="#3-4-3-LDTR寄存器" class="headerlink" title="3.4.3 LDTR寄存器"></a>3.4.3 <code>LDTR</code>寄存器</h3><h3 id="3-4-4-TR寄存器"><a href="#3-4-4-TR寄存器" class="headerlink" title="3.4.4 TR寄存器"></a>3.4.4 <code>TR</code>寄存器</h3><h1 id="4-长模式下寄存器（64bit）"><a href="#4-长模式下寄存器（64bit）" class="headerlink" title="4.长模式下寄存器（64bit）"></a>4.长模式下寄存器（64bit）</h1><p>在长模式下，也称为64位保护模式（64-bit Protected Mode）或x86-64架构，x86处理器提供了更广泛的寄存器集合。以下是长模式下可以使用的寄存器：</p><ol><li>通用寄存器（General Purpose Registers）：<ul><li><code>RAX</code>：累加器寄存器（Accumulator Register）。</li><li><code>RBX</code>：基址寄存器（Base Register）。</li><li><code>RCX</code>：计数寄存器（Counter Register）。</li><li><code>RDX</code>：数据寄存器（Data Register）。</li><li><code>RSI</code>：源索引寄存器（Source Index Register）。</li><li><code>RDI</code>：目的索引寄存器（Destination Index Register）。</li><li><code>RBP</code>：基址指针寄存器（Base Pointer Register）。</li><li><code>RSP</code>：堆栈指针寄存器（Stack Pointer Register）。</li><li><code>R8-R15</code>：扩展的通用寄存器。</li></ul></li><li>扩展通用寄存器：<ul><li><code>RIP</code>：指令指针寄存器（Instruction Pointer Register）。</li><li><code>RFLAGS</code>：标志寄存器（Flags Register），包含各种标志位。</li></ul></li><li>段寄存器（Segment Registers）：<ul><li><code>CS</code>：代码段寄存器（Code Segment Register）。</li><li><code>DS</code>：数据段寄存器（Data Segment Register）。</li><li><code>ES</code>：附加段寄存器（Extra Segment Register）。</li><li><code>FS、GS、SS</code>：附加段寄存器，用于访问额外的数据段。</li></ul></li><li>控制寄存器（Control Registers）：<ul><li><code>CR0、CR2、CR3、CR4、CR8</code>：用于控制和管理保护模式的特性，如分页机制、特权级等。</li></ul></li><li>段描述符寄存器（Descriptor Registers）：<ul><li><code>GDTR</code>：全局描述符表寄存器（Global Descriptor Table Register）。</li><li><code>IDTR</code>：中断描述符表寄存器（Interrupt Descriptor Table Register）。</li><li><code>LDTR</code>：局部描述符表寄存器（Local Descriptor Table Register）。</li><li><code>TR</code>：任务寄存器（Task Register）。</li></ul></li><li>XMM寄存器（SSE寄存器）：<ul><li><code>XMM0-XMM15</code>：128位的向量寄存器，用于执行SSE（Streaming SIMD Extensions）指令集中的向量运算。</li></ul></li><li>YMM寄存器（AVX寄存器）：<ul><li><code>YMM0-YMM15</code>：256位的向量寄存器，用于执行AVX（Advanced Vector Extensions）指令集中的向量运算。</li></ul></li><li>ZMM寄存器（AVX-512寄存器）：<ul><li><code>ZMM0-ZMM31</code>：512位的向量寄存器，用于执行AVX-512指令集中的向量运算。</li></ul></li></ol><h1 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5. 参考链接"></a>5. 参考链接</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/400007642">中断描述符表 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://blog.csdn.net/abc123lzf/article/details/109289567">(67条消息) x86保护模式——全局描述符表GDT详解_gdt全局描述符表_A__Plus的博客-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-1.概述</title>
      <link href="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h2><ul><li><p>开发环境：</p><ul><li><code>ubuntu20.04.5 WSL</code></li><li><code>sudo apt install nasm</code>: 安装汇编编译器 nasm</li><li><code>sudo apt install bochs-x</code>: 安装虚拟机 bochs</li><li><code>sudo apt-get install qemu-system</code> ：下载安装可以模拟全部硬件的qemu</li><li><code>sudo apt install gdb</code> ：安装gdb调试器</li><li><code>sudo apt-get install gcc-multilib</code>&amp;&amp;<code>sudo apt-get install g++-multilib</code>： 安装在64位的机器上产生32位的程序</li></ul></li><li><p>参考书籍:</p><ul><li>操作系统真相还原</li><li>30天自制操作系统</li><li>Orange’S:一个操作系统的实现</li></ul></li></ul><blockquote><p>源码地址：<a href="https://github.com/yanglianoo/Onix">yanglianoo&#x2F;Onix: 基于X86的操作系统，C语言 (github.com)</a></p></blockquote><h2 id="2-操作系统大纲"><a href="#2-操作系统大纲" class="headerlink" title="2.操作系统大纲"></a>2.操作系统大纲</h2><ul><li>系统引导<ul><li>自写bootloader</li><li>grub 引导</li></ul></li><li>硬件及驱动<ul><li>CPU : 32位X86架构</li><li>显示器：VGA</li><li>中断控制器：8259A</li><li>键盘</li><li>硬盘</li><li>时钟：内部时钟，外部时钟</li><li>网卡</li></ul></li><li>任务调度：内核进程，用户态线程</li><li>中断系统：外部中断、软中断、异常</li><li>内存管理</li><li>文件系统</li><li>系统调用</li><li>shell</li><li>网络</li></ul><h2 id="3-计算机组成概述"><a href="#3-计算机组成概述" class="headerlink" title="3.计算机组成概述"></a>3.计算机组成概述</h2><p>通常，计算机由以下几部分组成：</p><ul><li>负责计算和处理数据的 CPU</li><li>负责存储程序和数据的存储器</li><li>和外部进行数据交换的 I&#x2F;O（Input&#x2F;Output，输入输出装置）。</li></ul><p>各部分<code>通过总线连接</code>就构成了一台计算机</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.001-16862005447604.png" alt="img"></p><p>CPU在运行程序的逻辑如下：</p><ul><li><p><code>1.将磁盘上的程序加载到内存中</code></p></li><li><p><code>2.读取内存中的指令</code></p><p>首先，CPU 要把即将执行的指令从内存中读取出来。CPU 中有个 PC（Program Counter，程序计数器）寄存器，其中保存着即将执行的指令的地址。指令的读取是通过将 PC 寄存器的值输出给内存，由内存返回该值对应地址中的指令</p></li><li><p><code>3.对指令进行解码</code></p><p>然后，CPU 对读取的指令所对应的操作进行解码。指令有很多种，有进行各种运算的指令、控制下一条命令的指令、对内存和 I&#x2F;O 进行读写的指令，还有对 CPU 进行控制的指令。这些指令由 CPU 中被称为指令解码器的模块进行解码。可以用来保存地址和运算结果的寄存器称为通用寄存器（General Purpose Register）</p></li><li><p><code>4.执行指令</code></p><p>最后，CPU 对解码器确定的操作进行处理。CPU 可以从内部存储装置——寄存器或外部的内存读取数据并处理，然后将结果写回寄存器或内存。</p></li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.004.png" alt="img"></p><p>CPU 执行的指令，由代表操作种类的<code>操作码</code>和代表操作对象的<code>操作数</code>两部分组成。指令本身用特定的二进制序列来表示，这种二进制序列称为机器语言。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.005.png" alt="img"></p><blockquote><p>操作数：通常为寄存器地址、内存地址、立即数等</p><p>操作码：对应为cpu具体的操作，如加法、减法等</p></blockquote><p>根据执行的指令的特征，CPU 分为 <code>RISC</code>（Reduced Instruction Set Computer，精简指令集计算机）和 <code>CISC</code>（Complex Instruction Set Computer，复杂指令集计算机）两种</p><h3 id="3-1-内存和地址"><a href="#3-1-内存和地址" class="headerlink" title="3.1 内存和地址"></a>3.1 内存和地址</h3><p>所有能够存储数据的存储器都可称为内存，内存是用来存放运行时指令（程序）和数据的存储器。</p><p>我们一般说的电脑的内存条为DRAM，就是用来保存<code>程序运行</code>时的指令和数据。像固态硬盘、机械硬盘等存储介质也可用于存储指令和数据，但由于其访问速度实在是太慢，因此适用于计算机<code>长期保存数据和程序</code>的存储器。</p><p>内存使用地址的概念来管理存储的数据。地址表示的是数据存储的位置，如同数据的住所一样。每个数据单元都有一个地址。大多情况下数据单元是一个字节（8 位）长度。这种方式称为字节编址。不同架构的CPU有不同的编址方式。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.006.png" alt="img"></p><p>如上图，CPU可通过总线寻址找到内存空间每个数据单元，并从中取出每个数据单元存储的数据。</p><p>内存等存储器的特点是速度越快成本越高。因此通常使用“高速小容量”、“中速中等容量”到“低速大容量”等多种存储器组合的混合型架构。这种构造称为存储器层级。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.007.png" alt="img"></p><p>在存储层面，速度最快的是 CPU 中的寄存器。CPU 比内存速度快很多，由 CPU 直 接访问内存效率较低。为了提高内存访问速度，在 CPU 和内存间增加了被称为缓存的高速小容量存储器。</p><p>缓存可以暂时性地缓冲存储从内存中读取的数据。CPU 在访问内存时，如果需要的数据已经保存在缓存中，则可直接从缓存中读取，以提高访问效率。根据容量和速度的不同，缓存也分为多个层级，通常为一级缓存、二级缓存等多个级别。</p><h3 id="3-2-IO"><a href="#3-2-IO" class="headerlink" title="3.2 IO"></a>3.2 IO</h3><p>I&#x2F;O（Input&#x2F;Output）是进行数据输入输出的装置。计算机通过 I&#x2F;O 和外部实现数据交换。计算机的处理操作按照从外部读取数据、在内部处理数据、再向外部输出结果的顺序进行。以个人电脑为例，如下图所示，它从鼠标或键盘输入数据，处理器根据程序处理数据，通过显示器等向外部输出结果。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.009.png" alt="img"></p><p>访问 I&#x2F;O 的方式大致分为<code>存储器映射 I/O</code> 和<code>端口映射 I/O </code>两种。</p><ul><li><code>存储器映射 I/O</code> :存储器映射 I&#x2F;O 方式中，I&#x2F;O 也和内存一样使用地址进行管理，可以和访问内存一样的方式进行访问</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.010.png" alt="img"></p><ul><li><code>端口映射访问</code>:端口映射 I&#x2F;O 方式中，CPU 含有支持访问 I&#x2F;O 的专用指令。</li></ul><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.011.png" alt="img"></p><h3 id="3-3-字节序"><a href="#3-3-字节序" class="headerlink" title="3.3 字节序"></a>3.3 字节序</h3><p>将多字节数据存储在内存中时，各字节的存储顺序称为字节序。比如，将 4 字节数据 0x12345678 放入内存时，地址 0 中放 0x12、地址 1 中放 0x34、地址 2 中放 0x56、地址 3 中放 0x78 的方式，称为大端序。相对地，地址 0 中放 0x78、地址 1 中放 0x56、地址 2 中放 0x34、地址 3 中放 0x12 的方式，称为小端序。不同CPU采用的字节序不尽相同</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.008.png" alt="img"></p><h3 id="3-4-总线"><a href="#3-4-总线" class="headerlink" title="3.4 总线"></a>3.4 总线</h3><p>总线是 CPU、内存和 I&#x2F;O 之间交换数据的共同通道。总线将一根信号线在多个模块间共享进行通信。</p><p>总线包括<code>地址总线、数据总线、控制总线、IO总线</code>，顾名思义数据线是用于数据读取、地址总线用于地址寻址、控制总线用于控制cpu行为。</p><p><img src="/2023/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%A6%82%E8%BF%B0/08.1.2.012.png" alt="img"></p><p>当计算机中的各个组件之间需要进行数据传输和控制信号传递时，总线起到了关键的作用。下面是对四种主要总线的简要介绍：</p><ol><li>地址总线（Address Bus）：<ul><li>作用：地址总线用于传输CPU或其他设备发出的内存或外设的地址信息。</li><li>功能：它决定了CPU或其他设备要访问的内存单元或外设的位置。地址总线的宽度决定了系统能够寻址的内存空间大小。例如，32位地址总线可以寻址的内存空间大小为2^32个字节（4GB）。</li></ul></li><li>数据总线（Data Bus）：<ul><li>作用：数据总线用于传输CPU或其他设备之间的数据。</li><li>功能：数据总线承载着实际的数据传输，包括指令、操作数、计算结果等。数据总线的宽度决定了一次可以传输的数据位数，例如，32位数据总线可以一次传输32位（4字节）的数据。</li></ul></li><li>控制总线（Control Bus）：<ul><li>作用：控制总线用于传输各种控制信号，包括指令控制、时序控制和状态信号等。</li><li>功能：控制总线通过不同的信号线传递各种控制信号，例如，读取（Read）和写入（Write）信号用于指示数据传输的方向，时钟信号用于同步操作，中断信号用于通知CPU有外部事件需要处理等。</li></ul></li><li>I&#x2F;O总线（I&#x2F;O Bus）：<ul><li>作用：I&#x2F;O总线用于连接CPU和外部设备之间进行输入输出操作。</li><li>功能：I&#x2F;O总线是一种专门用于输入输出的总线，它提供了一种通信通道，使得CPU能够与外部设备进行数据交换。通过I&#x2F;O总线，CPU可以发送读取（IN）和写入（OUT）指令来控制外部设备的数据读取和写入。</li></ul></li></ol><p>这四种总线相互配合，构成了计算机系统中各个组件之间的连接和通信桥梁。它们共同工作，使得CPU能够与内存和外设进行数据传输、控制信号传递和输入输出操作，实现计算机的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 从零手写操作系统-X86架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写STL之Vector</title>
      <link href="/2023/06/07/%E6%89%8B%E5%86%99STL-Vector/"/>
      <url>/2023/06/07/%E6%89%8B%E5%86%99STL-Vector/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码仓库：<a href="https://github.com/yanglianoo/My_STL/tree/timer">yanglianoo&#x2F;My_STL at timer (github.com)</a></p></blockquote><h2 id="1-Vector-概述"><a href="#1-Vector-概述" class="headerlink" title="1.Vector 概述"></a>1.Vector 概述</h2><p>在C++ STL（标准模板库）中，<code>vector</code> 是一个动态数组容器，它是一个模板类具有以下特性：</p><ol><li><strong>动态大小</strong>: <code>vector</code> 的大小可以根据需要动态增长或缩小。它可以自动调整内部存储空间，以适应容器中元素的数量。</li><li><strong>连续存储</strong>: <code>vector</code> 中的元素在内存中是连续存储的，这使得对元素的随机访问变得高效。</li><li><strong>快速插入和删除</strong>: 在 <code>vector</code> 的末尾插入或删除元素是高效的，时间复杂度为常数。但在中间或开头插入或删除元素的操作可能会导致元素的移动，时间复杂度为线性。</li><li><strong>随机访问</strong>: <code>vector</code> 支持通过索引进行随机访问。可以使用下标运算符 <code>[]</code> 或 <code>at()</code> 函数来访问特定位置的元素。</li><li><strong>动态调整内存</strong>: 当 <code>vector</code> 的大小超过当前分配的内存空间时，它会重新分配更大的内存块，并将现有元素移动到新的内存中。这可以确保容器始终具有足够的内存来存储元素。</li><li><strong>元素访问</strong>: 可以使用迭代器来遍历 <code>vector</code> 中的元素。可以使用 <code>begin()</code> 和 <code>end()</code> 成员函数获取指向容器开头和结尾的迭代器。</li><li><strong>容器操作</strong>: <code>vector</code> 支持许多常见的容器操作，如排序、查找、插入和删除元素。它还提供了与其他容器兼容的接口，例如迭代器、范围构造函数和算法函数。</li></ol><p><code>STL</code>库中<code>vector</code>的定义如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Allocator</span> = std::allocator&lt;T&gt;&gt; </span><br><span class="line">    <span class="keyword">class</span> vector;</span><br></pre></td></tr></table></figure><table><thead><tr><th>T</th><th>元素的类型。<code>T</code> 必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>和<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>Allocator</th><th>用于获取&#x2F;释放内存及构造&#x2F;析构内存中元素的分配器。类型必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/Allocator"><em>分配器</em> <em>(Allocator)</em> </a>的要求。</th></tr></thead></table><table><thead><tr><th>成员函数</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/vector">(构造函数)</a></td><td>构造 <code>vector</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/~vector">(析构函数)</a></td><td>析构 <code>vector</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/operator%3D">operator&#x3D;</a></td><td>赋值给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/assign">assign</a></td><td>将值赋给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/get_allocator">get_allocator</a></td><td>返回相关的分配器 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/at">at</a></td><td>访问指定的元素，同时进行越界检查 (公开成员函数)</td></tr><tr><td>operator[]</td><td>访问指定的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/data">data</a></td><td>直接访问底层数组 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/reserve">reserve</a></td><td>预留存储空间 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/capacity">capacity</a></td><td>返回当前存储空间能够容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/shrink_to_fit">shrink_to_fit</a></td><td>通过释放未使用的内存减少内存的使用 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/swap">swap</a></td><td>交换内容</td></tr></tbody></table><blockquote><p>参考链接: <a href="https://zh.cppreference.com/w/cpp/container/vector">std::vector - cppreference.com</a></p></blockquote><h2 id="2-构造Vector"><a href="#2-构造Vector" class="headerlink" title="2.构造Vector"></a>2.构造Vector</h2><p>自己手写<code>vector</code>时，迭代器不是通用的<code>Allocator</code>类型，需要在<code>vector</code>内部实现一个自定义的迭代器</p><p>vector模板类定义如下，需要维护三个私有的成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;    <span class="comment">//实际数组大小</span></span><br><span class="line">    <span class="type">int</span> _capacity;<span class="comment">//最大容量</span></span><br><span class="line">    T* _elem;     <span class="comment">//数据区指针  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：模板类的实现和声明不能分离编译，因此最好将模板类的声明和实现都放在头文件中<br>参考链接：<a href="https://blog.csdn.net/u011201045/article/details/38679417">(64条消息) C++中模板类的编译过程_c++模板编译_jiazhucai的博客-CSDN博客</a></p></blockquote><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>构造函数定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>();   <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(std::initiallizer_list&lt;T&gt; init) <span class="comment">// c++11 列表初始化</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other); <span class="comment">//用另外一个vector来构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other,<span class="type">int</span> left,<span class="type">int</span> right); <span class="comment">//用另外一个vector区间构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">size_t</span> count, T&amp; value); <span class="comment">//初始化为count个 value</span></span><br></pre></td></tr></table></figure><h4 id="2-1-1-辅助函数"><a href="#2-1-1-辅助函数" class="headerlink" title="2.1.1 辅助函数"></a>2.1.1 辅助函数</h4><p>在定义构造函数具体实现时需要定义几个辅助函数:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span>; <span class="comment">//空间不足时扩容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink</span><span class="params">()</span></span>; <span class="comment">//装填因子过小时压缩</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyFrom</span> <span class="params">( T <span class="type">const</span>* A, <span class="type">int</span> left, <span class="type">int</span> right )</span></span>; <span class="comment">//复制数组区间 A[left, right]</span></span><br></pre></td></tr></table></figure><ul><li>内存扩充函数<code>expand()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_CAPACITY 3 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">expand</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_size &lt;= _capacity) <span class="keyword">return</span>;  <span class="comment">//当size 小于等于 capacity 时 不需要扩容</span></span><br><span class="line">    <span class="keyword">if</span>(_capacity &lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY; <span class="comment">//当capacity小于最小大小，更改capacity为最小大小</span></span><br><span class="line">    <span class="comment">/* 反复翻倍，直到 _capacity &gt; _size*/</span></span><br><span class="line">    <span class="keyword">while</span> (_capacity &lt; _size)</span><br><span class="line">    &#123;</span><br><span class="line">        _capacity *=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T* old_data = _data;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity &lt;&lt; <span class="number">1</span>];  <span class="comment">//capacity 增大一倍，重新 new 内存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;_size; i++)       <span class="comment">//赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = old_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] old_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内存缩小函数<code>shrink()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">shrink</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capacity &lt; DEFAULT_CAPACITY &lt;&lt; <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//不致收缩倒DEFAULT_CAPACITY以下</span></span><br><span class="line">    <span class="keyword">if</span>(_size &lt;&lt; <span class="number">2</span> &gt; _capacity) <span class="keyword">return</span>;  <span class="comment">//以 25% 为边界</span></span><br><span class="line"></span><br><span class="line">    T* old_data = _data;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = old_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] old_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>区间复制函数<code>copyFrom ( T const* A, int left, int right )</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">copyFrom</span> ( T <span class="type">const</span>* A, <span class="type">int</span> left, <span class="type">int</span> right )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _capacity = (right - left) * <span class="number">2</span>;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[_size] = A[left];</span><br><span class="line">        _size++;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-构造函数实现"><a href="#2-2-2-构造函数实现" class="headerlink" title="2.2.2 构造函数实现"></a>2.2.2 构造函数实现</h4><ul><li><code>vector()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*构造函数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>():_data(<span class="literal">nullptr</span>),_capacity(<span class="number">0</span>),_size(<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(const vector&lt;T&gt;&amp; *other*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">copyFrom</span>(other._data,<span class="number">0</span>,other._size); <span class="comment">//直接调用 copyFrom 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(std::initializer_list&lt;T&gt; *init*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* c++11 列表初始化 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(std::initializer_list&lt;T&gt; init)</span><br><span class="line">&#123;</span><br><span class="line">    _size = init.<span class="built_in">size</span>();</span><br><span class="line">    _capacity = _size * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; elem : init)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector(int *count*, T&amp; *value*)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::<span class="built_in">vector</span>(<span class="type">size_t</span> count, T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    _size = count;</span><br><span class="line">    _capacity = <span class="number">2</span> * _size;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i =<span class="number">0</span>; i&lt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-析构函数"><a href="#2-2-析构函数" class="headerlink" title="2.2 析构函数"></a>2.2 析构函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;::~<span class="built_in">vector</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-赋值"><a href="#3-赋值" class="headerlink" title="3.赋值"></a>3.赋值</h2><p>实现的成员函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//成员函数</span></span><br><span class="line">    vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector&amp; other);</span><br><span class="line">    vector&amp; <span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">size_t</span> count,<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>vector&amp; operator=(const vector&amp; other)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;&amp; vector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> vector&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">copyFrom</span>(other._data,<span class="number">0</span>,other._size);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector&lt;T&gt;::operator=( std::initializer_list&lt;T&gt; *ilist* )</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;&amp; vector&lt;T&gt;::<span class="keyword">operator</span>=( std::initializer_list&lt;T&gt; ilist )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = init.<span class="built_in">size</span>();</span><br><span class="line">    _capacity = _size * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    _data = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; elem : init)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-元素访问"><a href="#4-元素访问" class="headerlink" title="4.元素访问"></a>4.元素访问</h2><p>元素访问的接口有如下这些：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//元素访问</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);</span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">data</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;<span class="number">0</span> || index &gt;= _size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; vector&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data[_size<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* vector&lt;T&gt;::<span class="built_in">data</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h2><h3 id="5-1-迭代器使用实例"><a href="#5-1-迭代器使用实例" class="headerlink" title="5.1 迭代器使用实例"></a>5.1 迭代器使用实例</h3><p>在构建迭代器之前，先看看迭代器的用法，一般用于遍历容器中的各个元素</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 1. 使用迭代器进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1. Iterate using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 使用auto关键字进行简化</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2. Iterate using auto keyword: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 使用范围基于循环 (range-based loop)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3. Iterate using range-based loop: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 修改容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4. Modify elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        *it = *it * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 插入元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5. Insert elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> insertPos = vec.<span class="built_in">begin</span>() + <span class="number">2</span>; <span class="comment">// 在索引2的位置之后插入元素</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(insertPos, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 删除元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;6. Erase elements using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> erasePos = vec.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 删除索引1的元素</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(erasePos);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-迭代器类实现"><a href="#5-2-迭代器类实现" class="headerlink" title="5.2 迭代器类实现"></a>5.2 迭代器类实现</h3><p><code>iterrator</code>是一个类，在内部维护了一个指针，需要对其进行各种操作符重载，<code>iterrator</code>的具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterrator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            T * m_pointer;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Iterrator</span>():<span class="built_in">m_pointer</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">            <span class="built_in">Iterrator</span>(T * pointer) : <span class="built_in">m_pointer</span>(pointer) &#123;&#125;</span><br><span class="line">            ~<span class="built_in">Iterrator</span>() &#123;&#125;</span><br><span class="line">        <span class="comment">/* 判断两个迭代器是否相等 */</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Iterrator &amp; other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer == other.m_pointer;   </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* 迭代器赋值 */</span></span><br><span class="line">        Iterrator <span class="keyword">operator</span> = (<span class="type">const</span> Iterrator&amp; other)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer = other.m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 前缀递增*/</span></span><br><span class="line">        Iterrator &amp; <span class="keyword">operator</span> ++ ()</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer +=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 后缀递增 */</span></span><br><span class="line">        Iterrator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            ++(*<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> + (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            it.m_pointer += i;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterrator <span class="keyword">operator</span> += (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer += i;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> -= (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pointer -= i;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterrator <span class="keyword">operator</span> - (<span class="type">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">            it.m_pointer -= i;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="keyword">operator</span> - (<span class="type">const</span> Iterrator&amp; other) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer - other.m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T &amp; <span class="keyword">operator</span> * ()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T * <span class="keyword">operator</span> -&gt; ()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pointer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>记录：在对<code>Iterrator</code>前++和后++重载时，如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前缀递增*/</span></span><br><span class="line">Iterrator &amp; <span class="keyword">operator</span> ++ ()</span><br><span class="line">&#123;</span><br><span class="line">m_pointer +=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/* 后缀递增 */</span></span><br><span class="line">Iterrator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">     Iterrator it = *<span class="keyword">this</span>;</span><br><span class="line">     ++(*<span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中，后缀递增操作符(it++)可以通过接受一个额外的int参数进行区分，这是由C++语言规范所定义的。根据规范，后缀递增操作符的函数参数列表中必须有一个int类型的参数，尽管在函数体内并没有使用该参数。</p><p>这种设计是为了在语法上能够区分前缀递增和后缀递增操作。当编译器遇到<code>it++</code>表达式时，它会根据后缀递增操作符的函数参数列表中是否存在一个额外的int参数来决定使用后缀递增操作符的重载函数。</p><p>编译器会将后缀递增操作符的调用转换为对重载的后缀递增操作符函数的调用，并传递一个编译器生成的临时整数参数（通常是0）。</p><p>请注意，这个整数参数的名称在函数体内并没有使用，因为它的存在只是为了与前缀递增操作符进行区分，而不是为了实际使用。</p></blockquote><h3 id="5-3-迭代器操作函数实现"><a href="#5-3-迭代器操作函数实现" class="headerlink" title="5.3 迭代器操作函数实现"></a>5.3 迭代器操作函数实现</h3><p><code>begin</code>用于获取头指针，<code>end</code>用于获取尾指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//迭代器操作函数</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">begin</span>()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(_data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">end</span>()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(_data + _size)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要使用<code>typename</code>显示的告诉编译器<code>vector&lt;T&gt;::Iterator</code>是一个类型</p><h2 id="6-容量"><a href="#6-容量" class="headerlink" title="6.容量"></a>6.容量</h2><p>和容量相关的接口函数比较简单，实现的接口如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//容量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//判断容器是否为空</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//获取容器元素个数</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//获取容器最大存储个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> new_cap)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> vector&lt;T&gt;::<span class="built_in">empty</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _size==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">max_size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">capacity</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 重置容器大小 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">reserve</span>(<span class="type">size_t</span> new_cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capacity &gt;= new_cap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _size += new_cap;</span><br><span class="line">        <span class="built_in">expand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果 _capacity 过大则缩减*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">shrink_to_fit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shrink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-修改器"><a href="#7-修改器" class="headerlink" title="7.修改器"></a>7.修改器</h2><p>和修改容器有关的接口函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">//修改器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> Iterator it ,<span class="type">const</span> T &amp; value)</span></span>;  </span><br><span class="line">    <span class="function">Iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> Iterator it ,<span class="type">int</span> n,<span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">erase</span><span class="params">(<span class="type">const</span> Iterator it)</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">erase</span><span class="params">(<span class="type">const</span> Iterator first,<span class="type">const</span> Iterator last)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector &amp; other)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>clear()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* clear操作，直接将 _size 清零*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator insert(const Iterator it ,int n,const T &amp; value)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在 it 的位置插入 n 个 T 元素*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Iterator it ,<span class="type">int</span> n,<span class="type">const</span> T &amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = it - <span class="built_in">begin</span>();</span><br><span class="line">    _size += n;</span><br><span class="line">    <span class="comment">//如果有需要，则扩容</span></span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=_size; i&gt;size;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i+n<span class="number">-1</span>] = _data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[size+i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;T&gt;::<span class="built_in">Iterator</span>(_data + size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator insert(const Iterator it ,const T &amp; value) </code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在 it 位置插入 1 个元素 value*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Iterator it ,<span class="type">const</span> T &amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    _size+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">    <span class="built_in">insert</span>(it,<span class="number">1</span>,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator erase(const Iterator it)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除 it 位置的元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Iterator it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">end</span>() - it == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _size -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = it - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = count; i &lt; _size <span class="number">-1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[i] = _data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    _size -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Iterator erase(const Iterator first,const Iterator last)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 区间删除 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::Iterator vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Iterator first,<span class="type">const</span> Iterator last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( first == last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> first;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> f = first - <span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> l = last - <span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> ( l &lt; _size) <span class="comment">// [last,_szie) 顺次前移 l - f 个单元</span></span><br><span class="line">        &#123;</span><br><span class="line">            _data[f++] = _data[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        _size = f;  <span class="comment">//更新规模</span></span><br><span class="line">        <span class="built_in">shrink</span>(); <span class="comment">//若有必要则缩容</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void push_back(const T &amp; value)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在尾部插入一个元素value */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size &lt; _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        _data[_size] = value; </span><br><span class="line">        _size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _size++;</span><br><span class="line">        <span class="built_in">expand</span>();</span><br><span class="line">        <span class="type">int</span> index = _size - <span class="number">1</span>;</span><br><span class="line">        _data[index] = value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void pop_back()</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 弹出最后一个元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void resize(size_t size)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">resize</span>(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size &gt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        _size = size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i= _size; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _data[i] = <span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _size = size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _size = size;</span><br><span class="line">    <span class="built_in">expand</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>void swap(vector &amp; other)</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 两个 vector 交换*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">swap</span>(vector &amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    T * data = other._data;</span><br><span class="line">    <span class="type">int</span> size = other._size;</span><br><span class="line">    <span class="type">int</span> capacity = other._capacity;</span><br><span class="line"></span><br><span class="line">    other._data = _data;</span><br><span class="line">    other._size = _size;</span><br><span class="line">    other._capacity = _capacity;</span><br><span class="line"></span><br><span class="line">    _data = data;</span><br><span class="line">    _size = size;</span><br><span class="line">    _capacity = capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>至此，<code>vector</code> 构造完毕，未进行测试，不知道是否有<code>bug</code></p>]]></content>
      
      
      <categories>
          
          <category> 手写STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
